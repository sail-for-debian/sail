(*Generated by Lem from aarch64_mono.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasives_extraTheory sail2_instr_kindsTheory sail2_valuesTheory sail2_prompt_monadTheory sail2_operators_mwordsTheory sail2_promptTheory sail2_stringTheory aarch64_mono_typesTheory aarch64_extrasTheory;

val _ = numLib.prefer_num();



val _ = new_theory "aarch64_mono"

(*Generated by Sail from aarch64_mono.*)
(*open import Pervasives_extra*)
(*open import Sail2_instr_kinds*)
(*open import Sail2_values*)
(*open import Sail2_string*)
(*open import Sail2_operators_mwords*)
(*open import Sail2_prompt_monad*)
(*open import Sail2_prompt*)
(*open import Aarch64_mono_types*)
(*open import Aarch64_extras*)







(*val neq_bool : bool -> bool -> bool*)

val _ = Define `
 ((neq_bool:bool -> bool -> bool) x y=  (~ (((x = y)))))`;


(*val vcons : forall  'a. 'a -> list 'a -> list 'a*)





(*val builtin_and_vec : forall 'n. bits 'n -> bits 'n -> bits 'n*)



(*val builtin_or_vec : forall 'n. bits 'n -> bits 'n -> bits 'n*)



(*val __raw_SetSlice_int : forall 'w. integer -> ii -> ii -> bits 'w -> ii*)

(*val __GetSlice_int : forall 'n. Size 'n => itself 'n -> ii -> ii -> mword 'n*)

val _ = Define `
 ((GetSlice_int:'n itself -> int -> int -> 'n words$word) n m o1=
    (let n = (size_itself_int n) in
   (get_slice_int n m o1  :  'n words$word)))`;


(*val __raw_SetSlice_bits : forall 'n 'w. integer -> integer -> bits 'n -> ii -> bits 'w -> bits 'n*)

(*val __raw_GetSlice_bits : forall 'n 'w. integer -> integer -> bits 'n -> ii -> bits 'w*)

(*val cast_unit_vec : bitU -> mword ty1*)

val _ = Define `
 ((cast_unit_vec0:bitU ->(1)words$word) b=
    ((case b of   B0 => (vec_of_bits [B0]  :  1 words$word) | B1 => (vec_of_bits [B1]  :  1 words$word) )))`;


(*val BoolStr : bool -> string*)

val _ = Define `
 ((BoolStr:bool -> string) b=  (if b then "true" else "false"))`;


(*val ex_nat : ii -> integer*)

val _ = Define `
 ((ex_nat:int -> int) n=  n)`;


(*val ex_int : ii -> integer*)

val _ = Define `
 ((ex_int:int -> int) n=  n)`;


(*val ex_range : integer -> integer*)

(*val coerce_int_nat : ii -> M ii*)

val _ = Define `
 ((coerce_int_nat:int ->(regstate)sail2_state_monad$sequential_state ->(((int),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) x=  (sail2_state_monad$seqS (sail2_state_monad$assert_expS T "Cannot coerce int to nat") (sail2_state_monad$returnS x)))`;


(*val break : unit -> unit*)

val _ = Define `
 ((break:unit -> unit) () =  () )`;


(*val undefined_exception : unit -> M exception*)

val _ = Define `
 ((undefined_exception:unit ->(regstate)sail2_state_monad$sequential_state ->(((exception),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (undefined_string () ) (\ (u_0 : string) .  sail2_state_monad$bindS
   (undefined_unit () ) (\ (u_1 : unit) . 
   sail2_state$internal_pickS
     [Error_Undefined u_1;Error_See u_0;Error_Implementation_Defined u_0;Error_ReservedEncoding u_1;Error_ExceptionTaken u_1]))))`;


(*val __GetVerbosity : unit -> M (bits ty64)*)

(*val get_cycle_count : unit -> M ii*)

(*val __InitRAM : forall 'm. Size 'm => integer -> ii -> mword 'm -> mword ty8 -> unit*)

val _ = Define `
 ((InitRAM:int -> int -> 'm words$word ->(8)words$word -> unit) g__302 g__303 g__304 g__305=  () )`;


(*val __ReadRAM : forall  'm 'p8_times_n_ . Size 'm, Size 'p8_times_n_ => itself 'm -> integer -> mword 'm -> mword 'm -> M (mword 'p8_times_n_)*)

val _ = Define `
 ((ReadRAM:'m itself -> int -> 'm words$word -> 'm words$word ->(regstate)sail2_state_monad$sequential_state ->((('p8_times_n_ words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) addr_length bytes hex_ram addr=
    (let addr_length = (size_itself_int addr_length) in
   (read_ram addr_length bytes hex_ram addr  : ( 'p8_times_n_ words$word) M)))`;


(*val __TraceMemoryWrite : forall  'm 'p8_times_n_ . Size 'm, Size 'p8_times_n_ => integer -> mword 'm -> mword 'p8_times_n_ -> unit*)

(*val __WriteRAM : forall  'm 'p8_times_n_ . Size 'm, Size 'p8_times_n_ => itself 'm -> integer -> mword 'm -> mword 'm -> mword 'p8_times_n_ -> M unit*)

val _ = Define `
 ((WriteRAM:'m itself -> int -> 'm words$word -> 'm words$word -> 'p8_times_n_ words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) addr_length bytes hex_ram addr data=
    (let addr_length = (size_itself_int addr_length) in
   write_ram addr_length bytes hex_ram addr data))`;


val _ = Define `
 ((TraceMemoryWrite:int -> 'm words$word -> 'p8_times_n_ words$word -> unit) bytes addr data=  () )`;


(*val __TraceMemoryRead : forall  'm 'p8_times_n_ . Size 'm, Size 'p8_times_n_ => integer -> mword 'm -> mword 'p8_times_n_ -> unit*)

val _ = Define `
 ((TraceMemoryRead:int -> 'm words$word -> 'p8_times_n_ words$word -> unit) bytes addr data=  () )`;


(*val extzv : forall 'n 'm. Size 'm, Size 'n => integer -> mword 'n -> mword 'm*)

val _ = Define `
 ((extzv:int -> 'n words$word -> 'm words$word) (m__tv : int) v=  ((extz_vec m__tv v  :  'm words$word)))`;


(*val extsv : forall 'n 'm. Size 'm, Size 'n => integer -> mword 'n -> mword 'm*)

val _ = Define `
 ((extsv:int -> 'n words$word -> 'm words$word) (m__tv : int) v=  ((exts_vec m__tv v  :  'm words$word)))`;


(*val slice_mask : forall 'n . Size 'n => integer -> ii -> ii -> mword 'n*)

val _ = Define `
 ((slice_mask:int -> int -> int -> 'n words$word) (n__tv : int) i l=
    (let (one1 : 'n bits) = ((extzv n__tv (vec_of_bits [B1]  :  1 words$word)  :  'n words$word)) in
   (shiftl ((sub_vec ((shiftl one1 l  :  'n words$word)) one1  :  'n words$word)) i  :  'n words$word)))`;


(*val is_zero_subrange : forall 'n . Size 'n => mword 'n -> ii -> ii -> bool*)

val _ = Define `
 ((is_zero_subrange:'n words$word -> int -> int -> bool) xs i j=
    (((and_vec xs
         ((slice_mask ((int_of_num (words$word_len xs))) j ((((i - j)) + (( 1 : int):ii)))  :  'n words$word))
        :  'n words$word)) = ((extzv ((int_of_num (words$word_len xs))) (vec_of_bits [B0]  :  1 words$word)  :  'n words$word))))`;


(*val is_ones_subrange : forall 'n . Size 'n => mword 'n -> ii -> ii -> bool*)

val _ = Define `
 ((is_ones_subrange:'n words$word -> int -> int -> bool) xs i j=
    (let (m : 'n bits) =
     ((slice_mask ((int_of_num (words$word_len xs))) j ((((j - i)) + (( 1 : int):ii)))  :  'n words$word)) in
   (((and_vec xs m  :  'n words$word)) = m)))`;


(*val slice_slice_concat : forall 'n 'm 'r . Size 'm, Size 'n, Size 'r => integer -> mword 'n -> ii -> ii -> mword 'm -> ii -> ii -> mword 'r*)

val _ = Define `
 ((slice_slice_concat:int -> 'n words$word -> int -> int -> 'm words$word -> int -> int -> 'r words$word) (r__tv : int) xs i l ys i' l'=
    (let xs =
     ((shiftr ((and_vec xs ((slice_mask ((int_of_num (words$word_len xs))) i l  :  'n words$word))  :  'n words$word)) i  :  'n words$word)) in
   let ys =
     ((shiftr ((and_vec ys ((slice_mask ((int_of_num (words$word_len ys))) i' l'  :  'm words$word))  :  'm words$word)) i'
       :  'm words$word)) in
   (or_vec ((shiftl ((extzv r__tv xs  :  'r words$word)) l'  :  'r words$word)) ((extzv r__tv ys  :  'r words$word))
     :  'r words$word)))`;


(*val slice_zeros_concat : forall 'n   'r . Size 'n, Size 'r => integer -> mword 'n -> ii -> integer -> integer -> mword 'r*)

val _ = Define `
 ((slice_zeros_concat:int -> 'n words$word -> int -> int -> int -> 'r words$word) (r__tv : int) xs i l l'=
    (let xs =
     ((shiftr ((and_vec xs ((slice_mask ((int_of_num (words$word_len xs))) i l  :  'n words$word))  :  'n words$word)) i  :  'n words$word)) in
   (shiftl ((extzv r__tv xs  :  'r words$word)) l'  :  'r words$word)))`;


(*val subrange_subrange_eq : forall 'n . Size 'n => mword 'n -> ii -> ii -> mword 'n -> ii -> ii -> bool*)

val _ = Define `
 ((subrange_subrange_eq:'n words$word -> int -> int -> 'n words$word -> int -> int -> bool) xs i j ys i' j'=
    (let xs =
     ((shiftr
        ((and_vec xs
            ((slice_mask ((int_of_num (words$word_len xs))) j ((((i - j)) + (( 1 : int):ii)))  :  'n words$word))
           :  'n words$word)) j
       :  'n words$word)) in
   let ys =
     ((shiftr
        ((and_vec ys
            ((slice_mask ((int_of_num (words$word_len xs))) j' ((((i' - j')) + (( 1 : int):ii)))  :  'n words$word))
           :  'n words$word)) j'
       :  'n words$word)) in
   (xs = ys)))`;


(*val subrange_subrange_concat : forall 'n   'm   's . Size 'm, Size 'n, Size 's => integer -> mword 'n -> integer -> integer -> mword 'm -> integer -> integer -> mword 's*)

val _ = Define `
 ((subrange_subrange_concat:int -> 'n words$word -> int -> int -> 'm words$word -> int -> int -> 's words$word) (s__tv : int) xs i j ys i' j'=
    (let xs =
     ((shiftr
        ((and_vec xs
            ((slice_mask ((int_of_num (words$word_len xs))) j ((((i - j)) + (( 1 : int):ii)))  :  'n words$word))
           :  'n words$word)) j
       :  'n words$word)) in
   let ys =
     ((shiftr
        ((and_vec ys
            ((slice_mask ((int_of_num (words$word_len ys))) j' ((((i' - j')) + (( 1 : int):ii)))  :  'm words$word))
           :  'm words$word)) j'
       :  'm words$word)) in
   (or_vec
      ((shiftl ((extzv s__tv xs  :  's words$word)) ((((i' - j')) + (( 1 : int):ii)))
         :  's words$word)) ((extzv s__tv ys  :  's words$word))
     :  's words$word)))`;


(*val place_subrange : forall 'n 'm . Size 'm, Size 'n => integer -> mword 'n -> ii -> ii -> ii -> mword 'm*)

val _ = Define `
 ((place_subrange:int -> 'n words$word -> int -> int -> int -> 'm words$word) (m__tv : int) xs i j shift=
    (let xs =
     ((shiftr
        ((and_vec xs
            ((slice_mask ((int_of_num (words$word_len xs))) j ((((i - j)) + (( 1 : int):ii)))  :  'n words$word))
           :  'n words$word)) j
       :  'n words$word)) in
   (shiftl ((extzv m__tv xs  :  'm words$word)) shift  :  'm words$word)))`;


(*val place_slice : forall 'n 'm . Size 'm, Size 'n => integer -> mword 'n -> ii -> ii -> ii -> mword 'm*)

val _ = Define `
 ((place_slice:int -> 'n words$word -> int -> int -> int -> 'm words$word) (m__tv : int) xs i l shift=
    (let xs =
     ((shiftr ((and_vec xs ((slice_mask ((int_of_num (words$word_len xs))) i l  :  'n words$word))  :  'n words$word)) i  :  'n words$word)) in
   (shiftl ((extzv m__tv xs  :  'm words$word)) shift  :  'm words$word)))`;


(*val zext_slice : forall 'n 'm . Size 'm, Size 'n => integer -> mword 'n -> ii -> ii -> mword 'm*)

val _ = Define `
 ((zext_slice:int -> 'n words$word -> int -> int -> 'm words$word) (m__tv : int) xs i l=
    (let xs =
     ((shiftr ((and_vec xs ((slice_mask ((int_of_num (words$word_len xs))) i l  :  'n words$word))  :  'n words$word)) i  :  'n words$word)) in
   (extzv m__tv xs  :  'm words$word)))`;


(*val sext_slice : forall 'n 'm . Size 'm, Size 'n => integer -> mword 'n -> ii -> ii -> mword 'm*)

val _ = Define `
 ((sext_slice:int -> 'n words$word -> int -> int -> 'm words$word) (m__tv : int) xs i l=
    (let xs =
     ((arith_shiftr
        ((shiftl ((and_vec xs ((slice_mask ((int_of_num (words$word_len xs))) i l  :  'n words$word))  :  'n words$word))
            ((((((int_of_num (words$word_len xs))) - i)) - l))
           :  'n words$word)) ((((int_of_num (words$word_len xs))) - l))
       :  'n words$word)) in
   (extsv m__tv xs  :  'm words$word)))`;


(*val unsigned_slice : forall 'n . Size 'n => mword 'n -> ii -> ii -> ii*)

val _ = Define `
 ((unsigned_slice:'n words$word -> int -> int -> int) xs i l=
    (let xs =
     ((shiftr ((and_vec xs ((slice_mask ((int_of_num (words$word_len xs))) i l  :  'n words$word))  :  'n words$word)) i  :  'n words$word)) in
   lem$w2ui xs))`;


(*val unsigned_subrange : forall 'n . Size 'n => mword 'n -> ii -> ii -> ii*)

val _ = Define `
 ((unsigned_subrange:'n words$word -> int -> int -> int) xs i j=
    (let xs =
     ((shiftr
        ((and_vec xs
            ((slice_mask ((int_of_num (words$word_len xs))) j ((((i - j)) + (( 1 : int):ii)))  :  'n words$word))
           :  'n words$word)) i
       :  'n words$word)) in
   lem$w2ui xs))`;


(*val zext_ones : forall 'n . Size 'n => integer -> ii -> mword 'n*)

val _ = Define `
 ((zext_ones:int -> int -> 'n words$word) (n__tv : int) m=
    (let (v : 'n bits) = ((extsv n__tv (vec_of_bits [B1]  :  1 words$word)  :  'n words$word)) in
   (shiftr v ((((int_of_num (words$word_len v))) - m))  :  'n words$word)))`;


(*val boolean_of_num : integer -> boolean*)

val _ = Define `
 ((boolean_of_num:int -> boolean) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then FALSE
   else TRUE))`;


(*val num_of_boolean : boolean -> integer*)

val _ = Define `
 ((num_of_boolean:boolean -> int) arg_=  ((case arg_ of   FALSE => (( 0 : int):ii) | TRUE => (( 1 : int):ii) )))`;


(*val undefined_boolean : unit -> M boolean*)

val _ = Define `
 ((undefined_boolean:unit ->(regstate)sail2_state_monad$sequential_state ->(((boolean),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state$internal_pickS [FALSE;TRUE]))`;


(*val signal_of_num : integer -> signal*)

val _ = Define `
 ((signal_of_num:int -> signal) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then LOW
   else HIGH))`;


(*val num_of_signal : signal -> integer*)

val _ = Define `
 ((num_of_signal:signal -> int) arg_=  ((case arg_ of   LOW => (( 0 : int):ii) | HIGH => (( 1 : int):ii) )))`;


(*val undefined_signal : unit -> M signal*)

val _ = Define `
 ((undefined_signal:unit ->(regstate)sail2_state_monad$sequential_state ->(((signal),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state$internal_pickS [LOW;HIGH]))`;


(*val __RetCode_of_num : integer -> __RetCode*)

val _ = Define `
 ((RetCode_of_num:int -> RetCode) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then RC_OK
   else if (((p0_ = (( 1 : int):ii)))) then RC_UNDEFINED
   else if (((p0_ = (( 2 : int):ii)))) then RC_UNPREDICTABLE
   else if (((p0_ = (( 3 : int):ii)))) then RC_SEE
   else if (((p0_ = (( 4 : int):ii)))) then RC_IMPLEMENTATION_DEFINED
   else if (((p0_ = (( 5 : int):ii)))) then RC_SUBARCHITECTURE_DEFINED
   else if (((p0_ = (( 6 : int):ii)))) then RC_EXCEPTION_TAKEN
   else if (((p0_ = (( 7 : int):ii)))) then RC_ASSERT_FAILED
   else RC_UNMATCHED_CASE))`;


(*val num_of___RetCode : __RetCode -> integer*)

val _ = Define `
 ((num_of___RetCode:RetCode -> int) arg_=
    ((case arg_ of
     RC_OK => (( 0 : int):ii)
   | RC_UNDEFINED => (( 1 : int):ii)
   | RC_UNPREDICTABLE => (( 2 : int):ii)
   | RC_SEE => (( 3 : int):ii)
   | RC_IMPLEMENTATION_DEFINED => (( 4 : int):ii)
   | RC_SUBARCHITECTURE_DEFINED => (( 5 : int):ii)
   | RC_EXCEPTION_TAKEN => (( 6 : int):ii)
   | RC_ASSERT_FAILED => (( 7 : int):ii)
   | RC_UNMATCHED_CASE => (( 8 : int):ii)
   )))`;


(*val undefined___RetCode : unit -> M __RetCode*)

val _ = Define `
 ((undefined___RetCode:unit ->(regstate)sail2_state_monad$sequential_state ->(((RetCode),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$internal_pickS
     [RC_OK;RC_UNDEFINED;RC_UNPREDICTABLE;RC_SEE;RC_IMPLEMENTATION_DEFINED;RC_SUBARCHITECTURE_DEFINED;RC_EXCEPTION_TAKEN;RC_ASSERT_FAILED;RC_UNMATCHED_CASE]))`;


(*val FPConvOp_of_num : integer -> FPConvOp*)

val _ = Define `
 ((FPConvOp_of_num:int -> FPConvOp) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then FPConvOp_CVT_FtoI
   else if (((p0_ = (( 1 : int):ii)))) then FPConvOp_CVT_ItoF
   else if (((p0_ = (( 2 : int):ii)))) then FPConvOp_MOV_FtoI
   else if (((p0_ = (( 3 : int):ii)))) then FPConvOp_MOV_ItoF
   else FPConvOp_CVT_FtoI_JS))`;


(*val num_of_FPConvOp : FPConvOp -> integer*)

val _ = Define `
 ((num_of_FPConvOp:FPConvOp -> int) arg_=
    ((case arg_ of
     FPConvOp_CVT_FtoI => (( 0 : int):ii)
   | FPConvOp_CVT_ItoF => (( 1 : int):ii)
   | FPConvOp_MOV_FtoI => (( 2 : int):ii)
   | FPConvOp_MOV_ItoF => (( 3 : int):ii)
   | FPConvOp_CVT_FtoI_JS => (( 4 : int):ii)
   )))`;


(*val undefined_FPConvOp : unit -> M FPConvOp*)

val _ = Define `
 ((undefined_FPConvOp:unit ->(regstate)sail2_state_monad$sequential_state ->(((FPConvOp),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$internal_pickS
     [FPConvOp_CVT_FtoI;FPConvOp_CVT_ItoF;FPConvOp_MOV_FtoI;FPConvOp_MOV_ItoF;FPConvOp_CVT_FtoI_JS]))`;


(*val Exception_of_num : integer -> Exception*)

val _ = Define `
 ((Exception_of_num:int -> Exception) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then Exception_Uncategorized
   else if (((p0_ = (( 1 : int):ii)))) then Exception_WFxTrap
   else if (((p0_ = (( 2 : int):ii)))) then Exception_CP15RTTrap
   else if (((p0_ = (( 3 : int):ii)))) then Exception_CP15RRTTrap
   else if (((p0_ = (( 4 : int):ii)))) then Exception_CP14RTTrap
   else if (((p0_ = (( 5 : int):ii)))) then Exception_CP14DTTrap
   else if (((p0_ = (( 6 : int):ii)))) then Exception_AdvSIMDFPAccessTrap
   else if (((p0_ = (( 7 : int):ii)))) then Exception_FPIDTrap
   else if (((p0_ = (( 8 : int):ii)))) then Exception_PACTrap
   else if (((p0_ = (( 9 : int):ii)))) then Exception_CP14RRTTrap
   else if (((p0_ = (( 10 : int):ii)))) then Exception_IllegalState
   else if (((p0_ = (( 11 : int):ii)))) then Exception_SupervisorCall
   else if (((p0_ = (( 12 : int):ii)))) then Exception_HypervisorCall
   else if (((p0_ = (( 13 : int):ii)))) then Exception_MonitorCall
   else if (((p0_ = (( 14 : int):ii)))) then Exception_SystemRegisterTrap
   else if (((p0_ = (( 15 : int):ii)))) then Exception_ERetTrap
   else if (((p0_ = (( 16 : int):ii)))) then Exception_InstructionAbort
   else if (((p0_ = (( 17 : int):ii)))) then Exception_PCAlignment
   else if (((p0_ = (( 18 : int):ii)))) then Exception_DataAbort
   else if (((p0_ = (( 19 : int):ii)))) then Exception_SPAlignment
   else if (((p0_ = (( 20 : int):ii)))) then Exception_FPTrappedException
   else if (((p0_ = (( 21 : int):ii)))) then Exception_SError
   else if (((p0_ = (( 22 : int):ii)))) then Exception_Breakpoint
   else if (((p0_ = (( 23 : int):ii)))) then Exception_SoftwareStep
   else if (((p0_ = (( 24 : int):ii)))) then Exception_Watchpoint
   else if (((p0_ = (( 25 : int):ii)))) then Exception_SoftwareBreakpoint
   else if (((p0_ = (( 26 : int):ii)))) then Exception_VectorCatch
   else if (((p0_ = (( 27 : int):ii)))) then Exception_IRQ
   else Exception_FIQ))`;


(*val num_of_Exception : Exception -> integer*)

val _ = Define `
 ((num_of_Exception:Exception -> int) arg_=
    ((case arg_ of
     Exception_Uncategorized => (( 0 : int):ii)
   | Exception_WFxTrap => (( 1 : int):ii)
   | Exception_CP15RTTrap => (( 2 : int):ii)
   | Exception_CP15RRTTrap => (( 3 : int):ii)
   | Exception_CP14RTTrap => (( 4 : int):ii)
   | Exception_CP14DTTrap => (( 5 : int):ii)
   | Exception_AdvSIMDFPAccessTrap => (( 6 : int):ii)
   | Exception_FPIDTrap => (( 7 : int):ii)
   | Exception_PACTrap => (( 8 : int):ii)
   | Exception_CP14RRTTrap => (( 9 : int):ii)
   | Exception_IllegalState => (( 10 : int):ii)
   | Exception_SupervisorCall => (( 11 : int):ii)
   | Exception_HypervisorCall => (( 12 : int):ii)
   | Exception_MonitorCall => (( 13 : int):ii)
   | Exception_SystemRegisterTrap => (( 14 : int):ii)
   | Exception_ERetTrap => (( 15 : int):ii)
   | Exception_InstructionAbort => (( 16 : int):ii)
   | Exception_PCAlignment => (( 17 : int):ii)
   | Exception_DataAbort => (( 18 : int):ii)
   | Exception_SPAlignment => (( 19 : int):ii)
   | Exception_FPTrappedException => (( 20 : int):ii)
   | Exception_SError => (( 21 : int):ii)
   | Exception_Breakpoint => (( 22 : int):ii)
   | Exception_SoftwareStep => (( 23 : int):ii)
   | Exception_Watchpoint => (( 24 : int):ii)
   | Exception_SoftwareBreakpoint => (( 25 : int):ii)
   | Exception_VectorCatch => (( 26 : int):ii)
   | Exception_IRQ => (( 27 : int):ii)
   | Exception_FIQ => (( 28 : int):ii)
   )))`;


(*val undefined_Exception : unit -> M Exception*)

val _ = Define `
 ((undefined_Exception:unit ->(regstate)sail2_state_monad$sequential_state ->(((Exception),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$internal_pickS
     [Exception_Uncategorized;Exception_WFxTrap;Exception_CP15RTTrap;Exception_CP15RRTTrap;Exception_CP14RTTrap;Exception_CP14DTTrap;Exception_AdvSIMDFPAccessTrap;Exception_FPIDTrap;Exception_PACTrap;Exception_CP14RRTTrap;Exception_IllegalState;Exception_SupervisorCall;Exception_HypervisorCall;Exception_MonitorCall;Exception_SystemRegisterTrap;Exception_ERetTrap;Exception_InstructionAbort;Exception_PCAlignment;Exception_DataAbort;Exception_SPAlignment;Exception_FPTrappedException;Exception_SError;Exception_Breakpoint;Exception_SoftwareStep;Exception_Watchpoint;Exception_SoftwareBreakpoint;Exception_VectorCatch;Exception_IRQ;Exception_FIQ]))`;


(*val ArchVersion_of_num : integer -> ArchVersion*)

val _ = Define `
 ((ArchVersion_of_num:int -> ArchVersion) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then ARMv8p0
   else if (((p0_ = (( 1 : int):ii)))) then ARMv8p1
   else if (((p0_ = (( 2 : int):ii)))) then ARMv8p2
   else ARMv8p3))`;


(*val num_of_ArchVersion : ArchVersion -> integer*)

val _ = Define `
 ((num_of_ArchVersion:ArchVersion -> int) arg_=
    ((case arg_ of
     ARMv8p0 => (( 0 : int):ii)
   | ARMv8p1 => (( 1 : int):ii)
   | ARMv8p2 => (( 2 : int):ii)
   | ARMv8p3 => (( 3 : int):ii)
   )))`;


(*val undefined_ArchVersion : unit -> M ArchVersion*)

val _ = Define `
 ((undefined_ArchVersion:unit ->(regstate)sail2_state_monad$sequential_state ->(((ArchVersion),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state$internal_pickS [ARMv8p0;ARMv8p1;ARMv8p2;ARMv8p3]))`;


(*val Unpredictable_of_num : integer -> Unpredictable*)

val _ = Define `
 ((Unpredictable_of_num:int -> Unpredictable) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then Unpredictable_WBOVERLAPLD
   else if (((p0_ = (( 1 : int):ii)))) then Unpredictable_WBOVERLAPST
   else if (((p0_ = (( 2 : int):ii)))) then Unpredictable_LDPOVERLAP
   else if (((p0_ = (( 3 : int):ii)))) then Unpredictable_BASEOVERLAP
   else if (((p0_ = (( 4 : int):ii)))) then Unpredictable_DATAOVERLAP
   else if (((p0_ = (( 5 : int):ii)))) then Unpredictable_DEVPAGE2
   else if (((p0_ = (( 6 : int):ii)))) then Unpredictable_INSTRDEVICE
   else if (((p0_ = (( 7 : int):ii)))) then Unpredictable_RESCPACR
   else if (((p0_ = (( 8 : int):ii)))) then Unpredictable_RESMAIR
   else if (((p0_ = (( 9 : int):ii)))) then Unpredictable_RESTEXCB
   else if (((p0_ = (( 10 : int):ii)))) then Unpredictable_RESPRRR
   else if (((p0_ = (( 11 : int):ii)))) then Unpredictable_RESDACR
   else if (((p0_ = (( 12 : int):ii)))) then Unpredictable_RESVTCRS
   else if (((p0_ = (( 13 : int):ii)))) then Unpredictable_RESTnSZ
   else if (((p0_ = (( 14 : int):ii)))) then Unpredictable_OORTnSZ
   else if (((p0_ = (( 15 : int):ii)))) then Unpredictable_LARGEIPA
   else if (((p0_ = (( 16 : int):ii)))) then Unpredictable_ESRCONDPASS
   else if (((p0_ = (( 17 : int):ii)))) then Unpredictable_ILZEROIT
   else if (((p0_ = (( 18 : int):ii)))) then Unpredictable_ILZEROT
   else if (((p0_ = (( 19 : int):ii)))) then Unpredictable_BPVECTORCATCHPRI
   else if (((p0_ = (( 20 : int):ii)))) then Unpredictable_VCMATCHHALF
   else if (((p0_ = (( 21 : int):ii)))) then Unpredictable_VCMATCHDAPA
   else if (((p0_ = (( 22 : int):ii)))) then Unpredictable_WPMASKANDBAS
   else if (((p0_ = (( 23 : int):ii)))) then Unpredictable_WPBASCONTIGUOUS
   else if (((p0_ = (( 24 : int):ii)))) then Unpredictable_RESWPMASK
   else if (((p0_ = (( 25 : int):ii)))) then Unpredictable_WPMASKEDBITS
   else if (((p0_ = (( 26 : int):ii)))) then Unpredictable_RESBPWPCTRL
   else if (((p0_ = (( 27 : int):ii)))) then Unpredictable_BPNOTIMPL
   else if (((p0_ = (( 28 : int):ii)))) then Unpredictable_RESBPTYPE
   else if (((p0_ = (( 29 : int):ii)))) then Unpredictable_BPNOTCTXCMP
   else if (((p0_ = (( 30 : int):ii)))) then Unpredictable_BPMATCHHALF
   else if (((p0_ = (( 31 : int):ii)))) then Unpredictable_BPMISMATCHHALF
   else if (((p0_ = (( 32 : int):ii)))) then Unpredictable_RESTARTALIGNPC
   else if (((p0_ = (( 33 : int):ii)))) then Unpredictable_RESTARTZEROUPPERPC
   else if (((p0_ = (( 34 : int):ii)))) then Unpredictable_ZEROUPPER
   else if (((p0_ = (( 35 : int):ii)))) then Unpredictable_ERETZEROUPPERPC
   else if (((p0_ = (( 36 : int):ii)))) then Unpredictable_A32FORCEALIGNPC
   else if (((p0_ = (( 37 : int):ii)))) then Unpredictable_SMD
   else if (((p0_ = (( 38 : int):ii)))) then Unpredictable_AFUPDATE
   else if (((p0_ = (( 39 : int):ii)))) then Unpredictable_IESBinDebug
   else if (((p0_ = (( 40 : int):ii)))) then Unpredictable_ZEROPMSEVFR
   else if (((p0_ = (( 41 : int):ii)))) then Unpredictable_NOOPTYPES
   else if (((p0_ = (( 42 : int):ii)))) then Unpredictable_ZEROMINLATENCY
   else if (((p0_ = (( 43 : int):ii)))) then Unpredictable_CLEARERRITEZERO
   else Unpredictable_TBD))`;


(*val num_of_Unpredictable : Unpredictable -> integer*)

val _ = Define `
 ((num_of_Unpredictable:Unpredictable -> int) arg_=
    ((case arg_ of
     Unpredictable_WBOVERLAPLD => (( 0 : int):ii)
   | Unpredictable_WBOVERLAPST => (( 1 : int):ii)
   | Unpredictable_LDPOVERLAP => (( 2 : int):ii)
   | Unpredictable_BASEOVERLAP => (( 3 : int):ii)
   | Unpredictable_DATAOVERLAP => (( 4 : int):ii)
   | Unpredictable_DEVPAGE2 => (( 5 : int):ii)
   | Unpredictable_INSTRDEVICE => (( 6 : int):ii)
   | Unpredictable_RESCPACR => (( 7 : int):ii)
   | Unpredictable_RESMAIR => (( 8 : int):ii)
   | Unpredictable_RESTEXCB => (( 9 : int):ii)
   | Unpredictable_RESPRRR => (( 10 : int):ii)
   | Unpredictable_RESDACR => (( 11 : int):ii)
   | Unpredictable_RESVTCRS => (( 12 : int):ii)
   | Unpredictable_RESTnSZ => (( 13 : int):ii)
   | Unpredictable_OORTnSZ => (( 14 : int):ii)
   | Unpredictable_LARGEIPA => (( 15 : int):ii)
   | Unpredictable_ESRCONDPASS => (( 16 : int):ii)
   | Unpredictable_ILZEROIT => (( 17 : int):ii)
   | Unpredictable_ILZEROT => (( 18 : int):ii)
   | Unpredictable_BPVECTORCATCHPRI => (( 19 : int):ii)
   | Unpredictable_VCMATCHHALF => (( 20 : int):ii)
   | Unpredictable_VCMATCHDAPA => (( 21 : int):ii)
   | Unpredictable_WPMASKANDBAS => (( 22 : int):ii)
   | Unpredictable_WPBASCONTIGUOUS => (( 23 : int):ii)
   | Unpredictable_RESWPMASK => (( 24 : int):ii)
   | Unpredictable_WPMASKEDBITS => (( 25 : int):ii)
   | Unpredictable_RESBPWPCTRL => (( 26 : int):ii)
   | Unpredictable_BPNOTIMPL => (( 27 : int):ii)
   | Unpredictable_RESBPTYPE => (( 28 : int):ii)
   | Unpredictable_BPNOTCTXCMP => (( 29 : int):ii)
   | Unpredictable_BPMATCHHALF => (( 30 : int):ii)
   | Unpredictable_BPMISMATCHHALF => (( 31 : int):ii)
   | Unpredictable_RESTARTALIGNPC => (( 32 : int):ii)
   | Unpredictable_RESTARTZEROUPPERPC => (( 33 : int):ii)
   | Unpredictable_ZEROUPPER => (( 34 : int):ii)
   | Unpredictable_ERETZEROUPPERPC => (( 35 : int):ii)
   | Unpredictable_A32FORCEALIGNPC => (( 36 : int):ii)
   | Unpredictable_SMD => (( 37 : int):ii)
   | Unpredictable_AFUPDATE => (( 38 : int):ii)
   | Unpredictable_IESBinDebug => (( 39 : int):ii)
   | Unpredictable_ZEROPMSEVFR => (( 40 : int):ii)
   | Unpredictable_NOOPTYPES => (( 41 : int):ii)
   | Unpredictable_ZEROMINLATENCY => (( 42 : int):ii)
   | Unpredictable_CLEARERRITEZERO => (( 43 : int):ii)
   | Unpredictable_TBD => (( 44 : int):ii)
   )))`;


(*val undefined_Unpredictable : unit -> M Unpredictable*)

val _ = Define `
 ((undefined_Unpredictable:unit ->(regstate)sail2_state_monad$sequential_state ->(((Unpredictable),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$internal_pickS
     [Unpredictable_WBOVERLAPLD;Unpredictable_WBOVERLAPST;Unpredictable_LDPOVERLAP;Unpredictable_BASEOVERLAP;Unpredictable_DATAOVERLAP;Unpredictable_DEVPAGE2;Unpredictable_INSTRDEVICE;Unpredictable_RESCPACR;Unpredictable_RESMAIR;Unpredictable_RESTEXCB;Unpredictable_RESPRRR;Unpredictable_RESDACR;Unpredictable_RESVTCRS;Unpredictable_RESTnSZ;Unpredictable_OORTnSZ;Unpredictable_LARGEIPA;Unpredictable_ESRCONDPASS;Unpredictable_ILZEROIT;Unpredictable_ILZEROT;Unpredictable_BPVECTORCATCHPRI;Unpredictable_VCMATCHHALF;Unpredictable_VCMATCHDAPA;Unpredictable_WPMASKANDBAS;Unpredictable_WPBASCONTIGUOUS;Unpredictable_RESWPMASK;Unpredictable_WPMASKEDBITS;Unpredictable_RESBPWPCTRL;Unpredictable_BPNOTIMPL;Unpredictable_RESBPTYPE;Unpredictable_BPNOTCTXCMP;Unpredictable_BPMATCHHALF;Unpredictable_BPMISMATCHHALF;Unpredictable_RESTARTALIGNPC;Unpredictable_RESTARTZEROUPPERPC;Unpredictable_ZEROUPPER;Unpredictable_ERETZEROUPPERPC;Unpredictable_A32FORCEALIGNPC;Unpredictable_SMD;Unpredictable_AFUPDATE;Unpredictable_IESBinDebug;Unpredictable_ZEROPMSEVFR;Unpredictable_NOOPTYPES;Unpredictable_ZEROMINLATENCY;Unpredictable_CLEARERRITEZERO;Unpredictable_TBD]))`;


(*val Constraint_of_num : integer -> Constraint*)

val _ = Define `
 ((Constraint_of_num:int -> Constraint) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then Constraint_NONE
   else if (((p0_ = (( 1 : int):ii)))) then Constraint_UNKNOWN
   else if (((p0_ = (( 2 : int):ii)))) then Constraint_UNDEF
   else if (((p0_ = (( 3 : int):ii)))) then Constraint_UNDEFEL0
   else if (((p0_ = (( 4 : int):ii)))) then Constraint_NOP
   else if (((p0_ = (( 5 : int):ii)))) then Constraint_TRUE
   else if (((p0_ = (( 6 : int):ii)))) then Constraint_FALSE
   else if (((p0_ = (( 7 : int):ii)))) then Constraint_DISABLED
   else if (((p0_ = (( 8 : int):ii)))) then Constraint_UNCOND
   else if (((p0_ = (( 9 : int):ii)))) then Constraint_COND
   else if (((p0_ = (( 10 : int):ii)))) then Constraint_ADDITIONAL_DECODE
   else if (((p0_ = (( 11 : int):ii)))) then Constraint_WBSUPPRESS
   else if (((p0_ = (( 12 : int):ii)))) then Constraint_FAULT
   else if (((p0_ = (( 13 : int):ii)))) then Constraint_FORCE
   else Constraint_FORCENOSLCHECK))`;


(*val num_of_Constraint : Constraint -> integer*)

val _ = Define `
 ((num_of_Constraint:Constraint -> int) arg_=
    ((case arg_ of
     Constraint_NONE => (( 0 : int):ii)
   | Constraint_UNKNOWN => (( 1 : int):ii)
   | Constraint_UNDEF => (( 2 : int):ii)
   | Constraint_UNDEFEL0 => (( 3 : int):ii)
   | Constraint_NOP => (( 4 : int):ii)
   | Constraint_TRUE => (( 5 : int):ii)
   | Constraint_FALSE => (( 6 : int):ii)
   | Constraint_DISABLED => (( 7 : int):ii)
   | Constraint_UNCOND => (( 8 : int):ii)
   | Constraint_COND => (( 9 : int):ii)
   | Constraint_ADDITIONAL_DECODE => (( 10 : int):ii)
   | Constraint_WBSUPPRESS => (( 11 : int):ii)
   | Constraint_FAULT => (( 12 : int):ii)
   | Constraint_FORCE => (( 13 : int):ii)
   | Constraint_FORCENOSLCHECK => (( 14 : int):ii)
   )))`;


(*val undefined_Constraint : unit -> M Constraint*)

val _ = Define `
 ((undefined_Constraint:unit ->(regstate)sail2_state_monad$sequential_state ->(((Constraint),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$internal_pickS
     [Constraint_NONE;Constraint_UNKNOWN;Constraint_UNDEF;Constraint_UNDEFEL0;Constraint_NOP;Constraint_TRUE;Constraint_FALSE;Constraint_DISABLED;Constraint_UNCOND;Constraint_COND;Constraint_ADDITIONAL_DECODE;Constraint_WBSUPPRESS;Constraint_FAULT;Constraint_FORCE;Constraint_FORCENOSLCHECK]))`;


(*val InstrSet_of_num : integer -> InstrSet*)

val _ = Define `
 ((InstrSet_of_num:int -> InstrSet) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then InstrSet_A64
   else if (((p0_ = (( 1 : int):ii)))) then InstrSet_A32
   else InstrSet_T32))`;


(*val num_of_InstrSet : InstrSet -> integer*)

val _ = Define `
 ((num_of_InstrSet:InstrSet -> int) arg_=
    ((case arg_ of   InstrSet_A64 => (( 0 : int):ii) | InstrSet_A32 => (( 1 : int):ii) | InstrSet_T32 => (( 2 : int):ii) )))`;


(*val undefined_InstrSet : unit -> M InstrSet*)

val _ = Define `
 ((undefined_InstrSet:unit ->(regstate)sail2_state_monad$sequential_state ->(((InstrSet),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state$internal_pickS [InstrSet_A64;InstrSet_A32;InstrSet_T32]))`;


(*val undefined_ProcState : unit -> M ProcState*)

val _ = Define `
 ((undefined_ProcState:unit ->(regstate)sail2_state_monad$sequential_state ->(((ProcState),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__0 : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__1 : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__2 : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__3 : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__4 : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__5 : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__6 : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__7 : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__8 : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__9 : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__10 : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__11 : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 2 : int):ii)  : ( 2 words$word) M) (\ (w__12 : 2 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__13 : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__14 : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__15 : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (w__16 : 4 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M) (\ (w__17 : 8 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__18 : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__19 : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__20 : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 5 : int):ii)  : ( 5 words$word) M) (\ (w__21 : 5 bits) . 
   sail2_state_monad$returnS (<| ProcState_N := w__0; 
              ProcState_Z := w__1; 
              ProcState_C := w__2; 
              ProcState_V := w__3; 
              ProcState_D := w__4; 
              ProcState_A := w__5; 
              ProcState_I := w__6; 
              ProcState_F := w__7; 
              ProcState_PAN := w__8; 
              ProcState_UAO := w__9; 
              ProcState_SS := w__10; 
              ProcState_IL := w__11; 
              ProcState_EL := w__12; 
              ProcState_nRW := w__13; 
              ProcState_SP := w__14; 
              ProcState_Q := w__15; 
              ProcState_GE := w__16; 
              ProcState_IT := w__17; 
              ProcState_J := w__18; 
              ProcState_T := w__19; 
              ProcState_E := w__20; 
              ProcState_M := w__21 |>)))))))))))))))))))))))))`;


(*val BranchType_of_num : integer -> BranchType*)

val _ = Define `
 ((BranchType_of_num:int -> BranchType) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then BranchType_CALL
   else if (((p0_ = (( 1 : int):ii)))) then BranchType_ERET
   else if (((p0_ = (( 2 : int):ii)))) then BranchType_DBGEXIT
   else if (((p0_ = (( 3 : int):ii)))) then BranchType_RET
   else if (((p0_ = (( 4 : int):ii)))) then BranchType_JMP
   else if (((p0_ = (( 5 : int):ii)))) then BranchType_EXCEPTION
   else BranchType_UNKNOWN))`;


(*val num_of_BranchType : BranchType -> integer*)

val _ = Define `
 ((num_of_BranchType:BranchType -> int) arg_=
    ((case arg_ of
     BranchType_CALL => (( 0 : int):ii)
   | BranchType_ERET => (( 1 : int):ii)
   | BranchType_DBGEXIT => (( 2 : int):ii)
   | BranchType_RET => (( 3 : int):ii)
   | BranchType_JMP => (( 4 : int):ii)
   | BranchType_EXCEPTION => (( 5 : int):ii)
   | BranchType_UNKNOWN => (( 6 : int):ii)
   )))`;


(*val undefined_BranchType : unit -> M BranchType*)

val _ = Define `
 ((undefined_BranchType:unit ->(regstate)sail2_state_monad$sequential_state ->(((BranchType),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$internal_pickS
     [BranchType_CALL;BranchType_ERET;BranchType_DBGEXIT;BranchType_RET;BranchType_JMP;BranchType_EXCEPTION;BranchType_UNKNOWN]))`;


(*val undefined_ExceptionRecord : unit -> M ExceptionRecord*)

val _ = Define `
 ((undefined_ExceptionRecord:unit ->(regstate)sail2_state_monad$sequential_state ->(((ExceptionRecord),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (undefined_Exception () ) (\ (w__0 : Exception) .  sail2_state_monad$bindS
   (undefined_bitvector (( 25 : int):ii)  : ( 25 words$word) M) (\ (w__1 : 25 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (w__2 : 64 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (w__3 : bool) .  sail2_state_monad$bindS
   (undefined_bitvector (( 52 : int):ii)  : ( 52 words$word) M) (\ (w__4 : 52 bits) . 
   sail2_state_monad$returnS (<| ExceptionRecord_typ := w__0; 
              ExceptionRecord_syndrome := w__1; 
              ExceptionRecord_vaddress := w__2; 
              ExceptionRecord_ipavalid := w__3; 
              ExceptionRecord_ipaddress := w__4 |>))))))))`;


(*val Fault_of_num : integer -> Fault*)

val _ = Define `
 ((Fault_of_num:int -> Fault) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then Fault_None
   else if (((p0_ = (( 1 : int):ii)))) then Fault_AccessFlag
   else if (((p0_ = (( 2 : int):ii)))) then Fault_Alignment
   else if (((p0_ = (( 3 : int):ii)))) then Fault_Background
   else if (((p0_ = (( 4 : int):ii)))) then Fault_Domain
   else if (((p0_ = (( 5 : int):ii)))) then Fault_Permission
   else if (((p0_ = (( 6 : int):ii)))) then Fault_Translation
   else if (((p0_ = (( 7 : int):ii)))) then Fault_AddressSize
   else if (((p0_ = (( 8 : int):ii)))) then Fault_SyncExternal
   else if (((p0_ = (( 9 : int):ii)))) then Fault_SyncExternalOnWalk
   else if (((p0_ = (( 10 : int):ii)))) then Fault_SyncParity
   else if (((p0_ = (( 11 : int):ii)))) then Fault_SyncParityOnWalk
   else if (((p0_ = (( 12 : int):ii)))) then Fault_AsyncParity
   else if (((p0_ = (( 13 : int):ii)))) then Fault_AsyncExternal
   else if (((p0_ = (( 14 : int):ii)))) then Fault_Debug
   else if (((p0_ = (( 15 : int):ii)))) then Fault_TLBConflict
   else if (((p0_ = (( 16 : int):ii)))) then Fault_Lockdown
   else if (((p0_ = (( 17 : int):ii)))) then Fault_Exclusive
   else Fault_ICacheMaint))`;


(*val num_of_Fault : Fault -> integer*)

val _ = Define `
 ((num_of_Fault:Fault -> int) arg_=
    ((case arg_ of
     Fault_None => (( 0 : int):ii)
   | Fault_AccessFlag => (( 1 : int):ii)
   | Fault_Alignment => (( 2 : int):ii)
   | Fault_Background => (( 3 : int):ii)
   | Fault_Domain => (( 4 : int):ii)
   | Fault_Permission => (( 5 : int):ii)
   | Fault_Translation => (( 6 : int):ii)
   | Fault_AddressSize => (( 7 : int):ii)
   | Fault_SyncExternal => (( 8 : int):ii)
   | Fault_SyncExternalOnWalk => (( 9 : int):ii)
   | Fault_SyncParity => (( 10 : int):ii)
   | Fault_SyncParityOnWalk => (( 11 : int):ii)
   | Fault_AsyncParity => (( 12 : int):ii)
   | Fault_AsyncExternal => (( 13 : int):ii)
   | Fault_Debug => (( 14 : int):ii)
   | Fault_TLBConflict => (( 15 : int):ii)
   | Fault_Lockdown => (( 16 : int):ii)
   | Fault_Exclusive => (( 17 : int):ii)
   | Fault_ICacheMaint => (( 18 : int):ii)
   )))`;


(*val undefined_Fault : unit -> M Fault*)

val _ = Define `
 ((undefined_Fault:unit ->(regstate)sail2_state_monad$sequential_state ->(((Fault),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$internal_pickS
     [Fault_None;Fault_AccessFlag;Fault_Alignment;Fault_Background;Fault_Domain;Fault_Permission;Fault_Translation;Fault_AddressSize;Fault_SyncExternal;Fault_SyncExternalOnWalk;Fault_SyncParity;Fault_SyncParityOnWalk;Fault_AsyncParity;Fault_AsyncExternal;Fault_Debug;Fault_TLBConflict;Fault_Lockdown;Fault_Exclusive;Fault_ICacheMaint]))`;


(*val AccType_of_num : integer -> AccType*)

val _ = Define `
 ((AccType_of_num:int -> AccType) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then AccType_NORMAL
   else if (((p0_ = (( 1 : int):ii)))) then AccType_VEC
   else if (((p0_ = (( 2 : int):ii)))) then AccType_STREAM
   else if (((p0_ = (( 3 : int):ii)))) then AccType_VECSTREAM
   else if (((p0_ = (( 4 : int):ii)))) then AccType_ATOMIC
   else if (((p0_ = (( 5 : int):ii)))) then AccType_ATOMICRW
   else if (((p0_ = (( 6 : int):ii)))) then AccType_ORDERED
   else if (((p0_ = (( 7 : int):ii)))) then AccType_ORDEREDRW
   else if (((p0_ = (( 8 : int):ii)))) then AccType_LIMITEDORDERED
   else if (((p0_ = (( 9 : int):ii)))) then AccType_UNPRIV
   else if (((p0_ = (( 10 : int):ii)))) then AccType_IFETCH
   else if (((p0_ = (( 11 : int):ii)))) then AccType_PTW
   else if (((p0_ = (( 12 : int):ii)))) then AccType_DC
   else if (((p0_ = (( 13 : int):ii)))) then AccType_IC
   else if (((p0_ = (( 14 : int):ii)))) then AccType_DCZVA
   else AccType_AT))`;


(*val num_of_AccType : AccType -> integer*)

val _ = Define `
 ((num_of_AccType:AccType -> int) arg_=
    ((case arg_ of
     AccType_NORMAL => (( 0 : int):ii)
   | AccType_VEC => (( 1 : int):ii)
   | AccType_STREAM => (( 2 : int):ii)
   | AccType_VECSTREAM => (( 3 : int):ii)
   | AccType_ATOMIC => (( 4 : int):ii)
   | AccType_ATOMICRW => (( 5 : int):ii)
   | AccType_ORDERED => (( 6 : int):ii)
   | AccType_ORDEREDRW => (( 7 : int):ii)
   | AccType_LIMITEDORDERED => (( 8 : int):ii)
   | AccType_UNPRIV => (( 9 : int):ii)
   | AccType_IFETCH => (( 10 : int):ii)
   | AccType_PTW => (( 11 : int):ii)
   | AccType_DC => (( 12 : int):ii)
   | AccType_IC => (( 13 : int):ii)
   | AccType_DCZVA => (( 14 : int):ii)
   | AccType_AT => (( 15 : int):ii)
   )))`;


(*val undefined_AccType : unit -> M AccType*)

val _ = Define `
 ((undefined_AccType:unit ->(regstate)sail2_state_monad$sequential_state ->(((AccType),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$internal_pickS
     [AccType_NORMAL;AccType_VEC;AccType_STREAM;AccType_VECSTREAM;AccType_ATOMIC;AccType_ATOMICRW;AccType_ORDERED;AccType_ORDEREDRW;AccType_LIMITEDORDERED;AccType_UNPRIV;AccType_IFETCH;AccType_PTW;AccType_DC;AccType_IC;AccType_DCZVA;AccType_AT]))`;


(*val undefined_FaultRecord : unit -> M FaultRecord*)

val _ = Define `
 ((undefined_FaultRecord:unit ->(regstate)sail2_state_monad$sequential_state ->(((FaultRecord),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (undefined_Fault () ) (\ (w__0 : Fault) .  sail2_state_monad$bindS
   (undefined_AccType () ) (\ (w__1 : AccType) .  sail2_state_monad$bindS
   (undefined_bitvector (( 52 : int):ii)  : ( 52 words$word) M) (\ (w__2 : 52 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (w__3 : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (w__4 : bool) .  sail2_state_monad$bindS
   (undefined_int () ) (\ (w__5 : ii) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__6 : 1 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (w__7 : bool) .  sail2_state_monad$bindS
   (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (w__8 : 4 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 2 : int):ii)  : ( 2 words$word) M) (\ (w__9 : 2 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (w__10 : 4 bits) . 
   sail2_state_monad$returnS (<| FaultRecord_typ := w__0; 
              FaultRecord_acctype := w__1; 
              FaultRecord_ipaddress := w__2; 
              FaultRecord_s2fs1walk := w__3; 
              FaultRecord_write := w__4; 
              FaultRecord_level := w__5; 
              FaultRecord_extflag := w__6; 
              FaultRecord_secondstage := w__7; 
              FaultRecord_domain := w__8; 
              FaultRecord_errortype := w__9; 
              FaultRecord_debugmoe := w__10 |>))))))))))))))`;


(*val MBReqDomain_of_num : integer -> MBReqDomain*)

val _ = Define `
 ((MBReqDomain_of_num:int -> MBReqDomain) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then MBReqDomain_Nonshareable
   else if (((p0_ = (( 1 : int):ii)))) then MBReqDomain_InnerShareable
   else if (((p0_ = (( 2 : int):ii)))) then MBReqDomain_OuterShareable
   else MBReqDomain_FullSystem))`;


(*val num_of_MBReqDomain : MBReqDomain -> integer*)

val _ = Define `
 ((num_of_MBReqDomain:MBReqDomain -> int) arg_=
    ((case arg_ of
     MBReqDomain_Nonshareable => (( 0 : int):ii)
   | MBReqDomain_InnerShareable => (( 1 : int):ii)
   | MBReqDomain_OuterShareable => (( 2 : int):ii)
   | MBReqDomain_FullSystem => (( 3 : int):ii)
   )))`;


(*val undefined_MBReqDomain : unit -> M MBReqDomain*)

val _ = Define `
 ((undefined_MBReqDomain:unit ->(regstate)sail2_state_monad$sequential_state ->(((MBReqDomain),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$internal_pickS
     [MBReqDomain_Nonshareable;MBReqDomain_InnerShareable;MBReqDomain_OuterShareable;MBReqDomain_FullSystem]))`;


(*val MBReqTypes_of_num : integer -> MBReqTypes*)

val _ = Define `
 ((MBReqTypes_of_num:int -> MBReqTypes) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then MBReqTypes_Reads
   else if (((p0_ = (( 1 : int):ii)))) then MBReqTypes_Writes
   else MBReqTypes_All))`;


(*val num_of_MBReqTypes : MBReqTypes -> integer*)

val _ = Define `
 ((num_of_MBReqTypes:MBReqTypes -> int) arg_=
    ((case arg_ of
     MBReqTypes_Reads => (( 0 : int):ii)
   | MBReqTypes_Writes => (( 1 : int):ii)
   | MBReqTypes_All => (( 2 : int):ii)
   )))`;


(*val undefined_MBReqTypes : unit -> M MBReqTypes*)

val _ = Define `
 ((undefined_MBReqTypes:unit ->(regstate)sail2_state_monad$sequential_state ->(((MBReqTypes),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state$internal_pickS [MBReqTypes_Reads;MBReqTypes_Writes;MBReqTypes_All]))`;


(*val MemType_of_num : integer -> MemType*)

val _ = Define `
 ((MemType_of_num:int -> MemType) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then MemType_Normal
   else MemType_Device))`;


(*val num_of_MemType : MemType -> integer*)

val _ = Define `
 ((num_of_MemType:MemType -> int) arg_=  ((case arg_ of   MemType_Normal => (( 0 : int):ii) | MemType_Device => (( 1 : int):ii) )))`;


(*val undefined_MemType : unit -> M MemType*)

val _ = Define `
 ((undefined_MemType:unit ->(regstate)sail2_state_monad$sequential_state ->(((MemType),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state$internal_pickS [MemType_Normal;MemType_Device]))`;


(*val DeviceType_of_num : integer -> DeviceType*)

val _ = Define `
 ((DeviceType_of_num:int -> DeviceType) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then DeviceType_GRE
   else if (((p0_ = (( 1 : int):ii)))) then DeviceType_nGRE
   else if (((p0_ = (( 2 : int):ii)))) then DeviceType_nGnRE
   else DeviceType_nGnRnE))`;


(*val num_of_DeviceType : DeviceType -> integer*)

val _ = Define `
 ((num_of_DeviceType:DeviceType -> int) arg_=
    ((case arg_ of
     DeviceType_GRE => (( 0 : int):ii)
   | DeviceType_nGRE => (( 1 : int):ii)
   | DeviceType_nGnRE => (( 2 : int):ii)
   | DeviceType_nGnRnE => (( 3 : int):ii)
   )))`;


(*val undefined_DeviceType : unit -> M DeviceType*)

val _ = Define `
 ((undefined_DeviceType:unit ->(regstate)sail2_state_monad$sequential_state ->(((DeviceType),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$internal_pickS [DeviceType_GRE;DeviceType_nGRE;DeviceType_nGnRE;DeviceType_nGnRnE]))`;


(*val undefined_MemAttrHints : unit -> M MemAttrHints*)

val _ = Define `
 ((undefined_MemAttrHints:unit ->(regstate)sail2_state_monad$sequential_state ->(((MemAttrHints),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (undefined_bitvector (( 2 : int):ii)  : ( 2 words$word) M) (\ (w__0 : 2 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 2 : int):ii)  : ( 2 words$word) M) (\ (w__1 : 2 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (w__2 : bool) . 
   sail2_state_monad$returnS (<| MemAttrHints_attrs := w__0; 
              MemAttrHints_hints := w__1; 
              MemAttrHints_transient := w__2 |>))))))`;


(*val undefined_MemoryAttributes : unit -> M MemoryAttributes*)

val _ = Define `
 ((undefined_MemoryAttributes:unit ->(regstate)sail2_state_monad$sequential_state ->(((MemoryAttributes),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (undefined_MemType () ) (\ (w__0 : MemType) .  sail2_state_monad$bindS
   (undefined_DeviceType () ) (\ (w__1 : DeviceType) .  sail2_state_monad$bindS
   (undefined_MemAttrHints () ) (\ (w__2 : MemAttrHints) .  sail2_state_monad$bindS
   (undefined_MemAttrHints () ) (\ (w__3 : MemAttrHints) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (w__4 : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (w__5 : bool) . 
   sail2_state_monad$returnS (<| MemoryAttributes_typ := w__0; 
              MemoryAttributes_device := w__1; 
              MemoryAttributes_inner := w__2; 
              MemoryAttributes_outer := w__3; 
              MemoryAttributes_shareable := w__4; 
              MemoryAttributes_outershareable := w__5 |>)))))))))`;


(*val undefined_FullAddress : unit -> M FullAddress*)

val _ = Define `
 ((undefined_FullAddress:unit ->(regstate)sail2_state_monad$sequential_state ->(((FullAddress),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (undefined_bitvector (( 52 : int):ii)  : ( 52 words$word) M) (\ (w__0 : 52 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__1 : 1 bits) . 
   sail2_state_monad$returnS (<| FullAddress_physicaladdress := w__0; 
              FullAddress_NS := w__1 |>)))))`;


(*val undefined_AddressDescriptor : unit -> M AddressDescriptor*)

val _ = Define `
 ((undefined_AddressDescriptor:unit ->(regstate)sail2_state_monad$sequential_state ->(((AddressDescriptor),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (undefined_FaultRecord () ) (\ (w__0 : FaultRecord) .  sail2_state_monad$bindS
   (undefined_MemoryAttributes () ) (\ (w__1 : MemoryAttributes) .  sail2_state_monad$bindS
   (undefined_FullAddress () ) (\ (w__2 : FullAddress) .  sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (w__3 : 64 bits) . 
   sail2_state_monad$returnS (<| AddressDescriptor_fault := w__0; 
              AddressDescriptor_memattrs := w__1; 
              AddressDescriptor_paddress := w__2; 
              AddressDescriptor_vaddress := w__3 |>)))))))`;


(*val undefined_DescriptorUpdate : unit -> M DescriptorUpdate*)

val _ = Define `
 ((undefined_DescriptorUpdate:unit ->(regstate)sail2_state_monad$sequential_state ->(((DescriptorUpdate),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (w__0 : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (w__1 : bool) .  sail2_state_monad$bindS
   (undefined_AddressDescriptor () ) (\ (w__2 : AddressDescriptor) . 
   sail2_state_monad$returnS (<| DescriptorUpdate_AF := w__0; 
              DescriptorUpdate_AP := w__1; 
              DescriptorUpdate_descaddr := w__2 |>))))))`;


(*val MemAtomicOp_of_num : integer -> MemAtomicOp*)

val _ = Define `
 ((MemAtomicOp_of_num:int -> MemAtomicOp) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then MemAtomicOp_ADD
   else if (((p0_ = (( 1 : int):ii)))) then MemAtomicOp_BIC
   else if (((p0_ = (( 2 : int):ii)))) then MemAtomicOp_EOR
   else if (((p0_ = (( 3 : int):ii)))) then MemAtomicOp_ORR
   else if (((p0_ = (( 4 : int):ii)))) then MemAtomicOp_SMAX
   else if (((p0_ = (( 5 : int):ii)))) then MemAtomicOp_SMIN
   else if (((p0_ = (( 6 : int):ii)))) then MemAtomicOp_UMAX
   else if (((p0_ = (( 7 : int):ii)))) then MemAtomicOp_UMIN
   else MemAtomicOp_SWP))`;


(*val num_of_MemAtomicOp : MemAtomicOp -> integer*)

val _ = Define `
 ((num_of_MemAtomicOp:MemAtomicOp -> int) arg_=
    ((case arg_ of
     MemAtomicOp_ADD => (( 0 : int):ii)
   | MemAtomicOp_BIC => (( 1 : int):ii)
   | MemAtomicOp_EOR => (( 2 : int):ii)
   | MemAtomicOp_ORR => (( 3 : int):ii)
   | MemAtomicOp_SMAX => (( 4 : int):ii)
   | MemAtomicOp_SMIN => (( 5 : int):ii)
   | MemAtomicOp_UMAX => (( 6 : int):ii)
   | MemAtomicOp_UMIN => (( 7 : int):ii)
   | MemAtomicOp_SWP => (( 8 : int):ii)
   )))`;


(*val undefined_MemAtomicOp : unit -> M MemAtomicOp*)

val _ = Define `
 ((undefined_MemAtomicOp:unit ->(regstate)sail2_state_monad$sequential_state ->(((MemAtomicOp),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$internal_pickS
     [MemAtomicOp_ADD;MemAtomicOp_BIC;MemAtomicOp_EOR;MemAtomicOp_ORR;MemAtomicOp_SMAX;MemAtomicOp_SMIN;MemAtomicOp_UMAX;MemAtomicOp_UMIN;MemAtomicOp_SWP]))`;


(*val FPType_of_num : integer -> FPType*)

val _ = Define `
 ((FPType_of_num:int -> FPType) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then FPType_Nonzero
   else if (((p0_ = (( 1 : int):ii)))) then FPType_Zero
   else if (((p0_ = (( 2 : int):ii)))) then FPType_Infinity
   else if (((p0_ = (( 3 : int):ii)))) then FPType_QNaN
   else FPType_SNaN))`;


(*val num_of_FPType : FPType -> integer*)

val _ = Define `
 ((num_of_FPType:FPType -> int) arg_=
    ((case arg_ of
     FPType_Nonzero => (( 0 : int):ii)
   | FPType_Zero => (( 1 : int):ii)
   | FPType_Infinity => (( 2 : int):ii)
   | FPType_QNaN => (( 3 : int):ii)
   | FPType_SNaN => (( 4 : int):ii)
   )))`;


(*val undefined_FPType : unit -> M FPType*)

val _ = Define `
 ((undefined_FPType:unit ->(regstate)sail2_state_monad$sequential_state ->(((FPType),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$internal_pickS [FPType_Nonzero;FPType_Zero;FPType_Infinity;FPType_QNaN;FPType_SNaN]))`;


(*val FPExc_of_num : integer -> FPExc*)

val _ = Define `
 ((FPExc_of_num:int -> FPExc) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then FPExc_InvalidOp
   else if (((p0_ = (( 1 : int):ii)))) then FPExc_DivideByZero
   else if (((p0_ = (( 2 : int):ii)))) then FPExc_Overflow
   else if (((p0_ = (( 3 : int):ii)))) then FPExc_Underflow
   else if (((p0_ = (( 4 : int):ii)))) then FPExc_Inexact
   else FPExc_InputDenorm))`;


(*val num_of_FPExc : FPExc -> integer*)

val _ = Define `
 ((num_of_FPExc:FPExc -> int) arg_=
    ((case arg_ of
     FPExc_InvalidOp => (( 0 : int):ii)
   | FPExc_DivideByZero => (( 1 : int):ii)
   | FPExc_Overflow => (( 2 : int):ii)
   | FPExc_Underflow => (( 3 : int):ii)
   | FPExc_Inexact => (( 4 : int):ii)
   | FPExc_InputDenorm => (( 5 : int):ii)
   )))`;


(*val undefined_FPExc : unit -> M FPExc*)

val _ = Define `
 ((undefined_FPExc:unit ->(regstate)sail2_state_monad$sequential_state ->(((FPExc),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$internal_pickS
     [FPExc_InvalidOp;FPExc_DivideByZero;FPExc_Overflow;FPExc_Underflow;FPExc_Inexact;FPExc_InputDenorm]))`;


(*val FPRounding_of_num : integer -> FPRounding*)

val _ = Define `
 ((FPRounding_of_num:int -> FPRounding) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then FPRounding_TIEEVEN
   else if (((p0_ = (( 1 : int):ii)))) then FPRounding_POSINF
   else if (((p0_ = (( 2 : int):ii)))) then FPRounding_NEGINF
   else if (((p0_ = (( 3 : int):ii)))) then FPRounding_ZERO
   else if (((p0_ = (( 4 : int):ii)))) then FPRounding_TIEAWAY
   else FPRounding_ODD))`;


(*val num_of_FPRounding : FPRounding -> integer*)

val _ = Define `
 ((num_of_FPRounding:FPRounding -> int) arg_=
    ((case arg_ of
     FPRounding_TIEEVEN => (( 0 : int):ii)
   | FPRounding_POSINF => (( 1 : int):ii)
   | FPRounding_NEGINF => (( 2 : int):ii)
   | FPRounding_ZERO => (( 3 : int):ii)
   | FPRounding_TIEAWAY => (( 4 : int):ii)
   | FPRounding_ODD => (( 5 : int):ii)
   )))`;


(*val undefined_FPRounding : unit -> M FPRounding*)

val _ = Define `
 ((undefined_FPRounding:unit ->(regstate)sail2_state_monad$sequential_state ->(((FPRounding),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$internal_pickS
     [FPRounding_TIEEVEN;FPRounding_POSINF;FPRounding_NEGINF;FPRounding_ZERO;FPRounding_TIEAWAY;FPRounding_ODD]))`;


(*val SysRegAccess_of_num : integer -> SysRegAccess*)

val _ = Define `
 ((SysRegAccess_of_num:int -> SysRegAccess) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then SysRegAccess_OK
   else if (((p0_ = (( 1 : int):ii)))) then SysRegAccess_UNDEFINED
   else if (((p0_ = (( 2 : int):ii)))) then SysRegAccess_TrapToEL1
   else if (((p0_ = (( 3 : int):ii)))) then SysRegAccess_TrapToEL2
   else SysRegAccess_TrapToEL3))`;


(*val num_of_SysRegAccess : SysRegAccess -> integer*)

val _ = Define `
 ((num_of_SysRegAccess:SysRegAccess -> int) arg_=
    ((case arg_ of
     SysRegAccess_OK => (( 0 : int):ii)
   | SysRegAccess_UNDEFINED => (( 1 : int):ii)
   | SysRegAccess_TrapToEL1 => (( 2 : int):ii)
   | SysRegAccess_TrapToEL2 => (( 3 : int):ii)
   | SysRegAccess_TrapToEL3 => (( 4 : int):ii)
   )))`;


(*val undefined_SysRegAccess : unit -> M SysRegAccess*)

val _ = Define `
 ((undefined_SysRegAccess:unit ->(regstate)sail2_state_monad$sequential_state ->(((SysRegAccess),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$internal_pickS
     [SysRegAccess_OK;SysRegAccess_UNDEFINED;SysRegAccess_TrapToEL1;SysRegAccess_TrapToEL2;SysRegAccess_TrapToEL3]))`;


(*val SRType_of_num : integer -> SRType*)

val _ = Define `
 ((SRType_of_num:int -> SRType) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then SRType_LSL
   else if (((p0_ = (( 1 : int):ii)))) then SRType_LSR
   else if (((p0_ = (( 2 : int):ii)))) then SRType_ASR
   else if (((p0_ = (( 3 : int):ii)))) then SRType_ROR
   else SRType_RRX))`;


(*val num_of_SRType : SRType -> integer*)

val _ = Define `
 ((num_of_SRType:SRType -> int) arg_=
    ((case arg_ of
     SRType_LSL => (( 0 : int):ii)
   | SRType_LSR => (( 1 : int):ii)
   | SRType_ASR => (( 2 : int):ii)
   | SRType_ROR => (( 3 : int):ii)
   | SRType_RRX => (( 4 : int):ii)
   )))`;


(*val undefined_SRType : unit -> M SRType*)

val _ = Define `
 ((undefined_SRType:unit ->(regstate)sail2_state_monad$sequential_state ->(((SRType),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state$internal_pickS [SRType_LSL;SRType_LSR;SRType_ASR;SRType_ROR;SRType_RRX]))`;


(*val ShiftType_of_num : integer -> ShiftType*)

val _ = Define `
 ((ShiftType_of_num:int -> ShiftType) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then ShiftType_LSL
   else if (((p0_ = (( 1 : int):ii)))) then ShiftType_LSR
   else if (((p0_ = (( 2 : int):ii)))) then ShiftType_ASR
   else ShiftType_ROR))`;


(*val num_of_ShiftType : ShiftType -> integer*)

val _ = Define `
 ((num_of_ShiftType:ShiftType -> int) arg_=
    ((case arg_ of
     ShiftType_LSL => (( 0 : int):ii)
   | ShiftType_LSR => (( 1 : int):ii)
   | ShiftType_ASR => (( 2 : int):ii)
   | ShiftType_ROR => (( 3 : int):ii)
   )))`;


(*val undefined_ShiftType : unit -> M ShiftType*)

val _ = Define `
 ((undefined_ShiftType:unit ->(regstate)sail2_state_monad$sequential_state ->(((ShiftType),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state$internal_pickS [ShiftType_LSL;ShiftType_LSR;ShiftType_ASR;ShiftType_ROR]))`;


(*val PrefetchHint_of_num : integer -> PrefetchHint*)

val _ = Define `
 ((PrefetchHint_of_num:int -> PrefetchHint) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then Prefetch_READ
   else if (((p0_ = (( 1 : int):ii)))) then Prefetch_WRITE
   else Prefetch_EXEC))`;


(*val num_of_PrefetchHint : PrefetchHint -> integer*)

val _ = Define `
 ((num_of_PrefetchHint:PrefetchHint -> int) arg_=
    ((case arg_ of
     Prefetch_READ => (( 0 : int):ii)
   | Prefetch_WRITE => (( 1 : int):ii)
   | Prefetch_EXEC => (( 2 : int):ii)
   )))`;


(*val undefined_PrefetchHint : unit -> M PrefetchHint*)

val _ = Define `
 ((undefined_PrefetchHint:unit ->(regstate)sail2_state_monad$sequential_state ->(((PrefetchHint),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state$internal_pickS [Prefetch_READ;Prefetch_WRITE;Prefetch_EXEC]))`;


(*val InterruptID_of_num : integer -> InterruptID*)

val _ = Define `
 ((InterruptID_of_num:int -> InterruptID) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then InterruptID_PMUIRQ
   else if (((p0_ = (( 1 : int):ii)))) then InterruptID_COMMIRQ
   else if (((p0_ = (( 2 : int):ii)))) then InterruptID_CTIIRQ
   else if (((p0_ = (( 3 : int):ii)))) then InterruptID_COMMRX
   else InterruptID_COMMTX))`;


(*val num_of_InterruptID : InterruptID -> integer*)

val _ = Define `
 ((num_of_InterruptID:InterruptID -> int) arg_=
    ((case arg_ of
     InterruptID_PMUIRQ => (( 0 : int):ii)
   | InterruptID_COMMIRQ => (( 1 : int):ii)
   | InterruptID_CTIIRQ => (( 2 : int):ii)
   | InterruptID_COMMRX => (( 3 : int):ii)
   | InterruptID_COMMTX => (( 4 : int):ii)
   )))`;


(*val undefined_InterruptID : unit -> M InterruptID*)

val _ = Define `
 ((undefined_InterruptID:unit ->(regstate)sail2_state_monad$sequential_state ->(((InterruptID),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$internal_pickS
     [InterruptID_PMUIRQ;InterruptID_COMMIRQ;InterruptID_CTIIRQ;InterruptID_COMMRX;InterruptID_COMMTX]))`;


(*val CrossTriggerOut_of_num : integer -> CrossTriggerOut*)

val _ = Define `
 ((CrossTriggerOut_of_num:int -> CrossTriggerOut) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then CrossTriggerOut_DebugRequest
   else if (((p0_ = (( 1 : int):ii)))) then CrossTriggerOut_RestartRequest
   else if (((p0_ = (( 2 : int):ii)))) then CrossTriggerOut_IRQ
   else if (((p0_ = (( 3 : int):ii)))) then CrossTriggerOut_RSVD3
   else if (((p0_ = (( 4 : int):ii)))) then CrossTriggerOut_TraceExtIn0
   else if (((p0_ = (( 5 : int):ii)))) then CrossTriggerOut_TraceExtIn1
   else if (((p0_ = (( 6 : int):ii)))) then CrossTriggerOut_TraceExtIn2
   else CrossTriggerOut_TraceExtIn3))`;


(*val num_of_CrossTriggerOut : CrossTriggerOut -> integer*)

val _ = Define `
 ((num_of_CrossTriggerOut:CrossTriggerOut -> int) arg_=
    ((case arg_ of
     CrossTriggerOut_DebugRequest => (( 0 : int):ii)
   | CrossTriggerOut_RestartRequest => (( 1 : int):ii)
   | CrossTriggerOut_IRQ => (( 2 : int):ii)
   | CrossTriggerOut_RSVD3 => (( 3 : int):ii)
   | CrossTriggerOut_TraceExtIn0 => (( 4 : int):ii)
   | CrossTriggerOut_TraceExtIn1 => (( 5 : int):ii)
   | CrossTriggerOut_TraceExtIn2 => (( 6 : int):ii)
   | CrossTriggerOut_TraceExtIn3 => (( 7 : int):ii)
   )))`;


(*val undefined_CrossTriggerOut : unit -> M CrossTriggerOut*)

val _ = Define `
 ((undefined_CrossTriggerOut:unit ->(regstate)sail2_state_monad$sequential_state ->(((CrossTriggerOut),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$internal_pickS
     [CrossTriggerOut_DebugRequest;CrossTriggerOut_RestartRequest;CrossTriggerOut_IRQ;CrossTriggerOut_RSVD3;CrossTriggerOut_TraceExtIn0;CrossTriggerOut_TraceExtIn1;CrossTriggerOut_TraceExtIn2;CrossTriggerOut_TraceExtIn3]))`;


(*val CrossTriggerIn_of_num : integer -> CrossTriggerIn*)

val _ = Define `
 ((CrossTriggerIn_of_num:int -> CrossTriggerIn) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then CrossTriggerIn_CrossHalt
   else if (((p0_ = (( 1 : int):ii)))) then CrossTriggerIn_PMUOverflow
   else if (((p0_ = (( 2 : int):ii)))) then CrossTriggerIn_RSVD2
   else if (((p0_ = (( 3 : int):ii)))) then CrossTriggerIn_RSVD3
   else if (((p0_ = (( 4 : int):ii)))) then CrossTriggerIn_TraceExtOut0
   else if (((p0_ = (( 5 : int):ii)))) then CrossTriggerIn_TraceExtOut1
   else if (((p0_ = (( 6 : int):ii)))) then CrossTriggerIn_TraceExtOut2
   else CrossTriggerIn_TraceExtOut3))`;


(*val num_of_CrossTriggerIn : CrossTriggerIn -> integer*)

val _ = Define `
 ((num_of_CrossTriggerIn:CrossTriggerIn -> int) arg_=
    ((case arg_ of
     CrossTriggerIn_CrossHalt => (( 0 : int):ii)
   | CrossTriggerIn_PMUOverflow => (( 1 : int):ii)
   | CrossTriggerIn_RSVD2 => (( 2 : int):ii)
   | CrossTriggerIn_RSVD3 => (( 3 : int):ii)
   | CrossTriggerIn_TraceExtOut0 => (( 4 : int):ii)
   | CrossTriggerIn_TraceExtOut1 => (( 5 : int):ii)
   | CrossTriggerIn_TraceExtOut2 => (( 6 : int):ii)
   | CrossTriggerIn_TraceExtOut3 => (( 7 : int):ii)
   )))`;


(*val undefined_CrossTriggerIn : unit -> M CrossTriggerIn*)

val _ = Define `
 ((undefined_CrossTriggerIn:unit ->(regstate)sail2_state_monad$sequential_state ->(((CrossTriggerIn),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$internal_pickS
     [CrossTriggerIn_CrossHalt;CrossTriggerIn_PMUOverflow;CrossTriggerIn_RSVD2;CrossTriggerIn_RSVD3;CrossTriggerIn_TraceExtOut0;CrossTriggerIn_TraceExtOut1;CrossTriggerIn_TraceExtOut2;CrossTriggerIn_TraceExtOut3]))`;


(*val MemBarrierOp_of_num : integer -> MemBarrierOp*)

val _ = Define `
 ((MemBarrierOp_of_num:int -> MemBarrierOp) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then MemBarrierOp_DSB
   else if (((p0_ = (( 1 : int):ii)))) then MemBarrierOp_DMB
   else MemBarrierOp_ISB))`;


(*val num_of_MemBarrierOp : MemBarrierOp -> integer*)

val _ = Define `
 ((num_of_MemBarrierOp:MemBarrierOp -> int) arg_=
    ((case arg_ of
     MemBarrierOp_DSB => (( 0 : int):ii)
   | MemBarrierOp_DMB => (( 1 : int):ii)
   | MemBarrierOp_ISB => (( 2 : int):ii)
   )))`;


(*val undefined_MemBarrierOp : unit -> M MemBarrierOp*)

val _ = Define `
 ((undefined_MemBarrierOp:unit ->(regstate)sail2_state_monad$sequential_state ->(((MemBarrierOp),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state$internal_pickS [MemBarrierOp_DSB;MemBarrierOp_DMB;MemBarrierOp_ISB]))`;


(*val undefined_AccessDescriptor : unit -> M AccessDescriptor*)

val _ = Define `
 ((undefined_AccessDescriptor:unit ->(regstate)sail2_state_monad$sequential_state ->(((AccessDescriptor),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (undefined_AccType () ) (\ (w__0 : AccType) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (w__1 : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (w__2 : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (w__3 : bool) .  sail2_state_monad$bindS
   (undefined_int () ) (\ (w__4 : ii) . 
   sail2_state_monad$returnS (<| AccessDescriptor_acctype := w__0; 
              AccessDescriptor_page_table_walk := w__1; 
              AccessDescriptor_secondstage := w__2; 
              AccessDescriptor_s2fs1walk := w__3; 
              AccessDescriptor_level := w__4 |>))))))))`;


(*val undefined_Permissions : unit -> M Permissions*)

val _ = Define `
 ((undefined_Permissions:unit ->(regstate)sail2_state_monad$sequential_state ->(((Permissions),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (undefined_bitvector (( 3 : int):ii)  : ( 3 words$word) M) (\ (w__0 : 3 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__1 : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__2 : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__3 : 1 bits) . 
   sail2_state_monad$returnS (<| Permissions_ap := w__0; 
              Permissions_xn := w__1; 
              Permissions_xxn := w__2; 
              Permissions_pxn := w__3 |>)))))))`;


(*val undefined_TLBRecord : unit -> M TLBRecord*)

val _ = Define `
 ((undefined_TLBRecord:unit ->(regstate)sail2_state_monad$sequential_state ->(((TLBRecord),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (undefined_Permissions () ) (\ (w__0 : Permissions) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__1 : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (w__2 : 4 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (w__3 : bool) .  sail2_state_monad$bindS
   (undefined_int () ) (\ (w__4 : ii) .  sail2_state_monad$bindS
   (undefined_int () ) (\ (w__5 : ii) .  sail2_state_monad$bindS
   (undefined_DescriptorUpdate () ) (\ (w__6 : DescriptorUpdate) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__7 : 1 bits) .  sail2_state_monad$bindS
   (undefined_AddressDescriptor () ) (\ (w__8 : AddressDescriptor) . 
   sail2_state_monad$returnS (<| TLBRecord_perms := w__0; 
              TLBRecord_nG := w__1; 
              TLBRecord_domain := w__2; 
              TLBRecord_contiguous := w__3; 
              TLBRecord_level := w__4; 
              TLBRecord_blocksize := w__5; 
              TLBRecord_descupdate := w__6; 
              TLBRecord_CnP := w__7; 
              TLBRecord_addrdesc := w__8 |>))))))))))))`;


(*val ImmediateOp_of_num : integer -> ImmediateOp*)

val _ = Define `
 ((ImmediateOp_of_num:int -> ImmediateOp) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then ImmediateOp_MOVI
   else if (((p0_ = (( 1 : int):ii)))) then ImmediateOp_MVNI
   else if (((p0_ = (( 2 : int):ii)))) then ImmediateOp_ORR
   else ImmediateOp_BIC))`;


(*val num_of_ImmediateOp : ImmediateOp -> integer*)

val _ = Define `
 ((num_of_ImmediateOp:ImmediateOp -> int) arg_=
    ((case arg_ of
     ImmediateOp_MOVI => (( 0 : int):ii)
   | ImmediateOp_MVNI => (( 1 : int):ii)
   | ImmediateOp_ORR => (( 2 : int):ii)
   | ImmediateOp_BIC => (( 3 : int):ii)
   )))`;


(*val undefined_ImmediateOp : unit -> M ImmediateOp*)

val _ = Define `
 ((undefined_ImmediateOp:unit ->(regstate)sail2_state_monad$sequential_state ->(((ImmediateOp),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$internal_pickS [ImmediateOp_MOVI;ImmediateOp_MVNI;ImmediateOp_ORR;ImmediateOp_BIC]))`;


(*val MoveWideOp_of_num : integer -> MoveWideOp*)

val _ = Define `
 ((MoveWideOp_of_num:int -> MoveWideOp) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then MoveWideOp_N
   else if (((p0_ = (( 1 : int):ii)))) then MoveWideOp_Z
   else MoveWideOp_K))`;


(*val num_of_MoveWideOp : MoveWideOp -> integer*)

val _ = Define `
 ((num_of_MoveWideOp:MoveWideOp -> int) arg_=
    ((case arg_ of   MoveWideOp_N => (( 0 : int):ii) | MoveWideOp_Z => (( 1 : int):ii) | MoveWideOp_K => (( 2 : int):ii) )))`;


(*val undefined_MoveWideOp : unit -> M MoveWideOp*)

val _ = Define `
 ((undefined_MoveWideOp:unit ->(regstate)sail2_state_monad$sequential_state ->(((MoveWideOp),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state$internal_pickS [MoveWideOp_N;MoveWideOp_Z;MoveWideOp_K]))`;


(*val SystemAccessType_of_num : integer -> SystemAccessType*)

val _ = Define `
 ((SystemAccessType_of_num:int -> SystemAccessType) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then SystemAccessType_RT
   else if (((p0_ = (( 1 : int):ii)))) then SystemAccessType_RRT
   else SystemAccessType_DT))`;


(*val num_of_SystemAccessType : SystemAccessType -> integer*)

val _ = Define `
 ((num_of_SystemAccessType:SystemAccessType -> int) arg_=
    ((case arg_ of
     SystemAccessType_RT => (( 0 : int):ii)
   | SystemAccessType_RRT => (( 1 : int):ii)
   | SystemAccessType_DT => (( 2 : int):ii)
   )))`;


(*val undefined_SystemAccessType : unit -> M SystemAccessType*)

val _ = Define `
 ((undefined_SystemAccessType:unit ->(regstate)sail2_state_monad$sequential_state ->(((SystemAccessType),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$internal_pickS [SystemAccessType_RT;SystemAccessType_RRT;SystemAccessType_DT]))`;


(*val VBitOp_of_num : integer -> VBitOp*)

val _ = Define `
 ((VBitOp_of_num:int -> VBitOp) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then VBitOp_VBIF
   else if (((p0_ = (( 1 : int):ii)))) then VBitOp_VBIT
   else if (((p0_ = (( 2 : int):ii)))) then VBitOp_VBSL
   else VBitOp_VEOR))`;


(*val num_of_VBitOp : VBitOp -> integer*)

val _ = Define `
 ((num_of_VBitOp:VBitOp -> int) arg_=
    ((case arg_ of
     VBitOp_VBIF => (( 0 : int):ii)
   | VBitOp_VBIT => (( 1 : int):ii)
   | VBitOp_VBSL => (( 2 : int):ii)
   | VBitOp_VEOR => (( 3 : int):ii)
   )))`;


(*val undefined_VBitOp : unit -> M VBitOp*)

val _ = Define `
 ((undefined_VBitOp:unit ->(regstate)sail2_state_monad$sequential_state ->(((VBitOp),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state$internal_pickS [VBitOp_VBIF;VBitOp_VBIT;VBitOp_VBSL;VBitOp_VEOR]))`;


(*val TimeStamp_of_num : integer -> TimeStamp*)

val _ = Define `
 ((TimeStamp_of_num:int -> TimeStamp) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then TimeStamp_None
   else if (((p0_ = (( 1 : int):ii)))) then TimeStamp_Virtual
   else TimeStamp_Physical))`;


(*val num_of_TimeStamp : TimeStamp -> integer*)

val _ = Define `
 ((num_of_TimeStamp:TimeStamp -> int) arg_=
    ((case arg_ of
     TimeStamp_None => (( 0 : int):ii)
   | TimeStamp_Virtual => (( 1 : int):ii)
   | TimeStamp_Physical => (( 2 : int):ii)
   )))`;


(*val undefined_TimeStamp : unit -> M TimeStamp*)

val _ = Define `
 ((undefined_TimeStamp:unit ->(regstate)sail2_state_monad$sequential_state ->(((TimeStamp),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state$internal_pickS [TimeStamp_None;TimeStamp_Virtual;TimeStamp_Physical]))`;


(*val PrivilegeLevel_of_num : integer -> PrivilegeLevel*)

val _ = Define `
 ((PrivilegeLevel_of_num:int -> PrivilegeLevel) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then PL3
   else if (((p0_ = (( 1 : int):ii)))) then PL2
   else if (((p0_ = (( 2 : int):ii)))) then PL1
   else PL0))`;


(*val num_of_PrivilegeLevel : PrivilegeLevel -> integer*)

val _ = Define `
 ((num_of_PrivilegeLevel:PrivilegeLevel -> int) arg_=
    ((case arg_ of   PL3 => (( 0 : int):ii) | PL2 => (( 1 : int):ii) | PL1 => (( 2 : int):ii) | PL0 => (( 3 : int):ii) )))`;


(*val undefined_PrivilegeLevel : unit -> M PrivilegeLevel*)

val _ = Define `
 ((undefined_PrivilegeLevel:unit ->(regstate)sail2_state_monad$sequential_state ->(((PrivilegeLevel),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state$internal_pickS [PL3;PL2;PL1;PL0]))`;


(*val undefined_AArch32_SErrorSyndrome : unit -> M AArch32_SErrorSyndrome*)

val _ = Define `
 ((undefined_AArch32_SErrorSyndrome:unit ->(regstate)sail2_state_monad$sequential_state ->(((AArch32_SErrorSyndrome),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (undefined_bitvector (( 2 : int):ii)  : ( 2 words$word) M) (\ (w__0 : 2 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__1 : 1 bits) . 
   sail2_state_monad$returnS (<| AArch32_SErrorSyndrome_AET := w__0; 
              AArch32_SErrorSyndrome_ExT := w__1 |>)))))`;


(*val SystemOp_of_num : integer -> SystemOp*)

val _ = Define `
 ((SystemOp_of_num:int -> SystemOp) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then Sys_AT
   else if (((p0_ = (( 1 : int):ii)))) then Sys_DC
   else if (((p0_ = (( 2 : int):ii)))) then Sys_IC
   else if (((p0_ = (( 3 : int):ii)))) then Sys_TLBI
   else Sys_SYS))`;


(*val num_of_SystemOp : SystemOp -> integer*)

val _ = Define `
 ((num_of_SystemOp:SystemOp -> int) arg_=
    ((case arg_ of
     Sys_AT => (( 0 : int):ii)
   | Sys_DC => (( 1 : int):ii)
   | Sys_IC => (( 2 : int):ii)
   | Sys_TLBI => (( 3 : int):ii)
   | Sys_SYS => (( 4 : int):ii)
   )))`;


(*val undefined_SystemOp : unit -> M SystemOp*)

val _ = Define `
 ((undefined_SystemOp:unit ->(regstate)sail2_state_monad$sequential_state ->(((SystemOp),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state$internal_pickS [Sys_AT;Sys_DC;Sys_IC;Sys_TLBI;Sys_SYS]))`;


(*val undefined_PCSample : unit -> M PCSample*)

val _ = Define `
 ((undefined_PCSample:unit ->(regstate)sail2_state_monad$sequential_state ->(((PCSample),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (w__0 : bool) .  sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (w__1 : 64 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 2 : int):ii)  : ( 2 words$word) M) (\ (w__2 : 2 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__3 : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__4 : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (w__5 : 32 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (w__6 : 32 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M) (\ (w__7 : 16 bits) . 
   sail2_state_monad$returnS (<| PCSample_valid_name := w__0; 
              PCSample_pc := w__1; 
              PCSample_el := w__2; 
              PCSample_rw := w__3; 
              PCSample_ns := w__4; 
              PCSample_contextidr := w__5; 
              PCSample_contextidr_el2 := w__6; 
              PCSample_vmid := w__7 |>)))))))))))`;


(*val ReduceOp_of_num : integer -> ReduceOp*)

val _ = Define `
 ((ReduceOp_of_num:int -> ReduceOp) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then ReduceOp_FMINNUM
   else if (((p0_ = (( 1 : int):ii)))) then ReduceOp_FMAXNUM
   else if (((p0_ = (( 2 : int):ii)))) then ReduceOp_FMIN
   else if (((p0_ = (( 3 : int):ii)))) then ReduceOp_FMAX
   else if (((p0_ = (( 4 : int):ii)))) then ReduceOp_FADD
   else ReduceOp_ADD))`;


(*val num_of_ReduceOp : ReduceOp -> integer*)

val _ = Define `
 ((num_of_ReduceOp:ReduceOp -> int) arg_=
    ((case arg_ of
     ReduceOp_FMINNUM => (( 0 : int):ii)
   | ReduceOp_FMAXNUM => (( 1 : int):ii)
   | ReduceOp_FMIN => (( 2 : int):ii)
   | ReduceOp_FMAX => (( 3 : int):ii)
   | ReduceOp_FADD => (( 4 : int):ii)
   | ReduceOp_ADD => (( 5 : int):ii)
   )))`;


(*val undefined_ReduceOp : unit -> M ReduceOp*)

val _ = Define `
 ((undefined_ReduceOp:unit ->(regstate)sail2_state_monad$sequential_state ->(((ReduceOp),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$internal_pickS
     [ReduceOp_FMINNUM;ReduceOp_FMAXNUM;ReduceOp_FMIN;ReduceOp_FMAX;ReduceOp_FADD;ReduceOp_ADD]))`;


(*val LogicalOp_of_num : integer -> LogicalOp*)

val _ = Define `
 ((LogicalOp_of_num:int -> LogicalOp) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then LogicalOp_AND
   else if (((p0_ = (( 1 : int):ii)))) then LogicalOp_EOR
   else LogicalOp_ORR))`;


(*val num_of_LogicalOp : LogicalOp -> integer*)

val _ = Define `
 ((num_of_LogicalOp:LogicalOp -> int) arg_=
    ((case arg_ of   LogicalOp_AND => (( 0 : int):ii) | LogicalOp_EOR => (( 1 : int):ii) | LogicalOp_ORR => (( 2 : int):ii) )))`;


(*val undefined_LogicalOp : unit -> M LogicalOp*)

val _ = Define `
 ((undefined_LogicalOp:unit ->(regstate)sail2_state_monad$sequential_state ->(((LogicalOp),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state$internal_pickS [LogicalOp_AND;LogicalOp_EOR;LogicalOp_ORR]))`;


(*val ExtendType_of_num : integer -> ExtendType*)

val _ = Define `
 ((ExtendType_of_num:int -> ExtendType) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then ExtendType_SXTB
   else if (((p0_ = (( 1 : int):ii)))) then ExtendType_SXTH
   else if (((p0_ = (( 2 : int):ii)))) then ExtendType_SXTW
   else if (((p0_ = (( 3 : int):ii)))) then ExtendType_SXTX
   else if (((p0_ = (( 4 : int):ii)))) then ExtendType_UXTB
   else if (((p0_ = (( 5 : int):ii)))) then ExtendType_UXTH
   else if (((p0_ = (( 6 : int):ii)))) then ExtendType_UXTW
   else ExtendType_UXTX))`;


(*val num_of_ExtendType : ExtendType -> integer*)

val _ = Define `
 ((num_of_ExtendType:ExtendType -> int) arg_=
    ((case arg_ of
     ExtendType_SXTB => (( 0 : int):ii)
   | ExtendType_SXTH => (( 1 : int):ii)
   | ExtendType_SXTW => (( 2 : int):ii)
   | ExtendType_SXTX => (( 3 : int):ii)
   | ExtendType_UXTB => (( 4 : int):ii)
   | ExtendType_UXTH => (( 5 : int):ii)
   | ExtendType_UXTW => (( 6 : int):ii)
   | ExtendType_UXTX => (( 7 : int):ii)
   )))`;


(*val undefined_ExtendType : unit -> M ExtendType*)

val _ = Define `
 ((undefined_ExtendType:unit ->(regstate)sail2_state_monad$sequential_state ->(((ExtendType),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$internal_pickS
     [ExtendType_SXTB;ExtendType_SXTH;ExtendType_SXTW;ExtendType_SXTX;ExtendType_UXTB;ExtendType_UXTH;ExtendType_UXTW;ExtendType_UXTX]))`;


(*val SystemHintOp_of_num : integer -> SystemHintOp*)

val _ = Define `
 ((SystemHintOp_of_num:int -> SystemHintOp) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then SystemHintOp_NOP
   else if (((p0_ = (( 1 : int):ii)))) then SystemHintOp_YIELD
   else if (((p0_ = (( 2 : int):ii)))) then SystemHintOp_WFE
   else if (((p0_ = (( 3 : int):ii)))) then SystemHintOp_WFI
   else if (((p0_ = (( 4 : int):ii)))) then SystemHintOp_SEV
   else if (((p0_ = (( 5 : int):ii)))) then SystemHintOp_SEVL
   else if (((p0_ = (( 6 : int):ii)))) then SystemHintOp_ESB
   else SystemHintOp_PSB))`;


(*val num_of_SystemHintOp : SystemHintOp -> integer*)

val _ = Define `
 ((num_of_SystemHintOp:SystemHintOp -> int) arg_=
    ((case arg_ of
     SystemHintOp_NOP => (( 0 : int):ii)
   | SystemHintOp_YIELD => (( 1 : int):ii)
   | SystemHintOp_WFE => (( 2 : int):ii)
   | SystemHintOp_WFI => (( 3 : int):ii)
   | SystemHintOp_SEV => (( 4 : int):ii)
   | SystemHintOp_SEVL => (( 5 : int):ii)
   | SystemHintOp_ESB => (( 6 : int):ii)
   | SystemHintOp_PSB => (( 7 : int):ii)
   )))`;


(*val undefined_SystemHintOp : unit -> M SystemHintOp*)

val _ = Define `
 ((undefined_SystemHintOp:unit ->(regstate)sail2_state_monad$sequential_state ->(((SystemHintOp),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$internal_pickS
     [SystemHintOp_NOP;SystemHintOp_YIELD;SystemHintOp_WFE;SystemHintOp_WFI;SystemHintOp_SEV;SystemHintOp_SEVL;SystemHintOp_ESB;SystemHintOp_PSB]))`;


(*val MemOp_of_num : integer -> MemOp*)

val _ = Define `
 ((MemOp_of_num:int -> MemOp) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then MemOp_LOAD
   else if (((p0_ = (( 1 : int):ii)))) then MemOp_STORE
   else MemOp_PREFETCH))`;


(*val num_of_MemOp : MemOp -> integer*)

val _ = Define `
 ((num_of_MemOp:MemOp -> int) arg_=
    ((case arg_ of   MemOp_LOAD => (( 0 : int):ii) | MemOp_STORE => (( 1 : int):ii) | MemOp_PREFETCH => (( 2 : int):ii) )))`;


(*val undefined_MemOp : unit -> M MemOp*)

val _ = Define `
 ((undefined_MemOp:unit ->(regstate)sail2_state_monad$sequential_state ->(((MemOp),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state$internal_pickS [MemOp_LOAD;MemOp_STORE;MemOp_PREFETCH]))`;


(*val OpType_of_num : integer -> OpType*)

val _ = Define `
 ((OpType_of_num:int -> OpType) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then OpType_Load
   else if (((p0_ = (( 1 : int):ii)))) then OpType_Store
   else if (((p0_ = (( 2 : int):ii)))) then OpType_LoadAtomic
   else if (((p0_ = (( 3 : int):ii)))) then OpType_Branch
   else OpType_Other))`;


(*val num_of_OpType : OpType -> integer*)

val _ = Define `
 ((num_of_OpType:OpType -> int) arg_=
    ((case arg_ of
     OpType_Load => (( 0 : int):ii)
   | OpType_Store => (( 1 : int):ii)
   | OpType_LoadAtomic => (( 2 : int):ii)
   | OpType_Branch => (( 3 : int):ii)
   | OpType_Other => (( 4 : int):ii)
   )))`;


(*val undefined_OpType : unit -> M OpType*)

val _ = Define `
 ((undefined_OpType:unit ->(regstate)sail2_state_monad$sequential_state ->(((OpType),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$internal_pickS [OpType_Load;OpType_Store;OpType_LoadAtomic;OpType_Branch;OpType_Other]))`;


(*val FPUnaryOp_of_num : integer -> FPUnaryOp*)

val _ = Define `
 ((FPUnaryOp_of_num:int -> FPUnaryOp) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then FPUnaryOp_ABS
   else if (((p0_ = (( 1 : int):ii)))) then FPUnaryOp_MOV
   else if (((p0_ = (( 2 : int):ii)))) then FPUnaryOp_NEG
   else FPUnaryOp_SQRT))`;


(*val num_of_FPUnaryOp : FPUnaryOp -> integer*)

val _ = Define `
 ((num_of_FPUnaryOp:FPUnaryOp -> int) arg_=
    ((case arg_ of
     FPUnaryOp_ABS => (( 0 : int):ii)
   | FPUnaryOp_MOV => (( 1 : int):ii)
   | FPUnaryOp_NEG => (( 2 : int):ii)
   | FPUnaryOp_SQRT => (( 3 : int):ii)
   )))`;


(*val undefined_FPUnaryOp : unit -> M FPUnaryOp*)

val _ = Define `
 ((undefined_FPUnaryOp:unit ->(regstate)sail2_state_monad$sequential_state ->(((FPUnaryOp),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$internal_pickS [FPUnaryOp_ABS;FPUnaryOp_MOV;FPUnaryOp_NEG;FPUnaryOp_SQRT]))`;


(*val CompareOp_of_num : integer -> CompareOp*)

val _ = Define `
 ((CompareOp_of_num:int -> CompareOp) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then CompareOp_GT
   else if (((p0_ = (( 1 : int):ii)))) then CompareOp_GE
   else if (((p0_ = (( 2 : int):ii)))) then CompareOp_EQ
   else if (((p0_ = (( 3 : int):ii)))) then CompareOp_LE
   else CompareOp_LT))`;


(*val num_of_CompareOp : CompareOp -> integer*)

val _ = Define `
 ((num_of_CompareOp:CompareOp -> int) arg_=
    ((case arg_ of
     CompareOp_GT => (( 0 : int):ii)
   | CompareOp_GE => (( 1 : int):ii)
   | CompareOp_EQ => (( 2 : int):ii)
   | CompareOp_LE => (( 3 : int):ii)
   | CompareOp_LT => (( 4 : int):ii)
   )))`;


(*val undefined_CompareOp : unit -> M CompareOp*)

val _ = Define `
 ((undefined_CompareOp:unit ->(regstate)sail2_state_monad$sequential_state ->(((CompareOp),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$internal_pickS [CompareOp_GT;CompareOp_GE;CompareOp_EQ;CompareOp_LE;CompareOp_LT]))`;


(*val PSTATEField_of_num : integer -> PSTATEField*)

val _ = Define `
 ((PSTATEField_of_num:int -> PSTATEField) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then PSTATEField_DAIFSet
   else if (((p0_ = (( 1 : int):ii)))) then PSTATEField_DAIFClr
   else if (((p0_ = (( 2 : int):ii)))) then PSTATEField_PAN
   else if (((p0_ = (( 3 : int):ii)))) then PSTATEField_UAO
   else PSTATEField_SP))`;


(*val num_of_PSTATEField : PSTATEField -> integer*)

val _ = Define `
 ((num_of_PSTATEField:PSTATEField -> int) arg_=
    ((case arg_ of
     PSTATEField_DAIFSet => (( 0 : int):ii)
   | PSTATEField_DAIFClr => (( 1 : int):ii)
   | PSTATEField_PAN => (( 2 : int):ii)
   | PSTATEField_UAO => (( 3 : int):ii)
   | PSTATEField_SP => (( 4 : int):ii)
   )))`;


(*val undefined_PSTATEField : unit -> M PSTATEField*)

val _ = Define `
 ((undefined_PSTATEField:unit ->(regstate)sail2_state_monad$sequential_state ->(((PSTATEField),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$internal_pickS
     [PSTATEField_DAIFSet;PSTATEField_DAIFClr;PSTATEField_PAN;PSTATEField_UAO;PSTATEField_SP]))`;


(*val FPMaxMinOp_of_num : integer -> FPMaxMinOp*)

val _ = Define `
 ((FPMaxMinOp_of_num:int -> FPMaxMinOp) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then FPMaxMinOp_MAX
   else if (((p0_ = (( 1 : int):ii)))) then FPMaxMinOp_MIN
   else if (((p0_ = (( 2 : int):ii)))) then FPMaxMinOp_MAXNUM
   else FPMaxMinOp_MINNUM))`;


(*val num_of_FPMaxMinOp : FPMaxMinOp -> integer*)

val _ = Define `
 ((num_of_FPMaxMinOp:FPMaxMinOp -> int) arg_=
    ((case arg_ of
     FPMaxMinOp_MAX => (( 0 : int):ii)
   | FPMaxMinOp_MIN => (( 1 : int):ii)
   | FPMaxMinOp_MAXNUM => (( 2 : int):ii)
   | FPMaxMinOp_MINNUM => (( 3 : int):ii)
   )))`;


(*val undefined_FPMaxMinOp : unit -> M FPMaxMinOp*)

val _ = Define `
 ((undefined_FPMaxMinOp:unit ->(regstate)sail2_state_monad$sequential_state ->(((FPMaxMinOp),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$internal_pickS [FPMaxMinOp_MAX;FPMaxMinOp_MIN;FPMaxMinOp_MAXNUM;FPMaxMinOp_MINNUM]))`;


(*val CountOp_of_num : integer -> CountOp*)

val _ = Define `
 ((CountOp_of_num:int -> CountOp) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then CountOp_CLZ
   else if (((p0_ = (( 1 : int):ii)))) then CountOp_CLS
   else CountOp_CNT))`;


(*val num_of_CountOp : CountOp -> integer*)

val _ = Define `
 ((num_of_CountOp:CountOp -> int) arg_=
    ((case arg_ of   CountOp_CLZ => (( 0 : int):ii) | CountOp_CLS => (( 1 : int):ii) | CountOp_CNT => (( 2 : int):ii) )))`;


(*val undefined_CountOp : unit -> M CountOp*)

val _ = Define `
 ((undefined_CountOp:unit ->(regstate)sail2_state_monad$sequential_state ->(((CountOp),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state$internal_pickS [CountOp_CLZ;CountOp_CLS;CountOp_CNT]))`;


(*val VFPNegMul_of_num : integer -> VFPNegMul*)

val _ = Define `
 ((VFPNegMul_of_num:int -> VFPNegMul) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then VFPNegMul_VNMLA
   else if (((p0_ = (( 1 : int):ii)))) then VFPNegMul_VNMLS
   else VFPNegMul_VNMUL))`;


(*val num_of_VFPNegMul : VFPNegMul -> integer*)

val _ = Define `
 ((num_of_VFPNegMul:VFPNegMul -> int) arg_=
    ((case arg_ of
     VFPNegMul_VNMLA => (( 0 : int):ii)
   | VFPNegMul_VNMLS => (( 1 : int):ii)
   | VFPNegMul_VNMUL => (( 2 : int):ii)
   )))`;


(*val undefined_VFPNegMul : unit -> M VFPNegMul*)

val _ = Define `
 ((undefined_VFPNegMul:unit ->(regstate)sail2_state_monad$sequential_state ->(((VFPNegMul),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state$internal_pickS [VFPNegMul_VNMLA;VFPNegMul_VNMLS;VFPNegMul_VNMUL]))`;


(*val VBitOps_of_num : integer -> VBitOps*)

val _ = Define `
 ((VBitOps_of_num:int -> VBitOps) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then VBitOps_VBIF
   else if (((p0_ = (( 1 : int):ii)))) then VBitOps_VBIT
   else VBitOps_VBSL))`;


(*val num_of_VBitOps : VBitOps -> integer*)

val _ = Define `
 ((num_of_VBitOps:VBitOps -> int) arg_=
    ((case arg_ of   VBitOps_VBIF => (( 0 : int):ii) | VBitOps_VBIT => (( 1 : int):ii) | VBitOps_VBSL => (( 2 : int):ii) )))`;


(*val undefined_VBitOps : unit -> M VBitOps*)

val _ = Define `
 ((undefined_VBitOps:unit ->(regstate)sail2_state_monad$sequential_state ->(((VBitOps),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state$internal_pickS [VBitOps_VBIF;VBitOps_VBIT;VBitOps_VBSL]))`;


(*val VCGEtype_of_num : integer -> VCGEtype*)

val _ = Define `
 ((VCGEtype_of_num:int -> VCGEtype) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then VCGEtype_signed
   else if (((p0_ = (( 1 : int):ii)))) then VCGEtype_unsigned
   else VCGEtype_fp))`;


(*val num_of_VCGEtype : VCGEtype -> integer*)

val _ = Define `
 ((num_of_VCGEtype:VCGEtype -> int) arg_=
    ((case arg_ of
     VCGEtype_signed => (( 0 : int):ii)
   | VCGEtype_unsigned => (( 1 : int):ii)
   | VCGEtype_fp => (( 2 : int):ii)
   )))`;


(*val undefined_VCGEtype : unit -> M VCGEtype*)

val _ = Define `
 ((undefined_VCGEtype:unit ->(regstate)sail2_state_monad$sequential_state ->(((VCGEtype),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state$internal_pickS [VCGEtype_signed;VCGEtype_unsigned;VCGEtype_fp]))`;


(*val VCGTtype_of_num : integer -> VCGTtype*)

val _ = Define `
 ((VCGTtype_of_num:int -> VCGTtype) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then VCGTtype_signed
   else if (((p0_ = (( 1 : int):ii)))) then VCGTtype_unsigned
   else VCGTtype_fp))`;


(*val num_of_VCGTtype : VCGTtype -> integer*)

val _ = Define `
 ((num_of_VCGTtype:VCGTtype -> int) arg_=
    ((case arg_ of
     VCGTtype_signed => (( 0 : int):ii)
   | VCGTtype_unsigned => (( 1 : int):ii)
   | VCGTtype_fp => (( 2 : int):ii)
   )))`;


(*val undefined_VCGTtype : unit -> M VCGTtype*)

val _ = Define `
 ((undefined_VCGTtype:unit ->(regstate)sail2_state_monad$sequential_state ->(((VCGTtype),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state$internal_pickS [VCGTtype_signed;VCGTtype_unsigned;VCGTtype_fp]))`;


(*val __InstrEnc_of_num : integer -> __InstrEnc*)

val _ = Define `
 ((InstrEnc_of_num:int -> InstrEnc) arg_=
    (let p0_ = arg_ in
   if (((p0_ = (( 0 : int):ii)))) then A64
   else if (((p0_ = (( 1 : int):ii)))) then A32
   else if (((p0_ = (( 2 : int):ii)))) then T16
   else T32))`;


(*val num_of___InstrEnc : __InstrEnc -> integer*)

val _ = Define `
 ((num_of___InstrEnc:InstrEnc -> int) arg_=
    ((case arg_ of   A64 => (( 0 : int):ii) | A32 => (( 1 : int):ii) | T16 => (( 2 : int):ii) | T32 => (( 3 : int):ii) )))`;


(*val undefined___InstrEnc : unit -> M __InstrEnc*)

val _ = Define `
 ((undefined___InstrEnc:unit ->(regstate)sail2_state_monad$sequential_state ->(((InstrEnc),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state$internal_pickS [A64;A32;T16;T32]))`;


(*val AArch64_CheckAndUpdateDescriptor_SecondStage : DescriptorUpdate -> FaultRecord -> mword ty64 -> AccType -> bool -> bool -> bool -> M FaultRecord*)

(*val AArch64_TranslationTableWalk_SecondStage : mword ty52 -> mword ty64 -> AccType -> bool -> bool -> ii -> M TLBRecord*)

(*val AArch64_SecondStageTranslate : AddressDescriptor -> mword ty64 -> AccType -> bool -> bool -> bool -> ii -> bool -> M AddressDescriptor*)

(*val AArch64_CheckAndUpdateDescriptor : DescriptorUpdate -> FaultRecord -> bool -> mword ty64 -> AccType -> bool -> bool -> bool -> M FaultRecord*)

(*val __UNKNOWN_real : unit -> real*)

val _ = Define `
 ((UNKNOWN_real:unit -> real) () =  (realFromFrac(( 0 : int))(( 10 : int))))`;


(*val __UNKNOWN_integer : unit -> ii*)

val _ = Define `
 ((UNKNOWN_integer:unit -> int) () =  ((( 0 : int):ii)))`;


(*val aget_PC : unit -> M (mword ty64)*)

val _ = Define `
 ((aget_PC:unit ->(regstate)sail2_state_monad$sequential_state ->((((64)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  ((sail2_state_monad$read_regS PC_ref  : ( 64 words$word) M)))`;


(*val UndefinedFault : unit -> M unit*)

val _ = Define `
 ((UndefinedFault:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$assert_expS F "Undefined fault"))`;


(*val ThisInstrAddr : forall 'N . Size 'N => integer -> unit -> M (mword 'N)*)

val _ = Define `
 ((ThisInstrAddr:int -> unit ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) (N__tv : int) () =  (sail2_state_monad$bindS
   (sail2_state_monad$read_regS PC_ref  : ( 64 words$word) M) (\ (w__0 : 64 bits) . 
   sail2_state_monad$returnS ((slice w__0 (( 0 : int):ii) N__tv  :  'N words$word)))))`;


(*val ThisInstr : unit -> M (mword ty32)*)

val _ = Define `
 ((ThisInstr0:unit ->(regstate)sail2_state_monad$sequential_state ->((((32)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  ((sail2_state_monad$read_regS ThisInstr_ref  : ( 32 words$word) M)))`;


(*val __UNKNOWN_SystemHintOp : unit -> SystemHintOp*)

val _ = Define `
 ((UNKNOWN_SystemHintOp:unit -> SystemHintOp) () =  SystemHintOp_NOP)`;


(*val SynchronizeContext : unit -> unit*)

val _ = Define `
 ((SynchronizeContext:unit -> unit) () =  () )`;


(*val SErrorPending : unit -> M bool*)

val _ = Define `
 ((SErrorPending:unit ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$read_regS PendingPhysicalSError_ref))`;


(*val ResetExternalDebugRegisters : bool -> unit*)

val _ = Define `
 ((ResetExternalDebugRegisters:bool -> unit) cold_reset=  () )`;


(*val ProfilingSynchronizationBarrier : unit -> unit*)

val _ = Define `
 ((ProfilingSynchronizationBarrier:unit -> unit) () =  () )`;


(*val ProcessorID : unit -> ii*)

val _ = Define `
 ((ProcessorID:unit -> int) () =  ((( 0 : int):ii)))`;


(*val __UNKNOWN_PrefetchHint : unit -> PrefetchHint*)

val _ = Define `
 ((UNKNOWN_PrefetchHint:unit -> PrefetchHint) () =  Prefetch_READ)`;


(*val __UNKNOWN_PSTATEField : unit -> PSTATEField*)

val _ = Define `
 ((UNKNOWN_PSTATEField:unit -> PSTATEField) () =  PSTATEField_DAIFSet)`;


(*val PACCellShuffle : mword ty64 -> M (mword ty64)*)

val _ = Define `
 ((PACCellShuffle:(64)words$word ->(regstate)sail2_state_monad$sequential_state ->((((64)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) indata=  (sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (outdata : 64 bits) . 
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 0 : int):ii) ((slice indata (( 52 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 4 : int):ii) ((slice indata (( 24 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 8 : int):ii) ((slice indata (( 44 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 12 : int):ii) ((slice indata (( 0 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 16 : int):ii) ((slice indata (( 28 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 20 : int):ii) ((slice indata (( 48 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 24 : int):ii) ((slice indata (( 4 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 28 : int):ii) ((slice indata (( 40 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 32 : int):ii) ((slice indata (( 32 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 36 : int):ii) ((slice indata (( 12 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 40 : int):ii) ((slice indata (( 56 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 44 : int):ii) ((slice indata (( 20 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 48 : int):ii) ((slice indata (( 8 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 52 : int):ii) ((slice indata (( 36 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 56 : int):ii) ((slice indata (( 16 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 60 : int):ii) ((slice indata (( 60 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   sail2_state_monad$returnS outdata)))`;


(*val PACCellInvShuffle : mword ty64 -> M (mword ty64)*)

val _ = Define `
 ((PACCellInvShuffle:(64)words$word ->(regstate)sail2_state_monad$sequential_state ->((((64)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) indata=  (sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (outdata : 64 bits) . 
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 0 : int):ii) ((slice indata (( 12 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 4 : int):ii) ((slice indata (( 24 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 8 : int):ii) ((slice indata (( 48 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 12 : int):ii) ((slice indata (( 36 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 16 : int):ii) ((slice indata (( 56 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 20 : int):ii) ((slice indata (( 44 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 24 : int):ii) ((slice indata (( 4 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 28 : int):ii) ((slice indata (( 16 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 32 : int):ii) ((slice indata (( 32 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 36 : int):ii) ((slice indata (( 52 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 40 : int):ii) ((slice indata (( 28 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 44 : int):ii) ((slice indata (( 8 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 48 : int):ii) ((slice indata (( 20 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 52 : int):ii) ((slice indata (( 0 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 56 : int):ii) ((slice indata (( 40 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 60 : int):ii) ((slice indata (( 60 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   sail2_state_monad$returnS outdata)))`;


(*val __UNKNOWN_MoveWideOp : unit -> MoveWideOp*)

val _ = Define `
 ((UNKNOWN_MoveWideOp:unit -> MoveWideOp) () =  MoveWideOp_N)`;


(*val __UNKNOWN_MemType : unit -> MemType*)

val _ = Define `
 ((UNKNOWN_MemType:unit -> MemType) () =  MemType_Normal)`;


(*val __UNKNOWN_MemOp : unit -> MemOp*)

val _ = Define `
 ((UNKNOWN_MemOp:unit -> MemOp) () =  MemOp_LOAD)`;


val _ = Define `
((MemHint_RWA:(2)words$word)=  ((vec_of_bits [B1;B1]  :  2 words$word)))`;


val _ = Define `
((MemHint_RA:(2)words$word)=  ((vec_of_bits [B1;B0]  :  2 words$word)))`;


val _ = Define `
((MemHint_No:(2)words$word)=  ((vec_of_bits [B0;B0]  :  2 words$word)))`;


(*val __UNKNOWN_MemBarrierOp : unit -> MemBarrierOp*)

val _ = Define `
 ((UNKNOWN_MemBarrierOp:unit -> MemBarrierOp) () =  MemBarrierOp_DSB)`;


val _ = Define `
((MemAttr_WT:(2)words$word)=  ((vec_of_bits [B1;B0]  :  2 words$word)))`;


val _ = Define `
((MemAttr_WB:(2)words$word)=  ((vec_of_bits [B1;B1]  :  2 words$word)))`;


val _ = Define `
((MemAttr_NC:(2)words$word)=  ((vec_of_bits [B0;B0]  :  2 words$word)))`;


(*val __UNKNOWN_MemAtomicOp : unit -> MemAtomicOp*)

val _ = Define `
 ((UNKNOWN_MemAtomicOp:unit -> MemAtomicOp) () =  MemAtomicOp_ADD)`;


(*val __UNKNOWN_MBReqTypes : unit -> MBReqTypes*)

val _ = Define `
 ((UNKNOWN_MBReqTypes:unit -> MBReqTypes) () =  MBReqTypes_Reads)`;


(*val __UNKNOWN_MBReqDomain : unit -> MBReqDomain*)

val _ = Define `
 ((UNKNOWN_MBReqDomain:unit -> MBReqDomain) () =  MBReqDomain_Nonshareable)`;


val _ = Define `
((M32_User:(5)words$word)=  ((vec_of_bits [B1;B0;B0;B0;B0]  :  5 words$word)))`;


val _ = Define `
((M32_Undef:(5)words$word)=  ((vec_of_bits [B1;B1;B0;B1;B1]  :  5 words$word)))`;


val _ = Define `
((M32_System:(5)words$word)=  ((vec_of_bits [B1;B1;B1;B1;B1]  :  5 words$word)))`;


val _ = Define `
((M32_Svc:(5)words$word)=  ((vec_of_bits [B1;B0;B0;B1;B1]  :  5 words$word)))`;


val _ = Define `
((M32_Monitor:(5)words$word)=  ((vec_of_bits [B1;B0;B1;B1;B0]  :  5 words$word)))`;


val _ = Define `
((M32_IRQ:(5)words$word)=  ((vec_of_bits [B1;B0;B0;B1;B0]  :  5 words$word)))`;


val _ = Define `
((M32_Hyp:(5)words$word)=  ((vec_of_bits [B1;B1;B0;B1;B0]  :  5 words$word)))`;


val _ = Define `
((M32_FIQ:(5)words$word)=  ((vec_of_bits [B1;B0;B0;B0;B1]  :  5 words$word)))`;


val _ = Define `
((M32_Abort:(5)words$word)=  ((vec_of_bits [B1;B0;B1;B1;B1]  :  5 words$word)))`;


(*val __UNKNOWN_LogicalOp : unit -> LogicalOp*)

val _ = Define `
 ((UNKNOWN_LogicalOp:unit -> LogicalOp) () =  LogicalOp_AND)`;


(*val IsExclusiveLocal : FullAddress -> ii -> ii -> M bool*)

val _ = Define `
 ((IsExclusiveLocal:FullAddress -> int -> int ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) paddress processorid size1=  (sail2_state_monad$read_regS ExclusiveLocal_ref))`;


(*val InterruptPending : unit -> M bool*)

val _ = Define `
 ((InterruptPending:unit ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$read_regS PendingInterrupt_ref))`;


(*val asl_Int : forall 'N . Size 'N => mword 'N -> bool -> ii*)

val _ = Define `
 ((asl_Int:'N words$word -> bool -> int) x unsigned=  (if unsigned then lem$w2ui x else integer_word$w2i x))`;


(*val InstructionSynchronizationBarrier : unit -> unit*)

val _ = Define `
 ((InstructionSynchronizationBarrier:unit -> unit) () =  () )`;


(*val __UNKNOWN_InstrSet : unit -> InstrSet*)

val _ = Define `
 ((UNKNOWN_InstrSet:unit -> InstrSet) () =  InstrSet_A64)`;


(*val Hint_Yield : unit -> unit*)

val _ = Define `
 ((Hint_Yield:unit -> unit) () =  () )`;


(*val Hint_Prefetch : mword ty64 -> PrefetchHint -> ii -> bool -> unit*)

val _ = Define `
 ((Hint_Prefetch:(64)words$word -> PrefetchHint -> int -> bool -> unit) address hint target stream=  () )`;


(*val Hint_Branch : BranchType -> unit*)

val _ = Define `
 ((Hint_Branch:BranchType -> unit) hint=  () )`;


(*val HaveFP16Ext : unit -> bool*)

val _ = Define `
 ((HaveFP16Ext:unit -> bool) () =  T)`;


(*val HaveAnyAArch32 : unit -> bool*)

val _ = Define `
 ((HaveAnyAArch32:unit -> bool) () =  F)`;


(*val __UNKNOWN_Fault : unit -> Fault*)

val _ = Define `
 ((UNKNOWN_Fault:unit -> Fault) () =  Fault_None)`;


(*val __UNKNOWN_FPUnaryOp : unit -> FPUnaryOp*)

val _ = Define `
 ((UNKNOWN_FPUnaryOp:unit -> FPUnaryOp) () =  FPUnaryOp_ABS)`;


(*val __UNKNOWN_FPType : unit -> FPType*)

val _ = Define `
 ((UNKNOWN_FPType:unit -> FPType) () =  FPType_Nonzero)`;


(*val __UNKNOWN_FPRounding : unit -> FPRounding*)

val _ = Define `
 ((UNKNOWN_FPRounding:unit -> FPRounding) () =  FPRounding_TIEEVEN)`;


(*val __UNKNOWN_FPMaxMinOp : unit -> FPMaxMinOp*)

val _ = Define `
 ((UNKNOWN_FPMaxMinOp:unit -> FPMaxMinOp) () =  FPMaxMinOp_MAX)`;


(*val FPDecodeRounding : mword ty2 -> FPRounding*)

val _ = Define `
 ((FPDecodeRounding:(2)words$word -> FPRounding) rmode=
    (let b__0 = rmode in
   if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then FPRounding_TIEEVEN
   else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then FPRounding_POSINF
   else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then FPRounding_NEGINF
   else FPRounding_ZERO))`;


(*val FPRoundingMode : mword ty32 -> FPRounding*)

val _ = Define `
 ((FPRoundingMode:(32)words$word -> FPRounding) fpcr=  (FPDecodeRounding ((slice fpcr (( 22 : int):ii) (( 2 : int):ii)  :  2 words$word))))`;


(*val __UNKNOWN_FPConvOp : unit -> FPConvOp*)

val _ = Define `
 ((UNKNOWN_FPConvOp:unit -> FPConvOp) () =  FPConvOp_CVT_FtoI)`;


(*val __UNKNOWN_boolean : unit -> bool*)

val _ = Define `
 ((UNKNOWN_boolean:unit -> bool) () =  F)`;


(*val __ResetInterruptState : unit -> M unit*)

val _ = Define `
 ((ResetInterruptState:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PendingPhysicalSError_ref F) (sail2_state_monad$write_regS PendingInterrupt_ref F)))`;


(*val __ResetExecuteState : unit -> M unit*)

val _ = Define `
 ((ResetExecuteState:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$write_regS Sleeping_ref F))`;


(*val Unreachable : unit -> M unit*)

val _ = Define `
 ((Unreachable:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$assert_expS F "FALSE"))`;


(*val RBankSelect : mword ty5 -> ii -> ii -> ii -> ii -> ii -> ii -> ii -> M ii*)

val _ = Define `
 ((RBankSelect:(5)words$word -> int -> int -> int -> int -> int -> int -> int ->(regstate)sail2_state_monad$sequential_state ->(((int),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) mode usr fiq irq svc abt und hyp=  (sail2_state_monad$bindS
   (undefined_int () ) (\ (result : ii) . 
   let pat_0 = mode in
   if (((pat_0 = M32_User))) then sail2_state_monad$returnS usr
   else if (((pat_0 = M32_FIQ))) then sail2_state_monad$returnS fiq
   else if (((pat_0 = M32_IRQ))) then sail2_state_monad$returnS irq
   else if (((pat_0 = M32_Svc))) then sail2_state_monad$returnS svc
   else if (((pat_0 = M32_Abort))) then sail2_state_monad$returnS abt
   else if (((pat_0 = M32_Hyp))) then sail2_state_monad$returnS hyp
   else if (((pat_0 = M32_Undef))) then sail2_state_monad$returnS und
   else if (((pat_0 = M32_System))) then sail2_state_monad$returnS usr
   else sail2_state_monad$seqS (Unreachable () ) (sail2_state_monad$returnS result))))`;


(*val TakeUnmaskedSErrorInterrupts : unit -> M unit*)

val _ = Define `
 ((TakeUnmaskedSErrorInterrupts:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$assert_expS F "FALSE"))`;


(*val TakeUnmaskedPhysicalSErrorInterrupts : bool -> M unit*)

val _ = Define `
 ((TakeUnmaskedPhysicalSErrorInterrupts:bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) iesb_req=  (sail2_state_monad$assert_expS F "FALSE"))`;


(*val StopInstructionPrefetchAndEnableITR : unit -> M unit*)

val _ = Define `
 ((StopInstructionPrefetchAndEnableITR:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$assert_expS F "FALSE"))`;


(*val SendEvent : unit -> M unit*)

val _ = Define `
 ((SendEvent:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$assert_expS F "FALSE"))`;


(*val MarkExclusiveLocal : FullAddress -> ii -> ii -> M unit*)

val _ = Define `
 ((MarkExclusiveLocal:FullAddress -> int -> int ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) paddress processorid size1=  (sail2_state_monad$write_regS ExclusiveLocal_ref F))`;


(*val MarkExclusiveGlobal : FullAddress -> ii -> ii -> M unit*)

val _ = Define `
 ((MarkExclusiveGlobal:FullAddress -> int -> int ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) paddress processorid size1=  (sail2_state_monad$assert_expS F "FALSE"))`;


(*val IsExclusiveGlobal : FullAddress -> ii -> ii -> M bool*)

val _ = Define `
 ((IsExclusiveGlobal:FullAddress -> int -> int ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) paddress processorid size1=  (sail2_state_monad$seqS (sail2_state_monad$assert_expS F "FALSE") (sail2_state_monad$returnS F)))`;


(*val ExclusiveMonitorsStatus : unit -> M (mword ty1)*)

val _ = Define `
 ((ExclusiveMonitorsStatus:unit ->(regstate)sail2_state_monad$sequential_state ->((((1)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$seqS (sail2_state_monad$assert_expS F "FALSE") (sail2_state_monad$returnS (vec_of_bits [B0]  :  1 words$word))))`;


(*val __UNKNOWN_Exception : unit -> Exception*)

val _ = Define `
 ((UNKNOWN_Exception:unit -> Exception) () =  Exception_Uncategorized)`;


(*val SendEventLocal : unit -> M unit*)

val _ = Define `
 ((SendEventLocal:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$write_regS EventRegister_ref (vec_of_bits [B1]  :  1 words$word)))`;


(*val ErrorSynchronizationBarrier : MBReqDomain -> MBReqTypes -> unit*)

val _ = Define `
 ((ErrorSynchronizationBarrier:MBReqDomain -> MBReqTypes -> unit) domain1 types=  () )`;


(*val EnterLowPowerState : unit -> M unit*)

val _ = Define `
 ((EnterLowPowerState:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$write_regS Sleeping_ref T))`;


(*val WaitForInterrupt : unit -> M unit*)

val _ = Define `
 ((WaitForInterrupt:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (EnterLowPowerState () ))`;


(*val EndOfInstruction : unit -> M unit*)

val _ = Define `
 ((EndOfInstruction:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$throwS (Error_ExceptionTaken () )))`;


(*val TweakCellRot : mword ty4 -> M (mword ty4)*)

val _ = Define `
 ((TweakCellRot:(4)words$word ->(regstate)sail2_state_monad$sequential_state ->((((4)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) incell_name=  (sail2_state_monad$bindS
   (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (outcell : 4 bits) . 
   let (outcell : 4 bits) =
     ((set_slice (( 4 : int):ii) (( 1 : int):ii) outcell (( 3 : int):ii)
        ((xor_vec (vec_of_bits [access_vec_dec incell_name (( 0 : int):ii)]  :  1 words$word)
            (vec_of_bits [access_vec_dec incell_name (( 1 : int):ii)]  :  1 words$word)
           :  1 words$word))
       :  4 words$word)) in
   let (outcell : 4 bits) =
     ((set_slice (( 4 : int):ii) (( 1 : int):ii) outcell (( 2 : int):ii)
        (vec_of_bits [access_vec_dec incell_name (( 3 : int):ii)]  :  1 words$word)
       :  4 words$word)) in
   let (outcell : 4 bits) =
     ((set_slice (( 4 : int):ii) (( 1 : int):ii) outcell (( 1 : int):ii)
        (vec_of_bits [access_vec_dec incell_name (( 2 : int):ii)]  :  1 words$word)
       :  4 words$word)) in
   let (outcell : 4 bits) =
     ((set_slice (( 4 : int):ii) (( 1 : int):ii) outcell (( 0 : int):ii)
        (vec_of_bits [access_vec_dec incell_name (( 1 : int):ii)]  :  1 words$word)
       :  4 words$word)) in
   sail2_state_monad$returnS outcell)))`;


(*val TweakShuffle : mword ty64 -> M (mword ty64)*)

val _ = Define `
 ((TweakShuffle:(64)words$word ->(regstate)sail2_state_monad$sequential_state ->((((64)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) indata=  (sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (outdata : 64 bits) . 
   let (outdata : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 0 : int):ii) ((slice indata (( 16 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let outdata =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 4 : int):ii) ((slice indata (( 20 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in sail2_state_monad$bindS
   (TweakCellRot ((slice indata (( 24 : int):ii) (( 4 : int):ii)  :  4 words$word))  : ( 4 words$word) M) (\ (w__0 :
      4 words$word) . 
   let outdata = ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 8 : int):ii) w__0  :  64 words$word)) in
   let outdata =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 12 : int):ii) ((slice indata (( 28 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in sail2_state_monad$bindS
   (TweakCellRot ((slice indata (( 44 : int):ii) (( 4 : int):ii)  :  4 words$word))  : ( 4 words$word) M) (\ (w__1 :
      4 words$word) . 
   let outdata = ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 16 : int):ii) w__1  :  64 words$word)) in
   let outdata =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 20 : int):ii) ((slice indata (( 8 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let outdata =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 24 : int):ii) ((slice indata (( 12 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in sail2_state_monad$bindS
   (TweakCellRot ((slice indata (( 32 : int):ii) (( 4 : int):ii)  :  4 words$word))  : ( 4 words$word) M) (\ (w__2 :
      4 words$word) . 
   let outdata = ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 28 : int):ii) w__2  :  64 words$word)) in
   let outdata =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 32 : int):ii) ((slice indata (( 48 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let outdata =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 36 : int):ii) ((slice indata (( 52 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let outdata =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 40 : int):ii) ((slice indata (( 56 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in sail2_state_monad$bindS
   (TweakCellRot ((slice indata (( 60 : int):ii) (( 4 : int):ii)  :  4 words$word))  : ( 4 words$word) M) (\ (w__3 :
      4 words$word) . 
   let outdata = ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 44 : int):ii) w__3  :  64 words$word)) in sail2_state_monad$bindS
   (TweakCellRot ((slice indata (( 0 : int):ii) (( 4 : int):ii)  :  4 words$word))  : ( 4 words$word) M) (\ (w__4 :
      4 words$word) . 
   let outdata = ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 48 : int):ii) w__4  :  64 words$word)) in
   let outdata =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 52 : int):ii) ((slice indata (( 4 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in sail2_state_monad$bindS
   (TweakCellRot ((slice indata (( 40 : int):ii) (( 4 : int):ii)  :  4 words$word))  : ( 4 words$word) M) (\ (w__5 :
      4 words$word) . 
   let outdata = ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 56 : int):ii) w__5  :  64 words$word)) in sail2_state_monad$bindS
   (TweakCellRot ((slice indata (( 36 : int):ii) (( 4 : int):ii)  :  4 words$word))  : ( 4 words$word) M) (\ (w__6 :
      4 words$word) . 
   let (outdata : 64 bits) = ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 60 : int):ii) w__6  :  64 words$word)) in
   sail2_state_monad$returnS outdata))))))))))`;


(*val TweakCellInvRot : mword ty4 -> M (mword ty4)*)

val _ = Define `
 ((TweakCellInvRot:(4)words$word ->(regstate)sail2_state_monad$sequential_state ->((((4)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) incell_name=  (sail2_state_monad$bindS
   (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (outcell : 4 bits) . 
   let (outcell : 4 bits) =
     ((set_slice (( 4 : int):ii) (( 1 : int):ii) outcell (( 3 : int):ii)
        (vec_of_bits [access_vec_dec incell_name (( 2 : int):ii)]  :  1 words$word)
       :  4 words$word)) in
   let (outcell : 4 bits) =
     ((set_slice (( 4 : int):ii) (( 1 : int):ii) outcell (( 2 : int):ii)
        (vec_of_bits [access_vec_dec incell_name (( 1 : int):ii)]  :  1 words$word)
       :  4 words$word)) in
   let (outcell : 4 bits) =
     ((set_slice (( 4 : int):ii) (( 1 : int):ii) outcell (( 1 : int):ii)
        (vec_of_bits [access_vec_dec incell_name (( 0 : int):ii)]  :  1 words$word)
       :  4 words$word)) in
   let (outcell : 4 bits) =
     ((set_slice (( 4 : int):ii) (( 1 : int):ii) outcell (( 0 : int):ii)
        ((xor_vec (vec_of_bits [access_vec_dec incell_name (( 0 : int):ii)]  :  1 words$word)
            (vec_of_bits [access_vec_dec incell_name (( 3 : int):ii)]  :  1 words$word)
           :  1 words$word))
       :  4 words$word)) in
   sail2_state_monad$returnS outcell)))`;


(*val TweakInvShuffle : mword ty64 -> M (mword ty64)*)

val _ = Define `
 ((TweakInvShuffle:(64)words$word ->(regstate)sail2_state_monad$sequential_state ->((((64)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) indata=  (sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (outdata : 64 bits) .  sail2_state_monad$bindS
   (TweakCellInvRot ((slice indata (( 48 : int):ii) (( 4 : int):ii)  :  4 words$word))  : ( 4 words$word) M) (\ (w__0 :
      4 words$word) . 
   let (outdata : 64 bits) = ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 0 : int):ii) w__0  :  64 words$word)) in
   let outdata =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 4 : int):ii) ((slice indata (( 52 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let outdata =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 8 : int):ii) ((slice indata (( 20 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let outdata =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 12 : int):ii) ((slice indata (( 24 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let outdata =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 16 : int):ii) ((slice indata (( 0 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let outdata =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 20 : int):ii) ((slice indata (( 4 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in sail2_state_monad$bindS
   (TweakCellInvRot ((slice indata (( 8 : int):ii) (( 4 : int):ii)  :  4 words$word))  : ( 4 words$word) M) (\ (w__1 :
      4 words$word) . 
   let outdata = ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 24 : int):ii) w__1  :  64 words$word)) in
   let outdata =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 28 : int):ii) ((slice indata (( 12 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in sail2_state_monad$bindS
   (TweakCellInvRot ((slice indata (( 28 : int):ii) (( 4 : int):ii)  :  4 words$word))  : ( 4 words$word) M) (\ (w__2 :
      4 words$word) . 
   let outdata = ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 32 : int):ii) w__2  :  64 words$word)) in sail2_state_monad$bindS
   (TweakCellInvRot ((slice indata (( 60 : int):ii) (( 4 : int):ii)  :  4 words$word))  : ( 4 words$word) M) (\ (w__3 :
      4 words$word) . 
   let outdata = ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 36 : int):ii) w__3  :  64 words$word)) in sail2_state_monad$bindS
   (TweakCellInvRot ((slice indata (( 56 : int):ii) (( 4 : int):ii)  :  4 words$word))  : ( 4 words$word) M) (\ (w__4 :
      4 words$word) . 
   let outdata = ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 40 : int):ii) w__4  :  64 words$word)) in sail2_state_monad$bindS
   (TweakCellInvRot ((slice indata (( 16 : int):ii) (( 4 : int):ii)  :  4 words$word))  : ( 4 words$word) M) (\ (w__5 :
      4 words$word) . 
   let outdata = ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 44 : int):ii) w__5  :  64 words$word)) in
   let outdata =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 48 : int):ii) ((slice indata (( 32 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let outdata =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 52 : int):ii) ((slice indata (( 36 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in
   let outdata =
     ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 56 : int):ii) ((slice indata (( 40 : int):ii) (( 4 : int):ii)  :  4 words$word))
       :  64 words$word)) in sail2_state_monad$bindS
   (TweakCellInvRot ((slice indata (( 44 : int):ii) (( 4 : int):ii)  :  4 words$word))  : ( 4 words$word) M) (\ (w__6 :
      4 words$word) . 
   let (outdata : 64 bits) = ((set_slice (( 64 : int):ii) (( 4 : int):ii) outdata (( 60 : int):ii) w__6  :  64 words$word)) in
   sail2_state_monad$returnS outdata))))))))))`;


val _ = Define `
((EL3:(2)words$word)=  ((vec_of_bits [B1;B1]  :  2 words$word)))`;


val _ = Define `
((EL2:(2)words$word)=  ((vec_of_bits [B1;B0]  :  2 words$word)))`;


val _ = Define `
((EL1:(2)words$word)=  ((vec_of_bits [B0;B1]  :  2 words$word)))`;


val _ = Define `
((EL0:(2)words$word)=  ((vec_of_bits [B0;B0]  :  2 words$word)))`;


(*val __UNKNOWN_DeviceType : unit -> DeviceType*)

val _ = Define `
 ((UNKNOWN_DeviceType:unit -> DeviceType) () =  DeviceType_GRE)`;


(*val DecodeShift : mword ty2 -> ShiftType*)

val _ = Define `
 ((DecodeShift:(2)words$word -> ShiftType) op=
    (let b__0 = op in
   if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then ShiftType_LSL
   else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then ShiftType_LSR
   else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then ShiftType_ASR
   else ShiftType_ROR))`;


(*val DecodeRegExtend : mword ty3 -> ExtendType*)

val _ = Define `
 ((DecodeRegExtend:(3)words$word -> ExtendType) op=
    (let b__0 = op in
   if (((b__0 = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) then ExtendType_UXTB
   else if (((b__0 = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) then ExtendType_UXTH
   else if (((b__0 = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) then ExtendType_UXTW
   else if (((b__0 = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) then ExtendType_UXTX
   else if (((b__0 = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) then ExtendType_SXTB
   else if (((b__0 = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) then ExtendType_SXTH
   else if (((b__0 = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) then ExtendType_SXTW
   else ExtendType_SXTX))`;


val _ = Define `
((DebugHalt_Watchpoint:(6)words$word)=  ((vec_of_bits [B1;B0;B1;B0;B1;B1]  :  6 words$word)))`;


val _ = Define `
((DebugHalt_HaltInstruction:(6)words$word)=  ((vec_of_bits [B1;B0;B1;B1;B1;B1]  :  6 words$word)))`;


val _ = Define `
((DebugHalt_Breakpoint:(6)words$word)=  ((vec_of_bits [B0;B0;B0;B1;B1;B1]  :  6 words$word)))`;


val _ = Define `
((DebugException_VectorCatch:(4)words$word)=  ((vec_of_bits [B0;B1;B0;B1]  :  4 words$word)))`;


(*val DataSynchronizationBarrier : MBReqDomain -> MBReqTypes -> unit*)

val _ = Define `
 ((DataSynchronizationBarrier:MBReqDomain -> MBReqTypes -> unit) domain1 types=  () )`;


(*val DataMemoryBarrier : MBReqDomain -> MBReqTypes -> unit*)

val _ = Define `
 ((DataMemoryBarrier:MBReqDomain -> MBReqTypes -> unit) domain1 types=  () )`;


(*val aarch64_system_barriers : MBReqDomain -> MemBarrierOp -> MBReqTypes -> unit*)

val _ = Define `
 ((aarch64_system_barriers:MBReqDomain -> MemBarrierOp -> MBReqTypes -> unit) domain1 op types=
    ((case op of
     MemBarrierOp_DSB => DataSynchronizationBarrier domain1 types
   | MemBarrierOp_DMB => DataMemoryBarrier domain1 types
   | MemBarrierOp_ISB => InstructionSynchronizationBarrier () 
   )))`;


(*val __UNKNOWN_Constraint : unit -> Constraint*)

val _ = Define `
 ((UNKNOWN_Constraint:unit -> Constraint) () =  Constraint_NONE)`;


(*val ConstrainUnpredictable : Unpredictable -> Constraint*)

val _ = Define `
 ((ConstrainUnpredictable:Unpredictable -> Constraint) which=
    ((case which of
     Unpredictable_WBOVERLAPLD => Constraint_WBSUPPRESS
   | Unpredictable_WBOVERLAPST => Constraint_NONE
   | Unpredictable_LDPOVERLAP => Constraint_UNDEF
   | Unpredictable_BASEOVERLAP => Constraint_NONE
   | Unpredictable_DATAOVERLAP => Constraint_NONE
   | Unpredictable_DEVPAGE2 => Constraint_FAULT
   | Unpredictable_INSTRDEVICE => Constraint_NONE
   | Unpredictable_RESCPACR => Constraint_UNKNOWN
   | Unpredictable_RESMAIR => Constraint_UNKNOWN
   | Unpredictable_RESTEXCB => Constraint_UNKNOWN
   | Unpredictable_RESDACR => Constraint_UNKNOWN
   | Unpredictable_RESPRRR => Constraint_UNKNOWN
   | Unpredictable_RESVTCRS => Constraint_UNKNOWN
   | Unpredictable_RESTnSZ => Constraint_FORCE
   | Unpredictable_OORTnSZ => Constraint_FORCE
   | Unpredictable_LARGEIPA => Constraint_FORCE
   | Unpredictable_ESRCONDPASS => Constraint_FALSE
   | Unpredictable_ILZEROIT => Constraint_FALSE
   | Unpredictable_ILZEROT => Constraint_FALSE
   | Unpredictable_BPVECTORCATCHPRI => Constraint_TRUE
   | Unpredictable_VCMATCHHALF => Constraint_FALSE
   | Unpredictable_VCMATCHDAPA => Constraint_FALSE
   | Unpredictable_WPMASKANDBAS => Constraint_FALSE
   | Unpredictable_WPBASCONTIGUOUS => Constraint_FALSE
   | Unpredictable_RESWPMASK => Constraint_DISABLED
   | Unpredictable_WPMASKEDBITS => Constraint_FALSE
   | Unpredictable_RESBPWPCTRL => Constraint_DISABLED
   | Unpredictable_BPNOTIMPL => Constraint_DISABLED
   | Unpredictable_RESBPTYPE => Constraint_DISABLED
   | Unpredictable_BPNOTCTXCMP => Constraint_DISABLED
   | Unpredictable_BPMATCHHALF => Constraint_FALSE
   | Unpredictable_BPMISMATCHHALF => Constraint_FALSE
   | Unpredictable_RESTARTALIGNPC => Constraint_FALSE
   | Unpredictable_RESTARTZEROUPPERPC => Constraint_TRUE
   | Unpredictable_ZEROUPPER => Constraint_TRUE
   | Unpredictable_ERETZEROUPPERPC => Constraint_TRUE
   | Unpredictable_A32FORCEALIGNPC => Constraint_FALSE
   | Unpredictable_SMD => Constraint_UNDEF
   | Unpredictable_AFUPDATE => Constraint_TRUE
   | Unpredictable_IESBinDebug => Constraint_TRUE
   | Unpredictable_CLEARERRITEZERO => Constraint_FALSE
   )))`;


(*val ClearPendingPhysicalSError : unit -> M unit*)

val _ = Define `
 ((ClearPendingPhysicalSError:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$write_regS PendingPhysicalSError_ref F))`;


(*val ClearExclusiveLocal : ii -> M unit*)

val _ = Define `
 ((ClearExclusiveLocal:int ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) processorid=  (sail2_state_monad$write_regS ExclusiveLocal_ref F))`;


(*val aarch64_system_monitors : unit -> M unit*)

val _ = Define `
 ((aarch64_system_monitors:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (ClearExclusiveLocal ((ProcessorID () ))))`;


(*val system_monitors_decode : mword ty1 -> mword ty2 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty3 -> mword ty5 -> M unit*)

val _ = Define `
 ((system_monitors_decode:(1)words$word ->(2)words$word ->(3)words$word ->(4)words$word ->(4)words$word ->(3)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) L op0 op1 CRn CRm op2 Rt=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T) (aarch64_system_monitors () )))`;


(*val ClearExclusiveByAddress : FullAddress -> ii -> ii -> unit*)

val _ = Define `
 ((ClearExclusiveByAddress:FullAddress -> int -> int -> unit) paddress processorid size1=  () )`;


(*val ClearEventRegister : unit -> M unit*)

val _ = Define `
 ((ClearEventRegister:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$write_regS EventRegister_ref (vec_of_bits [B0]  :  1 words$word)))`;


(*val CTI_SignalEvent : CrossTriggerIn -> M unit*)

val _ = Define `
 ((CTI_SignalEvent:CrossTriggerIn ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) id=  (sail2_state_monad$assert_expS F "FALSE"))`;


(*val __UNKNOWN_BranchType : unit -> BranchType*)

val _ = Define `
 ((UNKNOWN_BranchType:unit -> BranchType) () =  BranchType_CALL)`;


(*val __UNKNOWN_AccType : unit -> AccType*)

val _ = Define `
 ((UNKNOWN_AccType:unit -> AccType) () =  AccType_NORMAL)`;


(*val CreateAccessDescriptorPTW : AccType -> bool -> bool -> ii -> M AccessDescriptor*)

val _ = Define `
 ((CreateAccessDescriptorPTW:AccType -> bool -> bool -> int ->(regstate)sail2_state_monad$sequential_state ->(((AccessDescriptor),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) acctype secondstage s2fs1walk level=  (sail2_state_monad$bindS
   (undefined_AccessDescriptor () ) (\ (accdesc : AccessDescriptor) . 
   let (accdesc : AccessDescriptor) = ((accdesc with<| AccessDescriptor_acctype := acctype|>)) in
   let (accdesc : AccessDescriptor) = ((accdesc with<| AccessDescriptor_page_table_walk := T|>)) in
   let (accdesc : AccessDescriptor) = ((accdesc with<| AccessDescriptor_secondstage := s2fs1walk|>)) in
   let (accdesc : AccessDescriptor) = ((accdesc with<| AccessDescriptor_secondstage := secondstage|>)) in
   let (accdesc : AccessDescriptor) = ((accdesc with<| AccessDescriptor_level := level|>)) in
   sail2_state_monad$returnS accdesc)))`;


(*val CreateAccessDescriptor : AccType -> M AccessDescriptor*)

val _ = Define `
 ((CreateAccessDescriptor:AccType ->(regstate)sail2_state_monad$sequential_state ->(((AccessDescriptor),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) acctype=  (sail2_state_monad$bindS
   (undefined_AccessDescriptor () ) (\ (accdesc : AccessDescriptor) . 
   let (accdesc : AccessDescriptor) = ((accdesc with<| AccessDescriptor_acctype := acctype|>)) in
   let (accdesc : AccessDescriptor) = ((accdesc with<| AccessDescriptor_page_table_walk := F|>)) in
   sail2_state_monad$returnS accdesc)))`;


(*val aarch64_system_register_cpsr : PSTATEField -> mword ty4 -> M unit*)

val _ = Define `
 ((aarch64_system_register_cpsr:PSTATEField ->(4)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) field' operand=
    ((case field' of
     PSTATEField_SP => sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) . 
      sail2_state_monad$write_regS
        PSTATE_ref
        (w__0 with<| ProcState_SP := ((vec_of_bits [access_vec_dec operand (( 0 : int):ii)]  :  1 words$word))|>))
   | PSTATEField_DAIFSet => sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__1 : ProcState) .  sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS
        PSTATE_ref
        (w__1 with<|
          ProcState_D :=
            ((or_vec w__2.ProcState_D (vec_of_bits [access_vec_dec operand (( 3 : int):ii)]  :  1 words$word)
               :  1 words$word))|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__3 : ProcState) .  sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__4 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS
        PSTATE_ref
        (w__3 with<|
          ProcState_A :=
            ((or_vec w__4.ProcState_A (vec_of_bits [access_vec_dec operand (( 2 : int):ii)]  :  1 words$word)
               :  1 words$word))|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__5 : ProcState) .  sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__6 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS
        PSTATE_ref
        (w__5 with<|
          ProcState_I :=
            ((or_vec w__6.ProcState_I (vec_of_bits [access_vec_dec operand (( 1 : int):ii)]  :  1 words$word)
               :  1 words$word))|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__7 : ProcState) .  sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__8 : ProcState) . 
      sail2_state_monad$write_regS
        PSTATE_ref
        (w__7 with<|
          ProcState_F :=
            ((or_vec w__8.ProcState_F (vec_of_bits [access_vec_dec operand (( 0 : int):ii)]  :  1 words$word)
               :  1 words$word))|>)))))))))
   | PSTATEField_DAIFClr => sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__9 : ProcState) .  sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__10 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS
        PSTATE_ref
        (w__9 with<|
          ProcState_D :=
            ((and_vec w__10.ProcState_D
                ((not_vec (vec_of_bits [access_vec_dec operand (( 3 : int):ii)]  :  1 words$word)  :  1 words$word))
               :  1 words$word))|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__11 : ProcState) .  sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__12 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS
        PSTATE_ref
        (w__11 with<|
          ProcState_A :=
            ((and_vec w__12.ProcState_A
                ((not_vec (vec_of_bits [access_vec_dec operand (( 2 : int):ii)]  :  1 words$word)  :  1 words$word))
               :  1 words$word))|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__13 : ProcState) .  sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__14 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS
        PSTATE_ref
        (w__13 with<|
          ProcState_I :=
            ((and_vec w__14.ProcState_I
                ((not_vec (vec_of_bits [access_vec_dec operand (( 1 : int):ii)]  :  1 words$word)  :  1 words$word))
               :  1 words$word))|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__15 : ProcState) .  sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__16 : ProcState) . 
      sail2_state_monad$write_regS
        PSTATE_ref
        (w__15 with<|
          ProcState_F :=
            ((and_vec w__16.ProcState_F
                ((not_vec (vec_of_bits [access_vec_dec operand (( 0 : int):ii)]  :  1 words$word)  :  1 words$word))
               :  1 words$word))|>)))))))))
   | PSTATEField_PAN => sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__17 : ProcState) . 
      sail2_state_monad$write_regS
        PSTATE_ref
        (w__17 with<| ProcState_PAN := ((vec_of_bits [access_vec_dec operand (( 0 : int):ii)]  :  1 words$word))|>))
   | PSTATEField_UAO => sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__18 : ProcState) . 
      sail2_state_monad$write_regS
        PSTATE_ref
        (w__18 with<| ProcState_UAO := ((vec_of_bits [access_vec_dec operand (( 0 : int):ii)]  :  1 words$word))|>))
   )))`;


(*val AArch64_SysRegWrite : ii -> ii -> ii -> ii -> ii -> mword ty64 -> M unit*)

val _ = Define `
 ((AArch64_SysRegWrite:int -> int -> int -> int -> int ->(64)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) op0 op1 crn crm op2 val_name=  (sail2_state_monad$assert_expS F "FALSE"))`;


(*val AArch64_SysRegRead : ii -> ii -> ii -> ii -> ii -> M (mword ty64)*)

val _ = Define `
 ((AArch64_SysRegRead:int -> int -> int -> int -> int ->(regstate)sail2_state_monad$sequential_state ->((((64)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) arg0 arg1 arg2 arg3 arg4=
    (let g__301 = (arg0, arg1, arg2, arg3, arg4) in sail2_state_monad$seqS
   (sail2_state_monad$assert_expS F "Tried to read system register")
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)))`;


(*val AArch64_SysInstr : ii -> ii -> ii -> ii -> ii -> mword ty64 -> M unit*)

val _ = Define `
 ((AArch64_SysInstr:int -> int -> int -> int -> int ->(64)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) op0 op1 crn crm op2 val_name=  (sail2_state_monad$assert_expS F "FALSE"))`;


(*val AArch64_ResetControlRegisters : bool -> unit*)

val _ = Define `
 ((AArch64_ResetControlRegisters:bool -> unit) cold_reset=  () )`;


(*val AArch64_ReportDeferredSError : mword ty25 -> M (mword ty64)*)

val _ = Define `
 ((AArch64_ReportDeferredSError:(25)words$word ->(regstate)sail2_state_monad$sequential_state ->((((64)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) syndrome=  (sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (target : 64 bits) . 
   let (target : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 1 : int):ii) target (( 31 : int):ii) (vec_of_bits [B1]  :  1 words$word)  :  64 words$word)) in
   let (target : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 1 : int):ii) target (( 24 : int):ii)
        (vec_of_bits [access_vec_dec syndrome (( 24 : int):ii)]  :  1 words$word)
       :  64 words$word)) in
   let (target : 64 bits) =
     ((set_slice (( 64 : int):ii) (( 24 : int):ii) target (( 0 : int):ii) ((slice syndrome (( 0 : int):ii) (( 24 : int):ii)  :  24 words$word))
       :  64 words$word)) in
   sail2_state_monad$returnS target)))`;


(*val AArch64_MarkExclusiveVA : mword ty64 -> ii -> ii -> M unit*)

val _ = Define `
 ((AArch64_MarkExclusiveVA:(64)words$word -> int -> int ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) address processorid size1=  (sail2_state_monad$assert_expS F "FALSE"))`;


(*val AArch64_IsExclusiveVA : mword ty64 -> ii -> ii -> M bool*)

val _ = Define `
 ((AArch64_IsExclusiveVA:(64)words$word -> int -> int ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) address processorid size1=  (sail2_state_monad$seqS (sail2_state_monad$assert_expS F "FALSE") (sail2_state_monad$returnS F)))`;


(*val AArch64_CreateFaultRecord : Fault -> mword ty52 -> ii -> AccType -> bool -> mword ty1 -> mword ty2 -> bool -> bool -> M FaultRecord*)

val _ = Define `
 ((AArch64_CreateFaultRecord:Fault ->(52)words$word -> int -> AccType -> bool ->(1)words$word ->(2)words$word -> bool -> bool ->(regstate)sail2_state_monad$sequential_state ->(((FaultRecord),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) typ ipaddress level acctype write extflag errortype secondstage s2fs1walk=  (sail2_state_monad$bindS
   (undefined_FaultRecord () ) (\ (fault : FaultRecord) . 
   let fault = ((fault with<| FaultRecord_typ := typ|>)) in sail2_state_monad$bindS
   (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (w__0 : 4 bits) . 
   let fault = ((fault with<| FaultRecord_domain := w__0|>)) in sail2_state_monad$bindS
   (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (w__1 : 4 bits) . 
   let (fault : FaultRecord) = ((fault with<| FaultRecord_debugmoe := w__1|>)) in
   let (fault : FaultRecord) = ((fault with<| FaultRecord_errortype := errortype|>)) in
   let (fault : FaultRecord) = ((fault with<| FaultRecord_ipaddress := ipaddress|>)) in
   let (fault : FaultRecord) = ((fault with<| FaultRecord_level := level|>)) in
   let (fault : FaultRecord) = ((fault with<| FaultRecord_acctype := acctype|>)) in
   let (fault : FaultRecord) = ((fault with<| FaultRecord_write := write|>)) in
   let (fault : FaultRecord) = ((fault with<| FaultRecord_extflag := extflag|>)) in
   let (fault : FaultRecord) = ((fault with<| FaultRecord_secondstage := secondstage|>)) in
   let (fault : FaultRecord) = ((fault with<| FaultRecord_s2fs1walk := s2fs1walk|>)) in
   sail2_state_monad$returnS fault)))))`;


(*val AArch64_TranslationFault : mword ty52 -> ii -> AccType -> bool -> bool -> bool -> M FaultRecord*)

val _ = Define `
 ((AArch64_TranslationFault:(52)words$word -> int -> AccType -> bool -> bool -> bool ->(regstate)sail2_state_monad$sequential_state ->(((FaultRecord),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) ipaddress level acctype iswrite secondstage s2fs1walk=  (sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (extflag : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 2 : int):ii)  : ( 2 words$word) M) (\ (errortype : 2 bits) . 
   AArch64_CreateFaultRecord Fault_Translation ipaddress level acctype iswrite extflag errortype
     secondstage s2fs1walk))))`;


(*val AArch64_PermissionFault : mword ty52 -> ii -> AccType -> bool -> bool -> bool -> M FaultRecord*)

val _ = Define `
 ((AArch64_PermissionFault:(52)words$word -> int -> AccType -> bool -> bool -> bool ->(regstate)sail2_state_monad$sequential_state ->(((FaultRecord),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) ipaddress level acctype iswrite secondstage s2fs1walk=  (sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (extflag : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 2 : int):ii)  : ( 2 words$word) M) (\ (errortype : 2 bits) . 
   AArch64_CreateFaultRecord Fault_Permission ipaddress level acctype iswrite extflag errortype
     secondstage s2fs1walk))))`;


(*val AArch64_NoFault : unit -> M FaultRecord*)

val _ = Define `
 ((AArch64_NoFault:unit ->(regstate)sail2_state_monad$sequential_state ->(((FaultRecord),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (undefined_bitvector (( 52 : int):ii)  : ( 52 words$word) M) (\ (ipaddress : 52 bits) .  sail2_state_monad$bindS
   (undefined_int () ) (\ (level : ii) . 
   let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (iswrite : bool) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (extflag : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 2 : int):ii)  : ( 2 words$word) M) (\ (errortype : 2 bits) . 
   let (secondstage : bool) = F in
   let (s2fs1walk : bool) = F in
   AArch64_CreateFaultRecord Fault_None ipaddress level acctype iswrite extflag errortype
     secondstage s2fs1walk)))))))`;


(*val AArch64_DebugFault : AccType -> bool -> M FaultRecord*)

val _ = Define `
 ((AArch64_DebugFault:AccType -> bool ->(regstate)sail2_state_monad$sequential_state ->(((FaultRecord),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) acctype iswrite=  (sail2_state_monad$bindS
   (undefined_bitvector (( 52 : int):ii)  : ( 52 words$word) M) (\ (ipaddress : 52 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 2 : int):ii)  : ( 2 words$word) M) (\ (errortype : 2 bits) .  sail2_state_monad$bindS
   (undefined_int () ) (\ (level : ii) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (extflag : 1 bits) . 
   let (secondstage : bool) = F in
   let (s2fs1walk : bool) = F in
   AArch64_CreateFaultRecord Fault_Debug ipaddress level acctype iswrite extflag errortype
     secondstage s2fs1walk))))))`;


(*val AArch64_CheckUnallocatedSystemAccess : mword ty2 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty3 -> mword ty1 -> M bool*)

val _ = Define `
 ((AArch64_CheckUnallocatedSystemAccess:(2)words$word ->(3)words$word ->(4)words$word ->(4)words$word ->(3)words$word ->(1)words$word ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) op0 op1 crn crm op2 read=  (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS F "FALSE") (sail2_state_monad$returnS F)))`;


(*val AArch64_CheckSystemRegisterTraps : mword ty2 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty3 -> mword ty1 -> M (bool * mword ty2)*)

val _ = Define `
 ((AArch64_CheckSystemRegisterTraps:(2)words$word ->(3)words$word ->(4)words$word ->(4)words$word ->(3)words$word ->(1)words$word ->(regstate)sail2_state_monad$sequential_state ->(((bool#(2)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) op0 op1 crn crm op2 read=  (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS F "FALSE") (sail2_state_monad$returnS (F, (vec_of_bits [B0;B0]  :  2 words$word)))))`;


(*val AArch64_CheckAdvSIMDFPSystemRegisterTraps : mword ty2 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty3 -> mword ty1 -> M (bool * mword ty2)*)

val _ = Define `
 ((AArch64_CheckAdvSIMDFPSystemRegisterTraps:(2)words$word ->(3)words$word ->(4)words$word ->(4)words$word ->(3)words$word ->(1)words$word ->(regstate)sail2_state_monad$sequential_state ->(((bool#(2)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) op0 op1 crn crm op2 read=  (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS F "FALSE") (sail2_state_monad$returnS (F, (vec_of_bits [B0;B0]  :  2 words$word)))))`;


(*val AArch64_AlignmentFault : AccType -> bool -> bool -> M FaultRecord*)

val _ = Define `
 ((AArch64_AlignmentFault:AccType -> bool -> bool ->(regstate)sail2_state_monad$sequential_state ->(((FaultRecord),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) acctype iswrite secondstage=  (sail2_state_monad$bindS
   (undefined_bitvector (( 52 : int):ii)  : ( 52 words$word) M) (\ (ipaddress : 52 bits) .  sail2_state_monad$bindS
   (undefined_int () ) (\ (level : ii) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (extflag : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 2 : int):ii)  : ( 2 words$word) M) (\ (errortype : 2 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (s2fs1walk : bool) . 
   AArch64_CreateFaultRecord Fault_Alignment ipaddress level acctype iswrite extflag errortype
     secondstage s2fs1walk)))))))`;


(*val AArch64_AddressSizeFault : mword ty52 -> ii -> AccType -> bool -> bool -> bool -> M FaultRecord*)

val _ = Define `
 ((AArch64_AddressSizeFault:(52)words$word -> int -> AccType -> bool -> bool -> bool ->(regstate)sail2_state_monad$sequential_state ->(((FaultRecord),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) ipaddress level acctype iswrite secondstage s2fs1walk=  (sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (extflag : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 2 : int):ii)  : ( 2 words$word) M) (\ (errortype : 2 bits) . 
   AArch64_CreateFaultRecord Fault_AddressSize ipaddress level acctype iswrite extflag errortype
     secondstage s2fs1walk))))`;


(*val AArch64_AccessFlagFault : mword ty52 -> ii -> AccType -> bool -> bool -> bool -> M FaultRecord*)

val _ = Define `
 ((AArch64_AccessFlagFault:(52)words$word -> int -> AccType -> bool -> bool -> bool ->(regstate)sail2_state_monad$sequential_state ->(((FaultRecord),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) ipaddress level acctype iswrite secondstage s2fs1walk=  (sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (extflag : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 2 : int):ii)  : ( 2 words$word) M) (\ (errortype : 2 bits) . 
   AArch64_CreateFaultRecord Fault_AccessFlag ipaddress level acctype iswrite extflag errortype
     secondstage s2fs1walk))))`;


(*val AArch32_CurrentCond : unit -> M (mword ty4)*)

val _ = Define `
 ((AArch32_CurrentCond:unit ->(regstate)sail2_state_monad$sequential_state ->((((4)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  ((sail2_state_monad$read_regS currentCond_ref  : ( 4 words$word) M)))`;


(*val aget_SP : forall 'width . Size 'width => integer -> unit -> M (mword 'width)*)

val _ = Define `
 ((aget_SP:int -> unit ->(regstate)sail2_state_monad$sequential_state ->((('width words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) (width__tv : int) () =  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((((width__tv = (( 8 : int):ii)))) \/ ((((((width__tv = (( 16 : int):ii)))) \/ ((((((width__tv = (( 32 : int):ii)))) \/ (((width__tv = (( 64 : int):ii))))))))))))) "((width == 8) || ((width == 16) || ((width == 32) || (width == 64))))")
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__0 : ProcState) . 
   if (((w__0.ProcState_SP = (vec_of_bits [B0]  :  1 words$word)))) then sail2_state_monad$bindS
     (sail2_state_monad$read_regS SP_EL0_ref  : ( 64 words$word) M) (\ (w__1 : 64 bits) . 
     sail2_state_monad$returnS ((slice w__1 (( 0 : int):ii) width__tv  :  'width words$word)))
   else sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) . 
     let p__300 = (w__2.ProcState_EL) in
     let pat_0 = p__300 in
     if (((pat_0 = EL0))) then sail2_state_monad$bindS
       (sail2_state_monad$read_regS SP_EL0_ref  : ( 64 words$word) M) (\ (w__3 : 64 bits) . 
       sail2_state_monad$returnS ((slice w__3 (( 0 : int):ii) width__tv  :  'width words$word)))
     else if (((pat_0 = EL1))) then sail2_state_monad$bindS
       (sail2_state_monad$read_regS SP_EL1_ref  : ( 64 words$word) M) (\ (w__4 : 64 bits) . 
       sail2_state_monad$returnS ((slice w__4 (( 0 : int):ii) width__tv  :  'width words$word)))
     else if (((pat_0 = EL2))) then sail2_state_monad$bindS
       (sail2_state_monad$read_regS SP_EL2_ref  : ( 64 words$word) M) (\ (w__5 : 64 bits) . 
       sail2_state_monad$returnS ((slice w__5 (( 0 : int):ii) width__tv  :  'width words$word)))
     else sail2_state_monad$bindS
       (sail2_state_monad$read_regS SP_EL3_ref  : ( 64 words$word) M) (\ (w__6 : 64 bits) . 
       sail2_state_monad$returnS ((slice w__6 (( 0 : int):ii) width__tv  :  'width words$word)))))))`;


(*val __IMPDEF_integer : string -> ii*)

val _ = Define `
 ((IMPDEF_integer:string -> int) x=
    (if (((x = "Maximum Physical Address Size"))) then (( 52 : int):ii)
   else if (((x = "Maximum Virtual Address Size"))) then (( 56 : int):ii)
   else (( 0 : int):ii)))`;


(*val VAMax : unit -> ii*)

val _ = Define `
 ((VAMax:unit -> int) () =  (IMPDEF_integer "Maximum Virtual Address Size"))`;


(*val PAMax : unit -> ii*)

val _ = Define `
 ((PAMax:unit -> int) () =  (IMPDEF_integer "Maximum Physical Address Size"))`;


(*val __IMPDEF_boolean : string -> bool*)

val _ = Define `
 ((IMPDEF_boolean:string -> bool) x=
    (if (((x = "Condition valid for trapped T32"))) then T
   else if (((x = "Has Dot Product extension"))) then T
   else if (((x = "Has RAS extension"))) then T
   else if (((x = "Has SHA512 and SHA3 Crypto instructions"))) then T
   else if (((x = "Has SM3 and SM4 Crypto instructions"))) then T
   else if (((x = "Has basic Crypto instructions"))) then T
   else if (((x = "Have CRC extension"))) then T
   else if (((x = "Report I-cache maintenance fault in IFSR"))) then T
   else if (((x = "Reserved Control Space EL0 Trapped"))) then T
   else if (((x = "Translation fault on misprogrammed contiguous bit"))) then T
   else if (((x = "UNDEF unallocated CP15 access at NS EL0"))) then T
   else if (((x = "UNDEF unallocated CP15 access at NS EL0"))) then T
   else F))`;


(*val WaitForEvent : unit -> M unit*)

val _ = Define `
 ((WaitForEvent:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (sail2_state_monad$read_regS EventRegister_ref  : ( 1 words$word) M) (\ (w__0 : 1 bits) . 
   if (((w__0 = (vec_of_bits [B0]  :  1 words$word)))) then EnterLowPowerState () 
   else sail2_state_monad$returnS () )))`;


(*val ThisInstrLength : unit -> M ii*)

val _ = Define `
 ((ThisInstrLength:unit ->(regstate)sail2_state_monad$sequential_state ->(((int),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (sail2_state_monad$read_regS ThisInstrEnc_ref) (\ (w__0 : InstrEnc) . 
   sail2_state_monad$returnS (if (((w__0 = T16))) then (( 16 : int):ii)
           else (( 32 : int):ii)))))`;


(*val RoundTowardsZero : real -> ii*)

val _ = Define `
 ((RoundTowardsZero:real -> int) x=
    (if (((x = (realFromFrac(( 0 : int))(( 10 : int)))))) then (( 0 : int):ii)
   else if ((x >= (realFromFrac(( 0 : int))(( 10 : int))))) then flr x
   else clg x))`;


(*val Restarting : unit -> M bool*)

val _ = Define `
 ((Restarting:unit ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (sail2_state_monad$read_regS EDSCR_ref  : ( 32 words$word) M) (\ (w__0 : 32 bits) . 
   sail2_state_monad$returnS (((((slice w__0 (( 0 : int):ii) (( 6 : int):ii)  :  6 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B1]  :  6 words$word)))))))`;


(*val PtrHasUpperAndLowerAddRanges : unit -> M bool*)

val _ = Define `
 ((PtrHasUpperAndLowerAddRanges:unit ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$or_boolS
     (sail2_state$or_boolS
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) .  sail2_state_monad$returnS (((w__0.ProcState_EL = EL1)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__1 : ProcState) .  sail2_state_monad$returnS (((w__1.ProcState_EL = EL0))))))
     (sail2_state$and_boolS
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__3 : ProcState) .  sail2_state_monad$returnS (((w__3.ProcState_EL = EL2)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__4 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__4 (( 34 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))))`;


(*val MemAttrDefaults : MemoryAttributes -> M MemoryAttributes*)

val _ = Define `
 ((MemAttrDefaults:MemoryAttributes ->(regstate)sail2_state_monad$sequential_state ->(((MemoryAttributes),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) memattrs__arg=
    (let memattrs = memattrs__arg in
   if (((memattrs.MemoryAttributes_typ = MemType_Device))) then sail2_state_monad$bindS
     (undefined_MemAttrHints () ) (\ (w__0 : MemAttrHints) . 
     let memattrs = ((memattrs with<| MemoryAttributes_inner := w__0|>)) in sail2_state_monad$bindS
     (undefined_MemAttrHints () ) (\ (w__1 : MemAttrHints) . 
     let (memattrs : MemoryAttributes) = ((memattrs with<| MemoryAttributes_outer := w__1|>)) in
     let (memattrs : MemoryAttributes) = ((memattrs with<| MemoryAttributes_shareable := T|>)) in
     let (memattrs : MemoryAttributes) = ((memattrs with<| MemoryAttributes_outershareable := T|>)) in
     sail2_state_monad$returnS memattrs))
   else sail2_state_monad$bindS
     (undefined_DeviceType () ) (\ (w__2 : DeviceType) . 
     let (memattrs : MemoryAttributes) = ((memattrs with<| MemoryAttributes_device := w__2|>)) in
     let (memattrs : MemoryAttributes) =
       (if ((((((memattrs.MemoryAttributes_inner.MemAttrHints_attrs = MemAttr_NC))) /\ (((memattrs.MemoryAttributes_outer.MemAttrHints_attrs = MemAttr_NC)))))) then
         let (memattrs : MemoryAttributes) = ((memattrs with<| MemoryAttributes_shareable := T|>)) in
         (memattrs with<| MemoryAttributes_outershareable := T|>)
       else memattrs) in
     sail2_state_monad$returnS memattrs)))`;


(*val IsEventRegisterSet : unit -> M bool*)

val _ = Define `
 ((IsEventRegisterSet:unit ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (sail2_state_monad$read_regS EventRegister_ref  : ( 1 words$word) M) (\ (w__0 : 1 bits) . 
   sail2_state_monad$returnS (((w__0 = (vec_of_bits [B1]  :  1 words$word)))))))`;


(*val HaveEL : mword ty2 -> bool*)

val _ = Define `
 ((HaveEL:(2)words$word -> bool) el=  (if ((((((el = EL1))) \/ (((el = EL0)))))) then T else T))`;


(*val HighestEL : unit -> mword ty2*)

val _ = Define `
 ((HighestEL:unit ->(2)words$word) () =  (if ((HaveEL EL3)) then EL3 else if ((HaveEL EL2)) then EL2 else EL1))`;


(*val Have16bitVMID : unit -> bool*)

val _ = Define `
 ((Have16bitVMID:unit -> bool) () =  (HaveEL EL2))`;


(*val HasArchVersion : ArchVersion -> bool*)

val _ = Define `
 ((HasArchVersion:ArchVersion -> bool) version=
    ((((version = ARMv8p0))) \/ ((((((version = ARMv8p1))) \/ ((((((version = ARMv8p2))) \/ (((version = ARMv8p3)))))))))))`;


(*val HaveVirtHostExt : unit -> bool*)

val _ = Define `
 ((HaveVirtHostExt:unit -> bool) () =  (HasArchVersion ARMv8p1))`;


(*val HaveUAOExt : unit -> bool*)

val _ = Define `
 ((HaveUAOExt:unit -> bool) () =  (HasArchVersion ARMv8p2))`;


(*val HaveTrapLoadStoreMultipleDeviceExt : unit -> bool*)

val _ = Define `
 ((HaveTrapLoadStoreMultipleDeviceExt:unit -> bool) () =  (HasArchVersion ARMv8p2))`;


(*val HaveStatisticalProfiling : unit -> bool*)

val _ = Define `
 ((HaveStatisticalProfiling:unit -> bool) () =  (HasArchVersion ARMv8p2))`;


(*val HaveRASExt : unit -> bool*)

val _ = Define `
 ((HaveRASExt:unit -> bool) () =  (((HasArchVersion ARMv8p2)) \/ ((IMPDEF_boolean "Has RAS extension"))))`;


(*val HavePrivATExt : unit -> bool*)

val _ = Define `
 ((HavePrivATExt:unit -> bool) () =  (HasArchVersion ARMv8p2))`;


(*val HavePANExt : unit -> bool*)

val _ = Define `
 ((HavePANExt:unit -> bool) () =  (HasArchVersion ARMv8p1))`;


(*val HavePACExt : unit -> bool*)

val _ = Define `
 ((HavePACExt:unit -> bool) () =  (HasArchVersion ARMv8p3))`;


(*val HaveNVExt : unit -> bool*)

val _ = Define `
 ((HaveNVExt:unit -> bool) () =  (HasArchVersion ARMv8p3))`;


(*val HaveFJCVTZSExt : unit -> bool*)

val _ = Define `
 ((HaveFJCVTZSExt:unit -> bool) () =  (HasArchVersion ARMv8p3))`;


(*val HaveExtendedExecuteNeverExt : unit -> bool*)

val _ = Define `
 ((HaveExtendedExecuteNeverExt:unit -> bool) () =  (HasArchVersion ARMv8p2))`;


(*val HaveDirtyBitModifierExt : unit -> bool*)

val _ = Define `
 ((HaveDirtyBitModifierExt:unit -> bool) () =  (HasArchVersion ARMv8p1))`;


(*val HaveCommonNotPrivateTransExt : unit -> bool*)

val _ = Define `
 ((HaveCommonNotPrivateTransExt:unit -> bool) () =  (HasArchVersion ARMv8p2))`;


(*val HaveCRCExt : unit -> bool*)

val _ = Define `
 ((HaveCRCExt:unit -> bool) () =  (((HasArchVersion ARMv8p1)) \/ ((IMPDEF_boolean "Have CRC extension"))))`;


(*val HaveAtomicExt : unit -> bool*)

val _ = Define `
 ((HaveAtomicExt:unit -> bool) () =  (HasArchVersion ARMv8p1))`;


(*val HaveAccessFlagUpdateExt : unit -> bool*)

val _ = Define `
 ((HaveAccessFlagUpdateExt:unit -> bool) () =  (HasArchVersion ARMv8p1))`;


(*val Have52BitVAExt : unit -> bool*)

val _ = Define `
 ((Have52BitVAExt:unit -> bool) () =  (HasArchVersion ARMv8p2))`;


(*val Have52BitPAExt : unit -> bool*)

val _ = Define `
 ((Have52BitPAExt:unit -> bool) () =  (HasArchVersion ARMv8p2))`;


(*val AArch64_HaveHPDExt : unit -> bool*)

val _ = Define `
 ((AArch64_HaveHPDExt:unit -> bool) () =  (HasArchVersion ARMv8p1))`;


(*val ExternalInvasiveDebugEnabled : unit -> M bool*)

val _ = Define `
 ((ExternalInvasiveDebugEnabled:unit ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (sail2_state_monad$read_regS DBGEN_ref) (\ (w__0 : signal) .  sail2_state_monad$returnS (((w__0 = HIGH))))))`;


(*val ConstrainUnpredictableInteger : ii -> ii -> Unpredictable -> M (Constraint * ii)*)

val _ = Define `
 ((ConstrainUnpredictableInteger:int -> int -> Unpredictable ->(regstate)sail2_state_monad$sequential_state ->(((Constraint#int),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) low high which=
    (let (c : Constraint) = (ConstrainUnpredictable which) in
   if (((c = Constraint_UNKNOWN))) then sail2_state_monad$returnS (c, low)
   else sail2_state_monad$bindS (undefined_int () ) (\ (w__0 : ii) .  sail2_state_monad$returnS (c, w__0))))`;


(*val ConstrainUnpredictableBool : Unpredictable -> M bool*)

val _ = Define `
 ((ConstrainUnpredictableBool:Unpredictable ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) which=
    (let (c : Constraint) = (ConstrainUnpredictable which) in sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((((c = Constraint_TRUE))) \/ (((c = Constraint_FALSE)))))) "((c == Constraint_TRUE) || (c == Constraint_FALSE))")
   (sail2_state_monad$returnS (((c = Constraint_TRUE))))))`;


(*val CombineS1S2Device : DeviceType -> DeviceType -> M DeviceType*)

val _ = Define `
 ((CombineS1S2Device:DeviceType -> DeviceType ->(regstate)sail2_state_monad$sequential_state ->(((DeviceType),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) s1device s2device=  (sail2_state_monad$bindS
   (undefined_DeviceType () ) (\ (result : DeviceType) . 
   let (result : DeviceType) =
     (if ((((((s2device = DeviceType_nGnRnE))) \/ (((s1device = DeviceType_nGnRnE)))))) then
       DeviceType_nGnRnE
     else if ((((((s2device = DeviceType_nGnRE))) \/ (((s1device = DeviceType_nGnRE)))))) then
       DeviceType_nGnRE
     else if ((((((s2device = DeviceType_nGRE))) \/ (((s1device = DeviceType_nGRE)))))) then
       DeviceType_nGRE
     else DeviceType_GRE) in
   sail2_state_monad$returnS result)))`;


(*val CombineS1S2AttrHints : MemAttrHints -> MemAttrHints -> M MemAttrHints*)

val _ = Define `
 ((CombineS1S2AttrHints:MemAttrHints -> MemAttrHints ->(regstate)sail2_state_monad$sequential_state ->(((MemAttrHints),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) s1desc s2desc=  (sail2_state_monad$bindS
   (undefined_MemAttrHints () ) (\ (result : MemAttrHints) .  sail2_state_monad$bindS
   (if ((((((s2desc.MemAttrHints_attrs = (vec_of_bits [B0;B1]  :  2 words$word)))) \/ (((s1desc.MemAttrHints_attrs = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$bindS
      (undefined_bitvector (( 2 : int):ii)  : ( 2 words$word) M) (\ (w__0 : 2 bits) . 
      let (result : MemAttrHints) = ((result with<| MemAttrHints_attrs := w__0|>)) in
      sail2_state_monad$returnS result)
    else
      let (result : MemAttrHints) =
        (if ((((((s2desc.MemAttrHints_attrs = MemAttr_NC))) \/ (((s1desc.MemAttrHints_attrs = MemAttr_NC)))))) then
          (result with<| MemAttrHints_attrs := MemAttr_NC|>)
        else if ((((((s2desc.MemAttrHints_attrs = MemAttr_WT))) \/ (((s1desc.MemAttrHints_attrs = MemAttr_WT)))))) then
          (result with<| MemAttrHints_attrs := MemAttr_WT|>)
        else (result with<| MemAttrHints_attrs := MemAttr_WB|>)) in
      sail2_state_monad$returnS result) (\ (result : MemAttrHints) . 
   let (result : MemAttrHints) = ((result with<| MemAttrHints_hints := (s1desc.MemAttrHints_hints)|>)) in
   let (result : MemAttrHints) =
     ((result with<| MemAttrHints_transient := (s1desc.MemAttrHints_transient)|>)) in
   sail2_state_monad$returnS result))))`;


(*val AArch64_InstructionDevice : AddressDescriptor -> mword ty64 -> mword ty52 -> ii -> AccType -> bool -> bool -> bool -> M AddressDescriptor*)

val _ = Define `
 ((AArch64_InstructionDevice:AddressDescriptor ->(64)words$word ->(52)words$word -> int -> AccType -> bool -> bool -> bool ->(regstate)sail2_state_monad$sequential_state ->(((AddressDescriptor),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) addrdesc__arg vaddress ipaddress level acctype iswrite secondstage s2fs1walk=
    (let addrdesc = addrdesc__arg in
   let (c : Constraint) = (ConstrainUnpredictable Unpredictable_INSTRDEVICE) in sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((((c = Constraint_NONE))) \/ (((c = Constraint_FAULT)))))) "((c == Constraint_NONE) || (c == Constraint_FAULT))")
   (if (((c = Constraint_FAULT))) then sail2_state_monad$bindS
     (AArch64_PermissionFault ipaddress level acctype iswrite secondstage s2fs1walk) (\ (w__0 :
       FaultRecord) . 
     let (addrdesc : AddressDescriptor) = ((addrdesc with<| AddressDescriptor_fault := w__0|>)) in
     sail2_state_monad$returnS addrdesc)
   else
     let (tmp_120 : MemoryAttributes) = (addrdesc.AddressDescriptor_memattrs) in
     let tmp_120 = ((tmp_120 with<| MemoryAttributes_typ := MemType_Normal|>)) in
     let addrdesc = ((addrdesc with<| AddressDescriptor_memattrs := tmp_120|>)) in
     let (tmp_130 : MemAttrHints) = (addrdesc.AddressDescriptor_memattrs.MemoryAttributes_inner) in
     let tmp_130 = ((tmp_130 with<| MemAttrHints_attrs := MemAttr_NC|>)) in
     let (tmp_140 : MemoryAttributes) = (addrdesc.AddressDescriptor_memattrs) in
     let tmp_140 = ((tmp_140 with<| MemoryAttributes_inner := tmp_130|>)) in
     let addrdesc = ((addrdesc with<| AddressDescriptor_memattrs := tmp_140|>)) in
     let (tmp_150 : MemAttrHints) = (addrdesc.AddressDescriptor_memattrs.MemoryAttributes_inner) in
     let tmp_150 = ((tmp_150 with<| MemAttrHints_hints := MemHint_No|>)) in
     let (tmp_160 : MemoryAttributes) = (addrdesc.AddressDescriptor_memattrs) in
     let tmp_160 = ((tmp_160 with<| MemoryAttributes_inner := tmp_150|>)) in
     let addrdesc = ((addrdesc with<| AddressDescriptor_memattrs := tmp_160|>)) in
     let (tmp_170 : MemoryAttributes) = (addrdesc.AddressDescriptor_memattrs) in
     let tmp_170 =
       ((tmp_170 with<|
         MemoryAttributes_outer := (addrdesc.AddressDescriptor_memattrs.MemoryAttributes_inner)|>)) in
     let addrdesc = ((addrdesc with<| AddressDescriptor_memattrs := tmp_170|>)) in sail2_state_monad$bindS
     (MemAttrDefaults addrdesc.AddressDescriptor_memattrs) (\ (w__1 : MemoryAttributes) . 
     let (addrdesc : AddressDescriptor) = ((addrdesc with<| AddressDescriptor_memattrs := w__1|>)) in
     sail2_state_monad$returnS addrdesc))))`;


(*val aget_Vpart : forall 'width . Size 'width => integer -> ii -> ii -> M (mword 'width)*)

val _ = Define `
 ((aget_Vpart:int -> int -> int ->(regstate)sail2_state_monad$sequential_state ->((('width words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) (width__tv : int) n part=  (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS (((((n >= (( 0 : int):ii))) /\ ((n <= (( 31 : int):ii)))))) "((n >= 0) && (n <= 31))")
   (sail2_state_monad$assert_expS ((((((part = (( 0 : int):ii)))) \/ (((part = (( 1 : int):ii))))))) "((part == 0) || (part == 1))"))
   (if (((part = (( 0 : int):ii)))) then sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS ((((((width__tv = (( 8 : int):ii)))) \/ ((((((width__tv = (( 16 : int):ii)))) \/ ((((((width__tv = (( 32 : int):ii)))) \/ (((width__tv = (( 64 : int):ii))))))))))))) "((width == 8) || ((width == 16) || ((width == 32) || (width == 64))))")
     (sail2_state_monad$read_regS V_ref)) (\ (w__0 : ( 128 bits) list) . 
     sail2_state_monad$returnS ((slice ((access_list_dec w__0 n  :  128 words$word)) (( 0 : int):ii) width__tv  :  'width words$word)))
   else sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS (((width__tv = (( 64 : int):ii)))) "(width == 64)")
     (sail2_state_monad$read_regS V_ref)) (\ (w__1 : ( 128 bits) list) . 
     sail2_state_monad$returnS ((words$w2w
                ((slice ((access_list_dec w__1 n  :  128 words$word)) (( 64 : int):ii) (( 64 : int):ii)  :  'width words$word))
               :  'width words$word))))))`;


(*val aget_V : forall 'width . Size 'width => integer -> ii -> M (mword 'width)*)

val _ = Define `
 ((aget_V:int -> int ->(regstate)sail2_state_monad$sequential_state ->((('width words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) (width__tv : int) n=  (sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS (((((n >= (( 0 : int):ii))) /\ ((n <= (( 31 : int):ii)))))) "((n >= 0) && (n <= 31))")
   (sail2_state_monad$assert_expS ((((((width__tv = (( 8 : int):ii)))) \/ ((((((width__tv = (( 16 : int):ii)))) \/ ((((((width__tv = (( 32 : int):ii)))) \/ ((((((width__tv = (( 64 : int):ii)))) \/ (((width__tv = (( 128 : int):ii)))))))))))))))) "((width == 8) || ((width == 16) || ((width == 32) || ((width == 64) || (width == 128)))))"))
   (sail2_state_monad$read_regS V_ref)) (\ (w__0 : ( 128 bits) list) . 
   sail2_state_monad$returnS ((slice ((access_list_dec w__0 n  :  128 words$word)) (( 0 : int):ii) width__tv  :  'width words$word)))))`;


(*val LookUpRIndex : ii -> mword ty5 -> M ii*)

val _ = Define `
 ((LookUpRIndex:int ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((int),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) n mode=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS (((((n >= (( 0 : int):ii))) /\ ((n <= (( 14 : int):ii)))))) "((n >= 0) && (n <= 14))")
   (undefined_int () )) (\ (result : ii) . 
   let p0_ = n in
   if (((p0_ = (( 8 : int):ii)))) then RBankSelect mode (( 8 : int):ii) (( 24 : int):ii) (( 8 : int):ii) (( 8 : int):ii) (( 8 : int):ii) (( 8 : int):ii) (( 8 : int):ii)
   else if (((p0_ = (( 9 : int):ii)))) then RBankSelect mode (( 9 : int):ii) (( 25 : int):ii) (( 9 : int):ii) (( 9 : int):ii) (( 9 : int):ii) (( 9 : int):ii) (( 9 : int):ii)
   else if (((p0_ = (( 10 : int):ii)))) then
     RBankSelect mode (( 10 : int):ii) (( 26 : int):ii) (( 10 : int):ii) (( 10 : int):ii) (( 10 : int):ii) (( 10 : int):ii) (( 10 : int):ii)
   else if (((p0_ = (( 11 : int):ii)))) then
     RBankSelect mode (( 11 : int):ii) (( 27 : int):ii) (( 11 : int):ii) (( 11 : int):ii) (( 11 : int):ii) (( 11 : int):ii) (( 11 : int):ii)
   else if (((p0_ = (( 12 : int):ii)))) then
     RBankSelect mode (( 12 : int):ii) (( 28 : int):ii) (( 12 : int):ii) (( 12 : int):ii) (( 12 : int):ii) (( 12 : int):ii) (( 12 : int):ii)
   else if (((p0_ = (( 13 : int):ii)))) then
     RBankSelect mode (( 13 : int):ii) (( 29 : int):ii) (( 17 : int):ii) (( 19 : int):ii) (( 21 : int):ii) (( 23 : int):ii) (( 15 : int):ii)
   else if (((p0_ = (( 14 : int):ii)))) then
     RBankSelect mode (( 14 : int):ii) (( 30 : int):ii) (( 16 : int):ii) (( 18 : int):ii) (( 20 : int):ii) (( 22 : int):ii) (( 14 : int):ii)
   else sail2_state_monad$returnS n)))`;


(*val HighestSetBit : forall 'N . Size 'N => mword 'N -> M ii*)

val _ = Define `
 ((HighestSetBit:'N words$word ->(regstate)sail2_state_monad$sequential_state ->(((int),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) x=
    (sail2_state_monad$catch_early_returnS
     ( sail2_state_monad$seqS(sail2_state$foreachS (index_list ((((int_of_num (words$word_len x))) - (( 1 : int):ii))) (( 0 : int):ii) (~ (( 1 : int):ii))) () 
        (\ i unit_var . 
          if ((((vec_of_bits [access_vec_dec x i]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
            (sail2_state_monad$early_returnS i : (unit, ii) MR)
          else sail2_state_monad$returnS () ))
      (sail2_state_monad$returnS ((~ (( 1 : int):ii)))))))`;


(*val CountLeadingZeroBits : forall 'N . Size 'N => mword 'N -> M ii*)

val _ = Define `
 ((CountLeadingZeroBits:'N words$word ->(regstate)sail2_state_monad$sequential_state ->(((int),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) x=  (sail2_state_monad$bindS
   (HighestSetBit x) (\ (w__0 : ii) . 
   sail2_state_monad$returnS ((((((int_of_num (words$word_len x))) - (( 1 : int):ii))) - ((ex_int w__0)))))))`;


(*val CountLeadingSignBits : forall 'N . Size 'N => mword 'N -> M ii*)

val _ = Define `
 ((CountLeadingSignBits:'N words$word ->(regstate)sail2_state_monad$sequential_state ->(((ii),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) x=
    (CountLeadingZeroBits
     ((xor_vec ((shiftr x (( 1 : int):ii)  :  'N words$word))
         ((and_vec x ((slice_mask ((int_of_num (words$word_len x))) (( 0 : int):ii) ((int_of_num (words$word_len x)))  :  'N words$word))  :  'N words$word))
        :  'N words$word))))`;


(*val BitReverse : forall 'N . Size 'N => mword 'N -> M (mword 'N)*)

val _ = Define `
 ((BitReverse:'N words$word ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) data=  (sail2_state_monad$bindS
   (undefined_bitvector ((int_of_num (words$word_len data)))  : ( 'N words$word) M) (\ (result : 'N bits) . 
   let (result : 'N bits) =
     (foreach (index_list (( 0 : int):ii) ((((int_of_num (words$word_len data))) - (( 1 : int):ii))) (( 1 : int):ii)) result
       (\ i result . 
         (set_slice ((int_of_num (words$word_len data))) (( 1 : int):ii) result
            ((((((int_of_num (words$word_len data))) - i)) - (( 1 : int):ii)))
            (vec_of_bits [access_vec_dec data i]  :  1 words$word)
           :  'N words$word))) in
   sail2_state_monad$returnS result)))`;


(*val NextInstrAddr : forall 'N . Size 'N => integer -> unit -> M (mword 'N)*)

val _ = Define `
 ((NextInstrAddr:int -> unit ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) (N__tv : int) () =  (sail2_state_monad$bindS
   (sail2_state_monad$read_regS PC_ref  : ( 64 words$word) M) (\ (w__0 : 64 bits) .  sail2_state_monad$bindS
   (ThisInstrLength () ) (\ (w__1 : ii) . 
   sail2_state_monad$returnS ((slice ((add_vec_int w__0 ((((ex_int w__1)) / (( 8 : int):ii)))  :  64 words$word)) (( 0 : int):ii)
              N__tv
             :  'N words$word))))))`;


(*val AArch32_ExceptionClass : Exception -> M (ii * mword ty1)*)

val _ = Define `
 ((AArch32_ExceptionClass:Exception ->(regstate)sail2_state_monad$sequential_state ->(((int#(1)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) typ=  (sail2_state_monad$bindS
   (ThisInstrLength () ) (\ (w__0 : ii) . 
   let (il : 1 bits) =
     (if (((((ex_int w__0)) = (( 32 : int):ii)))) then (vec_of_bits [B1]  :  1 words$word)
     else (vec_of_bits [B0]  :  1 words$word)) in sail2_state_monad$bindS
   (undefined_int () ) (\ (ec : ii) .  sail2_state_monad$bindS
   (case typ of
     Exception_Uncategorized =>
      let (ec : ii) = ((( 0 : int):ii)) in
      let (il : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_WFxTrap =>
      let (ec : ii) = ((( 1 : int):ii)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_CP15RTTrap =>
      let (ec : ii) = ((( 3 : int):ii)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_CP15RRTTrap =>
      let (ec : ii) = ((( 4 : int):ii)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_CP14RTTrap =>
      let (ec : ii) = ((( 5 : int):ii)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_CP14DTTrap =>
      let (ec : ii) = ((( 6 : int):ii)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_AdvSIMDFPAccessTrap =>
      let (ec : ii) = ((( 7 : int):ii)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_FPIDTrap =>
      let (ec : ii) = ((( 8 : int):ii)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_CP14RRTTrap =>
      let (ec : ii) = ((( 12 : int):ii)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_IllegalState =>
      let (ec : ii) = ((( 14 : int):ii)) in
      let (il : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_SupervisorCall =>
      let (ec : ii) = ((( 17 : int):ii)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_HypervisorCall =>
      let (ec : ii) = ((( 18 : int):ii)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_MonitorCall =>
      let (ec : ii) = ((( 19 : int):ii)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_InstructionAbort =>
      let (ec : ii) = ((( 32 : int):ii)) in
      let (il : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_PCAlignment =>
      let (ec : ii) = ((( 34 : int):ii)) in
      let (il : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_DataAbort =>
      let (ec : ii) = ((( 36 : int):ii)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_FPTrappedException =>
      let (ec : ii) = ((( 40 : int):ii)) in
      sail2_state_monad$returnS (ec, il)
   | _ => sail2_state_monad$seqS (Unreachable () ) (sail2_state_monad$returnS (ec, il))
   ) (\ varstup .  let ((ec : ii), (il : 1 bits)) = varstup in sail2_state_monad$bindS
   (sail2_state$and_boolS (sail2_state_monad$returnS ((((((((ex_int ec)) = (( 32 : int):ii)))) \/ (((((ex_int ec)) = (( 36 : int):ii))))))))
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__1 : ProcState) .  sail2_state_monad$returnS (((w__1.ProcState_EL = EL2)))))) (\ (w__2 :
     bool) . 
   let (ec : ii) = (if w__2 then ((ex_int ec)) + (( 1 : int):ii) else ec) in
   sail2_state_monad$returnS (ec, il)))))))`;


(*val RotCell : mword ty4 -> ii -> M (mword ty4)*)

val _ = Define `
 ((RotCell:(4)words$word -> int ->(regstate)sail2_state_monad$sequential_state ->((((4)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) incell_name amount=  (sail2_state_monad$bindS
   (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M) (\ (tmp : 8 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (outcell : 4 bits) . 
   let (tmp : 8 bits) =
     ((set_slice (( 8 : int):ii) (( 8 : int):ii) tmp (( 0 : int):ii)
        ((concat_vec ((slice incell_name (( 0 : int):ii) (( 4 : int):ii)  :  4 words$word))
            ((slice incell_name (( 0 : int):ii) (( 4 : int):ii)  :  4 words$word))
           :  8 words$word))
       :  8 words$word)) in
   let (outcell : 4 bits) = ((slice tmp (((( 4 : int):ii) - amount)) (( 4 : int):ii)  :  4 words$word)) in
   sail2_state_monad$returnS outcell))))`;


(*val FPNeg : forall 'N . Size 'N => mword 'N -> M (mword 'N)*)

val _ = Define `
 ((FPNeg:'N words$word ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) op=
    (let p0_ = (int_of_num (words$word_len op)) in
   if (((p0_ = (( 16 : int):ii)))) then
     let (op :  16 words$word) = ((words$w2w op  :  16 words$word)) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "((N == 16) || ((N == 32) || (N == 64)))")
     (sail2_state_monad$returnS ((words$w2w
                ((concat_vec
                    ((not_vec
                        (vec_of_bits [access_vec_dec op (((( 16 : int):ii) - (( 1 : int):ii)))]
                          :  1 words$word)
                       :  1 words$word))
                    ((slice op (( 0 : int):ii) (((( 16 : int):ii) - (( 1 : int):ii)))  :  15 words$word))
                   :  'N words$word))
               :  'N words$word)))
   else if (((p0_ = (( 32 : int):ii)))) then
     let (op :  32 words$word) = ((words$w2w op  :  32 words$word)) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "((N == 16) || ((N == 32) || (N == 64)))")
     (sail2_state_monad$returnS ((words$w2w
                ((concat_vec
                    ((not_vec
                        (vec_of_bits [access_vec_dec op (((( 32 : int):ii) - (( 1 : int):ii)))]
                          :  1 words$word)
                       :  1 words$word))
                    ((slice op (( 0 : int):ii) (((( 32 : int):ii) - (( 1 : int):ii)))  :  31 words$word))
                   :  'N words$word))
               :  'N words$word)))
   else if (((p0_ = (( 64 : int):ii)))) then
     let (op :  64 words$word) = ((words$w2w op  :  64 words$word)) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "((N == 16) || ((N == 32) || (N == 64)))")
     (sail2_state_monad$returnS ((words$w2w
                ((concat_vec
                    ((not_vec
                        (vec_of_bits [access_vec_dec op (((( 64 : int):ii) - (( 1 : int):ii)))]
                          :  1 words$word)
                       :  1 words$word))
                    ((slice op (( 0 : int):ii) (((( 64 : int):ii) - (( 1 : int):ii)))  :  63 words$word))
                   :  'N words$word))
               :  'N words$word)))
   else sail2_state_monad$seqS (sail2_state_monad$assert_expS F "((N == 16) || ((N == 32) || (N == 64)))") (sail2_state_monad$exitS () )))`;


(*val FPAbs : forall 'N . Size 'N => mword 'N -> M (mword 'N)*)

val _ = Define `
 ((FPAbs:'N words$word ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) op=
    (let p0_ = (int_of_num (words$word_len op)) in
   if (((p0_ = (( 16 : int):ii)))) then
     let (op :  16 words$word) = ((words$w2w op  :  16 words$word)) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "((N == 16) || ((N == 32) || (N == 64)))")
     (sail2_state_monad$returnS ((words$w2w
                ((concat_vec (vec_of_bits [B0]  :  1 words$word)
                    ((slice op (( 0 : int):ii) (((( 16 : int):ii) - (( 1 : int):ii)))  :  15 words$word))
                   :  'N words$word))
               :  'N words$word)))
   else if (((p0_ = (( 32 : int):ii)))) then
     let (op :  32 words$word) = ((words$w2w op  :  32 words$word)) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "((N == 16) || ((N == 32) || (N == 64)))")
     (sail2_state_monad$returnS ((words$w2w
                ((concat_vec (vec_of_bits [B0]  :  1 words$word)
                    ((slice op (( 0 : int):ii) (((( 32 : int):ii) - (( 1 : int):ii)))  :  31 words$word))
                   :  'N words$word))
               :  'N words$word)))
   else if (((p0_ = (( 64 : int):ii)))) then
     let (op :  64 words$word) = ((words$w2w op  :  64 words$word)) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "((N == 16) || ((N == 32) || (N == 64)))")
     (sail2_state_monad$returnS ((words$w2w
                ((concat_vec (vec_of_bits [B0]  :  1 words$word)
                    ((slice op (( 0 : int):ii) (((( 64 : int):ii) - (( 1 : int):ii)))  :  63 words$word))
                   :  'N words$word))
               :  'N words$word)))
   else sail2_state_monad$seqS (sail2_state_monad$assert_expS F "((N == 16) || ((N == 32) || (N == 64)))") (sail2_state_monad$exitS () )))`;


(*val EncodeLDFSC : Fault -> ii -> M (mword ty6)*)

val _ = Define `
 ((EncodeLDFSC:Fault -> int ->(regstate)sail2_state_monad$sequential_state ->((((6)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) typ level=  (sail2_state_monad$bindS
   (undefined_bitvector (( 6 : int):ii)  : ( 6 words$word) M) (\ (result : 6 bits) . 
   (case typ of
     Fault_AddressSize =>
      let result =
        ((concat_vec (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)
           ((GetSlice_int ((make_the_value (( 2 : int):ii)  :  2 itself)) level (( 0 : int):ii)  :  2 words$word))
          :  6 words$word)) in sail2_state_monad$seqS
      (sail2_state_monad$assert_expS ((((((level = (( 0 : int):ii)))) \/ ((((((level = (( 1 : int):ii)))) \/ ((((((level = (( 2 : int):ii)))) \/ (((level = (( 3 : int):ii))))))))))))) "((level == 0) || ((level == 1) || ((level == 2) || (level == 3))))")
      (sail2_state_monad$returnS result)
   | Fault_AccessFlag =>
      let result =
        ((concat_vec (vec_of_bits [B0;B0;B1;B0]  :  4 words$word)
           ((GetSlice_int ((make_the_value (( 2 : int):ii)  :  2 itself)) level (( 0 : int):ii)  :  2 words$word))
          :  6 words$word)) in sail2_state_monad$seqS
      (sail2_state_monad$assert_expS ((((((level = (( 1 : int):ii)))) \/ ((((((level = (( 2 : int):ii)))) \/ (((level = (( 3 : int):ii)))))))))) "((level == 1) || ((level == 2) || (level == 3)))")
      (sail2_state_monad$returnS result)
   | Fault_Permission =>
      let result =
        ((concat_vec (vec_of_bits [B0;B0;B1;B1]  :  4 words$word)
           ((GetSlice_int ((make_the_value (( 2 : int):ii)  :  2 itself)) level (( 0 : int):ii)  :  2 words$word))
          :  6 words$word)) in sail2_state_monad$seqS
      (sail2_state_monad$assert_expS ((((((level = (( 1 : int):ii)))) \/ ((((((level = (( 2 : int):ii)))) \/ (((level = (( 3 : int):ii)))))))))) "((level == 1) || ((level == 2) || (level == 3)))")
      (sail2_state_monad$returnS result)
   | Fault_Translation =>
      let result =
        ((concat_vec (vec_of_bits [B0;B0;B0;B1]  :  4 words$word)
           ((GetSlice_int ((make_the_value (( 2 : int):ii)  :  2 itself)) level (( 0 : int):ii)  :  2 words$word))
          :  6 words$word)) in sail2_state_monad$seqS
      (sail2_state_monad$assert_expS ((((((level = (( 0 : int):ii)))) \/ ((((((level = (( 1 : int):ii)))) \/ ((((((level = (( 2 : int):ii)))) \/ (((level = (( 3 : int):ii))))))))))))) "((level == 0) || ((level == 1) || ((level == 2) || (level == 3))))")
      (sail2_state_monad$returnS result)
   | Fault_SyncExternal =>
      let (result : 6 bits) = ((vec_of_bits [B0;B1;B0;B0;B0;B0]  :  6 words$word)) in
      sail2_state_monad$returnS result
   | Fault_SyncExternalOnWalk =>
      let result =
        ((concat_vec (vec_of_bits [B0;B1;B0;B1]  :  4 words$word)
           ((GetSlice_int ((make_the_value (( 2 : int):ii)  :  2 itself)) level (( 0 : int):ii)  :  2 words$word))
          :  6 words$word)) in sail2_state_monad$seqS
      (sail2_state_monad$assert_expS ((((((level = (( 0 : int):ii)))) \/ ((((((level = (( 1 : int):ii)))) \/ ((((((level = (( 2 : int):ii)))) \/ (((level = (( 3 : int):ii))))))))))))) "((level == 0) || ((level == 1) || ((level == 2) || (level == 3))))")
      (sail2_state_monad$returnS result)
   | Fault_SyncParity =>
      let (result : 6 bits) = ((vec_of_bits [B0;B1;B1;B0;B0;B0]  :  6 words$word)) in
      sail2_state_monad$returnS result
   | Fault_SyncParityOnWalk =>
      let result =
        ((concat_vec (vec_of_bits [B0;B1;B1;B1]  :  4 words$word)
           ((GetSlice_int ((make_the_value (( 2 : int):ii)  :  2 itself)) level (( 0 : int):ii)  :  2 words$word))
          :  6 words$word)) in sail2_state_monad$seqS
      (sail2_state_monad$assert_expS ((((((level = (( 0 : int):ii)))) \/ ((((((level = (( 1 : int):ii)))) \/ ((((((level = (( 2 : int):ii)))) \/ (((level = (( 3 : int):ii))))))))))))) "((level == 0) || ((level == 1) || ((level == 2) || (level == 3))))")
      (sail2_state_monad$returnS result)
   | Fault_AsyncParity =>
      let (result : 6 bits) = ((vec_of_bits [B0;B1;B1;B0;B0;B1]  :  6 words$word)) in
      sail2_state_monad$returnS result
   | Fault_AsyncExternal =>
      let (result : 6 bits) = ((vec_of_bits [B0;B1;B0;B0;B0;B1]  :  6 words$word)) in
      sail2_state_monad$returnS result
   | Fault_Alignment =>
      let (result : 6 bits) = ((vec_of_bits [B1;B0;B0;B0;B0;B1]  :  6 words$word)) in
      sail2_state_monad$returnS result
   | Fault_Debug =>
      let (result : 6 bits) = ((vec_of_bits [B1;B0;B0;B0;B1;B0]  :  6 words$word)) in
      sail2_state_monad$returnS result
   | Fault_TLBConflict =>
      let (result : 6 bits) = ((vec_of_bits [B1;B1;B0;B0;B0;B0]  :  6 words$word)) in
      sail2_state_monad$returnS result
   | Fault_Lockdown =>
      let (result : 6 bits) = ((vec_of_bits [B1;B1;B0;B1;B0;B0]  :  6 words$word)) in
      sail2_state_monad$returnS result
   | Fault_Exclusive =>
      let (result : 6 bits) = ((vec_of_bits [B1;B1;B0;B1;B0;B1]  :  6 words$word)) in
      sail2_state_monad$returnS result
   | _ => sail2_state_monad$seqS (Unreachable () ) (sail2_state_monad$returnS result)
   ))))`;




(*val AArch32_ReportHypEntry : ExceptionRecord -> M unit*)

val _ = Define `
 ((AArch32_ReportHypEntry:ExceptionRecord ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) exception=
    (let (typ : Exception) = (exception.ExceptionRecord_typ) in sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (il : 1 bits) .  sail2_state_monad$bindS
   (undefined_int () ) (\ (ec : ii) .  sail2_state_monad$bindS
   (AArch32_ExceptionClass typ  : ((ii #  1 words$word)) M) (\ varstup .  let (tup__0, tup__1) = varstup in
   let ec = tup__0 in
   let il = tup__1 in
   let (iss : 25 bits) = (exception.ExceptionRecord_syndrome) in
   let (il : 1 bits) =
     (if (((((((((((ex_int ec)) = (( 36 : int):ii)))) \/ (((((ex_int ec)) = (( 37 : int):ii))))))) /\ ((((vec_of_bits [access_vec_dec iss (( 24 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) then
       (vec_of_bits [B1]  :  1 words$word)
     else il) in sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS
     HSR_ref
     ((concat_vec
         ((concat_vec
             ((GetSlice_int ((make_the_value (( 6 : int):ii)  :  6 itself)) ec (( 0 : int):ii)  :  6 words$word)) il
            :  7 words$word)) iss
        :  32 words$word)))
   (if ((((((typ = Exception_InstructionAbort))) \/ (((typ = Exception_PCAlignment)))))) then sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS HIFAR_ref ((slice exception.ExceptionRecord_vaddress (( 0 : int):ii) (( 32 : int):ii)  :  32 words$word)))
      (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__0 : 32 bits) . 
      sail2_state_monad$write_regS HDFAR_ref w__0)
    else if (((typ = Exception_DataAbort))) then sail2_state_monad$bindS
      (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (w__1 : 32 bits) .  sail2_state_monad$seqS
      (sail2_state_monad$write_regS HIFAR_ref w__1)
      (sail2_state_monad$write_regS HDFAR_ref ((slice exception.ExceptionRecord_vaddress (( 0 : int):ii) (( 32 : int):ii)  :  32 words$word))))
    else sail2_state_monad$returnS () ))
   (if exception.ExceptionRecord_ipavalid then sail2_state_monad$bindS
     (sail2_state_monad$read_regS HPFAR_ref  : ( 32 words$word) M) (\ (w__2 :  32 words$word) . 
     sail2_state_monad$write_regS
       HPFAR_ref
       ((set_slice (( 32 : int):ii) (( 28 : int):ii) w__2 (( 4 : int):ii)
           ((slice exception.ExceptionRecord_ipaddress (( 12 : int):ii) (( 28 : int):ii)  :  28 words$word))
          :  32 words$word)))
   else sail2_state_monad$bindS
     (sail2_state_monad$read_regS HPFAR_ref  : ( 32 words$word) M) (\ (w__3 :  32 words$word) .  sail2_state_monad$bindS
     (undefined_bitvector (( 28 : int):ii)  : ( 28 words$word) M) (\ (w__4 :  28 words$word) . 
     sail2_state_monad$write_regS HPFAR_ref ((set_slice (( 32 : int):ii) (( 28 : int):ii) w__3 (( 4 : int):ii) w__4  :  32 words$word))))))))))`;


(*val aset_Elem__0 : forall 'N 'size . Size 'N, Size 'size => mword 'N -> ii -> itself 'size -> mword 'size -> M (mword 'N)*)

(*val aset_Elem__1 : forall 'N 'size . Size 'N, Size 'size => mword 'N -> ii -> mword 'size -> M (mword 'N)*)

val _ = Define `
 ((aset_Elem__0:'N words$word -> int -> 'size itself -> 'size words$word ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) vector_name__arg e size1 value_name=
    (let size1 = (size_itself_int size1) in
   let vector_name = vector_name__arg in sail2_state_monad$seqS
   (sail2_state_monad$assert_expS (((((e >= (( 0 : int):ii))) /\ ((((((e + (( 1 : int):ii))) * size1)) <= ((int_of_num (words$word_len vector_name)))))))) "((e >= 0) && (((e + 1) * size) <= N))")
   (let (vector_name :  'N words$word) =
     ((set_slice ((int_of_num (words$word_len vector_name))) size1 vector_name ((e * size1)) value_name
       :  'N words$word)) in
   sail2_state_monad$returnS vector_name)))`;


val _ = Define `
 ((aset_Elem__1:'N words$word -> int -> 'size words$word ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) vector_name__arg e value_name=
    (let vector_name = vector_name__arg in
   (aset_Elem__0 vector_name e ((make_the_value ((int_of_num (words$word_len value_name)))  :  'size itself)) value_name
     : ( 'N words$word) M)))`;


(*val aget_Elem__0 : forall 'N 'size . Size 'N, Size 'size => mword 'N -> ii -> itself 'size -> M (mword 'size)*)

(*val aget_Elem__1 : forall 'N 'size . Size 'N, Size 'size => integer -> mword 'N -> ii -> M (mword 'size)*)

val _ = Define `
 ((aget_Elem__0:'N words$word -> int -> 'size itself ->(regstate)sail2_state_monad$sequential_state ->((('size words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) vector_name e size1=
    (let size1 = (size_itself_int size1) in sail2_state_monad$seqS
   (sail2_state_monad$assert_expS (((((e >= (( 0 : int):ii))) /\ ((((((e + (( 1 : int):ii))) * size1)) <= ((int_of_num (words$word_len vector_name)))))))) "((e >= 0) && (((e + 1) * size) <= N))")
   (sail2_state_monad$returnS ((slice vector_name ((e * size1)) size1  :  'size words$word)))))`;


val _ = Define `
 ((aget_Elem__1:int -> 'N words$word -> int ->(regstate)sail2_state_monad$sequential_state ->((('size words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) (size__tv : int) vector_name e=
    ((aget_Elem__0 vector_name e ((make_the_value size__tv  :  'size itself))  : ( 'size words$word) M)))`;


(*val UnsignedSatQ : forall 'N . Size 'N => ii -> itself 'N -> M (mword 'N * bool)*)

val _ = Define `
 ((UnsignedSatQ:int -> 'N itself ->(regstate)sail2_state_monad$sequential_state ->((('N words$word#bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) i N=
    (let N = (size_itself_int N) in sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (saturated : bool) .  sail2_state_monad$bindS
   (undefined_int () ) (\ (result : ii) . 
   let ((result : ii), (saturated : bool)) =
     (if ((i > ((((pow2 N)) - (( 1 : int):ii))))) then
       let (result : ii) = (((pow2 N)) - (( 1 : int):ii)) in
       let (saturated : bool) = T in
       (result, saturated)
     else
       let ((result : ii), (saturated : bool)) =
         (if ((i < (( 0 : int):ii))) then
           let (result : ii) = ((( 0 : int):ii)) in
           let (saturated : bool) = T in
           (result, saturated)
         else
           let (result : ii) = i in
           let (saturated : bool) = F in
           (result, saturated)) in
       (result, saturated)) in
   sail2_state_monad$returnS ((GetSlice_int ((make_the_value N  :  'N itself)) result (( 0 : int):ii)  :  'N words$word), saturated)))))`;


(*val SignedSatQ : forall 'N . Size 'N => ii -> itself 'N -> M (mword 'N * bool)*)

val _ = Define `
 ((SignedSatQ:int -> 'N itself ->(regstate)sail2_state_monad$sequential_state ->((('N words$word#bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) i N=
    (let N = (size_itself_int N) in sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (saturated : bool) .  sail2_state_monad$bindS
   (undefined_int () ) (\ (result : ii) . 
   let ((result : ii), (saturated : bool)) =
     (if ((i > ((((pow2 ((N - (( 1 : int):ii))))) - (( 1 : int):ii))))) then
       let (result : ii) = (((pow2 ((N - (( 1 : int):ii))))) - (( 1 : int):ii)) in
       let (saturated : bool) = T in
       (result, saturated)
     else
       let ((result : ii), (saturated : bool)) =
         (if ((i < ((~ ((pow2 ((N - (( 1 : int):ii))))))))) then
           let (result : ii) = (~ ((pow2 ((N - (( 1 : int):ii)))))) in
           let (saturated : bool) = T in
           (result, saturated)
         else
           let (result : ii) = i in
           let (saturated : bool) = F in
           (result, saturated)) in
       (result, saturated)) in
   sail2_state_monad$returnS ((GetSlice_int ((make_the_value N  :  'N itself)) result (( 0 : int):ii)  :  'N words$word), saturated)))))`;


(*val SatQ : forall 'N . Size 'N => ii -> itself 'N -> bool -> M (mword 'N * bool)*)

val _ = Define `
 ((SatQ:int -> 'N itself -> bool ->(regstate)sail2_state_monad$sequential_state ->((('N words$word#bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) i N unsigned=
    (let N = (size_itself_int N) in sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (sat : bool) .  sail2_state_monad$bindS
   (undefined_bitvector N  : ( 'N words$word) M) (\ (result : 'N bits) .  sail2_state_monad$bindS
   (if unsigned then (UnsignedSatQ i ((make_the_value N  :  'N itself))  : (( 'N words$word # bool)) M)
    else (SignedSatQ i ((make_the_value N  :  'N itself))  : (( 'N words$word # bool)) M)) (\ varstup .  let (tup__0, tup__1) = varstup in
   let (result : 'N bits) = tup__0 in
   let (sat : bool) = tup__1 in
   sail2_state_monad$returnS (result, sat))))))`;


(*val Replicate : forall 'M 'N . Size 'M, Size 'N => integer -> mword 'M -> M (mword 'N)*)

val _ = Define `
 ((Replicate:int -> 'M words$word ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) (N__tv : int) x=  (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS (((((N__tv % ((int_of_num (words$word_len x))))) = (( 0 : int):ii)))) "((N MOD M) == 0)")
   (let O1 = (N__tv / ((int_of_num (words$word_len x)))) in sail2_state_monad$seqS
   (sail2_state_monad$assert_expS T "") (sail2_state_monad$returnS ((replicate_bits x ((N__tv / ((int_of_num (words$word_len x)))))  :  'N words$word))))))`;


(*val Zeros__0 : forall 'N . Size 'N => itself 'N -> mword 'N*)

(*val Zeros__1 : forall 'N . Size 'N => integer -> unit -> mword 'N*)

val _ = Define `
 ((Zeros__0:'N itself -> 'N words$word) N=
    (let N = (size_itself_int N) in
   (replicate_bits (vec_of_bits [B0]  :  1 words$word) N  :  'N words$word)))`;


val _ = Define `
 ((Zeros__1:int -> unit -> 'N words$word) (N__tv : int) () =  ((Zeros__0 ((make_the_value N__tv  :  'N itself))  :  'N words$word)))`;


(*val __ResetMemoryState : unit -> M unit*)

val _ = Define `
 ((ResetMemoryState:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (sail2_state_monad$read_regS Memory_ref  : ( 52 words$word) M) (\ (w__0 :  52 words$word) . 
   let (_ : unit) =
     (InitRAM (( 52 : int):ii) (( 1 : int):ii) w__0 ((Zeros__0 ((make_the_value (( 8 : int):ii)  :  8 itself))  :  8 words$word))) in
   sail2_state_monad$write_regS ExclusiveLocal_ref F)))`;


(*val ZeroExtend__0 : forall 'M 'N . Size 'M, Size 'N => mword 'M -> itself 'N -> M (mword 'N)*)

(*val ZeroExtend__1 : forall 'M 'N . Size 'M, Size 'N => integer -> mword 'M -> M (mword 'N)*)

val _ = Define `
 ((ZeroExtend__0:'M words$word -> 'N itself ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) x N=
    (let N = (size_itself_int N) in sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((N >= ((int_of_num (words$word_len x))))) "") (sail2_state_monad$returnS ((extzv N x  :  'N words$word)))))`;


val _ = Define `
 ((ZeroExtend__1:int -> 'M words$word ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) (N__tv : int) x=
    ((ZeroExtend__0 x ((make_the_value N__tv  :  'N itself))  : ( 'N words$word) M)))`;


(*val aset_Vpart : forall 'width . Size 'width => ii -> ii -> mword 'width -> M unit*)

val _ = Define `
 ((aset_Vpart:int -> int -> 'width words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) n part value_name=  (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS (((((n >= (( 0 : int):ii))) /\ ((n <= (( 31 : int):ii)))))) "((n >= 0) && (n <= 31))")
   (sail2_state_monad$assert_expS ((((((part = (( 0 : int):ii)))) \/ (((part = (( 1 : int):ii))))))) "((part == 0) || (part == 1))"))
   (if (((part = (( 0 : int):ii)))) then sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS ((((((((int_of_num (words$word_len value_name))) = (( 8 : int):ii)))) \/ ((((((((int_of_num (words$word_len value_name))) = (( 16 : int):ii)))) \/ ((((((((int_of_num (words$word_len value_name))) = (( 32 : int):ii)))) \/ (((((int_of_num (words$word_len value_name))) = (( 64 : int):ii))))))))))))) "((width == 8) || ((width == 16) || ((width == 32) || (width == 64))))")
     (sail2_state_monad$read_regS V_ref)) (\ (w__0 : ( 128 words$word) list) .  sail2_state_monad$bindS
     (ZeroExtend__1 (( 128 : int):ii) value_name  : ( 128 words$word) M) (\ (w__1 : 128 bits) . 
     sail2_state_monad$write_regS V_ref ((update_list_dec w__0 n w__1  : ( 128 words$word) list))))
   else sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS (((((int_of_num (words$word_len value_name))) = (( 64 : int):ii)))) "(width == 64)")
     (sail2_state_monad$read_regS V_ref)) (\ (w__2 : ( 128 bits) list) . 
     let (tmp_2870 : 128 bits) = ((access_list_dec w__2 n  :  128 words$word)) in
     let tmp_2870 =
       ((update_subrange_vec_dec tmp_2870 (( 127 : int):ii) (( 64 : int):ii)
          ((subrange_vec_dec value_name (( 63 : int):ii) (( 0 : int):ii)  :  64 words$word))
         :  128 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS V_ref) (\ (w__3 : ( 128 words$word) list) . 
     sail2_state_monad$write_regS V_ref ((update_list_dec w__3 n tmp_2870  : ( 128 words$word) list)))))))`;


(*val aset_V : forall 'width . Size 'width => ii -> mword 'width -> M unit*)

val _ = Define `
 ((aset_V:int -> 'width words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) n value_name=  (sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS (((((n >= (( 0 : int):ii))) /\ ((n <= (( 31 : int):ii)))))) "((n >= 0) && (n <= 31))")
   (sail2_state_monad$assert_expS ((((((((int_of_num (words$word_len value_name))) = (( 8 : int):ii)))) \/ ((((((((int_of_num (words$word_len value_name))) = (( 16 : int):ii)))) \/ ((((((((int_of_num (words$word_len value_name))) = (( 32 : int):ii)))) \/ ((((((((int_of_num (words$word_len value_name))) = (( 64 : int):ii)))) \/ (((((int_of_num (words$word_len value_name))) = (( 128 : int):ii)))))))))))))))) "((width == 8) || ((width == 16) || ((width == 32) || ((width == 64) || (width == 128)))))"))
   (sail2_state_monad$read_regS V_ref)) (\ (w__0 : ( 128 words$word) list) .  sail2_state_monad$bindS
   (ZeroExtend__1 (( 128 : int):ii) value_name  : ( 128 words$word) M) (\ (w__1 : 128 bits) . 
   sail2_state_monad$write_regS V_ref ((update_list_dec w__0 n w__1  : ( 128 words$word) list))))))`;


(*val AArch64_ResetSIMDFPRegisters : unit -> M unit*)

val _ = Define `
 ((AArch64_ResetSIMDFPRegisters:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$foreachS (index_list (( 0 : int):ii) (( 31 : int):ii) (( 1 : int):ii)) () 
     (\ i unit_var .  sail2_state_monad$bindS
       (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (w__0 : 64 bits) .  aset_V i w__0))))`;


(*val aset_SP : forall 'width . Size 'width => mword 'width -> M unit*)

val _ = Define `
 ((aset_SP:'width words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) value_name=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((((((int_of_num (words$word_len value_name))) = (( 32 : int):ii)))) \/ (((((int_of_num (words$word_len value_name))) = (( 64 : int):ii))))))) "((width == 32) || (width == 64))")
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__0 : ProcState) . 
   if (((w__0.ProcState_SP = (vec_of_bits [B0]  :  1 words$word)))) then sail2_state_monad$bindS
     (ZeroExtend__1 (( 64 : int):ii) value_name  : ( 64 words$word) M) (\ (w__1 : 64 bits) . 
     sail2_state_monad$write_regS SP_EL0_ref w__1)
   else sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) . 
     let p__299 = (w__2.ProcState_EL) in
     let pat_0 = p__299 in
     if (((pat_0 = EL0))) then sail2_state_monad$bindS
       (ZeroExtend__1 (( 64 : int):ii) value_name  : ( 64 words$word) M) (\ (w__3 : 64 bits) . 
       sail2_state_monad$write_regS SP_EL0_ref w__3)
     else if (((pat_0 = EL1))) then sail2_state_monad$bindS
       (ZeroExtend__1 (( 64 : int):ii) value_name  : ( 64 words$word) M) (\ (w__4 : 64 bits) . 
       sail2_state_monad$write_regS SP_EL1_ref w__4)
     else if (((pat_0 = EL2))) then sail2_state_monad$bindS
       (ZeroExtend__1 (( 64 : int):ii) value_name  : ( 64 words$word) M) (\ (w__5 : 64 bits) . 
       sail2_state_monad$write_regS SP_EL2_ref w__5)
     else sail2_state_monad$bindS
       (ZeroExtend__1 (( 64 : int):ii) value_name  : ( 64 words$word) M) (\ (w__6 : 64 bits) . 
       sail2_state_monad$write_regS SP_EL3_ref w__6)))))`;


(*val LSR_C : forall 'N . Size 'N => mword 'N -> ii -> M (mword 'N * mword ty1)*)

val _ = Define `
 ((LSR_C:'N words$word -> int ->(regstate)sail2_state_monad$sequential_state ->((('N words$word#(1)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) x shift=  (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((shift > (( 0 : int):ii))) "(shift > 0)")
   (let (result : 'N bits) = ((shiftr x shift  :  'N words$word)) in
   let (carry_out : 1 bits) =
     (if ((shift > ((int_of_num (words$word_len result))))) then (vec_of_bits [B0]  :  1 words$word)
     else (vec_of_bits [access_vec_dec x ((shift - (( 1 : int):ii)))]  :  1 words$word)) in
   sail2_state_monad$returnS (result, carry_out))))`;


(*val LSR : forall 'N . Size 'N => mword 'N -> ii -> M (mword 'N)*)

val _ = Define `
 ((LSR:'N words$word -> int ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) x shift=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((shift >= (( 0 : int):ii))) "(shift >= 0)")
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M)) (\ (anon10 : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector ((int_of_num (words$word_len x)))  : ( 'N words$word) M) (\ (result : 'N bits) . 
   if (((shift = (( 0 : int):ii)))) then sail2_state_monad$returnS x
   else sail2_state_monad$bindS
     (LSR_C x shift  : (( 'N words$word #  1 words$word)) M) (\ varstup .  let (tup__0, tup__1) = varstup in
     let (result : 'N bits) = tup__0 in
     let (anon10 : 1 bits) = tup__1 in
     sail2_state_monad$returnS result)))))`;


(*val Poly32Mod2 : forall 'N . Size 'N => mword 'N -> mword ty32 -> M (mword ty32)*)

val _ = Define `
 ((Poly32Mod2:'N words$word ->(32)words$word ->(regstate)sail2_state_monad$sequential_state ->((((32)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) data__arg poly=
    (let data = data__arg in sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((int_of_num (words$word_len data))) > (( 32 : int):ii))) "(N > 32)")
   (let (poly' : 'N bits) = ((extzv ((int_of_num (words$word_len data))) poly  :  'N words$word)) in
   let (data :  'N words$word) =
     (foreach (index_list ((((int_of_num (words$word_len data))) - (( 1 : int):ii))) (( 32 : int):ii) (~ (( 1 : int):ii))) data
       (\ i data . 
         if ((((vec_of_bits [access_vec_dec data i]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
           (or_vec data ((sub_vec_int ((shiftl poly' i  :  'N words$word)) (( 32 : int):ii)  :  'N words$word))
             :  'N words$word)
         else data)) in
   sail2_state_monad$returnS ((slice data (( 0 : int):ii) (( 32 : int):ii)  :  32 words$word)))))`;


(*val LSL_C : forall 'N . Size 'N => mword 'N -> ii -> M (mword 'N * mword ty1)*)

val _ = Define `
 ((LSL_C:'N words$word -> int ->(regstate)sail2_state_monad$sequential_state ->((('N words$word#(1)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) x shift=  (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((shift > (( 0 : int):ii))) "(shift > 0)")
   (let (result : 'N bits) = ((shiftl x shift  :  'N words$word)) in
   let (carry_out : 1 bits) =
     (if ((shift > ((int_of_num (words$word_len result))))) then (vec_of_bits [B0]  :  1 words$word)
     else (vec_of_bits [access_vec_dec x ((((int_of_num (words$word_len result))) - shift))]  :  1 words$word)) in
   sail2_state_monad$returnS (result, carry_out))))`;


(*val LSL : forall 'N . Size 'N => mword 'N -> ii -> M (mword 'N)*)

val _ = Define `
 ((LSL:'N words$word -> int ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) x shift=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((shift >= (( 0 : int):ii))) "(shift >= 0)")
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M)) (\ (anon10 : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector ((int_of_num (words$word_len x)))  : ( 'N words$word) M) (\ (result : 'N bits) . 
   if (((shift = (( 0 : int):ii)))) then sail2_state_monad$returnS x
   else sail2_state_monad$bindS
     (LSL_C x shift  : (( 'N words$word #  1 words$word)) M) (\ varstup .  let (tup__0, tup__1) = varstup in
     let (result : 'N bits) = tup__0 in
     let (anon10 : 1 bits) = tup__1 in
     sail2_state_monad$returnS result)))))`;


(*val AArch32_ITAdvance : unit -> M unit*)

val _ = Define `
 ((AArch32_ITAdvance:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) . 
   if (((((slice w__0.ProcState_IT (( 0 : int):ii) (( 3 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) then sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__1 : ProcState) . 
     sail2_state_monad$write_regS
       PSTATE_ref
       (w__1 with<| ProcState_IT := ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0]  :  8 words$word))|>))
   else sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) . 
     let (tmp_2760 : 8 bits) = (w__2.ProcState_IT) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__3 : ProcState) .  sail2_state_monad$bindS
     (LSL ((slice w__3.ProcState_IT (( 0 : int):ii) (( 5 : int):ii)  :  5 words$word)) (( 1 : int):ii)  : ( 5 words$word) M) (\ (w__4 :
        5 words$word) . 
     let tmp_2760 = ((set_slice (( 8 : int):ii) (( 5 : int):ii) tmp_2760 (( 0 : int):ii) w__4  :  8 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__5 : ProcState) . 
     sail2_state_monad$write_regS PSTATE_ref (w__5 with<| ProcState_IT := tmp_2760|>))))))))`;


(*val LSInstructionSyndrome : unit -> M (mword ty11)*)

val _ = Define `
 ((LSInstructionSyndrome:unit ->(regstate)sail2_state_monad$sequential_state ->((((11)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS F "FALSE")
   (sail2_state_monad$returnS ((Zeros__0 ((make_the_value (( 11 : int):ii)  :  11 itself))  :  11 words$word)))))`;


(*val IsZero : forall 'N . Size 'N => mword 'N -> bool*)

val _ = Define `
 ((IsZero:'N words$word -> bool) x=  (x = ((Zeros__0 ((make_the_value ((int_of_num (words$word_len x)))  :  'N itself))  :  'N words$word))))`;


(*val IsZeroBit : forall 'N . Size 'N => mword 'N -> mword ty1*)

val _ = Define `
 ((IsZeroBit:'N words$word ->(1)words$word) x=
    (if ((IsZero x)) then (vec_of_bits [B1]  :  1 words$word)
   else (vec_of_bits [B0]  :  1 words$word)))`;


(*val AddWithCarry : forall 'N . Size 'N => mword 'N -> mword 'N -> mword ty1 -> (mword 'N * mword ty4)*)

val _ = Define `
 ((AddWithCarry:'N words$word -> 'N words$word ->(1)words$word -> 'N words$word#(4)words$word) x y carry_in=
    (let (unsigned_sum : ii) = (((((lem$w2ui x)) + ((lem$w2ui y)))) + ((lem$w2ui carry_in))) in
   let (signed_sum : ii) = (((((integer_word$w2i x)) + ((integer_word$w2i y)))) + ((lem$w2ui carry_in))) in
   let (result : 'N bits) =
     ((GetSlice_int ((make_the_value ((int_of_num (words$word_len x)))  :  'N itself)) unsigned_sum (( 0 : int):ii)  :  'N words$word)) in
   let (n : 1 bits) =
     ((vec_of_bits [access_vec_dec result ((((int_of_num (words$word_len result))) - (( 1 : int):ii)))]  :  1 words$word)) in
   let (z : 1 bits) =
     (if ((IsZero result)) then (vec_of_bits [B1]  :  1 words$word)
     else (vec_of_bits [B0]  :  1 words$word)) in
   let (c : 1 bits) =
     (if (((((lem$w2ui result)) = ((ex_int unsigned_sum))))) then (vec_of_bits [B0]  :  1 words$word)
     else (vec_of_bits [B1]  :  1 words$word)) in
   let (v : 1 bits) =
     (if (((((integer_word$w2i result)) = ((ex_int signed_sum))))) then (vec_of_bits [B0]  :  1 words$word)
     else (vec_of_bits [B1]  :  1 words$word)) in
   (result,
    (concat_vec ((concat_vec ((concat_vec n z  :  2 words$word)) c  :  3 words$word)) v  :  4 words$word))))`;


(*val GetPSRFromPSTATE : unit -> M (mword ty32)*)

val _ = Define `
 ((GetPSRFromPSTATE:unit ->(regstate)sail2_state_monad$sequential_state ->((((32)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (let (spsr : 32 bits) = ((Zeros__1 (( 32 : int):ii) ()   :  32 words$word)) in sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) . 
   let spsr = ((update_subrange_vec_dec spsr (( 31 : int):ii) (( 31 : int):ii) w__0.ProcState_N  :  32 words$word)) in sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__1 : ProcState) . 
   let spsr = ((update_subrange_vec_dec spsr (( 30 : int):ii) (( 30 : int):ii) w__1.ProcState_Z  :  32 words$word)) in sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) . 
   let spsr = ((update_subrange_vec_dec spsr (( 29 : int):ii) (( 29 : int):ii) w__2.ProcState_C  :  32 words$word)) in sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__3 : ProcState) . 
   let spsr = ((update_subrange_vec_dec spsr (( 28 : int):ii) (( 28 : int):ii) w__3.ProcState_V  :  32 words$word)) in sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__4 : ProcState) . 
   let spsr = ((update_subrange_vec_dec spsr (( 21 : int):ii) (( 21 : int):ii) w__4.ProcState_SS  :  32 words$word)) in sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__5 : ProcState) . 
   let spsr = ((update_subrange_vec_dec spsr (( 20 : int):ii) (( 20 : int):ii) w__5.ProcState_IL  :  32 words$word)) in sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__6 : ProcState) . 
   if (((w__6.ProcState_nRW = (vec_of_bits [B1]  :  1 words$word)))) then sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__7 : ProcState) . 
     let spsr = ((update_subrange_vec_dec spsr (( 27 : int):ii) (( 27 : int):ii) w__7.ProcState_Q  :  32 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__8 : ProcState) . 
     let spsr =
       ((update_subrange_vec_dec spsr (( 26 : int):ii) (( 25 : int):ii)
          ((subrange_vec_dec w__8.ProcState_IT (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word))
         :  32 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__9 : ProcState) . 
     let spsr = ((update_subrange_vec_dec spsr (( 19 : int):ii) (( 16 : int):ii) w__9.ProcState_GE  :  32 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__10 : ProcState) . 
     let spsr =
       ((update_subrange_vec_dec spsr (( 15 : int):ii) (( 10 : int):ii)
          ((subrange_vec_dec w__10.ProcState_IT (( 7 : int):ii) (( 2 : int):ii)  :  6 words$word))
         :  32 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__11 : ProcState) . 
     let spsr = ((update_subrange_vec_dec spsr (( 9 : int):ii) (( 9 : int):ii) w__11.ProcState_E  :  32 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__12 : ProcState) . 
     let spsr = ((update_subrange_vec_dec spsr (( 8 : int):ii) (( 8 : int):ii) w__12.ProcState_A  :  32 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__13 : ProcState) . 
     let spsr = ((update_subrange_vec_dec spsr (( 7 : int):ii) (( 7 : int):ii) w__13.ProcState_I  :  32 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__14 : ProcState) . 
     let spsr = ((update_subrange_vec_dec spsr (( 6 : int):ii) (( 6 : int):ii) w__14.ProcState_F  :  32 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__15 : ProcState) . 
     let spsr = ((update_subrange_vec_dec spsr (( 5 : int):ii) (( 5 : int):ii) w__15.ProcState_T  :  32 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__16 : ProcState) .  sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__17 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS ((((vec_of_bits [access_vec_dec w__16.ProcState_M (( 4 : int):ii)]  :  1 words$word) = w__17.ProcState_nRW))) "(((PSTATE).M)<4> == (PSTATE).nRW)")
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__18 : ProcState) . 
     let (spsr : 32 bits) =
       ((update_subrange_vec_dec spsr (( 4 : int):ii) (( 0 : int):ii) w__18.ProcState_M  :  32 words$word)) in
     sail2_state_monad$returnS spsr))))))))))))
   else sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__19 : ProcState) . 
     let spsr = ((update_subrange_vec_dec spsr (( 9 : int):ii) (( 9 : int):ii) w__19.ProcState_D  :  32 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__20 : ProcState) . 
     let spsr = ((update_subrange_vec_dec spsr (( 8 : int):ii) (( 8 : int):ii) w__20.ProcState_A  :  32 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__21 : ProcState) . 
     let spsr = ((update_subrange_vec_dec spsr (( 7 : int):ii) (( 7 : int):ii) w__21.ProcState_I  :  32 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__22 : ProcState) . 
     let spsr = ((update_subrange_vec_dec spsr (( 6 : int):ii) (( 6 : int):ii) w__22.ProcState_F  :  32 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__23 : ProcState) . 
     let spsr = ((update_subrange_vec_dec spsr (( 4 : int):ii) (( 4 : int):ii) w__23.ProcState_nRW  :  32 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__24 : ProcState) . 
     let spsr = ((update_subrange_vec_dec spsr (( 3 : int):ii) (( 2 : int):ii) w__24.ProcState_EL  :  32 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__25 : ProcState) . 
     let (spsr : 32 bits) =
       ((update_subrange_vec_dec spsr (( 0 : int):ii) (( 0 : int):ii) w__25.ProcState_SP  :  32 words$word)) in
     sail2_state_monad$returnS spsr))))))))))))))))`;


(*val FPZero : forall 'N . Size 'N => integer -> mword ty1 -> M (mword 'N)*)

val _ = Define `
 ((FPZero:int ->(1)words$word ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) (N__tv : int) sign=
    (let p0_ = N__tv in
   if (((p0_ = (( 16 : int):ii)))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "((N == 16) || ((N == 32) || (N == 64)))")
     (let (F1 : int) = ((((( 16 : int):ii) - (( 5 : int):ii))) - (( 1 : int):ii)) in
     let (exp : 5 bits) = ((Zeros__0 ((make_the_value (( 5 : int):ii)  :  5 itself))  :  5 words$word)) in
     let (frac : 10 bits) = ((Zeros__0 ((make_the_value F1  :  10 itself))  :  10 words$word)) in
     sail2_state_monad$returnS ((words$w2w ((concat_vec ((concat_vec sign exp  :  6 words$word)) frac  :  'N words$word))
               :  'N words$word)))
   else if (((p0_ = (( 32 : int):ii)))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "((N == 16) || ((N == 32) || (N == 64)))")
     (let (F1 : int) = ((((( 32 : int):ii) - (( 8 : int):ii))) - (( 1 : int):ii)) in
     let (exp : 8 bits) = ((Zeros__0 ((make_the_value (( 8 : int):ii)  :  8 itself))  :  8 words$word)) in
     let (frac : 23 bits) = ((Zeros__0 ((make_the_value F1  :  23 itself))  :  23 words$word)) in
     sail2_state_monad$returnS ((words$w2w ((concat_vec ((concat_vec sign exp  :  9 words$word)) frac  :  'N words$word))
               :  'N words$word)))
   else if (((p0_ = (( 64 : int):ii)))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "((N == 16) || ((N == 32) || (N == 64)))")
     (let (F1 : int) = ((((( 64 : int):ii) - (( 11 : int):ii))) - (( 1 : int):ii)) in
     let (exp : 11 bits) = ((Zeros__0 ((make_the_value (( 11 : int):ii)  :  11 itself))  :  11 words$word)) in
     let (frac : 52 bits) = ((Zeros__0 ((make_the_value F1  :  52 itself))  :  52 words$word)) in
     sail2_state_monad$returnS ((words$w2w ((concat_vec ((concat_vec sign exp  :  12 words$word)) frac  :  'N words$word))
               :  'N words$word)))
   else sail2_state_monad$seqS (sail2_state_monad$assert_expS F "((N == 16) || ((N == 32) || (N == 64)))") (sail2_state_monad$exitS () )))`;


(*val ExceptionSyndrome : Exception -> M ExceptionRecord*)

val _ = Define `
 ((ExceptionSyndrome:Exception ->(regstate)sail2_state_monad$sequential_state ->(((ExceptionRecord),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) typ=  (sail2_state_monad$bindS
   (undefined_ExceptionRecord () ) (\ (r : ExceptionRecord) . 
   let (r : ExceptionRecord) = ((r with<| ExceptionRecord_typ := typ|>)) in
   let (r : ExceptionRecord) =
     ((r with<| ExceptionRecord_syndrome := ((Zeros__1 (( 25 : int):ii) ()   :  25 words$word))|>)) in
   let (r : ExceptionRecord) =
     ((r with<| ExceptionRecord_vaddress := ((Zeros__1 (( 64 : int):ii) ()   :  64 words$word))|>)) in
   let (r : ExceptionRecord) = ((r with<| ExceptionRecord_ipavalid := F|>)) in
   let (r : ExceptionRecord) =
     ((r with<| ExceptionRecord_ipaddress := ((Zeros__1 (( 52 : int):ii) ()   :  52 words$word))|>)) in
   sail2_state_monad$returnS r)))`;


(*val ConstrainUnpredictableBits : forall 'width . Size 'width => integer -> Unpredictable -> M (Constraint * mword 'width)*)

val _ = Define `
 ((ConstrainUnpredictableBits:int -> Unpredictable ->(regstate)sail2_state_monad$sequential_state ->(((Constraint#'width words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) (width__tv : int) which=
    (let (c : Constraint) = (ConstrainUnpredictable which) in
   if (((c = Constraint_UNKNOWN))) then
     sail2_state_monad$returnS (c, (Zeros__0 ((make_the_value width__tv  :  'width itself))  :  'width words$word))
   else sail2_state_monad$bindS
     (undefined_bitvector width__tv  : ( 'width words$word) M) (\ (w__0 :  'width words$word) . 
     sail2_state_monad$returnS (c, w__0))))`;


(*val AArch64_SysInstrWithResult : ii -> ii -> ii -> ii -> ii -> M (mword ty64)*)

val _ = Define `
 ((AArch64_SysInstrWithResult:int -> int -> int -> int -> int ->(regstate)sail2_state_monad$sequential_state ->((((64)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) op0 op1 crn crm op2=  (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS F "FALSE")
   (sail2_state_monad$returnS ((Zeros__0 ((make_the_value (( 64 : int):ii)  :  64 itself))  :  64 words$word)))))`;


(*val AArch64_PhysicalSErrorSyndrome : bool -> M (mword ty25)*)

val _ = Define `
 ((AArch64_PhysicalSErrorSyndrome:bool ->(regstate)sail2_state_monad$sequential_state ->((((25)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) implicit_esb=  (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS F "FALSE")
   (sail2_state_monad$returnS ((Zeros__0 ((make_the_value (( 25 : int):ii)  :  25 itself))  :  25 words$word)))))`;


(*val AArch32_PhysicalSErrorSyndrome : unit -> M AArch32_SErrorSyndrome*)

val _ = Define `
 ((AArch32_PhysicalSErrorSyndrome:unit ->(regstate)sail2_state_monad$sequential_state ->(((AArch32_SErrorSyndrome),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS F "FALSE")
   (undefined_AArch32_SErrorSyndrome () )) (\ (r : AArch32_SErrorSyndrome) . 
   let (r : AArch32_SErrorSyndrome) =
     ((r with<|
       AArch32_SErrorSyndrome_AET :=
         ((Zeros__0 ((make_the_value (( 2 : int):ii)  :  2 itself))  :  2 words$word))|>)) in
   let (r : AArch32_SErrorSyndrome) =
     ((r with<|
       AArch32_SErrorSyndrome_ExT :=
         ((Zeros__0 ((make_the_value (( 1 : int):ii)  :  1 itself))  :  1 words$word))|>)) in
   sail2_state_monad$returnS r)))`;


(*val VFPExpandImm : forall 'N . Size 'N => integer -> mword ty8 -> M (mword 'N)*)

val _ = Define `
 ((VFPExpandImm:int ->(8)words$word ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) (N__tv : int) imm8=
    (let p0_ = N__tv in
   if (((p0_ = (( 16 : int):ii)))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "((N == 16) || ((N == 32) || (N == 64)))")
     (let (F1 : int) = ((((( 16 : int):ii) - (( 5 : int):ii))) - (( 1 : int):ii)) in
     let (sign : 1 bits) = ((vec_of_bits [access_vec_dec imm8 (( 7 : int):ii)]  :  1 words$word)) in
     let (exp : 5 bits) =
       ((concat_vec
          ((concat_vec
              ((not_vec (vec_of_bits [access_vec_dec imm8 (( 6 : int):ii)]  :  1 words$word)  :  1 words$word))
              ((replicate_bits (vec_of_bits [access_vec_dec imm8 (( 6 : int):ii)]  :  1 words$word)
                  (((( 5 : int):ii) - (( 3 : int):ii)))
                 :  2 words$word))
             :  3 words$word)) ((subrange_vec_dec imm8 (( 5 : int):ii) (( 4 : int):ii)  :  2 words$word))
         :  5 words$word)) in
     let (frac : 10 bits) =
       ((concat_vec ((subrange_vec_dec imm8 (( 3 : int):ii) (( 0 : int):ii)  :  4 words$word))
          ((Zeros__0 ((make_the_value ((F1 - (( 4 : int):ii)))  :  6 itself))  :  6 words$word))
         :  10 words$word)) in
     sail2_state_monad$returnS ((words$w2w ((concat_vec ((concat_vec sign exp  :  6 words$word)) frac  :  'N words$word))
               :  'N words$word)))
   else if (((p0_ = (( 32 : int):ii)))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "((N == 16) || ((N == 32) || (N == 64)))")
     (let (F1 : int) = ((((( 32 : int):ii) - (( 8 : int):ii))) - (( 1 : int):ii)) in
     let (sign : 1 bits) = ((vec_of_bits [access_vec_dec imm8 (( 7 : int):ii)]  :  1 words$word)) in
     let (exp : 8 bits) =
       ((concat_vec
          ((concat_vec
              ((not_vec (vec_of_bits [access_vec_dec imm8 (( 6 : int):ii)]  :  1 words$word)  :  1 words$word))
              ((replicate_bits (vec_of_bits [access_vec_dec imm8 (( 6 : int):ii)]  :  1 words$word)
                  (((( 8 : int):ii) - (( 3 : int):ii)))
                 :  5 words$word))
             :  6 words$word)) ((subrange_vec_dec imm8 (( 5 : int):ii) (( 4 : int):ii)  :  2 words$word))
         :  8 words$word)) in
     let (frac : 23 bits) =
       ((concat_vec ((subrange_vec_dec imm8 (( 3 : int):ii) (( 0 : int):ii)  :  4 words$word))
          ((Zeros__0 ((make_the_value ((F1 - (( 4 : int):ii)))  :  19 itself))  :  19 words$word))
         :  23 words$word)) in
     sail2_state_monad$returnS ((words$w2w ((concat_vec ((concat_vec sign exp  :  9 words$word)) frac  :  'N words$word))
               :  'N words$word)))
   else if (((p0_ = (( 64 : int):ii)))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "((N == 16) || ((N == 32) || (N == 64)))")
     (let (F1 : int) = ((((( 64 : int):ii) - (( 11 : int):ii))) - (( 1 : int):ii)) in
     let (sign : 1 bits) = ((vec_of_bits [access_vec_dec imm8 (( 7 : int):ii)]  :  1 words$word)) in
     let (exp : 11 bits) =
       ((concat_vec
          ((concat_vec
              ((not_vec (vec_of_bits [access_vec_dec imm8 (( 6 : int):ii)]  :  1 words$word)  :  1 words$word))
              ((replicate_bits (vec_of_bits [access_vec_dec imm8 (( 6 : int):ii)]  :  1 words$word)
                  (((( 11 : int):ii) - (( 3 : int):ii)))
                 :  8 words$word))
             :  9 words$word)) ((subrange_vec_dec imm8 (( 5 : int):ii) (( 4 : int):ii)  :  2 words$word))
         :  11 words$word)) in
     let (frac : 52 bits) =
       ((concat_vec ((subrange_vec_dec imm8 (( 3 : int):ii) (( 0 : int):ii)  :  4 words$word))
          ((Zeros__0 ((make_the_value ((F1 - (( 4 : int):ii)))  :  48 itself))  :  48 words$word))
         :  52 words$word)) in
     sail2_state_monad$returnS ((words$w2w ((concat_vec ((concat_vec sign exp  :  12 words$word)) frac  :  'N words$word))
               :  'N words$word)))
   else sail2_state_monad$seqS (sail2_state_monad$assert_expS F "((N == 16) || ((N == 32) || (N == 64)))") (sail2_state_monad$exitS () )))`;


(*val SignExtend__0 : forall 'M 'N . Size 'M, Size 'N => mword 'M -> itself 'N -> M (mword 'N)*)

(*val SignExtend__1 : forall 'M 'N . Size 'M, Size 'N => integer -> mword 'M -> M (mword 'N)*)

val _ = Define `
 ((SignExtend__0:'M words$word -> 'N itself ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) x N=
    (let N = (size_itself_int N) in sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((N >= ((int_of_num (words$word_len x))))) "") (sail2_state_monad$returnS ((extsv N x  :  'N words$word)))))`;


val _ = Define `
 ((SignExtend__1:int -> 'M words$word ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) (N__tv : int) x=
    ((SignExtend__0 x ((make_the_value N__tv  :  'N itself))  : ( 'N words$word) M)))`;


(*val Extend__0 : forall 'M 'N . Size 'M, Size 'N => mword 'M -> itself 'N -> bool -> M (mword 'N)*)

(*val Extend__1 : forall 'M 'N . Size 'M, Size 'N => integer -> mword 'M -> bool -> M (mword 'N)*)

val _ = Define `
 ((Extend__0:'M words$word -> 'N itself -> bool ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) x N unsigned=
    (let N = (size_itself_int N) in
   if unsigned then (ZeroExtend__0 x ((make_the_value N  :  'N itself))  : ( 'N words$word) M)
   else (SignExtend__0 x ((make_the_value N  :  'N itself))  : ( 'N words$word) M)))`;


val _ = Define `
 ((Extend__1:int -> 'M words$word -> bool ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) (N__tv : int) x unsigned=
    ((Extend__0 x ((make_the_value N__tv  :  'N itself)) unsigned  : ( 'N words$word) M)))`;


(*val ASR_C : forall 'N . Size 'N => mword 'N -> ii -> M (mword 'N * mword ty1)*)

val _ = Define `
 ((ASR_C:'N words$word -> int ->(regstate)sail2_state_monad$sequential_state ->((('N words$word#(1)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) x shift=  (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((shift > (( 0 : int):ii))) "(shift > 0)")
   (let (result : 'N bits) = ((arith_shiftr x shift  :  'N words$word)) in
   let (carry_out : 1 bits) =
     (if ((shift > ((int_of_num (words$word_len result))))) then
       (vec_of_bits [access_vec_dec x ((((int_of_num (words$word_len result))) - (( 1 : int):ii)))]  :  1 words$word)
     else (vec_of_bits [access_vec_dec x ((shift - (( 1 : int):ii)))]  :  1 words$word)) in
   sail2_state_monad$returnS (result, carry_out))))`;


(*val ASR : forall 'N . Size 'N => mword 'N -> ii -> M (mword 'N)*)

val _ = Define `
 ((ASR:'N words$word -> int ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) x shift=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((shift >= (( 0 : int):ii))) "(shift >= 0)")
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M)) (\ (anon10 : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector ((int_of_num (words$word_len x)))  : ( 'N words$word) M) (\ (result : 'N bits) . 
   if (((shift = (( 0 : int):ii)))) then sail2_state_monad$returnS x
   else sail2_state_monad$bindS
     (ASR_C x shift  : (( 'N words$word #  1 words$word)) M) (\ varstup .  let (tup__0, tup__1) = varstup in
     let (result : 'N bits) = tup__0 in
     let (anon10 : 1 bits) = tup__1 in
     sail2_state_monad$returnS result)))))`;


(*val Ones__0 : forall 'N . Size 'N => itself 'N -> mword 'N*)

(*val Ones__1 : forall 'N . Size 'N => integer -> unit -> mword 'N*)

val _ = Define `
 ((Ones__0:'N itself -> 'N words$word) N=
    (let N = (size_itself_int N) in
   (replicate_bits (vec_of_bits [B1]  :  1 words$word) N  :  'N words$word)))`;


val _ = Define `
 ((Ones__1:int -> unit -> 'N words$word) (N__tv : int) () =  ((Ones__0 ((make_the_value N__tv  :  'N itself))  :  'N words$word)))`;


(*val IsOnes : forall 'N . Size 'N => mword 'N -> bool*)

val _ = Define `
 ((IsOnes:'N words$word -> bool) x=  (x = ((Ones__0 ((make_the_value ((int_of_num (words$word_len x)))  :  'N itself))  :  'N words$word))))`;


(*val FPMaxNormal : forall 'N . Size 'N => integer -> mword ty1 -> M (mword 'N)*)

val _ = Define `
 ((FPMaxNormal:int ->(1)words$word ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) (N__tv : int) sign=
    (let p0_ = N__tv in
   if (((p0_ = (( 16 : int):ii)))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "((N == 16) || ((N == 32) || (N == 64)))")
     (let (F1 : int) = ((((( 16 : int):ii) - (( 5 : int):ii))) - (( 1 : int):ii)) in
     let (exp : 5 bits) =
       ((concat_vec
          ((Ones__0 ((make_the_value (((( 5 : int):ii) - (( 1 : int):ii)))  :  4 itself))  :  4 words$word))
          (vec_of_bits [B0]  :  1 words$word)
         :  5 words$word)) in
     let (frac : 10 bits) = ((Ones__0 ((make_the_value F1  :  10 itself))  :  10 words$word)) in
     sail2_state_monad$returnS ((words$w2w ((concat_vec ((concat_vec sign exp  :  6 words$word)) frac  :  'N words$word))
               :  'N words$word)))
   else if (((p0_ = (( 32 : int):ii)))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "((N == 16) || ((N == 32) || (N == 64)))")
     (let (F1 : int) = ((((( 32 : int):ii) - (( 8 : int):ii))) - (( 1 : int):ii)) in
     let (exp : 8 bits) =
       ((concat_vec
          ((Ones__0 ((make_the_value (((( 8 : int):ii) - (( 1 : int):ii)))  :  7 itself))  :  7 words$word))
          (vec_of_bits [B0]  :  1 words$word)
         :  8 words$word)) in
     let (frac : 23 bits) = ((Ones__0 ((make_the_value F1  :  23 itself))  :  23 words$word)) in
     sail2_state_monad$returnS ((words$w2w ((concat_vec ((concat_vec sign exp  :  9 words$word)) frac  :  'N words$word))
               :  'N words$word)))
   else if (((p0_ = (( 64 : int):ii)))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "((N == 16) || ((N == 32) || (N == 64)))")
     (let (F1 : int) = ((((( 64 : int):ii) - (( 11 : int):ii))) - (( 1 : int):ii)) in
     let (exp : 11 bits) =
       ((concat_vec
          ((Ones__0 ((make_the_value (((( 11 : int):ii) - (( 1 : int):ii)))  :  10 itself))  :  10 words$word))
          (vec_of_bits [B0]  :  1 words$word)
         :  11 words$word)) in
     let (frac : 52 bits) = ((Ones__0 ((make_the_value F1  :  52 itself))  :  52 words$word)) in
     sail2_state_monad$returnS ((words$w2w ((concat_vec ((concat_vec sign exp  :  12 words$word)) frac  :  'N words$word))
               :  'N words$word)))
   else sail2_state_monad$seqS (sail2_state_monad$assert_expS F "((N == 16) || ((N == 32) || (N == 64)))") (sail2_state_monad$exitS () )))`;


(*val FPInfinity : forall 'N . Size 'N => integer -> mword ty1 -> M (mword 'N)*)

val _ = Define `
 ((FPInfinity:int ->(1)words$word ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) (N__tv : int) sign=
    (let p0_ = N__tv in
   if (((p0_ = (( 16 : int):ii)))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "((N == 16) || ((N == 32) || (N == 64)))")
     (let (F1 : int) = ((((( 16 : int):ii) - (( 5 : int):ii))) - (( 1 : int):ii)) in
     let (exp : 5 bits) = ((Ones__0 ((make_the_value (( 5 : int):ii)  :  5 itself))  :  5 words$word)) in
     let (frac : 10 bits) = ((Zeros__0 ((make_the_value F1  :  10 itself))  :  10 words$word)) in
     sail2_state_monad$returnS ((words$w2w ((concat_vec ((concat_vec sign exp  :  6 words$word)) frac  :  'N words$word))
               :  'N words$word)))
   else if (((p0_ = (( 32 : int):ii)))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "((N == 16) || ((N == 32) || (N == 64)))")
     (let (F1 : int) = ((((( 32 : int):ii) - (( 8 : int):ii))) - (( 1 : int):ii)) in
     let (exp : 8 bits) = ((Ones__0 ((make_the_value (( 8 : int):ii)  :  8 itself))  :  8 words$word)) in
     let (frac : 23 bits) = ((Zeros__0 ((make_the_value F1  :  23 itself))  :  23 words$word)) in
     sail2_state_monad$returnS ((words$w2w ((concat_vec ((concat_vec sign exp  :  9 words$word)) frac  :  'N words$word))
               :  'N words$word)))
   else if (((p0_ = (( 64 : int):ii)))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "((N == 16) || ((N == 32) || (N == 64)))")
     (let (F1 : int) = ((((( 64 : int):ii) - (( 11 : int):ii))) - (( 1 : int):ii)) in
     let (exp : 11 bits) = ((Ones__0 ((make_the_value (( 11 : int):ii)  :  11 itself))  :  11 words$word)) in
     let (frac : 52 bits) = ((Zeros__0 ((make_the_value F1  :  52 itself))  :  52 words$word)) in
     sail2_state_monad$returnS ((words$w2w ((concat_vec ((concat_vec sign exp  :  12 words$word)) frac  :  'N words$word))
               :  'N words$word)))
   else sail2_state_monad$seqS (sail2_state_monad$assert_expS F "((N == 16) || ((N == 32) || (N == 64)))") (sail2_state_monad$exitS () )))`;


(*val FPDefaultNaN : forall 'N . Size 'N => integer -> unit -> M (mword 'N)*)

val _ = Define `
 ((FPDefaultNaN:int -> unit ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) (N__tv : int) () =
    (let p0_ = N__tv in
   if (((p0_ = (( 16 : int):ii)))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "((N == 16) || ((N == 32) || (N == 64)))")
     (let (F1 : int) = ((((( 16 : int):ii) - (( 5 : int):ii))) - (( 1 : int):ii)) in
     let (sign : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in
     let (exp : 5 bits) = ((Ones__0 ((make_the_value (( 5 : int):ii)  :  5 itself))  :  5 words$word)) in
     let (frac : 10 bits) =
       ((concat_vec (vec_of_bits [B1]  :  1 words$word)
          ((Zeros__0 ((make_the_value ((F1 - (( 1 : int):ii)))  :  9 itself))  :  9 words$word))
         :  10 words$word)) in
     sail2_state_monad$returnS ((words$w2w
                ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) exp  :  6 words$word)) frac
                   :  'N words$word))
               :  'N words$word)))
   else if (((p0_ = (( 32 : int):ii)))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "((N == 16) || ((N == 32) || (N == 64)))")
     (let (F1 : int) = ((((( 32 : int):ii) - (( 8 : int):ii))) - (( 1 : int):ii)) in
     let (sign : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in
     let (exp : 8 bits) = ((Ones__0 ((make_the_value (( 8 : int):ii)  :  8 itself))  :  8 words$word)) in
     let (frac : 23 bits) =
       ((concat_vec (vec_of_bits [B1]  :  1 words$word)
          ((Zeros__0 ((make_the_value ((F1 - (( 1 : int):ii)))  :  22 itself))  :  22 words$word))
         :  23 words$word)) in
     sail2_state_monad$returnS ((words$w2w
                ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) exp  :  9 words$word)) frac
                   :  'N words$word))
               :  'N words$word)))
   else if (((p0_ = (( 64 : int):ii)))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "((N == 16) || ((N == 32) || (N == 64)))")
     (let (F1 : int) = ((((( 64 : int):ii) - (( 11 : int):ii))) - (( 1 : int):ii)) in
     let (sign : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in
     let (exp : 11 bits) = ((Ones__0 ((make_the_value (( 11 : int):ii)  :  11 itself))  :  11 words$word)) in
     let (frac : 52 bits) =
       ((concat_vec (vec_of_bits [B1]  :  1 words$word)
          ((Zeros__0 ((make_the_value ((F1 - (( 1 : int):ii)))  :  51 itself))  :  51 words$word))
         :  52 words$word)) in
     sail2_state_monad$returnS ((words$w2w
                ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) exp  :  12 words$word)) frac
                   :  'N words$word))
               :  'N words$word)))
   else sail2_state_monad$seqS (sail2_state_monad$assert_expS F "((N == 16) || ((N == 32) || (N == 64)))") (sail2_state_monad$exitS () )))`;


(*val FPConvertNaN : forall 'N 'M . Size 'M, Size 'N => integer -> mword 'N -> M (mword 'M)*)

val _ = Define `
 ((FPConvertNaN:int -> 'N words$word ->(regstate)sail2_state_monad$sequential_state ->((('M words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) (M__tv : int) op=  (sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((((((int_of_num (words$word_len op))) = (( 16 : int):ii)))) \/ ((((((((int_of_num (words$word_len op))) = (( 32 : int):ii)))) \/ (((((int_of_num (words$word_len op))) = (( 64 : int):ii)))))))))) "((N == 16) || ((N == 32) || (N == 64)))")
   (sail2_state_monad$assert_expS ((((((M__tv = (( 16 : int):ii)))) \/ ((((((M__tv = (( 32 : int):ii)))) \/ (((M__tv = (( 64 : int):ii)))))))))) "((M == 16) || ((M == 32) || (M == 64)))"))
   (undefined_bitvector M__tv  : ( 'M words$word) M)) (\ (result : 'M bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 51 : int):ii)  : ( 51 words$word) M) (\ (frac : 51 bits) . 
   let (sign : 1 bits) =
     ((vec_of_bits [access_vec_dec op ((((int_of_num (words$word_len op))) - (( 1 : int):ii)))]  :  1 words$word)) in
   let p0_ = (int_of_num (words$word_len op)) in
   let (frac : 51 bits) =
     (if (((p0_ = (( 64 : int):ii)))) then
       let (op :  64 words$word) = ((words$w2w op  :  64 words$word)) in
       (slice op (( 0 : int):ii) (( 51 : int):ii)  :  51 words$word)
     else if (((p0_ = (( 32 : int):ii)))) then
       let (op :  32 words$word) = ((words$w2w op  :  32 words$word)) in
       (concat_vec ((slice op (( 0 : int):ii) (( 22 : int):ii)  :  22 words$word))
          ((Zeros__0 ((make_the_value (( 29 : int):ii)  :  29 itself))  :  29 words$word))
         :  51 words$word)
     else
       let (op :  16 words$word) = ((words$w2w op  :  16 words$word)) in
       (concat_vec ((slice op (( 0 : int):ii) (( 9 : int):ii)  :  9 words$word))
          ((Zeros__0 ((make_the_value (( 42 : int):ii)  :  42 itself))  :  42 words$word))
         :  51 words$word)) in
   let p0_ = (int_of_num (words$word_len result)) in
   let (result : 'M bits) =
     (if (((p0_ = (( 64 : int):ii)))) then
       (concat_vec
          ((concat_vec sign
              ((Ones__0 ((make_the_value (((( 64 : int):ii) - (( 52 : int):ii))) ))  :  12 words$word))
             :  13 words$word)) frac
         :  'M words$word)
     else if (((p0_ = (( 32 : int):ii)))) then
       (concat_vec
          ((concat_vec sign
              ((Ones__0 ((make_the_value (((( 32 : int):ii) - (( 23 : int):ii))) ))  :  9 words$word))
             :  10 words$word)) ((slice frac (( 29 : int):ii) (( 22 : int):ii)  :  22 words$word))
         :  'M words$word)
     else
       (concat_vec
          ((concat_vec sign
              ((Ones__0 ((make_the_value ((p0_ - (( 10 : int):ii))) ))  :  6 words$word))
             :  7 words$word)) ((slice frac (( 42 : int):ii) (( 9 : int):ii)  :  9 words$word))
         :  'M words$word)) in
   sail2_state_monad$returnS result))))`;


(*val ExcVectorBase : unit -> M (mword ty32)*)

val _ = Define `
 ((ExcVectorBase:unit ->(regstate)sail2_state_monad$sequential_state ->((((32)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (sail2_state_monad$read_regS SCTLR_ref  : ( 32 words$word) M) (\ (w__0 : 32 bits) . 
   if ((((vec_of_bits [access_vec_dec w__0 (( 13 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
     sail2_state_monad$returnS ((concat_vec ((Ones__0 ((make_the_value (( 16 : int):ii)  :  16 itself))  :  16 words$word))
                ((Zeros__0 ((make_the_value (( 16 : int):ii)  :  16 itself))  :  16 words$word))
               :  32 words$word))
   else sail2_state_monad$bindS
     (sail2_state_monad$read_regS VBAR_ref  : ( 32 words$word) M) (\ (w__1 : 32 bits) . 
     sail2_state_monad$returnS ((concat_vec ((slice w__1 (( 5 : int):ii) (( 27 : int):ii)  :  27 words$word))
                ((Zeros__0 ((make_the_value (( 5 : int):ii)  :  5 itself))  :  5 words$word))
               :  32 words$word))))))`;


(*val PACSub : mword ty64 -> M (mword ty64)*)

val _ = Define `
 ((PACSub:(64)words$word ->(regstate)sail2_state_monad$sequential_state ->((((64)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) Tinput=  (sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (Toutput : 64 bits) . 
   let (Toutput : 64 bits) =
     (foreach (index_list (( 0 : int):ii) (( 15 : int):ii) (( 1 : int):ii)) Toutput
       (\ i Toutput . 
         let b__0 = ((slice Tinput (((( 4 : int):ii) * i)) (( 4 : int):ii)  :  4 words$word)) in
         if (((b__0 = (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)))) then
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B1;B0;B1;B1]  :  4 words$word)
             :  64 words$word)
         else if (((b__0 = (vec_of_bits [B0;B0;B0;B1]  :  4 words$word)))) then
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B0;B1;B1;B0]  :  4 words$word)
             :  64 words$word)
         else if (((b__0 = (vec_of_bits [B0;B0;B1;B0]  :  4 words$word)))) then
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B1;B0;B0;B0]  :  4 words$word)
             :  64 words$word)
         else if (((b__0 = (vec_of_bits [B0;B0;B1;B1]  :  4 words$word)))) then
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B1;B1;B1;B1]  :  4 words$word)
             :  64 words$word)
         else if (((b__0 = (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)))) then
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B1;B1;B0;B0]  :  4 words$word)
             :  64 words$word)
         else if (((b__0 = (vec_of_bits [B0;B1;B0;B1]  :  4 words$word)))) then
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)
             :  64 words$word)
         else if (((b__0 = (vec_of_bits [B0;B1;B1;B0]  :  4 words$word)))) then
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B1;B0;B0;B1]  :  4 words$word)
             :  64 words$word)
         else if (((b__0 = (vec_of_bits [B0;B1;B1;B1]  :  4 words$word)))) then
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B1;B1;B1;B0]  :  4 words$word)
             :  64 words$word)
         else if (((b__0 = (vec_of_bits [B1;B0;B0;B0]  :  4 words$word)))) then
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B0;B0;B1;B1]  :  4 words$word)
             :  64 words$word)
         else if (((b__0 = (vec_of_bits [B1;B0;B0;B1]  :  4 words$word)))) then
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B0;B1;B1;B1]  :  4 words$word)
             :  64 words$word)
         else if (((b__0 = (vec_of_bits [B1;B0;B1;B0]  :  4 words$word)))) then
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)
             :  64 words$word)
         else if (((b__0 = (vec_of_bits [B1;B0;B1;B1]  :  4 words$word)))) then
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B0;B1;B0;B1]  :  4 words$word)
             :  64 words$word)
         else if (((b__0 = (vec_of_bits [B1;B1;B0;B0]  :  4 words$word)))) then
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B1;B1;B0;B1]  :  4 words$word)
             :  64 words$word)
         else if (((b__0 = (vec_of_bits [B1;B1;B0;B1]  :  4 words$word)))) then
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B0;B0;B1;B0]  :  4 words$word)
             :  64 words$word)
         else if (((b__0 = (vec_of_bits [B1;B1;B1;B0]  :  4 words$word)))) then
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B0;B0;B0;B1]  :  4 words$word)
             :  64 words$word)
         else
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B1;B0;B1;B0]  :  4 words$word)
             :  64 words$word))) in
   sail2_state_monad$returnS Toutput)))`;


(*val PACMult : mword ty64 -> M (mword ty64)*)

val _ = Define `
 ((PACMult:(64)words$word ->(regstate)sail2_state_monad$sequential_state ->((((64)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) Sinput=  (sail2_state_monad$bindS
   (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (t0 : 4 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (t1 : 4 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (t2 : 4 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (t3 : 4 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (Soutput : 64 bits) .  sail2_state_monad$bindS
   (sail2_state$foreachS (index_list (( 0 : int):ii) (( 3 : int):ii) (( 1 : int):ii)) (Soutput, t0, t1, t2, t3)
     (\ i varstup .  let (Soutput, t0, t1, t2, t3) = varstup in sail2_state_monad$bindS
       (RotCell ((slice Sinput (((( 4 : int):ii) * ((i + (( 8 : int):ii))))) (( 4 : int):ii)  :  4 words$word))
          (( 1 : int):ii)
         : ( 4 words$word) M) (\ (w__0 :  4 words$word) .  sail2_state_monad$bindS
       (RotCell ((slice Sinput (((( 4 : int):ii) * ((i + (( 4 : int):ii))))) (( 4 : int):ii)  :  4 words$word))
          (( 2 : int):ii)
         : ( 4 words$word) M) (\ (w__1 :  4 words$word) . 
       let t0 = ((set_slice (( 4 : int):ii) (( 4 : int):ii) t0 (( 0 : int):ii) ((xor_vec w__0 w__1  :  4 words$word))  :  4 words$word)) in sail2_state_monad$bindS
       (RotCell ((slice Sinput (((( 4 : int):ii) * i)) (( 4 : int):ii)  :  4 words$word)) (( 1 : int):ii)
         : ( 4 words$word) M) (\ (w__2 :  4 words$word) . 
       let t0 =
         ((set_slice (( 4 : int):ii) (( 4 : int):ii) t0 (( 0 : int):ii)
            ((xor_vec ((slice t0 (( 0 : int):ii) (( 4 : int):ii)  :  4 words$word)) w__2  :  4 words$word))
           :  4 words$word)) in sail2_state_monad$bindS
       (RotCell ((slice Sinput (((( 4 : int):ii) * ((i + (( 12 : int):ii))))) (( 4 : int):ii)  :  4 words$word))
          (( 1 : int):ii)
         : ( 4 words$word) M) (\ (w__3 :  4 words$word) .  sail2_state_monad$bindS
       (RotCell ((slice Sinput (((( 4 : int):ii) * ((i + (( 4 : int):ii))))) (( 4 : int):ii)  :  4 words$word))
          (( 1 : int):ii)
         : ( 4 words$word) M) (\ (w__4 :  4 words$word) . 
       let t1 = ((set_slice (( 4 : int):ii) (( 4 : int):ii) t1 (( 0 : int):ii) ((xor_vec w__3 w__4  :  4 words$word))  :  4 words$word)) in sail2_state_monad$bindS
       (RotCell ((slice Sinput (((( 4 : int):ii) * i)) (( 4 : int):ii)  :  4 words$word)) (( 2 : int):ii)
         : ( 4 words$word) M) (\ (w__5 :  4 words$word) . 
       let t1 =
         ((set_slice (( 4 : int):ii) (( 4 : int):ii) t1 (( 0 : int):ii)
            ((xor_vec ((slice t1 (( 0 : int):ii) (( 4 : int):ii)  :  4 words$word)) w__5  :  4 words$word))
           :  4 words$word)) in sail2_state_monad$bindS
       (RotCell ((slice Sinput (((( 4 : int):ii) * ((i + (( 12 : int):ii))))) (( 4 : int):ii)  :  4 words$word))
          (( 2 : int):ii)
         : ( 4 words$word) M) (\ (w__6 :  4 words$word) .  sail2_state_monad$bindS
       (RotCell ((slice Sinput (((( 4 : int):ii) * ((i + (( 8 : int):ii))))) (( 4 : int):ii)  :  4 words$word))
          (( 1 : int):ii)
         : ( 4 words$word) M) (\ (w__7 :  4 words$word) . 
       let t2 = ((set_slice (( 4 : int):ii) (( 4 : int):ii) t2 (( 0 : int):ii) ((xor_vec w__6 w__7  :  4 words$word))  :  4 words$word)) in sail2_state_monad$bindS
       (RotCell ((slice Sinput (((( 4 : int):ii) * i)) (( 4 : int):ii)  :  4 words$word)) (( 1 : int):ii)
         : ( 4 words$word) M) (\ (w__8 :  4 words$word) . 
       let t2 =
         ((set_slice (( 4 : int):ii) (( 4 : int):ii) t2 (( 0 : int):ii)
            ((xor_vec ((slice t2 (( 0 : int):ii) (( 4 : int):ii)  :  4 words$word)) w__8  :  4 words$word))
           :  4 words$word)) in sail2_state_monad$bindS
       (RotCell ((slice Sinput (((( 4 : int):ii) * ((i + (( 12 : int):ii))))) (( 4 : int):ii)  :  4 words$word))
          (( 1 : int):ii)
         : ( 4 words$word) M) (\ (w__9 :  4 words$word) .  sail2_state_monad$bindS
       (RotCell ((slice Sinput (((( 4 : int):ii) * ((i + (( 8 : int):ii))))) (( 4 : int):ii)  :  4 words$word))
          (( 2 : int):ii)
         : ( 4 words$word) M) (\ (w__10 :  4 words$word) . 
       let t3 = ((set_slice (( 4 : int):ii) (( 4 : int):ii) t3 (( 0 : int):ii) ((xor_vec w__9 w__10  :  4 words$word))  :  4 words$word)) in sail2_state_monad$bindS
       (RotCell ((slice Sinput (((( 4 : int):ii) * ((i + (( 4 : int):ii))))) (( 4 : int):ii)  :  4 words$word))
          (( 1 : int):ii)
         : ( 4 words$word) M) (\ (w__11 :  4 words$word) . 
       let (t3 : 4 bits) =
         ((set_slice (( 4 : int):ii) (( 4 : int):ii) t3 (( 0 : int):ii)
            ((xor_vec ((slice t3 (( 0 : int):ii) (( 4 : int):ii)  :  4 words$word)) w__11  :  4 words$word))
           :  4 words$word)) in
       let (Soutput : 64 bits) =
         ((set_slice (( 64 : int):ii) (( 4 : int):ii) Soutput (((( 4 : int):ii) * i))
            ((slice t3 (( 0 : int):ii) (( 4 : int):ii)  :  4 words$word))
           :  64 words$word)) in
       let (Soutput : 64 bits) =
         ((set_slice (( 64 : int):ii) (( 4 : int):ii) Soutput (((( 4 : int):ii) * ((i + (( 4 : int):ii)))))
            ((slice t2 (( 0 : int):ii) (( 4 : int):ii)  :  4 words$word))
           :  64 words$word)) in
       let (Soutput : 64 bits) =
         ((set_slice (( 64 : int):ii) (( 4 : int):ii) Soutput (((( 4 : int):ii) * ((i + (( 8 : int):ii)))))
            ((slice t1 (( 0 : int):ii) (( 4 : int):ii)  :  4 words$word))
           :  64 words$word)) in
       let (Soutput : 64 bits) =
         ((set_slice (( 64 : int):ii) (( 4 : int):ii) Soutput (((( 4 : int):ii) * ((i + (( 12 : int):ii)))))
            ((slice t0 (( 0 : int):ii) (( 4 : int):ii)  :  4 words$word))
           :  64 words$word)) in
       sail2_state_monad$returnS (Soutput, t0, t1, t2, t3))))))))))))))) (\ varstup .  let ((Soutput : 64 bits), (t0 : 4
     bits), (t1 : 4 bits), (t2 : 4 bits), (t3 : 4 bits)) = varstup in
   sail2_state_monad$returnS Soutput))))))))`;


(*val PACInvSub : mword ty64 -> M (mword ty64)*)

val _ = Define `
 ((PACInvSub:(64)words$word ->(regstate)sail2_state_monad$sequential_state ->((((64)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) Tinput=  (sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (Toutput : 64 bits) . 
   let (Toutput : 64 bits) =
     (foreach (index_list (( 0 : int):ii) (( 15 : int):ii) (( 1 : int):ii)) Toutput
       (\ i Toutput . 
         let b__0 = ((slice Tinput (((( 4 : int):ii) * i)) (( 4 : int):ii)  :  4 words$word)) in
         if (((b__0 = (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)))) then
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B0;B1;B0;B1]  :  4 words$word)
             :  64 words$word)
         else if (((b__0 = (vec_of_bits [B0;B0;B0;B1]  :  4 words$word)))) then
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B1;B1;B1;B0]  :  4 words$word)
             :  64 words$word)
         else if (((b__0 = (vec_of_bits [B0;B0;B1;B0]  :  4 words$word)))) then
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B1;B1;B0;B1]  :  4 words$word)
             :  64 words$word)
         else if (((b__0 = (vec_of_bits [B0;B0;B1;B1]  :  4 words$word)))) then
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B1;B0;B0;B0]  :  4 words$word)
             :  64 words$word)
         else if (((b__0 = (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)))) then
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B1;B0;B1;B0]  :  4 words$word)
             :  64 words$word)
         else if (((b__0 = (vec_of_bits [B0;B1;B0;B1]  :  4 words$word)))) then
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B1;B0;B1;B1]  :  4 words$word)
             :  64 words$word)
         else if (((b__0 = (vec_of_bits [B0;B1;B1;B0]  :  4 words$word)))) then
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B0;B0;B0;B1]  :  4 words$word)
             :  64 words$word)
         else if (((b__0 = (vec_of_bits [B0;B1;B1;B1]  :  4 words$word)))) then
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B1;B0;B0;B1]  :  4 words$word)
             :  64 words$word)
         else if (((b__0 = (vec_of_bits [B1;B0;B0;B0]  :  4 words$word)))) then
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B0;B0;B1;B0]  :  4 words$word)
             :  64 words$word)
         else if (((b__0 = (vec_of_bits [B1;B0;B0;B1]  :  4 words$word)))) then
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B0;B1;B1;B0]  :  4 words$word)
             :  64 words$word)
         else if (((b__0 = (vec_of_bits [B1;B0;B1;B0]  :  4 words$word)))) then
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B1;B1;B1;B1]  :  4 words$word)
             :  64 words$word)
         else if (((b__0 = (vec_of_bits [B1;B0;B1;B1]  :  4 words$word)))) then
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)
             :  64 words$word)
         else if (((b__0 = (vec_of_bits [B1;B1;B0;B0]  :  4 words$word)))) then
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)
             :  64 words$word)
         else if (((b__0 = (vec_of_bits [B1;B1;B0;B1]  :  4 words$word)))) then
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B1;B1;B0;B0]  :  4 words$word)
             :  64 words$word)
         else if (((b__0 = (vec_of_bits [B1;B1;B1;B0]  :  4 words$word)))) then
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B0;B1;B1;B1]  :  4 words$word)
             :  64 words$word)
         else
           (set_slice (( 64 : int):ii) (( 4 : int):ii) Toutput (((( 4 : int):ii) * i))
              (vec_of_bits [B0;B0;B1;B1]  :  4 words$word)
             :  64 words$word))) in
   sail2_state_monad$returnS Toutput)))`;


(*val ComputePAC : mword ty64 -> mword ty64 -> mword ty64 -> mword ty64 -> M (mword ty64)*)

val _ = Define `
 ((ComputePAC:(64)words$word ->(64)words$word ->(64)words$word ->(64)words$word ->(regstate)sail2_state_monad$sequential_state ->((((64)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) data modifier key0 key1=  (sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (workingval : 64 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (runningmod : 64 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (roundkey : 64 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (modk0 : 64 bits) .  sail2_state_monad$bindS
   (hex_slice "0xC0AC29B7C97C50DD" (( 64 : int):ii) (( 0 : int):ii)  : ( 64 words$word) M) (\ (Alpha : 64 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS RC_ref) (\ (w__0 : ( 64 words$word) list) .  sail2_state_monad$bindS
   (hex_slice "0x0" (( 64 : int):ii) (( 0 : int):ii)  : ( 64 words$word) M) (\ (w__1 :  64 words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS RC_ref ((update_list_dec w__0 (( 0 : int):ii) w__1  : ( 64 words$word) list)))
   (sail2_state_monad$read_regS RC_ref)) (\ (w__2 : ( 64 words$word) list) .  sail2_state_monad$bindS
   (hex_slice "0x13198A2E03707344" (( 64 : int):ii) (( 0 : int):ii)  : ( 64 words$word) M) (\ (w__3 :  64 words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS RC_ref ((update_list_dec w__2 (( 1 : int):ii) w__3  : ( 64 words$word) list)))
   (sail2_state_monad$read_regS RC_ref)) (\ (w__4 : ( 64 words$word) list) .  sail2_state_monad$bindS
   (hex_slice "0xA493822299F31D0" (( 64 : int):ii) (( 0 : int):ii)  : ( 64 words$word) M) (\ (w__5 :  64 words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS RC_ref ((update_list_dec w__4 (( 2 : int):ii) w__5  : ( 64 words$word) list)))
   (sail2_state_monad$read_regS RC_ref)) (\ (w__6 : ( 64 words$word) list) .  sail2_state_monad$bindS
   (hex_slice "0x82EFA98EC4E6C89" (( 64 : int):ii) (( 0 : int):ii)  : ( 64 words$word) M) (\ (w__7 :  64 words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS RC_ref ((update_list_dec w__6 (( 3 : int):ii) w__7  : ( 64 words$word) list)))
   (sail2_state_monad$read_regS RC_ref)) (\ (w__8 : ( 64 words$word) list) .  sail2_state_monad$bindS
   (hex_slice "0x452821E638D01377" (( 64 : int):ii) (( 0 : int):ii)  : ( 64 words$word) M) (\ (w__9 :  64 words$word) .  sail2_state_monad$seqS
   (sail2_state_monad$write_regS RC_ref ((update_list_dec w__8 (( 4 : int):ii) w__9  : ( 64 words$word) list)))
   (let modk0 =
     ((concat_vec
        ((concat_vec (vec_of_bits [access_vec_dec key0 (( 0 : int):ii)]  :  1 words$word)
            ((slice key0 (( 2 : int):ii) (( 62 : int):ii)  :  62 words$word))
           :  63 words$word))
        ((xor_vec (vec_of_bits [access_vec_dec key0 (( 63 : int):ii)]  :  1 words$word)
            (vec_of_bits [access_vec_dec key0 (( 1 : int):ii)]  :  1 words$word)
           :  1 words$word))
       :  64 words$word)) in
   let runningmod = modifier in
   let workingval = ((xor_vec data key0  :  64 words$word)) in sail2_state_monad$bindS
   (sail2_state$foreachS (index_list (( 0 : int):ii) (( 4 : int):ii) (( 1 : int):ii)) (roundkey, runningmod, workingval)
     (\ i varstup .  let (roundkey, runningmod, workingval) = varstup in
       let roundkey = ((xor_vec key1 runningmod  :  64 words$word)) in
       let workingval = ((xor_vec workingval roundkey  :  64 words$word)) in sail2_state_monad$bindS
       (sail2_state_monad$read_regS RC_ref) (\ (w__10 : ( 64 bits) list) . 
       let workingval = ((xor_vec workingval ((access_list_dec w__10 i  :  64 words$word))  :  64 words$word)) in sail2_state_monad$bindS
       (if ((i > (( 0 : int):ii))) then sail2_state_monad$bindS
          (PACCellShuffle workingval  : ( 64 words$word) M) (\ (w__11 : 64 bits) . 
          let workingval = w__11 in
          (PACMult workingval  : ( 64 words$word) M))
        else sail2_state_monad$returnS workingval) (\ (workingval : 64 bits) .  sail2_state_monad$bindS
       (PACSub workingval  : ( 64 words$word) M) (\ (w__13 : 64 bits) . 
       let workingval = w__13 in sail2_state_monad$bindS
       (TweakShuffle ((slice runningmod (( 0 : int):ii) (( 64 : int):ii)  :  64 words$word))  : ( 64 words$word) M) (\ (w__14 : 64
         bits) . 
       let (runningmod : 64 bits) = w__14 in
       sail2_state_monad$returnS (roundkey, runningmod, workingval))))))) (\ varstup .  let ((roundkey : 64 bits), (runningmod : 64
     bits), (workingval : 64 bits)) = varstup in
   let roundkey = ((xor_vec modk0 runningmod  :  64 words$word)) in
   let workingval = ((xor_vec workingval roundkey  :  64 words$word)) in sail2_state_monad$bindS
   (PACCellShuffle workingval  : ( 64 words$word) M) (\ (w__15 : 64 bits) . 
   let workingval = w__15 in sail2_state_monad$bindS
   (PACMult workingval  : ( 64 words$word) M) (\ (w__16 : 64 bits) . 
   let workingval = w__16 in sail2_state_monad$bindS
   (PACSub workingval  : ( 64 words$word) M) (\ (w__17 : 64 bits) . 
   let workingval = w__17 in sail2_state_monad$bindS
   (PACCellShuffle workingval  : ( 64 words$word) M) (\ (w__18 : 64 bits) . 
   let workingval = w__18 in sail2_state_monad$bindS
   (PACMult workingval  : ( 64 words$word) M) (\ (w__19 : 64 bits) . 
   let workingval = w__19 in
   let workingval = ((xor_vec key1 workingval  :  64 words$word)) in sail2_state_monad$bindS
   (PACCellInvShuffle workingval  : ( 64 words$word) M) (\ (w__20 : 64 bits) . 
   let workingval = w__20 in sail2_state_monad$bindS
   (PACInvSub workingval  : ( 64 words$word) M) (\ (w__21 : 64 bits) . 
   let workingval = w__21 in sail2_state_monad$bindS
   (PACMult workingval  : ( 64 words$word) M) (\ (w__22 : 64 bits) . 
   let workingval = w__22 in sail2_state_monad$bindS
   (PACCellInvShuffle workingval  : ( 64 words$word) M) (\ (w__23 : 64 bits) . 
   let workingval = w__23 in
   let workingval = ((xor_vec workingval key0  :  64 words$word)) in
   let workingval = ((xor_vec workingval runningmod  :  64 words$word)) in sail2_state_monad$bindS
   (sail2_state$foreachS (index_list (( 0 : int):ii) (( 4 : int):ii) (( 1 : int):ii)) (roundkey, runningmod, workingval)
     (\ i varstup .  let (roundkey, runningmod, workingval) = varstup in sail2_state_monad$bindS
       (PACInvSub workingval  : ( 64 words$word) M) (\ (w__24 : 64 bits) . 
       let workingval = w__24 in sail2_state_monad$bindS
       (if ((i < (( 4 : int):ii))) then sail2_state_monad$bindS
          (PACMult workingval  : ( 64 words$word) M) (\ (w__25 : 64 bits) . 
          let workingval = w__25 in
          (PACCellInvShuffle workingval  : ( 64 words$word) M))
        else sail2_state_monad$returnS workingval) (\ (workingval : 64 bits) .  sail2_state_monad$bindS
       (TweakInvShuffle ((slice runningmod (( 0 : int):ii) (( 64 : int):ii)  :  64 words$word))  : ( 64 words$word) M) (\ (w__27 : 64
         bits) . 
       let runningmod = w__27 in
       let roundkey = ((xor_vec key1 runningmod  :  64 words$word)) in sail2_state_monad$bindS
       (sail2_state_monad$read_regS RC_ref) (\ (w__28 : ( 64 bits) list) . 
       let (workingval : 64 bits) =
         ((xor_vec workingval ((access_list_dec w__28 (((( 4 : int):ii) - i))  :  64 words$word))
           :  64 words$word)) in
       let (workingval : 64 bits) = ((xor_vec workingval roundkey  :  64 words$word)) in
       let (workingval : 64 bits) = ((xor_vec workingval Alpha  :  64 words$word)) in
       sail2_state_monad$returnS (roundkey, runningmod, workingval))))))) (\ varstup .  let ((roundkey : 64 bits), (runningmod : 64
     bits), (workingval : 64 bits)) = varstup in
   let (workingval : 64 bits) = ((xor_vec workingval modk0  :  64 words$word)) in
   sail2_state_monad$returnS workingval)))))))))))))))))))))))))))))`;


(*val Align__0 : ii -> ii -> ii*)

(*val Align__1 : forall 'N . Size 'N => mword 'N -> ii -> mword 'N*)

val _ = Define `
 ((Align__0:int -> int -> int) x y=  (y * ((x / y))))`;


val _ = Define `
 ((Align__1:'N words$word -> int -> 'N words$word) x y=
    ((GetSlice_int ((make_the_value ((int_of_num (words$word_len x)))  :  'N itself)) ((Align__0 ((lem$w2ui x)) y)) (( 0 : int):ii)
     :  'N words$word)))`;


(*val aset__Mem : forall   'p8_times_size_ . Size 'p8_times_size_ => AddressDescriptor -> integer -> AccessDescriptor -> mword 'p8_times_size_ -> M unit*)

val _ = Define `
 ((aset__Mem:AddressDescriptor -> int -> AccessDescriptor -> 'p8_times_size_ words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) desc size1 accdesc value_name=  (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((((size1 = (( 1 : int):ii)))) \/ ((((((size1 = (( 2 : int):ii)))) \/ ((((((size1 = (( 4 : int):ii)))) \/ ((((((size1 = (( 8 : int):ii)))) \/ (((size1 = (( 16 : int):ii)))))))))))))))) "((size == 1) || ((size == 2) || ((size == 4) || ((size == 8) || (size == 16)))))")
   (let (address : 52 bits) = (desc.AddressDescriptor_paddress.FullAddress_physicaladdress) in sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS (((address = ((Align__1 address size1  :  52 words$word))))) "(address == Align(address, size))")
   (hex_slice "0x13000000" (( 52 : int):ii) (( 0 : int):ii)  : ( 52 words$word) M)) (\ (w__0 :  52 words$word) . 
   if (((address = w__0))) then
     if (((((lem$w2ui value_name)) = (( 4 : int):ii)))) then
       let (_ : unit) = (prerr "Program exited by writing ^^D to TUBE\n") in
       sail2_state_monad$exitS () 
     else sail2_state_monad$returnS ((putchar ((lem$w2ui ((slice value_name (( 0 : int):ii) (( 8 : int):ii)  :  8 words$word))))))
   else sail2_state_monad$bindS
     (sail2_state_monad$read_regS Memory_ref  : ( 52 words$word) M) (\ (w__1 :  52 words$word) . 
     WriteRAM ((make_the_value (( 52 : int):ii)  :  52 itself)) size1 w__1 address value_name)))))`;


(*val aget__Mem : forall   'p8_times_size_ . Size 'p8_times_size_ => AddressDescriptor -> integer -> AccessDescriptor -> M (mword 'p8_times_size_)*)

val _ = Define `
 ((aget__Mem:AddressDescriptor -> int -> AccessDescriptor ->(regstate)sail2_state_monad$sequential_state ->((('p8_times_size_ words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) desc size1 accdesc=  (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((((size1 = (( 1 : int):ii)))) \/ ((((((size1 = (( 2 : int):ii)))) \/ ((((((size1 = (( 4 : int):ii)))) \/ ((((((size1 = (( 8 : int):ii)))) \/ (((size1 = (( 16 : int):ii)))))))))))))))) "((size == 1) || ((size == 2) || ((size == 4) || ((size == 8) || (size == 16)))))")
   (let (address : 52 bits) = (desc.AddressDescriptor_paddress.FullAddress_physicaladdress) in sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS (((address = ((Align__1 address size1  :  52 words$word))))) "(address == Align(address, size))")
   (sail2_state_monad$read_regS Memory_ref  : ( 52 words$word) M)) (\ (w__0 :  52 words$word) . 
   (ReadRAM ((make_the_value (( 52 : int):ii)  :  52 itself)) size1 w__0 address
     : ( 'p8_times_size_ words$word) M)))))`;


(*val aset_X : forall 'width . Size 'width => ii -> mword 'width -> M unit*)

val _ = Define `
 ((aset_X:int -> 'width words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) n value_name=  (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS (((((n >= (( 0 : int):ii))) /\ ((n <= (( 31 : int):ii)))))) "((n >= 0) && (n <= 31))")
   (sail2_state_monad$assert_expS ((((((((int_of_num (words$word_len value_name))) = (( 32 : int):ii)))) \/ (((((int_of_num (words$word_len value_name))) = (( 64 : int):ii))))))) "((width == 32) || (width == 64))"))
   (if (((n <> (( 31 : int):ii)))) then sail2_state_monad$bindS
     (sail2_state_monad$read_regS R_ref) (\ (w__0 : ( 64 words$word) list) .  sail2_state_monad$bindS
     (ZeroExtend__0 value_name ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__1 :
        64 words$word) . 
     sail2_state_monad$write_regS R_ref ((update_list_dec w__0 n w__1  : ( 64 words$word) list))))
   else sail2_state_monad$returnS () )))`;


(*val aarch64_integer_arithmetic_address_pcrel : ii -> mword ty64 -> bool -> M unit*)

val _ = Define `
 ((aarch64_integer_arithmetic_address_pcrel:int ->(64)words$word -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d imm page=  (sail2_state_monad$bindS
   (aget_PC ()   : ( 64 words$word) M) (\ (base : 64 bits) . 
   let (base : 64 bits) =
     (if page then
       (set_slice (( 64 : int):ii) (( 12 : int):ii) base (( 0 : int):ii)
          ((Zeros__0 ((make_the_value (( 12 : int):ii)  :  12 itself))  :  12 words$word))
         :  64 words$word)
     else base) in
   aset_X d ((add_vec base imm  :  64 words$word)))))`;


(*val integer_arithmetic_address_pcrel_decode : mword ty1 -> mword ty2 -> mword ty19 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_arithmetic_address_pcrel_decode:(1)words$word ->(2)words$word ->(19)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) op immlo immhi Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (d : ii) = (lem$w2ui Rd) in
   let (page : bool) = (op = (vec_of_bits [B1]  :  1 words$word)) in sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (imm : 64 bits) .  sail2_state_monad$bindS
   (if page then
      (SignExtend__0
         ((concat_vec ((concat_vec immhi immlo  :  21 words$word))
             ((Zeros__0 ((make_the_value (( 12 : int):ii)  :  12 itself))  :  12 words$word))
            :  33 words$word)) ((make_the_value (( 64 : int):ii)  :  64 itself))
        : ( 64 words$word) M)
    else
      (SignExtend__0 ((concat_vec immhi immlo  :  21 words$word))
         ((make_the_value (( 64 : int):ii)  :  64 itself))
        : ( 64 words$word) M)) (\ (imm : 64 bits) . 
   aarch64_integer_arithmetic_address_pcrel d imm page)))))`;


(*val AArch64_ResetGeneralRegisters : unit -> M unit*)

val _ = Define `
 ((AArch64_ResetGeneralRegisters:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$foreachS (index_list (( 0 : int):ii) (( 30 : int):ii) (( 1 : int):ii)) () 
     (\ i unit_var .  sail2_state_monad$bindS
       (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (w__0 : 64 bits) .  aset_X i w__0))))`;


(*val aset_ELR__0 : mword ty2 -> mword ty64 -> M unit*)

(*val aset_ELR__1 : mword ty64 -> M unit*)

val _ = Define `
 ((aset_ELR__0:(2)words$word ->(64)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) el value_name=
    (let (r : 64 bits) = value_name in
   let pat_0 = el in
   if (((pat_0 = EL1))) then sail2_state_monad$write_regS ELR_EL1_ref r
   else if (((pat_0 = EL2))) then sail2_state_monad$write_regS ELR_EL2_ref r
   else if (((pat_0 = EL3))) then sail2_state_monad$write_regS ELR_EL3_ref r
   else Unreachable () ))`;


val _ = Define `
 ((aset_ELR__1:(64)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) value_name=  (sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS (((w__0.ProcState_EL <> EL0))) "")
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__1 : ProcState) .  aset_ELR__0 w__1.ProcState_EL value_name))))`;


(*val aget_X : forall 'width . Size 'width => integer -> ii -> M (mword 'width)*)

val _ = Define `
 ((aget_X:int -> int ->(regstate)sail2_state_monad$sequential_state ->((('width words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) (width__tv : int) n=  (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS (((((n >= (( 0 : int):ii))) /\ ((n <= (( 31 : int):ii)))))) "((n >= 0) && (n <= 31))")
   (sail2_state_monad$assert_expS ((((((width__tv = (( 8 : int):ii)))) \/ ((((((width__tv = (( 16 : int):ii)))) \/ ((((((width__tv = (( 32 : int):ii)))) \/ (((width__tv = (( 64 : int):ii))))))))))))) "((width == 8) || ((width == 16) || ((width == 32) || (width == 64))))"))
   (if (((n <> (( 31 : int):ii)))) then sail2_state_monad$bindS
     (sail2_state_monad$read_regS R_ref) (\ (w__0 : ( 64 bits) list) . 
     sail2_state_monad$returnS ((slice ((access_list_dec w__0 n  :  64 words$word)) (( 0 : int):ii) width__tv  :  'width words$word)))
   else sail2_state_monad$returnS ((Zeros__0 ((make_the_value width__tv  :  'width itself))  :  'width words$word)))))`;


(*val aarch64_system_sysops : bool -> ii -> ii -> ii -> ii -> ii -> ii -> M unit*)

val _ = Define `
 ((aarch64_system_sysops:bool -> int -> int -> int -> int -> int -> int ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) has_result sys_crm sys_crn sys_op0 sys_op1 sys_op2 t=
    (if has_result then sail2_state_monad$bindS
     (AArch64_SysInstrWithResult sys_op0 sys_op1 sys_crn sys_crm sys_op2  : ( 64 words$word) M) (\ (w__0 :
        64 words$word) . 
     aset_X t w__0)
   else sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) t  : ( 64 words$word) M) (\ (w__1 :  64 words$word) . 
     AArch64_SysInstr sys_op0 sys_op1 sys_crn sys_crm sys_op2 w__1)))`;


(*val aarch64_system_register_system : bool -> ii -> ii -> ii -> ii -> ii -> ii -> M unit*)

val _ = Define `
 ((aarch64_system_register_system:bool -> int -> int -> int -> int -> int -> int ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) read sys_crm sys_crn sys_op0 sys_op1 sys_op2 t=
    (if read then sail2_state_monad$bindS
     (AArch64_SysRegRead sys_op0 sys_op1 sys_crn sys_crm sys_op2  : ( 64 words$word) M) (\ (w__0 :
        64 words$word) . 
     aset_X t w__0)
   else sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) t  : ( 64 words$word) M) (\ (w__1 :  64 words$word) . 
     AArch64_SysRegWrite sys_op0 sys_op1 sys_crn sys_crm sys_op2 w__1)))`;


(*val aarch64_integer_insext_insert_movewide : ii -> ii -> mword ty16 -> MoveWideOp -> ii -> M unit*)

val _ = Define `
 ((aarch64_integer_insext_insert_movewide:int -> int ->(16)words$word -> MoveWideOp -> int ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d l__267 imm opcode pos=
    (if (((l__267 = (( 8 : int):ii)))) then
     let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M)) (\ (result : 8 bits) .  sail2_state_monad$bindS
     (if (((opcode = MoveWideOp_K))) then (aget_X (( 8 : int):ii) d  : ( 8 words$word) M)
      else
        let (result : 8 bits) = ((Zeros__1 (( 8 : int):ii) ()   :  8 words$word)) in
        sail2_state_monad$returnS result) (\ (result : 8 bits) . 
     let result = ((set_slice (( 8 : int):ii) (( 16 : int):ii) result pos imm  :  8 words$word)) in
     let (result : 8 bits) =
       (if (((opcode = MoveWideOp_N))) then (not_vec result  :  8 words$word)
       else result) in
     aset_X d result))
   else if (((l__267 = (( 16 : int):ii)))) then
     let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M)) (\ (result : 16 bits) .  sail2_state_monad$bindS
     (if (((opcode = MoveWideOp_K))) then (aget_X (( 16 : int):ii) d  : ( 16 words$word) M)
      else
        let (result : 16 bits) = ((Zeros__1 (( 16 : int):ii) ()   :  16 words$word)) in
        sail2_state_monad$returnS result) (\ (result : 16 bits) . 
     let result = ((set_slice (( 16 : int):ii) (( 16 : int):ii) result pos imm  :  16 words$word)) in
     let (result : 16 bits) =
       (if (((opcode = MoveWideOp_N))) then (not_vec result  :  16 words$word)
       else result) in
     aset_X d result))
   else if (((l__267 = (( 32 : int):ii)))) then
     let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (result : 32 bits) .  sail2_state_monad$bindS
     (if (((opcode = MoveWideOp_K))) then (aget_X (( 32 : int):ii) d  : ( 32 words$word) M)
      else
        let (result : 32 bits) = ((Zeros__1 (( 32 : int):ii) ()   :  32 words$word)) in
        sail2_state_monad$returnS result) (\ (result : 32 bits) . 
     let result = ((set_slice (( 32 : int):ii) (( 16 : int):ii) result pos imm  :  32 words$word)) in
     let (result : 32 bits) =
       (if (((opcode = MoveWideOp_N))) then (not_vec result  :  32 words$word)
       else result) in
     aset_X d result))
   else if (((l__267 = (( 64 : int):ii)))) then
     let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (result : 64 bits) .  sail2_state_monad$bindS
     (if (((opcode = MoveWideOp_K))) then (aget_X (( 64 : int):ii) d  : ( 64 words$word) M)
      else
        let (result : 64 bits) = ((Zeros__1 (( 64 : int):ii) ()   :  64 words$word)) in
        sail2_state_monad$returnS result) (\ (result : 64 bits) . 
     let result = ((set_slice (( 64 : int):ii) (( 16 : int):ii) result pos imm  :  64 words$word)) in
     let (result : 64 bits) =
       (if (((opcode = MoveWideOp_N))) then (not_vec result  :  64 words$word)
       else result) in
     aset_X d result))
   else if (((l__267 = (( 128 : int):ii)))) then
     let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M)) (\ (result : 128 bits) .  sail2_state_monad$bindS
     (if (((opcode = MoveWideOp_K))) then (aget_X (( 128 : int):ii) d  : ( 128 words$word) M)
      else
        let (result : 128 bits) = ((Zeros__1 (( 128 : int):ii) ()   :  128 words$word)) in
        sail2_state_monad$returnS result) (\ (result : 128 bits) . 
     let result = ((set_slice (( 128 : int):ii) (( 16 : int):ii) result pos imm  :  128 words$word)) in
     let (result : 128 bits) =
       (if (((opcode = MoveWideOp_N))) then (not_vec result  :  128 words$word)
       else result) in
     aset_X d result))
   else
     let dbytes = (ex_int ((l__267 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint"))`;


(*val aarch64_integer_insext_extract_immediate : ii -> ii -> ii -> ii -> ii -> M unit*)

val _ = Define `
 ((aarch64_integer_insext_extract_immediate:int -> int -> int -> int -> int ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d l__262 lsb m n=
    (if (((l__262 = (( 8 : int):ii)))) then
     let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M)) (\ (result : 8 bits) .  sail2_state_monad$bindS
     (aget_X (( 8 : int):ii) n  : ( 8 words$word) M) (\ (operand1 : 8 bits) .  sail2_state_monad$bindS
     (aget_X (( 8 : int):ii) m  : ( 8 words$word) M) (\ (operand2 : 8 bits) . 
     let (concat1 : 16 bits) = ((concat_vec operand1 operand2  :  16 words$word)) in
     let result = ((slice concat1 lsb (( 8 : int):ii)  :  8 words$word)) in
     aset_X d result)))
   else if (((l__262 = (( 16 : int):ii)))) then
     let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M)) (\ (result : 16 bits) .  sail2_state_monad$bindS
     (aget_X (( 16 : int):ii) n  : ( 16 words$word) M) (\ (operand1 : 16 bits) .  sail2_state_monad$bindS
     (aget_X (( 16 : int):ii) m  : ( 16 words$word) M) (\ (operand2 : 16 bits) . 
     let (concat1 : 32 bits) = ((concat_vec operand1 operand2  :  32 words$word)) in
     let result = ((slice concat1 lsb (( 16 : int):ii)  :  16 words$word)) in
     aset_X d result)))
   else if (((l__262 = (( 32 : int):ii)))) then
     let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (result : 32 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) n  : ( 32 words$word) M) (\ (operand1 : 32 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) m  : ( 32 words$word) M) (\ (operand2 : 32 bits) . 
     let (concat1 : 64 bits) = ((concat_vec operand1 operand2  :  64 words$word)) in
     let result = ((slice concat1 lsb (( 32 : int):ii)  :  32 words$word)) in
     aset_X d result)))
   else if (((l__262 = (( 64 : int):ii)))) then
     let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (result : 64 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) n  : ( 64 words$word) M) (\ (operand1 : 64 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) m  : ( 64 words$word) M) (\ (operand2 : 64 bits) . 
     let (concat1 : 128 bits) = ((concat_vec operand1 operand2  :  128 words$word)) in
     let result = ((slice concat1 lsb (( 64 : int):ii)  :  64 words$word)) in
     aset_X d result)))
   else if (((l__262 = (( 128 : int):ii)))) then
     let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M)) (\ (result : 128 bits) .  sail2_state_monad$bindS
     (aget_X (( 128 : int):ii) n  : ( 128 words$word) M) (\ (operand1 : 128 bits) .  sail2_state_monad$bindS
     (aget_X (( 128 : int):ii) m  : ( 128 words$word) M) (\ (operand2 : 128 bits) . 
     let (concat1 : 256 bits) = ((concat_vec operand1 operand2  :  256 words$word)) in
     let result = ((slice concat1 lsb (( 128 : int):ii)  :  128 words$word)) in
     aset_X d result)))
   else
     let dbytes = (ex_int ((l__262 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint"))`;


(*val aarch64_integer_arithmetic_rev : ii -> ii -> ii -> ii -> M unit*)

val _ = Define `
 ((aarch64_integer_arithmetic_rev:int -> int -> int -> int ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) container_size d l__257 n=
    (if (((l__257 = (( 8 : int):ii)))) then
     let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 8 : int):ii) n  : ( 8 words$word) M)) (\ (operand : 8 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M) (\ (result : 8 bits) . 
     let (containers : ii) = ((( 8 : int):ii) / container_size) in
     let (elements_per_container : ii) = (container_size / (( 8 : int):ii)) in
     let (index : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (rev_index : ii) . 
     let ((index : ii), (result : 8 bits), (rev_index : ii)) =
       (foreach (index_list (( 0 : int):ii) ((((ex_int containers)) - (( 1 : int):ii))) (( 1 : int):ii)) (index,
                                                                                          result,
                                                                                          rev_index)
         (\ c varstup .  let (index, result, rev_index) = varstup in
           let (rev_index : ii) =
             (((ex_int index)) +
               ((((((ex_int elements_per_container)) - (( 1 : int):ii))) * (( 8 : int):ii)))) in
           let ((index : ii), (result : 8 bits), (rev_index : ii)) =
             (foreach (index_list (( 0 : int):ii) ((((ex_int elements_per_container)) - (( 1 : int):ii))) (( 1 : int):ii)) (index,
                                                                                                            result,
                                                                                                            rev_index)
               (\ e varstup .  let (index, result, rev_index) = varstup in
                 let (result : 8 bits) =
                   ((set_slice (( 8 : int):ii) (( 8 : int):ii) result rev_index
                      ((slice operand index (( 8 : int):ii)  :  8 words$word))
                     :  8 words$word)) in
                 let (index : ii) = (((ex_int index)) + (( 8 : int):ii)) in
                 let (rev_index : ii) = (((ex_int rev_index)) - (( 8 : int):ii)) in
                 (index, result, rev_index))) in
           (index, result, rev_index))) in
     aset_X d result)))
   else if (((l__257 = (( 16 : int):ii)))) then
     let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 16 : int):ii) n  : ( 16 words$word) M)) (\ (operand : 16 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M) (\ (result : 16 bits) . 
     let (containers : ii) = ((( 16 : int):ii) / container_size) in
     let (elements_per_container : ii) = (container_size / (( 8 : int):ii)) in
     let (index : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (rev_index : ii) . 
     let ((index : ii), (result : 16 bits), (rev_index : ii)) =
       (foreach (index_list (( 0 : int):ii) ((((ex_int containers)) - (( 1 : int):ii))) (( 1 : int):ii)) (index,
                                                                                          result,
                                                                                          rev_index)
         (\ c varstup .  let (index, result, rev_index) = varstup in
           let (rev_index : ii) =
             (((ex_int index)) +
               ((((((ex_int elements_per_container)) - (( 1 : int):ii))) * (( 8 : int):ii)))) in
           let ((index : ii), (result : 16 bits), (rev_index : ii)) =
             (foreach (index_list (( 0 : int):ii) ((((ex_int elements_per_container)) - (( 1 : int):ii))) (( 1 : int):ii)) (index,
                                                                                                            result,
                                                                                                            rev_index)
               (\ e varstup .  let (index, result, rev_index) = varstup in
                 let (result : 16 bits) =
                   ((set_slice (( 16 : int):ii) (( 8 : int):ii) result rev_index
                      ((slice operand index (( 8 : int):ii)  :  8 words$word))
                     :  16 words$word)) in
                 let (index : ii) = (((ex_int index)) + (( 8 : int):ii)) in
                 let (rev_index : ii) = (((ex_int rev_index)) - (( 8 : int):ii)) in
                 (index, result, rev_index))) in
           (index, result, rev_index))) in
     aset_X d result)))
   else if (((l__257 = (( 32 : int):ii)))) then
     let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 32 : int):ii) n  : ( 32 words$word) M)) (\ (operand : 32 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (result : 32 bits) . 
     let (containers : ii) = ((( 32 : int):ii) / container_size) in
     let (elements_per_container : ii) = (container_size / (( 8 : int):ii)) in
     let (index : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (rev_index : ii) . 
     let ((index : ii), (result : 32 bits), (rev_index : ii)) =
       (foreach (index_list (( 0 : int):ii) ((((ex_int containers)) - (( 1 : int):ii))) (( 1 : int):ii)) (index,
                                                                                          result,
                                                                                          rev_index)
         (\ c varstup .  let (index, result, rev_index) = varstup in
           let (rev_index : ii) =
             (((ex_int index)) +
               ((((((ex_int elements_per_container)) - (( 1 : int):ii))) * (( 8 : int):ii)))) in
           let ((index : ii), (result : 32 bits), (rev_index : ii)) =
             (foreach (index_list (( 0 : int):ii) ((((ex_int elements_per_container)) - (( 1 : int):ii))) (( 1 : int):ii)) (index,
                                                                                                            result,
                                                                                                            rev_index)
               (\ e varstup .  let (index, result, rev_index) = varstup in
                 let (result : 32 bits) =
                   ((set_slice (( 32 : int):ii) (( 8 : int):ii) result rev_index
                      ((slice operand index (( 8 : int):ii)  :  8 words$word))
                     :  32 words$word)) in
                 let (index : ii) = (((ex_int index)) + (( 8 : int):ii)) in
                 let (rev_index : ii) = (((ex_int rev_index)) - (( 8 : int):ii)) in
                 (index, result, rev_index))) in
           (index, result, rev_index))) in
     aset_X d result)))
   else if (((l__257 = (( 64 : int):ii)))) then
     let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (operand : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (result : 64 bits) . 
     let (containers : ii) = ((( 64 : int):ii) / container_size) in
     let (elements_per_container : ii) = (container_size / (( 8 : int):ii)) in
     let (index : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (rev_index : ii) . 
     let ((index : ii), (result : 64 bits), (rev_index : ii)) =
       (foreach (index_list (( 0 : int):ii) ((((ex_int containers)) - (( 1 : int):ii))) (( 1 : int):ii)) (index,
                                                                                          result,
                                                                                          rev_index)
         (\ c varstup .  let (index, result, rev_index) = varstup in
           let (rev_index : ii) =
             (((ex_int index)) +
               ((((((ex_int elements_per_container)) - (( 1 : int):ii))) * (( 8 : int):ii)))) in
           let ((index : ii), (result : 64 bits), (rev_index : ii)) =
             (foreach (index_list (( 0 : int):ii) ((((ex_int elements_per_container)) - (( 1 : int):ii))) (( 1 : int):ii)) (index,
                                                                                                            result,
                                                                                                            rev_index)
               (\ e varstup .  let (index, result, rev_index) = varstup in
                 let (result : 64 bits) =
                   ((set_slice (( 64 : int):ii) (( 8 : int):ii) result rev_index
                      ((slice operand index (( 8 : int):ii)  :  8 words$word))
                     :  64 words$word)) in
                 let (index : ii) = (((ex_int index)) + (( 8 : int):ii)) in
                 let (rev_index : ii) = (((ex_int rev_index)) - (( 8 : int):ii)) in
                 (index, result, rev_index))) in
           (index, result, rev_index))) in
     aset_X d result)))
   else if (((l__257 = (( 128 : int):ii)))) then
     let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 128 : int):ii) n  : ( 128 words$word) M)) (\ (operand : 128 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M) (\ (result : 128 bits) . 
     let (containers : ii) = ((( 128 : int):ii) / container_size) in
     let (elements_per_container : ii) = (container_size / (( 8 : int):ii)) in
     let (index : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (rev_index : ii) . 
     let ((index : ii), (result : 128 bits), (rev_index : ii)) =
       (foreach (index_list (( 0 : int):ii) ((((ex_int containers)) - (( 1 : int):ii))) (( 1 : int):ii)) (index,
                                                                                          result,
                                                                                          rev_index)
         (\ c varstup .  let (index, result, rev_index) = varstup in
           let (rev_index : ii) =
             (((ex_int index)) +
               ((((((ex_int elements_per_container)) - (( 1 : int):ii))) * (( 8 : int):ii)))) in
           let ((index : ii), (result : 128 bits), (rev_index : ii)) =
             (foreach (index_list (( 0 : int):ii) ((((ex_int elements_per_container)) - (( 1 : int):ii))) (( 1 : int):ii)) (index,
                                                                                                            result,
                                                                                                            rev_index)
               (\ e varstup .  let (index, result, rev_index) = varstup in
                 let (result : 128 bits) =
                   ((set_slice (( 128 : int):ii) (( 8 : int):ii) result rev_index
                      ((slice operand index (( 8 : int):ii)  :  8 words$word))
                     :  128 words$word)) in
                 let (index : ii) = (((ex_int index)) + (( 8 : int):ii)) in
                 let (rev_index : ii) = (((ex_int rev_index)) - (( 8 : int):ii)) in
                 (index, result, rev_index))) in
           (index, result, rev_index))) in
     aset_X d result)))
   else
     let dbytes = (ex_int ((l__257 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint"))`;


(*val aarch64_integer_arithmetic_rbit : ii -> ii -> ii -> M unit*)

val _ = Define `
 ((aarch64_integer_arithmetic_rbit:int -> int -> int ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d l__252 n=
    (if (((l__252 = (( 8 : int):ii)))) then
     let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 8 : int):ii) n  : ( 8 words$word) M)) (\ (operand : 8 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M) (\ (result : 8 bits) . 
     let (result : 8 bits) =
       (foreach (index_list (( 0 : int):ii) (((( 8 : int):ii) - (( 1 : int):ii))) (( 1 : int):ii)) result
         (\ i result . 
           (set_slice (( 8 : int):ii) (( 1 : int):ii) result (((((( 8 : int):ii) - (( 1 : int):ii))) - i))
              (vec_of_bits [access_vec_dec operand i]  :  1 words$word)
             :  8 words$word))) in
     aset_X d result))
   else if (((l__252 = (( 16 : int):ii)))) then
     let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 16 : int):ii) n  : ( 16 words$word) M)) (\ (operand : 16 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M) (\ (result : 16 bits) . 
     let (result : 16 bits) =
       (foreach (index_list (( 0 : int):ii) (((( 16 : int):ii) - (( 1 : int):ii))) (( 1 : int):ii)) result
         (\ i result . 
           (set_slice (( 16 : int):ii) (( 1 : int):ii) result (((((( 16 : int):ii) - (( 1 : int):ii))) - i))
              (vec_of_bits [access_vec_dec operand i]  :  1 words$word)
             :  16 words$word))) in
     aset_X d result))
   else if (((l__252 = (( 32 : int):ii)))) then
     let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 32 : int):ii) n  : ( 32 words$word) M)) (\ (operand : 32 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (result : 32 bits) . 
     let (result : 32 bits) =
       (foreach (index_list (( 0 : int):ii) (((( 32 : int):ii) - (( 1 : int):ii))) (( 1 : int):ii)) result
         (\ i result . 
           (set_slice (( 32 : int):ii) (( 1 : int):ii) result (((((( 32 : int):ii) - (( 1 : int):ii))) - i))
              (vec_of_bits [access_vec_dec operand i]  :  1 words$word)
             :  32 words$word))) in
     aset_X d result))
   else if (((l__252 = (( 64 : int):ii)))) then
     let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (operand : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (result : 64 bits) . 
     let (result : 64 bits) =
       (foreach (index_list (( 0 : int):ii) (((( 64 : int):ii) - (( 1 : int):ii))) (( 1 : int):ii)) result
         (\ i result . 
           (set_slice (( 64 : int):ii) (( 1 : int):ii) result (((((( 64 : int):ii) - (( 1 : int):ii))) - i))
              (vec_of_bits [access_vec_dec operand i]  :  1 words$word)
             :  64 words$word))) in
     aset_X d result))
   else if (((l__252 = (( 128 : int):ii)))) then
     let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 128 : int):ii) n  : ( 128 words$word) M)) (\ (operand : 128 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M) (\ (result : 128 bits) . 
     let (result : 128 bits) =
       (foreach (index_list (( 0 : int):ii) (((( 128 : int):ii) - (( 1 : int):ii))) (( 1 : int):ii)) result
         (\ i result . 
           (set_slice (( 128 : int):ii) (( 1 : int):ii) result (((((( 128 : int):ii) - (( 1 : int):ii))) - i))
              (vec_of_bits [access_vec_dec operand i]  :  1 words$word)
             :  128 words$word))) in
     aset_X d result))
   else
     let dbytes = (ex_int ((l__252 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint"))`;


(*val integer_arithmetic_rbit_decode : mword ty1 -> mword ty1 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_arithmetic_rbit_decode:(1)words$word ->(1)words$word ->(5)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) sf S1 opcode2 Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in
   let (datasize : int) =
     (if (((sf = (vec_of_bits [B1]  :  1 words$word)))) then (( 64 : int):ii)
     else (( 32 : int):ii)) in
   aarch64_integer_arithmetic_rbit d datasize n)))`;


(*val aarch64_integer_arithmetic_mul_widening_64128hi : ii -> ii -> ii -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_integer_arithmetic_mul_widening_64128hi:int -> int -> int -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d l__247 m n unsigned=
    (if (((l__247 = (( 8 : int):ii)))) then
     let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 8 : int):ii) n  : ( 8 words$word) M)) (\ (operand1 : 8 bits) .  sail2_state_monad$bindS
     (aget_X (( 8 : int):ii) m  : ( 8 words$word) M) (\ (operand2 : 8 bits) . 
     let (result : ii) =
       (((ex_int ((asl_Int operand1 unsigned)))) * ((ex_int ((asl_Int operand2 unsigned))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 : int):ii)  :  64 itself)) result (( 64 : int):ii)  :  64 words$word))))
   else if (((l__247 = (( 16 : int):ii)))) then
     let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 16 : int):ii) n  : ( 16 words$word) M)) (\ (operand1 : 16 bits) .  sail2_state_monad$bindS
     (aget_X (( 16 : int):ii) m  : ( 16 words$word) M) (\ (operand2 : 16 bits) . 
     let (result : ii) =
       (((ex_int ((asl_Int operand1 unsigned)))) * ((ex_int ((asl_Int operand2 unsigned))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 : int):ii)  :  64 itself)) result (( 64 : int):ii)  :  64 words$word))))
   else if (((l__247 = (( 32 : int):ii)))) then
     let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 32 : int):ii) n  : ( 32 words$word) M)) (\ (operand1 : 32 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) m  : ( 32 words$word) M) (\ (operand2 : 32 bits) . 
     let (result : ii) =
       (((ex_int ((asl_Int operand1 unsigned)))) * ((ex_int ((asl_Int operand2 unsigned))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 : int):ii)  :  64 itself)) result (( 64 : int):ii)  :  64 words$word))))
   else if (((l__247 = (( 64 : int):ii)))) then
     let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (operand1 : 64 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) m  : ( 64 words$word) M) (\ (operand2 : 64 bits) . 
     let (result : ii) =
       (((ex_int ((asl_Int operand1 unsigned)))) * ((ex_int ((asl_Int operand2 unsigned))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 : int):ii)  :  64 itself)) result (( 64 : int):ii)  :  64 words$word))))
   else if (((l__247 = (( 128 : int):ii)))) then
     let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 128 : int):ii) n  : ( 128 words$word) M)) (\ (operand1 : 128 bits) .  sail2_state_monad$bindS
     (aget_X (( 128 : int):ii) m  : ( 128 words$word) M) (\ (operand2 : 128 bits) . 
     let (result : ii) =
       (((ex_int ((asl_Int operand1 unsigned)))) * ((ex_int ((asl_Int operand2 unsigned))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 : int):ii)  :  64 itself)) result (( 64 : int):ii)  :  64 words$word))))
   else
     let dbytes = (ex_int ((l__247 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint"))`;


(*val integer_arithmetic_mul_widening_64128hi_decode : mword ty1 -> mword ty2 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_arithmetic_mul_widening_64128hi_decode:(1)words$word ->(2)words$word ->(1)words$word ->(5)words$word ->(1)words$word ->(5)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) sf op54 U Rm o0 Ra Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in
   let (m : ii) = (lem$w2ui Rm) in
   let (a : ii) = (lem$w2ui Ra) in
   let (destsize : int) = ((( 64 : int):ii)) in
   let (datasize : ii) = destsize in
   let (unsigned : bool) = (U = (vec_of_bits [B1]  :  1 words$word)) in
   aarch64_integer_arithmetic_mul_widening_64128hi d datasize m n unsigned)))`;


(*val aarch64_integer_arithmetic_mul_widening_3264 : ii -> ii -> ii -> ii -> ii -> ii -> bool -> bool -> M unit*)

val _ = Define `
 ((aarch64_integer_arithmetic_mul_widening_3264:int -> int -> int -> int -> int -> int -> bool -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) a d l__220 l__221 m n sub_op unsigned=
    (if ((((((l__220 = (( 8 : int):ii)))) /\ (((l__221 = (( 32 : int):ii))))))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "destsize constraint")
     (let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 8 : int):ii) n  : ( 8 words$word) M)) (\ (operand1 : 8 bits) .  sail2_state_monad$bindS
     (aget_X (( 8 : int):ii) m  : ( 8 words$word) M) (\ (operand2 : 8 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) a  : ( 32 words$word) M) (\ (operand3 : 32 bits) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (result : ii) . 
     let (result : ii) =
       (if sub_op then
         ((ex_int ((asl_Int operand3 unsigned)))) -
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))
       else
         ((ex_int ((asl_Int operand3 unsigned)))) +
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 : int):ii)  :  64 itself)) result (( 0 : int):ii)  :  64 words$word)))))))
   else if ((((((l__220 = (( 8 : int):ii)))) /\ (((l__221 = (( 64 : int):ii))))))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "destsize constraint")
     (let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 8 : int):ii) n  : ( 8 words$word) M)) (\ (operand1 : 8 bits) .  sail2_state_monad$bindS
     (aget_X (( 8 : int):ii) m  : ( 8 words$word) M) (\ (operand2 : 8 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) a  : ( 64 words$word) M) (\ (operand3 : 64 bits) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (result : ii) . 
     let (result : ii) =
       (if sub_op then
         ((ex_int ((asl_Int operand3 unsigned)))) -
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))
       else
         ((ex_int ((asl_Int operand3 unsigned)))) +
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 : int):ii)  :  64 itself)) result (( 0 : int):ii)  :  64 words$word)))))))
   else if (((l__220 = (( 8 : int):ii)))) then sail2_state_monad$assert_expS T "destsize constraint"
   else if ((((((l__220 = (( 16 : int):ii)))) /\ (((l__221 = (( 32 : int):ii))))))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "destsize constraint")
     (let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 16 : int):ii) n  : ( 16 words$word) M)) (\ (operand1 : 16 bits) .  sail2_state_monad$bindS
     (aget_X (( 16 : int):ii) m  : ( 16 words$word) M) (\ (operand2 : 16 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) a  : ( 32 words$word) M) (\ (operand3 : 32 bits) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (result : ii) . 
     let (result : ii) =
       (if sub_op then
         ((ex_int ((asl_Int operand3 unsigned)))) -
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))
       else
         ((ex_int ((asl_Int operand3 unsigned)))) +
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 : int):ii)  :  64 itself)) result (( 0 : int):ii)  :  64 words$word)))))))
   else if ((((((l__220 = (( 16 : int):ii)))) /\ (((l__221 = (( 64 : int):ii))))))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "destsize constraint")
     (let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 16 : int):ii) n  : ( 16 words$word) M)) (\ (operand1 : 16 bits) .  sail2_state_monad$bindS
     (aget_X (( 16 : int):ii) m  : ( 16 words$word) M) (\ (operand2 : 16 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) a  : ( 64 words$word) M) (\ (operand3 : 64 bits) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (result : ii) . 
     let (result : ii) =
       (if sub_op then
         ((ex_int ((asl_Int operand3 unsigned)))) -
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))
       else
         ((ex_int ((asl_Int operand3 unsigned)))) +
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 : int):ii)  :  64 itself)) result (( 0 : int):ii)  :  64 words$word)))))))
   else if (((l__220 = (( 16 : int):ii)))) then sail2_state_monad$assert_expS T "destsize constraint"
   else if ((((((l__220 = (( 32 : int):ii)))) /\ (((l__221 = (( 32 : int):ii))))))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "destsize constraint")
     (let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 32 : int):ii) n  : ( 32 words$word) M)) (\ (operand1 : 32 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) m  : ( 32 words$word) M) (\ (operand2 : 32 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) a  : ( 32 words$word) M) (\ (operand3 : 32 bits) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (result : ii) . 
     let (result : ii) =
       (if sub_op then
         ((ex_int ((asl_Int operand3 unsigned)))) -
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))
       else
         ((ex_int ((asl_Int operand3 unsigned)))) +
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 : int):ii)  :  64 itself)) result (( 0 : int):ii)  :  64 words$word)))))))
   else if ((((((l__220 = (( 32 : int):ii)))) /\ (((l__221 = (( 64 : int):ii))))))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "destsize constraint")
     (let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 32 : int):ii) n  : ( 32 words$word) M)) (\ (operand1 : 32 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) m  : ( 32 words$word) M) (\ (operand2 : 32 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) a  : ( 64 words$word) M) (\ (operand3 : 64 bits) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (result : ii) . 
     let (result : ii) =
       (if sub_op then
         ((ex_int ((asl_Int operand3 unsigned)))) -
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))
       else
         ((ex_int ((asl_Int operand3 unsigned)))) +
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 : int):ii)  :  64 itself)) result (( 0 : int):ii)  :  64 words$word)))))))
   else if (((l__220 = (( 32 : int):ii)))) then sail2_state_monad$assert_expS T "destsize constraint"
   else if ((((((l__220 = (( 64 : int):ii)))) /\ (((l__221 = (( 32 : int):ii))))))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "destsize constraint")
     (let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (operand1 : 64 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) m  : ( 64 words$word) M) (\ (operand2 : 64 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) a  : ( 32 words$word) M) (\ (operand3 : 32 bits) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (result : ii) . 
     let (result : ii) =
       (if sub_op then
         ((ex_int ((asl_Int operand3 unsigned)))) -
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))
       else
         ((ex_int ((asl_Int operand3 unsigned)))) +
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 : int):ii)  :  64 itself)) result (( 0 : int):ii)  :  64 words$word)))))))
   else if ((((((l__220 = (( 64 : int):ii)))) /\ (((l__221 = (( 64 : int):ii))))))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "destsize constraint")
     (let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (operand1 : 64 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) m  : ( 64 words$word) M) (\ (operand2 : 64 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) a  : ( 64 words$word) M) (\ (operand3 : 64 bits) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (result : ii) . 
     let (result : ii) =
       (if sub_op then
         ((ex_int ((asl_Int operand3 unsigned)))) -
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))
       else
         ((ex_int ((asl_Int operand3 unsigned)))) +
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 : int):ii)  :  64 itself)) result (( 0 : int):ii)  :  64 words$word)))))))
   else if (((l__220 = (( 64 : int):ii)))) then sail2_state_monad$assert_expS T "destsize constraint"
   else if ((((((l__220 = (( 128 : int):ii)))) /\ (((l__221 = (( 32 : int):ii))))))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "destsize constraint")
     (let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 128 : int):ii) n  : ( 128 words$word) M)) (\ (operand1 : 128 bits) .  sail2_state_monad$bindS
     (aget_X (( 128 : int):ii) m  : ( 128 words$word) M) (\ (operand2 : 128 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) a  : ( 32 words$word) M) (\ (operand3 : 32 bits) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (result : ii) . 
     let (result : ii) =
       (if sub_op then
         ((ex_int ((asl_Int operand3 unsigned)))) -
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))
       else
         ((ex_int ((asl_Int operand3 unsigned)))) +
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 : int):ii)  :  64 itself)) result (( 0 : int):ii)  :  64 words$word)))))))
   else if ((((((l__220 = (( 128 : int):ii)))) /\ (((l__221 = (( 64 : int):ii))))))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "destsize constraint")
     (let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 128 : int):ii) n  : ( 128 words$word) M)) (\ (operand1 : 128 bits) .  sail2_state_monad$bindS
     (aget_X (( 128 : int):ii) m  : ( 128 words$word) M) (\ (operand2 : 128 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) a  : ( 64 words$word) M) (\ (operand3 : 64 bits) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (result : ii) . 
     let (result : ii) =
       (if sub_op then
         ((ex_int ((asl_Int operand3 unsigned)))) -
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))
       else
         ((ex_int ((asl_Int operand3 unsigned)))) +
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 : int):ii)  :  64 itself)) result (( 0 : int):ii)  :  64 words$word)))))))
   else if (((l__220 = (( 128 : int):ii)))) then sail2_state_monad$assert_expS T "destsize constraint"
   else if (((l__221 = (( 32 : int):ii)))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "destsize constraint")
     (let dbytes = (ex_int ((l__220 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint")
   else if (((l__221 = (( 64 : int):ii)))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "destsize constraint")
     (let dbytes = (ex_int ((l__220 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint")
   else sail2_state_monad$assert_expS T "destsize constraint"))`;


(*val integer_arithmetic_mul_widening_3264_decode : mword ty1 -> mword ty2 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_arithmetic_mul_widening_3264_decode:(1)words$word ->(2)words$word ->(1)words$word ->(5)words$word ->(1)words$word ->(5)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) sf op54 U Rm o0 Ra Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in
   let (m : ii) = (lem$w2ui Rm) in
   let (a : ii) = (lem$w2ui Ra) in
   let (destsize : int) = ((( 64 : int):ii)) in
   let (datasize : int) = ((( 32 : int):ii)) in
   let (sub_op : bool) = (o0 = (vec_of_bits [B1]  :  1 words$word)) in
   let (unsigned : bool) = (U = (vec_of_bits [B1]  :  1 words$word)) in
   aarch64_integer_arithmetic_mul_widening_3264 a d datasize destsize m n sub_op unsigned)))`;


(*val aarch64_integer_arithmetic_mul_uniform_addsub : ii -> ii -> ii -> ii -> ii -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_integer_arithmetic_mul_uniform_addsub:int -> int -> int -> int -> int -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) a d l__193 l__194 m n sub_op=
    (if ((((((l__193 = (( 8 : int):ii)))) /\ (((l__194 = (( 32 : int):ii))))))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "destsize constraint")
     (let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 8 : int):ii) n  : ( 8 words$word) M)) (\ (operand1 : 8 bits) .  sail2_state_monad$bindS
     (aget_X (( 8 : int):ii) m  : ( 8 words$word) M) (\ (operand2 : 8 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) a  : ( 32 words$word) M) (\ (operand3 : 32 bits) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (result : ii) . 
     let (result : ii) =
       (if sub_op then
         ((lem$w2ui operand3)) - ((((lem$w2ui operand1)) * ((lem$w2ui operand2))))
       else ((lem$w2ui operand3)) + ((((lem$w2ui operand1)) * ((lem$w2ui operand2))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 32 : int):ii)  :  32 itself)) result (( 0 : int):ii)  :  32 words$word)))))))
   else if ((((((l__193 = (( 8 : int):ii)))) /\ (((l__194 = (( 64 : int):ii))))))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "destsize constraint")
     (let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 8 : int):ii) n  : ( 8 words$word) M)) (\ (operand1 : 8 bits) .  sail2_state_monad$bindS
     (aget_X (( 8 : int):ii) m  : ( 8 words$word) M) (\ (operand2 : 8 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) a  : ( 64 words$word) M) (\ (operand3 : 64 bits) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (result : ii) . 
     let (result : ii) =
       (if sub_op then
         ((lem$w2ui operand3)) - ((((lem$w2ui operand1)) * ((lem$w2ui operand2))))
       else ((lem$w2ui operand3)) + ((((lem$w2ui operand1)) * ((lem$w2ui operand2))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 : int):ii)  :  64 itself)) result (( 0 : int):ii)  :  64 words$word)))))))
   else if (((l__193 = (( 8 : int):ii)))) then sail2_state_monad$assert_expS T "destsize constraint"
   else if ((((((l__193 = (( 16 : int):ii)))) /\ (((l__194 = (( 32 : int):ii))))))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "destsize constraint")
     (let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 16 : int):ii) n  : ( 16 words$word) M)) (\ (operand1 : 16 bits) .  sail2_state_monad$bindS
     (aget_X (( 16 : int):ii) m  : ( 16 words$word) M) (\ (operand2 : 16 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) a  : ( 32 words$word) M) (\ (operand3 : 32 bits) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (result : ii) . 
     let (result : ii) =
       (if sub_op then
         ((lem$w2ui operand3)) - ((((lem$w2ui operand1)) * ((lem$w2ui operand2))))
       else ((lem$w2ui operand3)) + ((((lem$w2ui operand1)) * ((lem$w2ui operand2))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 32 : int):ii)  :  32 itself)) result (( 0 : int):ii)  :  32 words$word)))))))
   else if ((((((l__193 = (( 16 : int):ii)))) /\ (((l__194 = (( 64 : int):ii))))))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "destsize constraint")
     (let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 16 : int):ii) n  : ( 16 words$word) M)) (\ (operand1 : 16 bits) .  sail2_state_monad$bindS
     (aget_X (( 16 : int):ii) m  : ( 16 words$word) M) (\ (operand2 : 16 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) a  : ( 64 words$word) M) (\ (operand3 : 64 bits) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (result : ii) . 
     let (result : ii) =
       (if sub_op then
         ((lem$w2ui operand3)) - ((((lem$w2ui operand1)) * ((lem$w2ui operand2))))
       else ((lem$w2ui operand3)) + ((((lem$w2ui operand1)) * ((lem$w2ui operand2))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 : int):ii)  :  64 itself)) result (( 0 : int):ii)  :  64 words$word)))))))
   else if (((l__193 = (( 16 : int):ii)))) then sail2_state_monad$assert_expS T "destsize constraint"
   else if ((((((l__193 = (( 32 : int):ii)))) /\ (((l__194 = (( 32 : int):ii))))))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "destsize constraint")
     (let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 32 : int):ii) n  : ( 32 words$word) M)) (\ (operand1 : 32 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) m  : ( 32 words$word) M) (\ (operand2 : 32 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) a  : ( 32 words$word) M) (\ (operand3 : 32 bits) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (result : ii) . 
     let (result : ii) =
       (if sub_op then
         ((lem$w2ui operand3)) - ((((lem$w2ui operand1)) * ((lem$w2ui operand2))))
       else ((lem$w2ui operand3)) + ((((lem$w2ui operand1)) * ((lem$w2ui operand2))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 32 : int):ii)  :  32 itself)) result (( 0 : int):ii)  :  32 words$word)))))))
   else if ((((((l__193 = (( 32 : int):ii)))) /\ (((l__194 = (( 64 : int):ii))))))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "destsize constraint")
     (let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 32 : int):ii) n  : ( 32 words$word) M)) (\ (operand1 : 32 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) m  : ( 32 words$word) M) (\ (operand2 : 32 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) a  : ( 64 words$word) M) (\ (operand3 : 64 bits) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (result : ii) . 
     let (result : ii) =
       (if sub_op then
         ((lem$w2ui operand3)) - ((((lem$w2ui operand1)) * ((lem$w2ui operand2))))
       else ((lem$w2ui operand3)) + ((((lem$w2ui operand1)) * ((lem$w2ui operand2))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 : int):ii)  :  64 itself)) result (( 0 : int):ii)  :  64 words$word)))))))
   else if (((l__193 = (( 32 : int):ii)))) then sail2_state_monad$assert_expS T "destsize constraint"
   else if ((((((l__193 = (( 64 : int):ii)))) /\ (((l__194 = (( 32 : int):ii))))))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "destsize constraint")
     (let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (operand1 : 64 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) m  : ( 64 words$word) M) (\ (operand2 : 64 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) a  : ( 32 words$word) M) (\ (operand3 : 32 bits) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (result : ii) . 
     let (result : ii) =
       (if sub_op then
         ((lem$w2ui operand3)) - ((((lem$w2ui operand1)) * ((lem$w2ui operand2))))
       else ((lem$w2ui operand3)) + ((((lem$w2ui operand1)) * ((lem$w2ui operand2))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 32 : int):ii)  :  32 itself)) result (( 0 : int):ii)  :  32 words$word)))))))
   else if ((((((l__193 = (( 64 : int):ii)))) /\ (((l__194 = (( 64 : int):ii))))))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "destsize constraint")
     (let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (operand1 : 64 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) m  : ( 64 words$word) M) (\ (operand2 : 64 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) a  : ( 64 words$word) M) (\ (operand3 : 64 bits) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (result : ii) . 
     let (result : ii) =
       (if sub_op then
         ((lem$w2ui operand3)) - ((((lem$w2ui operand1)) * ((lem$w2ui operand2))))
       else ((lem$w2ui operand3)) + ((((lem$w2ui operand1)) * ((lem$w2ui operand2))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 : int):ii)  :  64 itself)) result (( 0 : int):ii)  :  64 words$word)))))))
   else if (((l__193 = (( 64 : int):ii)))) then sail2_state_monad$assert_expS T "destsize constraint"
   else if ((((((l__193 = (( 128 : int):ii)))) /\ (((l__194 = (( 32 : int):ii))))))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "destsize constraint")
     (let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 128 : int):ii) n  : ( 128 words$word) M)) (\ (operand1 : 128 bits) .  sail2_state_monad$bindS
     (aget_X (( 128 : int):ii) m  : ( 128 words$word) M) (\ (operand2 : 128 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) a  : ( 32 words$word) M) (\ (operand3 : 32 bits) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (result : ii) . 
     let (result : ii) =
       (if sub_op then
         ((lem$w2ui operand3)) - ((((lem$w2ui operand1)) * ((lem$w2ui operand2))))
       else ((lem$w2ui operand3)) + ((((lem$w2ui operand1)) * ((lem$w2ui operand2))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 32 : int):ii)  :  32 itself)) result (( 0 : int):ii)  :  32 words$word)))))))
   else if ((((((l__193 = (( 128 : int):ii)))) /\ (((l__194 = (( 64 : int):ii))))))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "destsize constraint")
     (let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 128 : int):ii) n  : ( 128 words$word) M)) (\ (operand1 : 128 bits) .  sail2_state_monad$bindS
     (aget_X (( 128 : int):ii) m  : ( 128 words$word) M) (\ (operand2 : 128 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) a  : ( 64 words$word) M) (\ (operand3 : 64 bits) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (result : ii) . 
     let (result : ii) =
       (if sub_op then
         ((lem$w2ui operand3)) - ((((lem$w2ui operand1)) * ((lem$w2ui operand2))))
       else ((lem$w2ui operand3)) + ((((lem$w2ui operand1)) * ((lem$w2ui operand2))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 : int):ii)  :  64 itself)) result (( 0 : int):ii)  :  64 words$word)))))))
   else if (((l__193 = (( 128 : int):ii)))) then sail2_state_monad$assert_expS T "destsize constraint"
   else if (((l__194 = (( 32 : int):ii)))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "destsize constraint")
     (let dbytes = (ex_int ((l__193 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint")
   else if (((l__194 = (( 64 : int):ii)))) then sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "destsize constraint")
     (let dbytes = (ex_int ((l__193 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint")
   else sail2_state_monad$assert_expS T "destsize constraint"))`;


(*val integer_arithmetic_mul_uniform_addsub_decode : mword ty1 -> mword ty2 -> mword ty3 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_arithmetic_mul_uniform_addsub_decode:(1)words$word ->(2)words$word ->(3)words$word ->(5)words$word ->(1)words$word ->(5)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) sf op54 op31 Rm o0 Ra Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in
   let (m : ii) = (lem$w2ui Rm) in
   let (a : ii) = (lem$w2ui Ra) in
   let (destsize : int) =
     (if (((sf = (vec_of_bits [B1]  :  1 words$word)))) then (( 64 : int):ii)
     else (( 32 : int):ii)) in
   let (datasize : ii) = destsize in
   let (sub_op : bool) = (o0 = (vec_of_bits [B1]  :  1 words$word)) in
   aarch64_integer_arithmetic_mul_uniform_addsub a d datasize destsize m n sub_op)))`;


(*val aarch64_integer_arithmetic_div : ii -> ii -> ii -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_integer_arithmetic_div:int -> int -> int -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d l__188 m n unsigned=
    (if (((l__188 = (( 8 : int):ii)))) then
     let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 8 : int):ii) n  : ( 8 words$word) M)) (\ (operand1 : 8 bits) .  sail2_state_monad$bindS
     (aget_X (( 8 : int):ii) m  : ( 8 words$word) M) (\ (operand2 : 8 bits) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (result : ii) . 
     let (result : ii) =
       (if ((IsZero operand2)) then (( 0 : int):ii)
       else
         RoundTowardsZero
           (((((real_of_int ((asl_Int operand1 unsigned))))) /
               (((real_of_int ((asl_Int operand2 unsigned)))))))) in
     aset_X d ((GetSlice_int ((make_the_value (( 8 : int):ii)  :  8 itself)) result (( 0 : int):ii)  :  8 words$word)))))
   else if (((l__188 = (( 16 : int):ii)))) then
     let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 16 : int):ii) n  : ( 16 words$word) M)) (\ (operand1 : 16 bits) .  sail2_state_monad$bindS
     (aget_X (( 16 : int):ii) m  : ( 16 words$word) M) (\ (operand2 : 16 bits) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (result : ii) . 
     let (result : ii) =
       (if ((IsZero operand2)) then (( 0 : int):ii)
       else
         RoundTowardsZero
           (((((real_of_int ((asl_Int operand1 unsigned))))) /
               (((real_of_int ((asl_Int operand2 unsigned)))))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 16 : int):ii)  :  16 itself)) result (( 0 : int):ii)  :  16 words$word)))))
   else if (((l__188 = (( 32 : int):ii)))) then
     let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 32 : int):ii) n  : ( 32 words$word) M)) (\ (operand1 : 32 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) m  : ( 32 words$word) M) (\ (operand2 : 32 bits) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (result : ii) . 
     let (result : ii) =
       (if ((IsZero operand2)) then (( 0 : int):ii)
       else
         RoundTowardsZero
           (((((real_of_int ((asl_Int operand1 unsigned))))) /
               (((real_of_int ((asl_Int operand2 unsigned)))))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 32 : int):ii)  :  32 itself)) result (( 0 : int):ii)  :  32 words$word)))))
   else if (((l__188 = (( 64 : int):ii)))) then
     let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (operand1 : 64 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) m  : ( 64 words$word) M) (\ (operand2 : 64 bits) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (result : ii) . 
     let (result : ii) =
       (if ((IsZero operand2)) then (( 0 : int):ii)
       else
         RoundTowardsZero
           (((((real_of_int ((asl_Int operand1 unsigned))))) /
               (((real_of_int ((asl_Int operand2 unsigned)))))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 : int):ii)  :  64 itself)) result (( 0 : int):ii)  :  64 words$word)))))
   else if (((l__188 = (( 128 : int):ii)))) then
     let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 128 : int):ii) n  : ( 128 words$word) M)) (\ (operand1 : 128 bits) .  sail2_state_monad$bindS
     (aget_X (( 128 : int):ii) m  : ( 128 words$word) M) (\ (operand2 : 128 bits) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (result : ii) . 
     let (result : ii) =
       (if ((IsZero operand2)) then (( 0 : int):ii)
       else
         RoundTowardsZero
           (((((real_of_int ((asl_Int operand1 unsigned))))) /
               (((real_of_int ((asl_Int operand2 unsigned)))))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 128 : int):ii)  :  128 itself)) result (( 0 : int):ii)  :  128 words$word)))))
   else
     let dbytes = (ex_int ((l__188 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint"))`;


(*val integer_arithmetic_div_decode : mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_arithmetic_div_decode:(1)words$word ->(1)words$word ->(1)words$word ->(5)words$word ->(5)words$word ->(1)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) sf op S1 Rm opcode2 o1 Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in
   let (m : ii) = (lem$w2ui Rm) in
   let (datasize : int) =
     (if (((sf = (vec_of_bits [B1]  :  1 words$word)))) then (( 64 : int):ii)
     else (( 32 : int):ii)) in
   let (unsigned : bool) = (o1 = (vec_of_bits [B0]  :  1 words$word)) in
   aarch64_integer_arithmetic_div d datasize m n unsigned)))`;


(*val aarch64_integer_arithmetic_cnt : ii -> ii -> ii -> CountOp -> M unit*)

val _ = Define `
 ((aarch64_integer_arithmetic_cnt:int -> int -> int -> CountOp ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d l__183 n opcode=
    (if (((l__183 = (( 8 : int):ii)))) then
     let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_int () )) (\ (result : ii) .  sail2_state_monad$bindS
     (aget_X (( 8 : int):ii) n  : ( 8 words$word) M) (\ (operand1 : 8 bits) .  sail2_state_monad$bindS
     (if (((opcode = CountOp_CLZ))) then CountLeadingZeroBits operand1
      else CountLeadingSignBits operand1) (\ (result : ii) . 
     aset_X d ((GetSlice_int ((make_the_value (( 8 : int):ii)  :  8 itself)) result (( 0 : int):ii)  :  8 words$word)))))
   else if (((l__183 = (( 16 : int):ii)))) then
     let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_int () )) (\ (result : ii) .  sail2_state_monad$bindS
     (aget_X (( 16 : int):ii) n  : ( 16 words$word) M) (\ (operand1 : 16 bits) .  sail2_state_monad$bindS
     (if (((opcode = CountOp_CLZ))) then CountLeadingZeroBits operand1
      else CountLeadingSignBits operand1) (\ (result : ii) . 
     aset_X d
       ((GetSlice_int ((make_the_value (( 16 : int):ii)  :  16 itself)) result (( 0 : int):ii)  :  16 words$word)))))
   else if (((l__183 = (( 32 : int):ii)))) then
     let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_int () )) (\ (result : ii) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) n  : ( 32 words$word) M) (\ (operand1 : 32 bits) .  sail2_state_monad$bindS
     (if (((opcode = CountOp_CLZ))) then CountLeadingZeroBits operand1
      else CountLeadingSignBits operand1) (\ (result : ii) . 
     aset_X d
       ((GetSlice_int ((make_the_value (( 32 : int):ii)  :  32 itself)) result (( 0 : int):ii)  :  32 words$word)))))
   else if (((l__183 = (( 64 : int):ii)))) then
     let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_int () )) (\ (result : ii) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) n  : ( 64 words$word) M) (\ (operand1 : 64 bits) .  sail2_state_monad$bindS
     (if (((opcode = CountOp_CLZ))) then CountLeadingZeroBits operand1
      else CountLeadingSignBits operand1) (\ (result : ii) . 
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 : int):ii)  :  64 itself)) result (( 0 : int):ii)  :  64 words$word)))))
   else if (((l__183 = (( 128 : int):ii)))) then
     let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_int () )) (\ (result : ii) .  sail2_state_monad$bindS
     (aget_X (( 128 : int):ii) n  : ( 128 words$word) M) (\ (operand1 : 128 bits) .  sail2_state_monad$bindS
     (if (((opcode = CountOp_CLZ))) then CountLeadingZeroBits operand1
      else CountLeadingSignBits operand1) (\ (result : ii) . 
     aset_X d
       ((GetSlice_int ((make_the_value (( 128 : int):ii)  :  128 itself)) result (( 0 : int):ii)  :  128 words$word)))))
   else
     let dbytes = (ex_int ((l__183 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint"))`;


(*val integer_arithmetic_cnt_decode : mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_arithmetic_cnt_decode:(1)words$word ->(1)words$word ->(5)words$word ->(1)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) sf S1 opcode2 op Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in
   let (datasize : int) =
     (if (((sf = (vec_of_bits [B1]  :  1 words$word)))) then (( 64 : int):ii)
     else (( 32 : int):ii)) in
   let (opcode : CountOp) =
     (if (((op = (vec_of_bits [B0]  :  1 words$word)))) then CountOp_CLZ
     else CountOp_CLS) in
   aarch64_integer_arithmetic_cnt d datasize n opcode)))`;


(*val aarch64_integer_arithmetic_addsub_carry : ii -> ii -> ii -> ii -> bool -> bool -> M unit*)

val _ = Define `
 ((aarch64_integer_arithmetic_addsub_carry:int -> int -> int -> int -> bool -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d l__178 m n setflags sub_op=
    (if (((l__178 = (( 8 : int):ii)))) then
     let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M)) (\ (result : 8 bits) .  sail2_state_monad$bindS
     (aget_X (( 8 : int):ii) n  : ( 8 words$word) M) (\ (operand1 : 8 bits) .  sail2_state_monad$bindS
     (aget_X (( 8 : int):ii) m  : ( 8 words$word) M) (\ (operand2 : 8 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (nzcv1 : 4 bits) . 
     let (operand2 : 8 bits) = (if sub_op then (not_vec operand2  :  8 words$word) else operand2) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) . 
     let (tup__0, tup__1) =
       ((AddWithCarry operand1 operand2 w__0.ProcState_C  : ( 8 words$word #  4 words$word))) in
     let result = tup__0 in
     let nzcv1 = tup__1 in sail2_state_monad$seqS
     (if setflags then
        let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec nzcv1 (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__1 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__1 with<| ProcState_N := tup__0|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__2 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__2 with<| ProcState_Z := tup__1|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__3 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__3 with<| ProcState_C := tup__2|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__4 : ProcState) . 
        sail2_state_monad$write_regS PSTATE_ref (w__4 with<| ProcState_V := tup__3|>)))))
      else sail2_state_monad$returnS () )
     (aset_X d result))))))
   else if (((l__178 = (( 16 : int):ii)))) then
     let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M)) (\ (result : 16 bits) .  sail2_state_monad$bindS
     (aget_X (( 16 : int):ii) n  : ( 16 words$word) M) (\ (operand1 : 16 bits) .  sail2_state_monad$bindS
     (aget_X (( 16 : int):ii) m  : ( 16 words$word) M) (\ (operand2 : 16 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (nzcv1 : 4 bits) . 
     let (operand2 : 16 bits) = (if sub_op then (not_vec operand2  :  16 words$word) else operand2) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__5 : ProcState) . 
     let (tup__0, tup__1) =
       ((AddWithCarry operand1 operand2 w__5.ProcState_C  : ( 16 words$word #  4 words$word))) in
     let result = tup__0 in
     let nzcv1 = tup__1 in sail2_state_monad$seqS
     (if setflags then
        let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec nzcv1 (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__6 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__6 with<| ProcState_N := tup__0|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__7 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__7 with<| ProcState_Z := tup__1|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__8 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__8 with<| ProcState_C := tup__2|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__9 : ProcState) . 
        sail2_state_monad$write_regS PSTATE_ref (w__9 with<| ProcState_V := tup__3|>)))))
      else sail2_state_monad$returnS () )
     (aset_X d result))))))
   else if (((l__178 = (( 32 : int):ii)))) then
     let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (result : 32 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) n  : ( 32 words$word) M) (\ (operand1 : 32 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) m  : ( 32 words$word) M) (\ (operand2 : 32 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (nzcv1 : 4 bits) . 
     let (operand2 : 32 bits) = (if sub_op then (not_vec operand2  :  32 words$word) else operand2) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__10 : ProcState) . 
     let (tup__0, tup__1) =
       ((AddWithCarry operand1 operand2 w__10.ProcState_C  : ( 32 words$word #  4 words$word))) in
     let result = tup__0 in
     let nzcv1 = tup__1 in sail2_state_monad$seqS
     (if setflags then
        let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec nzcv1 (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__11 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__11 with<| ProcState_N := tup__0|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__12 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__12 with<| ProcState_Z := tup__1|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__13 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__13 with<| ProcState_C := tup__2|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__14 : ProcState) . 
        sail2_state_monad$write_regS PSTATE_ref (w__14 with<| ProcState_V := tup__3|>)))))
      else sail2_state_monad$returnS () )
     (aset_X d result))))))
   else if (((l__178 = (( 64 : int):ii)))) then
     let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (result : 64 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) n  : ( 64 words$word) M) (\ (operand1 : 64 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) m  : ( 64 words$word) M) (\ (operand2 : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (nzcv1 : 4 bits) . 
     let (operand2 : 64 bits) = (if sub_op then (not_vec operand2  :  64 words$word) else operand2) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__15 : ProcState) . 
     let (tup__0, tup__1) =
       ((AddWithCarry operand1 operand2 w__15.ProcState_C  : ( 64 words$word #  4 words$word))) in
     let result = tup__0 in
     let nzcv1 = tup__1 in sail2_state_monad$seqS
     (if setflags then
        let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec nzcv1 (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__16 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__16 with<| ProcState_N := tup__0|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__17 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__17 with<| ProcState_Z := tup__1|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__18 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__18 with<| ProcState_C := tup__2|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__19 : ProcState) . 
        sail2_state_monad$write_regS PSTATE_ref (w__19 with<| ProcState_V := tup__3|>)))))
      else sail2_state_monad$returnS () )
     (aset_X d result))))))
   else if (((l__178 = (( 128 : int):ii)))) then
     let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M)) (\ (result : 128 bits) .  sail2_state_monad$bindS
     (aget_X (( 128 : int):ii) n  : ( 128 words$word) M) (\ (operand1 : 128 bits) .  sail2_state_monad$bindS
     (aget_X (( 128 : int):ii) m  : ( 128 words$word) M) (\ (operand2 : 128 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (nzcv1 : 4 bits) . 
     let (operand2 : 128 bits) = (if sub_op then (not_vec operand2  :  128 words$word) else operand2) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__20 : ProcState) . 
     let (tup__0, tup__1) =
       ((AddWithCarry operand1 operand2 w__20.ProcState_C  : ( 128 words$word #  4 words$word))) in
     let result = tup__0 in
     let nzcv1 = tup__1 in sail2_state_monad$seqS
     (if setflags then
        let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec nzcv1 (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__21 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__21 with<| ProcState_N := tup__0|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__22 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__22 with<| ProcState_Z := tup__1|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__23 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__23 with<| ProcState_C := tup__2|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__24 : ProcState) . 
        sail2_state_monad$write_regS PSTATE_ref (w__24 with<| ProcState_V := tup__3|>)))))
      else sail2_state_monad$returnS () )
     (aset_X d result))))))
   else
     let dbytes = (ex_int ((l__178 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint"))`;


(*val integer_arithmetic_addsub_carry_decode : mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty6 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_arithmetic_addsub_carry_decode:(1)words$word ->(1)words$word ->(1)words$word ->(5)words$word ->(6)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) sf op S1 Rm opcode2 Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in
   let (m : ii) = (lem$w2ui Rm) in
   let (datasize : int) =
     (if (((sf = (vec_of_bits [B1]  :  1 words$word)))) then (( 64 : int):ii)
     else (( 32 : int):ii)) in
   let (sub_op : bool) = (op = (vec_of_bits [B1]  :  1 words$word)) in
   let (setflags : bool) = (S1 = (vec_of_bits [B1]  :  1 words$word)) in
   aarch64_integer_arithmetic_addsub_carry d datasize m n setflags sub_op)))`;


(*val ExtendReg : forall 'N . Size 'N => integer -> ii -> ExtendType -> ii -> M (mword 'N)*)

val _ = Define `
 ((ExtendReg:int -> int -> ExtendType -> int ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) (N__tv : int) reg typ shift=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS (((((shift >= (( 0 : int):ii))) /\ ((shift <= (( 4 : int):ii)))))) "((shift >= 0) && (shift <= 4))")
   (aget_X N__tv reg  : ( 'N words$word) M)) (\ (val_name : 'N bits) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (unsigned : bool) .  sail2_state_monad$bindS
   (undefined_int () ) (\ (len : ii) . 
   let (len : ii) =
     ((case typ of
       ExtendType_SXTB =>
        let (unsigned : bool) = F in
        (( 8 : int):ii)
     | ExtendType_SXTH =>
        let (unsigned : bool) = F in
        (( 16 : int):ii)
     | ExtendType_SXTW =>
        let (unsigned : bool) = F in
        (( 32 : int):ii)
     | ExtendType_SXTX =>
        let (unsigned : bool) = F in
        (( 64 : int):ii)
     | ExtendType_UXTB =>
        let (unsigned : bool) = T in
        (( 8 : int):ii)
     | ExtendType_UXTH =>
        let (unsigned : bool) = T in
        (( 16 : int):ii)
     | ExtendType_UXTW =>
        let (unsigned : bool) = T in
        (( 32 : int):ii)
     | ExtendType_UXTX =>
        let (unsigned : bool) = T in
        (( 64 : int):ii)
     )) in
   let len = (int_min len ((((int_of_num (words$word_len val_name))) - shift))) in sail2_state_monad$bindS
   (coerce_int_nat shift) (\ shift2 . 
   let (len2 : int) = (ex_int len) in sail2_state_monad$seqS
   (sail2_state_monad$assert_expS T "hack")
   (sail2_state_monad$returnS ((place_subrange ((int_of_num (words$word_len val_name))) val_name ((len2 - (( 1 : int):ii))) (( 0 : int):ii)
              ((ex_nat shift2))
             :  'N words$word)))))))))`;


(*val aget_ELR__0 : mword ty2 -> M (mword ty64)*)

(*val aget_ELR__1 : unit -> M (mword ty64)*)

val _ = Define `
 ((aget_ELR__0:(2)words$word ->(regstate)sail2_state_monad$sequential_state ->((((64)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) el=  (sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (r : 64 bits) . 
   let pat_0 = el in
   if (((pat_0 = EL1))) then (sail2_state_monad$read_regS ELR_EL1_ref  : ( 64 words$word) M)
   else if (((pat_0 = EL2))) then (sail2_state_monad$read_regS ELR_EL2_ref  : ( 64 words$word) M)
   else if (((pat_0 = EL3))) then (sail2_state_monad$read_regS ELR_EL3_ref  : ( 64 words$word) M)
   else sail2_state_monad$seqS (Unreachable () ) (sail2_state_monad$returnS r))))`;


val _ = Define `
 ((aget_ELR__1:unit ->(regstate)sail2_state_monad$sequential_state ->((((64)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS (((w__0.ProcState_EL <> EL0))) "")
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__1 : ProcState) . 
   (aget_ELR__0 w__1.ProcState_EL  : ( 64 words$word) M)))))`;


(*val ROR_C : forall 'N . Size 'N => mword 'N -> ii -> M (mword 'N * mword ty1)*)

val _ = Define `
 ((ROR_C:'N words$word -> int ->(regstate)sail2_state_monad$sequential_state ->((('N words$word#(1)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) x shift=  (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS (((shift <> (( 0 : int):ii)))) "(shift != 0)")
   (let (m : ii) = (shift % ((int_of_num (words$word_len x)))) in sail2_state_monad$bindS
   (LSR x m  : ( 'N words$word) M) (\ (w__0 :  'N words$word) .  sail2_state_monad$bindS
   (LSL x ((((int_of_num (words$word_len x))) - ((ex_int m))))  : ( 'N words$word) M) (\ (w__1 :  'N words$word) . 
   let (result : 'N bits) = ((or_vec w__0 w__1  :  'N words$word)) in
   let (carry_out : 1 bits) =
     ((vec_of_bits [access_vec_dec result ((((int_of_num (words$word_len result))) - (( 1 : int):ii)))]  :  1 words$word)) in
   sail2_state_monad$returnS (result, carry_out))))))`;


(*val ROR : forall 'N . Size 'N => mword 'N -> ii -> M (mword 'N)*)

val _ = Define `
 ((ROR:'N words$word -> int ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) x shift=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((shift >= (( 0 : int):ii))) "(shift >= 0)")
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M)) (\ (anon10 : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector ((int_of_num (words$word_len x)))  : ( 'N words$word) M) (\ (result : 'N bits) . 
   if (((shift = (( 0 : int):ii)))) then sail2_state_monad$returnS x
   else sail2_state_monad$bindS
     (ROR_C x shift  : (( 'N words$word #  1 words$word)) M) (\ varstup .  let (tup__0, tup__1) = varstup in
     let (result : 'N bits) = tup__0 in
     let (anon10 : 1 bits) = tup__1 in
     sail2_state_monad$returnS result)))))`;


(*val aarch64_integer_bitfield : forall 'datasize. Size 'datasize => ii -> ii -> ii -> itself 'datasize -> bool -> bool -> ii -> mword 'datasize -> mword 'datasize -> M unit*)

val _ = Define `
 ((aarch64_integer_bitfield:int -> int -> int -> 'datasize itself -> bool -> bool -> int -> 'datasize words$word -> 'datasize words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) R1 S1 d datasize extend inzero n tmask wmask=
    (let datasize = (size_itself_int datasize) in
   let dbytes = (ex_int ((datasize / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS T "datasize constraint")
   (sail2_state_monad$assert_expS T "dbytes constraint"))
   (if inzero then sail2_state_monad$returnS ((Zeros__1 datasize ()   :  'datasize words$word))
    else (aget_X datasize d  : ( 'datasize words$word) M))) (\ (dst : 'datasize bits) .  sail2_state_monad$bindS
   (aget_X datasize n  : ( 'datasize words$word) M) (\ (src : 'datasize bits) .  sail2_state_monad$bindS
   (ROR src R1  : ( 'datasize words$word) M) (\ (w__1 :  'datasize words$word) . 
   let (bot : 'datasize bits) =
     ((or_vec ((and_vec dst ((not_vec wmask  :  'datasize words$word))  :  'datasize words$word))
        ((and_vec w__1 wmask  :  'datasize words$word))
       :  'datasize words$word)) in sail2_state_monad$bindS
   (if extend then
      (Replicate ((int_of_num (words$word_len bot))) (vec_of_bits [access_vec_dec src S1]  :  1 words$word)
        : ( 'datasize words$word) M)
    else sail2_state_monad$returnS dst) (\ (top : 'datasize bits) . 
   aset_X d
     ((or_vec ((and_vec top ((not_vec tmask  :  'datasize words$word))  :  'datasize words$word))
         ((and_vec bot tmask  :  'datasize words$word))
        :  'datasize words$word))))))))`;


(*val ShiftReg : forall 'N . Size 'N => integer -> ii -> ShiftType -> ii -> M (mword 'N)*)

val _ = Define `
 ((ShiftReg:int -> int -> ShiftType -> int ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) (N__tv : int) reg typ amount=  (sail2_state_monad$bindS
   (aget_X N__tv reg  : ( 'N words$word) M) (\ (result : 'N bits) . 
   (case typ of
     ShiftType_LSL => (LSL result amount  : ( 'N words$word) M)
   | ShiftType_LSR => (LSR result amount  : ( 'N words$word) M)
   | ShiftType_ASR => (ASR result amount  : ( 'N words$word) M)
   | ShiftType_ROR => (ROR result amount  : ( 'N words$word) M)
   ))))`;


(*val aarch64_integer_shift_variable : ii -> ii -> ii -> ii -> ShiftType -> M unit*)

val _ = Define `
 ((aarch64_integer_shift_variable:int -> int -> int -> int -> ShiftType ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d l__173 m n shift_type=
    (if (((l__173 = (( 8 : int):ii)))) then
     let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M)) (\ (result : 8 bits) .  sail2_state_monad$bindS
     (aget_X (( 8 : int):ii) m  : ( 8 words$word) M) (\ (operand2 : 8 bits) .  sail2_state_monad$bindS
     (ShiftReg (( 8 : int):ii) n shift_type ((((lem$w2ui operand2)) % (( 8 : int):ii)))  : ( 8 words$word) M) (\ (w__0 : 8
       bits) . 
     let result = w__0 in
     aset_X d result)))
   else if (((l__173 = (( 16 : int):ii)))) then
     let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M)) (\ (result : 16 bits) .  sail2_state_monad$bindS
     (aget_X (( 16 : int):ii) m  : ( 16 words$word) M) (\ (operand2 : 16 bits) .  sail2_state_monad$bindS
     (ShiftReg (( 16 : int):ii) n shift_type ((((lem$w2ui operand2)) % (( 16 : int):ii)))  : ( 16 words$word) M) (\ (w__1 : 16
       bits) . 
     let result = w__1 in
     aset_X d result)))
   else if (((l__173 = (( 32 : int):ii)))) then
     let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (result : 32 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) m  : ( 32 words$word) M) (\ (operand2 : 32 bits) .  sail2_state_monad$bindS
     (ShiftReg (( 32 : int):ii) n shift_type ((((lem$w2ui operand2)) % (( 32 : int):ii)))  : ( 32 words$word) M) (\ (w__2 : 32
       bits) . 
     let result = w__2 in
     aset_X d result)))
   else if (((l__173 = (( 64 : int):ii)))) then
     let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (result : 64 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) m  : ( 64 words$word) M) (\ (operand2 : 64 bits) .  sail2_state_monad$bindS
     (ShiftReg (( 64 : int):ii) n shift_type ((((lem$w2ui operand2)) % (( 64 : int):ii)))  : ( 64 words$word) M) (\ (w__3 : 64
       bits) . 
     let result = w__3 in
     aset_X d result)))
   else if (((l__173 = (( 128 : int):ii)))) then
     let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M)) (\ (result : 128 bits) .  sail2_state_monad$bindS
     (aget_X (( 128 : int):ii) m  : ( 128 words$word) M) (\ (operand2 : 128 bits) .  sail2_state_monad$bindS
     (ShiftReg (( 128 : int):ii) n shift_type ((((lem$w2ui operand2)) % (( 128 : int):ii)))  : ( 128 words$word) M) (\ (w__4 : 128
       bits) . 
     let result = w__4 in
     aset_X d result)))
   else
     let dbytes = (ex_int ((l__173 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint"))`;


(*val integer_shift_variable_decode : mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty4 -> mword ty2 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_shift_variable_decode:(1)words$word ->(1)words$word ->(1)words$word ->(5)words$word ->(4)words$word ->(2)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) sf op S1 Rm opcode2 op2 Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in
   let (m : ii) = (lem$w2ui Rm) in
   let (datasize : int) =
     (if (((sf = (vec_of_bits [B1]  :  1 words$word)))) then (( 64 : int):ii)
     else (( 32 : int):ii)) in
   let (shift_type : ShiftType) = (DecodeShift op2) in
   aarch64_integer_shift_variable d datasize m n shift_type)))`;


(*val aarch64_integer_logical_shiftedreg : ii -> ii -> bool -> ii -> ii -> LogicalOp -> bool -> ii -> ShiftType -> M unit*)

val _ = Define `
 ((aarch64_integer_logical_shiftedreg:int -> int -> bool -> int -> int -> LogicalOp -> bool -> int -> ShiftType ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d l__168 invert m n op setflags shift_amount shift_type=
    (if (((l__168 = (( 8 : int):ii)))) then
     let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 8 : int):ii) n  : ( 8 words$word) M)) (\ (operand1 : 8 bits) .  sail2_state_monad$bindS
     (ShiftReg (( 8 : int):ii) m shift_type shift_amount  : ( 8 words$word) M) (\ (operand2 : 8 bits) . 
     let (operand2 : 8 bits) = (if invert then (not_vec operand2  :  8 words$word) else operand2) in sail2_state_monad$bindS
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M) (\ (result : 8 bits) . 
     let (result : 8 bits) =
       ((case op of
         LogicalOp_AND => (and_vec operand1 operand2  :  8 words$word)
       | LogicalOp_ORR => (or_vec operand1 operand2  :  8 words$word)
       | LogicalOp_EOR => (xor_vec operand1 operand2  :  8 words$word)
       )) in sail2_state_monad$seqS
     (if setflags then
        let split_vec =
          ((concat_vec
             ((concat_vec
                 (vec_of_bits [access_vec_dec result (((( 8 : int):ii) - (( 1 : int):ii)))]  :  1 words$word)
                 ((IsZeroBit result  :  1 words$word))
                :  2 words$word)) (vec_of_bits [B0;B0]  :  2 words$word)
            :  4 words$word)) in
        let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec split_vec (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
           (subrange_vec_dec split_vec (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
           (subrange_vec_dec split_vec (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
           (subrange_vec_dec split_vec (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__0 with<| ProcState_N := tup__0|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__1 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__1 with<| ProcState_Z := tup__1|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__2 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__2 with<| ProcState_C := tup__2|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__3 : ProcState) . 
        sail2_state_monad$write_regS PSTATE_ref (w__3 with<| ProcState_V := tup__3|>)))))
      else sail2_state_monad$returnS () )
     (aset_X d result))))
   else if (((l__168 = (( 16 : int):ii)))) then
     let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 16 : int):ii) n  : ( 16 words$word) M)) (\ (operand1 : 16 bits) .  sail2_state_monad$bindS
     (ShiftReg (( 16 : int):ii) m shift_type shift_amount  : ( 16 words$word) M) (\ (operand2 : 16 bits) . 
     let (operand2 : 16 bits) = (if invert then (not_vec operand2  :  16 words$word) else operand2) in sail2_state_monad$bindS
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M) (\ (result : 16 bits) . 
     let (result : 16 bits) =
       ((case op of
         LogicalOp_AND => (and_vec operand1 operand2  :  16 words$word)
       | LogicalOp_ORR => (or_vec operand1 operand2  :  16 words$word)
       | LogicalOp_EOR => (xor_vec operand1 operand2  :  16 words$word)
       )) in sail2_state_monad$seqS
     (if setflags then
        let split_vec =
          ((concat_vec
             ((concat_vec
                 (vec_of_bits [access_vec_dec result (((( 16 : int):ii) - (( 1 : int):ii)))]  :  1 words$word)
                 ((IsZeroBit result  :  1 words$word))
                :  2 words$word)) (vec_of_bits [B0;B0]  :  2 words$word)
            :  4 words$word)) in
        let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec split_vec (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
           (subrange_vec_dec split_vec (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
           (subrange_vec_dec split_vec (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
           (subrange_vec_dec split_vec (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__4 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__4 with<| ProcState_N := tup__0|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__5 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__5 with<| ProcState_Z := tup__1|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__6 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__6 with<| ProcState_C := tup__2|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__7 : ProcState) . 
        sail2_state_monad$write_regS PSTATE_ref (w__7 with<| ProcState_V := tup__3|>)))))
      else sail2_state_monad$returnS () )
     (aset_X d result))))
   else if (((l__168 = (( 32 : int):ii)))) then
     let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 32 : int):ii) n  : ( 32 words$word) M)) (\ (operand1 : 32 bits) .  sail2_state_monad$bindS
     (ShiftReg (( 32 : int):ii) m shift_type shift_amount  : ( 32 words$word) M) (\ (operand2 : 32 bits) . 
     let (operand2 : 32 bits) = (if invert then (not_vec operand2  :  32 words$word) else operand2) in sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (result : 32 bits) . 
     let (result : 32 bits) =
       ((case op of
         LogicalOp_AND => (and_vec operand1 operand2  :  32 words$word)
       | LogicalOp_ORR => (or_vec operand1 operand2  :  32 words$word)
       | LogicalOp_EOR => (xor_vec operand1 operand2  :  32 words$word)
       )) in sail2_state_monad$seqS
     (if setflags then
        let split_vec =
          ((concat_vec
             ((concat_vec
                 (vec_of_bits [access_vec_dec result (((( 32 : int):ii) - (( 1 : int):ii)))]  :  1 words$word)
                 ((IsZeroBit result  :  1 words$word))
                :  2 words$word)) (vec_of_bits [B0;B0]  :  2 words$word)
            :  4 words$word)) in
        let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec split_vec (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
           (subrange_vec_dec split_vec (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
           (subrange_vec_dec split_vec (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
           (subrange_vec_dec split_vec (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__8 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__8 with<| ProcState_N := tup__0|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__9 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__9 with<| ProcState_Z := tup__1|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__10 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__10 with<| ProcState_C := tup__2|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__11 : ProcState) . 
        sail2_state_monad$write_regS PSTATE_ref (w__11 with<| ProcState_V := tup__3|>)))))
      else sail2_state_monad$returnS () )
     (aset_X d result))))
   else if (((l__168 = (( 64 : int):ii)))) then
     let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (operand1 : 64 bits) .  sail2_state_monad$bindS
     (ShiftReg (( 64 : int):ii) m shift_type shift_amount  : ( 64 words$word) M) (\ (operand2 : 64 bits) . 
     let (operand2 : 64 bits) = (if invert then (not_vec operand2  :  64 words$word) else operand2) in sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (result : 64 bits) . 
     let (result : 64 bits) =
       ((case op of
         LogicalOp_AND => (and_vec operand1 operand2  :  64 words$word)
       | LogicalOp_ORR => (or_vec operand1 operand2  :  64 words$word)
       | LogicalOp_EOR => (xor_vec operand1 operand2  :  64 words$word)
       )) in sail2_state_monad$seqS
     (if setflags then
        let split_vec =
          ((concat_vec
             ((concat_vec
                 (vec_of_bits [access_vec_dec result (((( 64 : int):ii) - (( 1 : int):ii)))]  :  1 words$word)
                 ((IsZeroBit result  :  1 words$word))
                :  2 words$word)) (vec_of_bits [B0;B0]  :  2 words$word)
            :  4 words$word)) in
        let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec split_vec (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
           (subrange_vec_dec split_vec (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
           (subrange_vec_dec split_vec (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
           (subrange_vec_dec split_vec (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__12 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__12 with<| ProcState_N := tup__0|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__13 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__13 with<| ProcState_Z := tup__1|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__14 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__14 with<| ProcState_C := tup__2|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__15 : ProcState) . 
        sail2_state_monad$write_regS PSTATE_ref (w__15 with<| ProcState_V := tup__3|>)))))
      else sail2_state_monad$returnS () )
     (aset_X d result))))
   else if (((l__168 = (( 128 : int):ii)))) then
     let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 128 : int):ii) n  : ( 128 words$word) M)) (\ (operand1 : 128 bits) .  sail2_state_monad$bindS
     (ShiftReg (( 128 : int):ii) m shift_type shift_amount  : ( 128 words$word) M) (\ (operand2 : 128 bits) . 
     let (operand2 : 128 bits) = (if invert then (not_vec operand2  :  128 words$word) else operand2) in sail2_state_monad$bindS
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M) (\ (result : 128 bits) . 
     let (result : 128 bits) =
       ((case op of
         LogicalOp_AND => (and_vec operand1 operand2  :  128 words$word)
       | LogicalOp_ORR => (or_vec operand1 operand2  :  128 words$word)
       | LogicalOp_EOR => (xor_vec operand1 operand2  :  128 words$word)
       )) in sail2_state_monad$seqS
     (if setflags then
        let split_vec =
          ((concat_vec
             ((concat_vec
                 (vec_of_bits [access_vec_dec result (((( 128 : int):ii) - (( 1 : int):ii)))]  :  1 words$word)
                 ((IsZeroBit result  :  1 words$word))
                :  2 words$word)) (vec_of_bits [B0;B0]  :  2 words$word)
            :  4 words$word)) in
        let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec split_vec (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
           (subrange_vec_dec split_vec (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
           (subrange_vec_dec split_vec (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
           (subrange_vec_dec split_vec (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__16 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__16 with<| ProcState_N := tup__0|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__17 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__17 with<| ProcState_Z := tup__1|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__18 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__18 with<| ProcState_C := tup__2|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__19 : ProcState) . 
        sail2_state_monad$write_regS PSTATE_ref (w__19 with<| ProcState_V := tup__3|>)))))
      else sail2_state_monad$returnS () )
     (aset_X d result))))
   else
     let dbytes = (ex_int ((l__168 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint"))`;


(*val aarch64_integer_arithmetic_addsub_shiftedreg : ii -> ii -> ii -> ii -> bool -> ii -> ShiftType -> bool -> M unit*)

val _ = Define `
 ((aarch64_integer_arithmetic_addsub_shiftedreg:int -> int -> int -> int -> bool -> int -> ShiftType -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d l__163 m n setflags shift_amount shift_type sub_op=
    (if (((l__163 = (( 8 : int):ii)))) then
     let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M)) (\ (result : 8 bits) .  sail2_state_monad$bindS
     (aget_X (( 8 : int):ii) n  : ( 8 words$word) M) (\ (operand1 : 8 bits) .  sail2_state_monad$bindS
     (ShiftReg (( 8 : int):ii) m shift_type shift_amount  : ( 8 words$word) M) (\ (operand2 : 8 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (nzcv1 : 4 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (carry_in : 1 bits) . 
     let ((carry_in : 1 bits), (operand2 : 8 bits)) =
       (if sub_op then
         let (operand2 : 8 bits) = ((not_vec operand2  :  8 words$word)) in
         let (carry_in : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
         (carry_in, operand2)
       else
         let (carry_in : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in
         (carry_in, operand2)) in
     let (tup__0, tup__1) = ((AddWithCarry operand1 operand2 carry_in  : ( 8 words$word #  4 words$word))) in
     let result = tup__0 in
     let nzcv1 = tup__1 in sail2_state_monad$seqS
     (if setflags then
        let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec nzcv1 (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__0 with<| ProcState_N := tup__0|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__1 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__1 with<| ProcState_Z := tup__1|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__2 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__2 with<| ProcState_C := tup__2|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__3 : ProcState) . 
        sail2_state_monad$write_regS PSTATE_ref (w__3 with<| ProcState_V := tup__3|>)))))
      else sail2_state_monad$returnS () )
     (aset_X d result))))))
   else if (((l__163 = (( 16 : int):ii)))) then
     let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M)) (\ (result : 16 bits) .  sail2_state_monad$bindS
     (aget_X (( 16 : int):ii) n  : ( 16 words$word) M) (\ (operand1 : 16 bits) .  sail2_state_monad$bindS
     (ShiftReg (( 16 : int):ii) m shift_type shift_amount  : ( 16 words$word) M) (\ (operand2 : 16 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (nzcv1 : 4 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (carry_in : 1 bits) . 
     let ((carry_in : 1 bits), (operand2 : 16 bits)) =
       (if sub_op then
         let (operand2 : 16 bits) = ((not_vec operand2  :  16 words$word)) in
         let (carry_in : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
         (carry_in, operand2)
       else
         let (carry_in : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in
         (carry_in, operand2)) in
     let (tup__0, tup__1) = ((AddWithCarry operand1 operand2 carry_in  : ( 16 words$word #  4 words$word))) in
     let result = tup__0 in
     let nzcv1 = tup__1 in sail2_state_monad$seqS
     (if setflags then
        let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec nzcv1 (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__4 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__4 with<| ProcState_N := tup__0|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__5 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__5 with<| ProcState_Z := tup__1|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__6 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__6 with<| ProcState_C := tup__2|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__7 : ProcState) . 
        sail2_state_monad$write_regS PSTATE_ref (w__7 with<| ProcState_V := tup__3|>)))))
      else sail2_state_monad$returnS () )
     (aset_X d result))))))
   else if (((l__163 = (( 32 : int):ii)))) then
     let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (result : 32 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) n  : ( 32 words$word) M) (\ (operand1 : 32 bits) .  sail2_state_monad$bindS
     (ShiftReg (( 32 : int):ii) m shift_type shift_amount  : ( 32 words$word) M) (\ (operand2 : 32 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (nzcv1 : 4 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (carry_in : 1 bits) . 
     let ((carry_in : 1 bits), (operand2 : 32 bits)) =
       (if sub_op then
         let (operand2 : 32 bits) = ((not_vec operand2  :  32 words$word)) in
         let (carry_in : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
         (carry_in, operand2)
       else
         let (carry_in : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in
         (carry_in, operand2)) in
     let (tup__0, tup__1) = ((AddWithCarry operand1 operand2 carry_in  : ( 32 words$word #  4 words$word))) in
     let result = tup__0 in
     let nzcv1 = tup__1 in sail2_state_monad$seqS
     (if setflags then
        let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec nzcv1 (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__8 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__8 with<| ProcState_N := tup__0|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__9 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__9 with<| ProcState_Z := tup__1|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__10 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__10 with<| ProcState_C := tup__2|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__11 : ProcState) . 
        sail2_state_monad$write_regS PSTATE_ref (w__11 with<| ProcState_V := tup__3|>)))))
      else sail2_state_monad$returnS () )
     (aset_X d result))))))
   else if (((l__163 = (( 64 : int):ii)))) then
     let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (result : 64 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) n  : ( 64 words$word) M) (\ (operand1 : 64 bits) .  sail2_state_monad$bindS
     (ShiftReg (( 64 : int):ii) m shift_type shift_amount  : ( 64 words$word) M) (\ (operand2 : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (nzcv1 : 4 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (carry_in : 1 bits) . 
     let ((carry_in : 1 bits), (operand2 : 64 bits)) =
       (if sub_op then
         let (operand2 : 64 bits) = ((not_vec operand2  :  64 words$word)) in
         let (carry_in : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
         (carry_in, operand2)
       else
         let (carry_in : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in
         (carry_in, operand2)) in
     let (tup__0, tup__1) = ((AddWithCarry operand1 operand2 carry_in  : ( 64 words$word #  4 words$word))) in
     let result = tup__0 in
     let nzcv1 = tup__1 in sail2_state_monad$seqS
     (if setflags then
        let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec nzcv1 (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__12 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__12 with<| ProcState_N := tup__0|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__13 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__13 with<| ProcState_Z := tup__1|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__14 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__14 with<| ProcState_C := tup__2|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__15 : ProcState) . 
        sail2_state_monad$write_regS PSTATE_ref (w__15 with<| ProcState_V := tup__3|>)))))
      else sail2_state_monad$returnS () )
     (aset_X d result))))))
   else if (((l__163 = (( 128 : int):ii)))) then
     let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M)) (\ (result : 128 bits) .  sail2_state_monad$bindS
     (aget_X (( 128 : int):ii) n  : ( 128 words$word) M) (\ (operand1 : 128 bits) .  sail2_state_monad$bindS
     (ShiftReg (( 128 : int):ii) m shift_type shift_amount  : ( 128 words$word) M) (\ (operand2 : 128 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (nzcv1 : 4 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (carry_in : 1 bits) . 
     let ((carry_in : 1 bits), (operand2 : 128 bits)) =
       (if sub_op then
         let (operand2 : 128 bits) = ((not_vec operand2  :  128 words$word)) in
         let (carry_in : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
         (carry_in, operand2)
       else
         let (carry_in : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in
         (carry_in, operand2)) in
     let (tup__0, tup__1) = ((AddWithCarry operand1 operand2 carry_in  : ( 128 words$word #  4 words$word))) in
     let result = tup__0 in
     let nzcv1 = tup__1 in sail2_state_monad$seqS
     (if setflags then
        let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec nzcv1 (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__16 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__16 with<| ProcState_N := tup__0|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__17 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__17 with<| ProcState_Z := tup__1|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__18 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__18 with<| ProcState_C := tup__2|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__19 : ProcState) . 
        sail2_state_monad$write_regS PSTATE_ref (w__19 with<| ProcState_V := tup__3|>)))))
      else sail2_state_monad$returnS () )
     (aset_X d result))))))
   else
     let dbytes = (ex_int ((l__163 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint"))`;


(*val Prefetch : mword ty64 -> mword ty5 -> M unit*)

val _ = Define `
 ((Prefetch:(64)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) address prfop=  (sail2_state_monad$bindS
   (undefined_PrefetchHint () ) (\ (hint : PrefetchHint) .  sail2_state_monad$bindS
   (undefined_int () ) (\ (target : ii) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (stream : bool) . 
   let b__0 = ((slice prfop (( 3 : int):ii) (( 2 : int):ii)  :  2 words$word)) in
   let (hint : PrefetchHint) =
     (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then Prefetch_READ
     else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then Prefetch_EXEC
     else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then Prefetch_WRITE
     else hint) in
   let (target : ii) = (lem$w2ui ((slice prfop (( 1 : int):ii) (( 2 : int):ii)  :  2 words$word))) in
   let (stream : bool) =
     ((vec_of_bits [access_vec_dec prfop (( 0 : int):ii)]  :  1 words$word) <> (vec_of_bits [B0]  :  1 words$word)) in
   let (_ : unit) = (Hint_Prefetch address hint target stream) in
   sail2_state_monad$returnS () )))))`;


(*val IsSecondStage : FaultRecord -> M bool*)

val _ = Define `
 ((IsSecondStage:FaultRecord ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) fault=  (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS (((fault.FaultRecord_typ <> Fault_None))) "((fault).type != Fault_None)")
   (sail2_state_monad$returnS fault.FaultRecord_secondstage)))`;


(*val IsFault : AddressDescriptor -> bool*)

val _ = Define `
 ((IsFault:AddressDescriptor -> bool) addrdesc=  (addrdesc.AddressDescriptor_fault.FaultRecord_typ <> Fault_None))`;


(*val CombineS1S2Desc : AddressDescriptor -> AddressDescriptor -> M AddressDescriptor*)

val _ = Define `
 ((CombineS1S2Desc:AddressDescriptor -> AddressDescriptor ->(regstate)sail2_state_monad$sequential_state ->(((AddressDescriptor),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) s1desc s2desc=  (sail2_state_monad$bindS
   (undefined_AddressDescriptor () ) (\ (result : AddressDescriptor) . 
   let result = ((result with<| AddressDescriptor_paddress := (s2desc.AddressDescriptor_paddress)|>)) in sail2_state_monad$bindS
   (if (((((IsFault s1desc)) \/ ((IsFault s2desc))))) then
      let (result : AddressDescriptor) = (if ((IsFault s1desc)) then s1desc else s2desc) in
      sail2_state_monad$returnS result
    else if ((((((s2desc.AddressDescriptor_memattrs.MemoryAttributes_typ = MemType_Device))) \/ (((s1desc.AddressDescriptor_memattrs.MemoryAttributes_typ = MemType_Device)))))) then
      let (tmp_610 : MemoryAttributes) = (result.AddressDescriptor_memattrs) in
      let tmp_610 = ((tmp_610 with<| MemoryAttributes_typ := MemType_Device|>)) in
      let result = ((result with<| AddressDescriptor_memattrs := tmp_610|>)) in
      if (((s1desc.AddressDescriptor_memattrs.MemoryAttributes_typ = MemType_Normal))) then
        let (tmp_620 : MemoryAttributes) = (result.AddressDescriptor_memattrs) in
        let (tmp_620 : MemoryAttributes) =
          ((tmp_620 with<|
            MemoryAttributes_device := (s2desc.AddressDescriptor_memattrs.MemoryAttributes_device)|>)) in
        let (result : AddressDescriptor) = ((result with<| AddressDescriptor_memattrs := tmp_620|>)) in
        sail2_state_monad$returnS result
      else if (((s2desc.AddressDescriptor_memattrs.MemoryAttributes_typ = MemType_Normal))) then
        let (tmp_630 : MemoryAttributes) = (result.AddressDescriptor_memattrs) in
        let (tmp_630 : MemoryAttributes) =
          ((tmp_630 with<|
            MemoryAttributes_device := (s1desc.AddressDescriptor_memattrs.MemoryAttributes_device)|>)) in
        let (result : AddressDescriptor) = ((result with<| AddressDescriptor_memattrs := tmp_630|>)) in
        sail2_state_monad$returnS result
      else
        let (tmp_640 : MemoryAttributes) = (result.AddressDescriptor_memattrs) in sail2_state_monad$bindS
        (CombineS1S2Device s1desc.AddressDescriptor_memattrs.MemoryAttributes_device
          s2desc.AddressDescriptor_memattrs.MemoryAttributes_device) (\ (w__0 : DeviceType) . 
        let (tmp_640 : MemoryAttributes) = ((tmp_640 with<| MemoryAttributes_device := w__0|>)) in
        let (result : AddressDescriptor) = ((result with<| AddressDescriptor_memattrs := tmp_640|>)) in
        sail2_state_monad$returnS result)
    else
      let (tmp_650 : MemoryAttributes) = (result.AddressDescriptor_memattrs) in
      let tmp_650 = ((tmp_650 with<| MemoryAttributes_typ := MemType_Normal|>)) in
      let result = ((result with<| AddressDescriptor_memattrs := tmp_650|>)) in
      let (tmp_660 : MemoryAttributes) = (result.AddressDescriptor_memattrs) in sail2_state_monad$bindS
      (undefined_DeviceType () ) (\ (w__1 : DeviceType) . 
      let tmp_660 = ((tmp_660 with<| MemoryAttributes_device := w__1|>)) in
      let result = ((result with<| AddressDescriptor_memattrs := tmp_660|>)) in
      let (tmp_670 : MemoryAttributes) = (result.AddressDescriptor_memattrs) in sail2_state_monad$bindS
      (CombineS1S2AttrHints s1desc.AddressDescriptor_memattrs.MemoryAttributes_inner
        s2desc.AddressDescriptor_memattrs.MemoryAttributes_inner) (\ (w__2 : MemAttrHints) . 
      let tmp_670 = ((tmp_670 with<| MemoryAttributes_inner := w__2|>)) in
      let result = ((result with<| AddressDescriptor_memattrs := tmp_670|>)) in
      let (tmp_680 : MemoryAttributes) = (result.AddressDescriptor_memattrs) in sail2_state_monad$bindS
      (CombineS1S2AttrHints s1desc.AddressDescriptor_memattrs.MemoryAttributes_outer
        s2desc.AddressDescriptor_memattrs.MemoryAttributes_outer) (\ (w__3 : MemAttrHints) . 
      let (tmp_680 : MemoryAttributes) = ((tmp_680 with<| MemoryAttributes_outer := w__3|>)) in
      let (result : AddressDescriptor) = ((result with<| AddressDescriptor_memattrs := tmp_680|>)) in
      let (tmp_690 : MemoryAttributes) = (result.AddressDescriptor_memattrs) in
      let (tmp_690 : MemoryAttributes) =
        ((tmp_690 with<|
          MemoryAttributes_shareable :=
            (((s1desc.AddressDescriptor_memattrs.MemoryAttributes_shareable \/ s2desc.AddressDescriptor_memattrs.MemoryAttributes_shareable)))|>)) in
      let (result : AddressDescriptor) = ((result with<| AddressDescriptor_memattrs := tmp_690|>)) in
      let (tmp_700 : MemoryAttributes) = (result.AddressDescriptor_memattrs) in
      let (tmp_700 : MemoryAttributes) =
        ((tmp_700 with<|
          MemoryAttributes_outershareable :=
            (((s1desc.AddressDescriptor_memattrs.MemoryAttributes_outershareable \/ s2desc.AddressDescriptor_memattrs.MemoryAttributes_outershareable)))|>)) in
      let (result : AddressDescriptor) = ((result with<| AddressDescriptor_memattrs := tmp_700|>)) in
      sail2_state_monad$returnS result)))) (\ (result : AddressDescriptor) .  sail2_state_monad$bindS
   (MemAttrDefaults result.AddressDescriptor_memattrs) (\ (w__4 : MemoryAttributes) . 
   let (result : AddressDescriptor) = ((result with<| AddressDescriptor_memattrs := w__4|>)) in
   sail2_state_monad$returnS result)))))`;


(*val IsExternalSyncAbort__0 : Fault -> M bool*)

(*val IsExternalSyncAbort__1 : FaultRecord -> M bool*)

val _ = Define `
 ((IsExternalSyncAbort__0:Fault ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) typ=  (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS (((typ <> Fault_None))) "")
   (sail2_state_monad$returnS ((((((typ = Fault_SyncExternal))) \/ ((((((typ = Fault_SyncParity))) \/ ((((((typ = Fault_SyncExternalOnWalk))) \/ (((typ = Fault_SyncParityOnWalk)))))))))))))))`;


val _ = Define `
 ((IsExternalSyncAbort__1:FaultRecord ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) fault=  (IsExternalSyncAbort__0 fault.FaultRecord_typ))`;


(*val IsExternalAbort__0 : Fault -> M bool*)

(*val IsExternalAbort__1 : FaultRecord -> M bool*)

val _ = Define `
 ((IsExternalAbort__0:Fault ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) typ=  (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS (((typ <> Fault_None))) "")
   (sail2_state_monad$returnS ((((((typ = Fault_SyncExternal))) \/ ((((((typ = Fault_SyncParity))) \/ ((((((typ = Fault_SyncExternalOnWalk))) \/ ((((((typ = Fault_SyncParityOnWalk))) \/ ((((((typ = Fault_AsyncExternal))) \/ (((typ = Fault_AsyncParity)))))))))))))))))))))`;


val _ = Define `
 ((IsExternalAbort__1:FaultRecord ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) fault=  (IsExternalAbort__0 fault.FaultRecord_typ))`;


(*val IsDebugException : FaultRecord -> M bool*)

val _ = Define `
 ((IsDebugException:FaultRecord ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) fault=  (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS (((fault.FaultRecord_typ <> Fault_None))) "((fault).type != Fault_None)")
   (sail2_state_monad$returnS (((fault.FaultRecord_typ = Fault_Debug))))))`;


(*val IPAValid : FaultRecord -> M bool*)

val _ = Define `
 ((IPAValid:FaultRecord ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) fault=  (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS (((fault.FaultRecord_typ <> Fault_None))) "((fault).type != Fault_None)")
   (sail2_state_monad$returnS (if fault.FaultRecord_s2fs1walk then
             ((((fault.FaultRecord_typ = Fault_AccessFlag))) \/ ((((((fault.FaultRecord_typ = Fault_Permission))) \/ ((((((fault.FaultRecord_typ = Fault_Translation))) \/ (((fault.FaultRecord_typ = Fault_AddressSize))))))))))
           else if fault.FaultRecord_secondstage then
             ((((fault.FaultRecord_typ = Fault_AccessFlag))) \/ ((((((fault.FaultRecord_typ = Fault_Translation))) \/ (((fault.FaultRecord_typ = Fault_AddressSize)))))))
           else F))))`;


(*val aarch64_integer_logical_immediate : forall 'datasize. Size 'datasize => ii -> itself 'datasize -> mword 'datasize -> ii -> LogicalOp -> bool -> M unit*)

val _ = Define `
 ((aarch64_integer_logical_immediate:int -> 'datasize itself -> 'datasize words$word -> int -> LogicalOp -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d datasize imm n op setflags=
    (let datasize = (size_itself_int datasize) in
   let dbytes = (ex_int ((datasize / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS T "datasize constraint")
   (sail2_state_monad$assert_expS T "dbytes constraint"))
   (undefined_bitvector datasize  : ( 'datasize words$word) M)) (\ (result : 'datasize bits) .  sail2_state_monad$bindS
   (aget_X datasize n  : ( 'datasize words$word) M) (\ (operand1 : 'datasize bits) . 
   let (operand2 : 'datasize bits) = imm in
   let (result : 'datasize bits) =
     ((case op of
       LogicalOp_AND => (and_vec operand1 operand2  :  'datasize words$word)
     | LogicalOp_ORR => (or_vec operand1 operand2  :  'datasize words$word)
     | LogicalOp_EOR => (xor_vec operand1 operand2  :  'datasize words$word)
     )) in sail2_state_monad$seqS
   (if setflags then
      let split_vec =
        ((concat_vec
           ((concat_vec
               (vec_of_bits [access_vec_dec result ((datasize - (( 1 : int):ii)))]  :  1 words$word)
               ((IsZeroBit result  :  1 words$word))
              :  2 words$word)) (vec_of_bits [B0;B0]  :  2 words$word)
          :  4 words$word)) in
      let (tup__0, tup__1, tup__2, tup__3) =
        ((subrange_vec_dec split_vec (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__0 with<| ProcState_N := tup__0|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__1 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__1 with<| ProcState_Z := tup__1|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__2 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__2 with<| ProcState_C := tup__2|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__3 : ProcState) . 
      sail2_state_monad$write_regS PSTATE_ref (w__3 with<| ProcState_V := tup__3|>)))))
    else sail2_state_monad$returnS () )
   (if ((((((d = (( 31 : int):ii)))) /\ ((~ setflags))))) then aset_SP result
   else aset_X d result)))))`;


(*val aarch64_integer_arithmetic_addsub_immediate : forall 'datasize. Size 'datasize => ii -> itself 'datasize -> mword 'datasize -> ii -> bool -> bool -> M unit*)

val _ = Define `
 ((aarch64_integer_arithmetic_addsub_immediate:int -> 'datasize itself -> 'datasize words$word -> int -> bool -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d datasize imm n setflags sub_op=
    (let datasize = (size_itself_int datasize) in
   let dbytes = (ex_int ((datasize / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS T "datasize constraint")
   (sail2_state_monad$assert_expS T "dbytes constraint"))
   (undefined_bitvector datasize  : ( 'datasize words$word) M)) (\ (result : 'datasize bits) .  sail2_state_monad$bindS
   (if (((n = (( 31 : int):ii)))) then (aget_SP datasize ()   : ( 'datasize words$word) M)
    else (aget_X datasize n  : ( 'datasize words$word) M)) (\ (operand1 : 'datasize bits) . 
   let (operand2 : 'datasize bits) = imm in sail2_state_monad$bindS
   (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (nzcv1 : 4 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (carry_in : 1 bits) . 
   let ((carry_in : 1 bits), (operand2 : 'datasize bits)) =
     (if sub_op then
       let (operand2 : 'datasize bits) = ((not_vec operand2  :  'datasize words$word)) in
       let (carry_in : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
       (carry_in, operand2)
     else
       let (carry_in : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in
       (carry_in, operand2)) in
   let (tup__0, tup__1) = ((AddWithCarry operand1 operand2 carry_in  : ( 'datasize words$word #  4 words$word))) in
   let result = tup__0 in
   let nzcv1 = tup__1 in sail2_state_monad$seqS
   (if setflags then
      let (tup__0, tup__1, tup__2, tup__3) =
        ((subrange_vec_dec nzcv1 (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
         (subrange_vec_dec nzcv1 (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
         (subrange_vec_dec nzcv1 (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
         (subrange_vec_dec nzcv1 (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__2 with<| ProcState_N := tup__0|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__3 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__3 with<| ProcState_Z := tup__1|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__4 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__4 with<| ProcState_C := tup__2|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__5 : ProcState) . 
      sail2_state_monad$write_regS PSTATE_ref (w__5 with<| ProcState_V := tup__3|>)))))
    else sail2_state_monad$returnS () )
   (if ((((((d = (( 31 : int):ii)))) /\ ((~ setflags))))) then aset_SP result
   else aset_X d result)))))))`;


(*val aarch64_integer_arithmetic_addsub_extendedreg : ii -> ii -> ExtendType -> ii -> ii -> bool -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_integer_arithmetic_addsub_extendedreg:int -> int -> ExtendType -> int -> int -> bool -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d l__158 extend_type m n setflags shift sub_op=
    (if (((l__158 = (( 8 : int):ii)))) then
     let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M)) (\ (result : 8 bits) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then (aget_SP (( 8 : int):ii) ()   : ( 8 words$word) M)
      else (aget_X (( 8 : int):ii) n  : ( 8 words$word) M)) (\ (operand1 : 8 bits) .  sail2_state_monad$bindS
     (ExtendReg (( 8 : int):ii) m extend_type shift  : ( 8 words$word) M) (\ (operand2 : 8 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (nzcv1 : 4 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (carry_in : 1 bits) . 
     let ((carry_in : 1 bits), (operand2 : 8 bits)) =
       (if sub_op then
         let (operand2 : 8 bits) = ((not_vec operand2  :  8 words$word)) in
         let (carry_in : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
         (carry_in, operand2)
       else
         let (carry_in : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in
         (carry_in, operand2)) in
     let (tup__0, tup__1) = ((AddWithCarry operand1 operand2 carry_in  : ( 8 words$word #  4 words$word))) in
     let result = tup__0 in
     let nzcv1 = tup__1 in sail2_state_monad$seqS
     (if setflags then
        let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec nzcv1 (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__2 with<| ProcState_N := tup__0|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__3 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__3 with<| ProcState_Z := tup__1|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__4 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__4 with<| ProcState_C := tup__2|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__5 : ProcState) . 
        sail2_state_monad$write_regS PSTATE_ref (w__5 with<| ProcState_V := tup__3|>)))))
      else sail2_state_monad$returnS () )
     (if ((((((d = (( 31 : int):ii)))) /\ ((~ setflags))))) then aset_SP result
     else aset_X d result))))))
   else if (((l__158 = (( 16 : int):ii)))) then
     let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M)) (\ (result : 16 bits) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then (aget_SP (( 16 : int):ii) ()   : ( 16 words$word) M)
      else (aget_X (( 16 : int):ii) n  : ( 16 words$word) M)) (\ (operand1 : 16 bits) .  sail2_state_monad$bindS
     (ExtendReg (( 16 : int):ii) m extend_type shift  : ( 16 words$word) M) (\ (operand2 : 16 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (nzcv1 : 4 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (carry_in : 1 bits) . 
     let ((carry_in : 1 bits), (operand2 : 16 bits)) =
       (if sub_op then
         let (operand2 : 16 bits) = ((not_vec operand2  :  16 words$word)) in
         let (carry_in : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
         (carry_in, operand2)
       else
         let (carry_in : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in
         (carry_in, operand2)) in
     let (tup__0, tup__1) = ((AddWithCarry operand1 operand2 carry_in  : ( 16 words$word #  4 words$word))) in
     let result = tup__0 in
     let nzcv1 = tup__1 in sail2_state_monad$seqS
     (if setflags then
        let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec nzcv1 (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__8 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__8 with<| ProcState_N := tup__0|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__9 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__9 with<| ProcState_Z := tup__1|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__10 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__10 with<| ProcState_C := tup__2|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__11 : ProcState) . 
        sail2_state_monad$write_regS PSTATE_ref (w__11 with<| ProcState_V := tup__3|>)))))
      else sail2_state_monad$returnS () )
     (if ((((((d = (( 31 : int):ii)))) /\ ((~ setflags))))) then aset_SP result
     else aset_X d result))))))
   else if (((l__158 = (( 32 : int):ii)))) then
     let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (result : 32 bits) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then (aget_SP (( 32 : int):ii) ()   : ( 32 words$word) M)
      else (aget_X (( 32 : int):ii) n  : ( 32 words$word) M)) (\ (operand1 : 32 bits) .  sail2_state_monad$bindS
     (ExtendReg (( 32 : int):ii) m extend_type shift  : ( 32 words$word) M) (\ (operand2 : 32 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (nzcv1 : 4 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (carry_in : 1 bits) . 
     let ((carry_in : 1 bits), (operand2 : 32 bits)) =
       (if sub_op then
         let (operand2 : 32 bits) = ((not_vec operand2  :  32 words$word)) in
         let (carry_in : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
         (carry_in, operand2)
       else
         let (carry_in : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in
         (carry_in, operand2)) in
     let (tup__0, tup__1) = ((AddWithCarry operand1 operand2 carry_in  : ( 32 words$word #  4 words$word))) in
     let result = tup__0 in
     let nzcv1 = tup__1 in sail2_state_monad$seqS
     (if setflags then
        let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec nzcv1 (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__14 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__14 with<| ProcState_N := tup__0|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__15 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__15 with<| ProcState_Z := tup__1|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__16 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__16 with<| ProcState_C := tup__2|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__17 : ProcState) . 
        sail2_state_monad$write_regS PSTATE_ref (w__17 with<| ProcState_V := tup__3|>)))))
      else sail2_state_monad$returnS () )
     (if ((((((d = (( 31 : int):ii)))) /\ ((~ setflags))))) then aset_SP result
     else aset_X d result))))))
   else if (((l__158 = (( 64 : int):ii)))) then
     let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (result : 64 bits) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (operand1 : 64 bits) .  sail2_state_monad$bindS
     (ExtendReg (( 64 : int):ii) m extend_type shift  : ( 64 words$word) M) (\ (operand2 : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (nzcv1 : 4 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (carry_in : 1 bits) . 
     let ((carry_in : 1 bits), (operand2 : 64 bits)) =
       (if sub_op then
         let (operand2 : 64 bits) = ((not_vec operand2  :  64 words$word)) in
         let (carry_in : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
         (carry_in, operand2)
       else
         let (carry_in : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in
         (carry_in, operand2)) in
     let (tup__0, tup__1) = ((AddWithCarry operand1 operand2 carry_in  : ( 64 words$word #  4 words$word))) in
     let result = tup__0 in
     let nzcv1 = tup__1 in sail2_state_monad$seqS
     (if setflags then
        let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec nzcv1 (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__20 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__20 with<| ProcState_N := tup__0|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__21 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__21 with<| ProcState_Z := tup__1|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__22 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__22 with<| ProcState_C := tup__2|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__23 : ProcState) . 
        sail2_state_monad$write_regS PSTATE_ref (w__23 with<| ProcState_V := tup__3|>)))))
      else sail2_state_monad$returnS () )
     (if ((((((d = (( 31 : int):ii)))) /\ ((~ setflags))))) then aset_SP result
     else aset_X d result))))))
   else if (((l__158 = (( 128 : int):ii)))) then
     let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M)) (\ (result : 128 bits) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then (aget_SP (( 128 : int):ii) ()   : ( 128 words$word) M)
      else (aget_X (( 128 : int):ii) n  : ( 128 words$word) M)) (\ (operand1 : 128 bits) .  sail2_state_monad$bindS
     (ExtendReg (( 128 : int):ii) m extend_type shift  : ( 128 words$word) M) (\ (operand2 : 128 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (nzcv1 : 4 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (carry_in : 1 bits) . 
     let ((carry_in : 1 bits), (operand2 : 128 bits)) =
       (if sub_op then
         let (operand2 : 128 bits) = ((not_vec operand2  :  128 words$word)) in
         let (carry_in : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
         (carry_in, operand2)
       else
         let (carry_in : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in
         (carry_in, operand2)) in
     let (tup__0, tup__1) = ((AddWithCarry operand1 operand2 carry_in  : ( 128 words$word #  4 words$word))) in
     let result = tup__0 in
     let nzcv1 = tup__1 in sail2_state_monad$seqS
     (if setflags then
        let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec nzcv1 (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
           (subrange_vec_dec nzcv1 (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__26 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__26 with<| ProcState_N := tup__0|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__27 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__27 with<| ProcState_Z := tup__1|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__28 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__28 with<| ProcState_C := tup__2|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__29 : ProcState) . 
        sail2_state_monad$write_regS PSTATE_ref (w__29 with<| ProcState_V := tup__3|>)))))
      else sail2_state_monad$returnS () )
     (if ((((((d = (( 31 : int):ii)))) /\ ((~ setflags))))) then aset_SP result
     else aset_X d result))))))
   else
     let dbytes = (ex_int ((l__158 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint"))`;


(*val RestoredITBits : mword ty32 -> M (mword ty8)*)

val _ = Define `
 ((RestoredITBits:(32)words$word ->(regstate)sail2_state_monad$sequential_state ->((((8)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) spsr=
    (let (it : 8 bits) =
     ((concat_vec ((subrange_vec_dec spsr (( 15 : int):ii) (( 10 : int):ii)  :  6 words$word))
        ((subrange_vec_dec spsr (( 26 : int):ii) (( 25 : int):ii)  :  2 words$word))
       :  8 words$word)) in sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) . 
   if (((w__0.ProcState_IL = (vec_of_bits [B1]  :  1 words$word)))) then sail2_state_monad$bindS
     (ConstrainUnpredictableBool Unpredictable_ILZEROIT) (\ (w__1 : bool) . 
     sail2_state_monad$returnS (if w__1 then (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0]  :  8 words$word)
             else it))
   else if (((((~ ((IsZero ((subrange_vec_dec it (( 7 : int):ii) (( 4 : int):ii)  :  4 words$word)))))) /\ ((IsZero ((subrange_vec_dec it (( 3 : int):ii) (( 0 : int):ii)  :  4 words$word))))))) then
     sail2_state_monad$returnS (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0]  :  8 words$word)
   else sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) .  sail2_state_monad$bindS
     (if (((w__2.ProcState_EL = EL2))) then sail2_state_monad$bindS
        (sail2_state_monad$read_regS HSCTLR_ref  : ( 32 words$word) M) (\ (w__3 : 32 bits) . 
        sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__3 (( 7 : int):ii)]  :  1 words$word))
      else sail2_state_monad$bindS
        (sail2_state_monad$read_regS SCTLR_ref  : ( 32 words$word) M) (\ (w__4 : 32 bits) . 
        sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__4 (( 7 : int):ii)]  :  1 words$word))) (\ (itd : 1 bits) . 
     sail2_state_monad$returnS (if ((((((((((vec_of_bits [access_vec_dec spsr (( 5 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))) /\ ((~ ((IsZero it))))))) \/ ((((((itd = (vec_of_bits [B1]  :  1 words$word)))) /\ ((~ ((IsZero ((subrange_vec_dec it (( 2 : int):ii) (( 0 : int):ii)  :  3 words$word))))))))))))
             then
               (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0]  :  8 words$word)
             else it))))))`;


(*val IsEL1TransRegimeRegs : unit -> M bool*)

val _ = Define `
 ((IsEL1TransRegimeRegs:unit ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$or_boolS
     (sail2_state$or_boolS (sail2_state_monad$returnS ((~ ((HaveEL EL2)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) .  sail2_state_monad$returnS (((w__0.ProcState_EL = EL1))))))
     (sail2_state$and_boolS
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) .  sail2_state_monad$returnS (((w__2.ProcState_EL = EL0)))))
        (sail2_state$or_boolS
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__3 : 64 bits) . 
            sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__3 (( 34 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__4 : 64 bits) . 
            sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__4 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))))))`;


(*val CalculateTBI : mword ty64 -> bool -> M bool*)

val _ = Define `
 ((CalculateTBI:(64)words$word -> bool ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) ptr data=
    (let (tbi : bool) = F in sail2_state_monad$bindS
   (PtrHasUpperAndLowerAddRanges () ) (\ (w__0 : bool) . 
   if w__0 then sail2_state_monad$bindS
     (IsEL1TransRegimeRegs () ) (\ (w__1 : bool) . 
     if w__1 then
       if data then
         if ((((vec_of_bits [access_vec_dec ptr (( 55 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then sail2_state_monad$bindS
           (sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M) (\ (w__2 : 64 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__2 (( 38 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))
         else sail2_state_monad$bindS
           (sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M) (\ (w__3 : 64 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__3 (( 37 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))
       else if ((((vec_of_bits [access_vec_dec ptr (( 55 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
         sail2_state$and_boolS
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M) (\ (w__5 : 64 bits) . 
            sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__5 (( 38 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M) (\ (w__6 : 64 bits) . 
            sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__6 (( 52 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))
       else
         sail2_state$and_boolS
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M) (\ (w__8 : 64 bits) . 
            sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__8 (( 37 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M) (\ (w__9 : 64 bits) . 
            sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__9 (( 51 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))
     else if data then
       if ((((vec_of_bits [access_vec_dec ptr (( 55 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then sail2_state_monad$bindS
         (sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M) (\ (w__11 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__11 (( 38 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))
       else sail2_state_monad$bindS
         (sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M) (\ (w__12 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__12 (( 37 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))
     else if ((((vec_of_bits [access_vec_dec ptr (( 55 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
       sail2_state$and_boolS
         ( sail2_state_monad$bindS(sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M) (\ (w__14 : 64 bits) . 
          sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__14 (( 38 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))
         ( sail2_state_monad$bindS(sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M) (\ (w__15 : 64 bits) . 
          sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__15 (( 52 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))
     else
       sail2_state$and_boolS
         ( sail2_state_monad$bindS(sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M) (\ (w__17 : 64 bits) . 
          sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__17 (( 37 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))
         ( sail2_state_monad$bindS(sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M) (\ (w__18 : 64 bits) . 
          sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__18 (( 51 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))))))
   else sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__20 : ProcState) . 
     if (((w__20.ProcState_EL = EL2))) then
       if data then sail2_state_monad$bindS
         (sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M) (\ (w__21 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__21 (( 20 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))
       else
         sail2_state$and_boolS
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M) (\ (w__22 : 64 bits) . 
            sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__22 (( 20 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M) (\ (w__23 : 64 bits) . 
            sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__23 (( 29 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))
     else sail2_state_monad$bindS
       (sail2_state_monad$read_regS PSTATE_ref) (\ (w__26 : ProcState) . 
       if (((w__26.ProcState_EL = EL3))) then
         if data then sail2_state_monad$bindS
           (sail2_state_monad$read_regS TCR_EL3_ref  : ( 32 words$word) M) (\ (w__27 : 32 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__27 (( 20 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))
         else
           sail2_state$and_boolS
             ( sail2_state_monad$bindS(sail2_state_monad$read_regS TCR_EL3_ref  : ( 32 words$word) M) (\ (w__28 : 32 bits) . 
              sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__28 (( 20 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))
             ( sail2_state_monad$bindS(sail2_state_monad$read_regS TCR_EL3_ref  : ( 32 words$word) M) (\ (w__29 : 32 bits) . 
              sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__29 (( 29 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))
       else sail2_state_monad$returnS tbi)))))`;


(*val CalculateBottomPACBit : mword ty64 -> mword ty1 -> M ii*)

val _ = Define `
 ((CalculateBottomPACBit:(64)words$word ->(1)words$word ->(regstate)sail2_state_monad$sequential_state ->(((int),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) ptr top_bit=  (sail2_state_monad$bindS
   (undefined_int () ) (\ (tsz_field : ii) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (using64k : bool) .  sail2_state_monad$bindS
   (PtrHasUpperAndLowerAddRanges () ) (\ (w__0 : bool) .  sail2_state_monad$bindS
   (if w__0 then sail2_state_monad$bindS
      (IsEL1TransRegimeRegs () ) (\ (w__1 : bool) . 
      if w__1 then sail2_state_monad$bindS
        (if (((top_bit = (vec_of_bits [B1]  :  1 words$word)))) then sail2_state_monad$bindS
           (sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M) (\ (w__2 : 64 bits) . 
           sail2_state_monad$returnS ((lem$w2ui ((slice w__2 (( 16 : int):ii) (( 6 : int):ii)  :  6 words$word)))))
         else sail2_state_monad$bindS
           (sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M) (\ (w__3 : 64 bits) . 
           sail2_state_monad$returnS ((lem$w2ui ((slice w__3 (( 0 : int):ii) (( 6 : int):ii)  :  6 words$word)))))) (\ (w__4 : ii) . 
        let tsz_field = w__4 in sail2_state_monad$bindS
        (if (((top_bit = (vec_of_bits [B1]  :  1 words$word)))) then sail2_state_monad$bindS
           (sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M) (\ (w__5 : 64 bits) . 
           sail2_state_monad$returnS (((((slice w__5 (( 30 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B1]  :  2 words$word)))))
         else sail2_state_monad$bindS
           (sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M) (\ (w__6 : 64 bits) . 
           sail2_state_monad$returnS (((((slice w__6 (( 14 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B1]  :  2 words$word)))))) (\ (w__7 : bool) . 
        let (using64k : bool) = w__7 in
        sail2_state_monad$returnS (tsz_field, using64k)))
      else sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((HaveEL EL2)) "HaveEL(EL2)")
        (if (((top_bit = (vec_of_bits [B1]  :  1 words$word)))) then sail2_state_monad$bindS
           (sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M) (\ (w__8 : 64 bits) . 
           sail2_state_monad$returnS ((lem$w2ui ((slice w__8 (( 16 : int):ii) (( 6 : int):ii)  :  6 words$word)))))
         else sail2_state_monad$bindS
           (sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M) (\ (w__9 : 64 bits) . 
           sail2_state_monad$returnS ((lem$w2ui ((slice w__9 (( 0 : int):ii) (( 6 : int):ii)  :  6 words$word))))))) (\ (w__10 : ii) . 
        let tsz_field = w__10 in sail2_state_monad$bindS
        (if (((top_bit = (vec_of_bits [B1]  :  1 words$word)))) then sail2_state_monad$bindS
           (sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M) (\ (w__11 : 64 bits) . 
           sail2_state_monad$returnS (((((slice w__11 (( 30 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B1]  :  2 words$word)))))
         else sail2_state_monad$bindS
           (sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M) (\ (w__12 : 64 bits) . 
           sail2_state_monad$returnS (((((slice w__12 (( 14 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B1]  :  2 words$word)))))) (\ (w__13 : bool) . 
        let (using64k : bool) = w__13 in
        sail2_state_monad$returnS (tsz_field, using64k))))
    else sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__14 : ProcState) .  sail2_state_monad$bindS
      (if (((w__14.ProcState_EL = EL2))) then sail2_state_monad$bindS
         (sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M) (\ (w__15 : 64 bits) . 
         sail2_state_monad$returnS ((lem$w2ui ((slice w__15 (( 0 : int):ii) (( 6 : int):ii)  :  6 words$word)))))
       else sail2_state_monad$bindS
         (sail2_state_monad$read_regS TCR_EL3_ref  : ( 32 words$word) M) (\ (w__16 : 32 bits) . 
         sail2_state_monad$returnS ((lem$w2ui ((slice w__16 (( 0 : int):ii) (( 6 : int):ii)  :  6 words$word)))))) (\ (w__17 : ii) . 
      let tsz_field = w__17 in sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__18 : ProcState) .  sail2_state_monad$bindS
      (if (((w__18.ProcState_EL = EL2))) then sail2_state_monad$bindS
         (sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M) (\ (w__19 : 64 bits) . 
         sail2_state_monad$returnS (((((slice w__19 (( 14 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B1]  :  2 words$word)))))
       else sail2_state_monad$bindS
         (sail2_state_monad$read_regS TCR_EL3_ref  : ( 32 words$word) M) (\ (w__20 : 32 bits) . 
         sail2_state_monad$returnS (((((slice w__20 (( 14 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B1]  :  2 words$word)))))) (\ (w__21 : bool) . 
      let (using64k : bool) = w__21 in
      sail2_state_monad$returnS (tsz_field, using64k)))))) (\ varstup .  let ((tsz_field : ii), (using64k : bool)) = varstup in
   let (max_limit_tsz_field : ii) = ((( 39 : int):ii)) in sail2_state_monad$bindS
   (undefined_Constraint () ) (\ (c : Constraint) .  sail2_state_monad$bindS
   (if ((((ex_int tsz_field)) > ((ex_int max_limit_tsz_field)))) then
      let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in sail2_state_monad$seqS
      (sail2_state_monad$assert_expS ((((((c = Constraint_FORCE))) \/ (((c = Constraint_NONE)))))) "((c == Constraint_FORCE) || (c == Constraint_NONE))")
      (let (tsz_field : ii) = (if (((c = Constraint_FORCE))) then max_limit_tsz_field else tsz_field) in
      sail2_state_monad$returnS (c, tsz_field))
    else sail2_state_monad$returnS (c, tsz_field)) (\ varstup .  let ((c : Constraint), (tsz_field : ii)) = varstup in
   let (tszmin : ii) =
     (if (((using64k /\ (((((ex_int ((VAMax () )))) = (( 52 : int):ii))))))) then (( 12 : int):ii)
     else (( 16 : int):ii)) in sail2_state_monad$bindS
   (if ((((ex_int tsz_field)) < ((ex_int tszmin)))) then
      let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in sail2_state_monad$seqS
      (sail2_state_monad$assert_expS ((((((c = Constraint_FORCE))) \/ (((c = Constraint_NONE)))))) "((c == Constraint_FORCE) || (c == Constraint_NONE))")
      (let (tsz_field : ii) = (if (((c = Constraint_FORCE))) then tszmin else tsz_field) in
      sail2_state_monad$returnS tsz_field)
    else sail2_state_monad$returnS tsz_field) (\ (tsz_field : ii) . 
   sail2_state_monad$returnS (((( 64 : int):ii) - ((ex_int tsz_field)))))))))))))`;


(*val Auth : mword ty64 -> mword ty64 -> mword ty128 -> bool -> mword ty1 -> M (mword ty64)*)

val _ = Define `
 ((Auth:(64)words$word ->(64)words$word ->(128)words$word -> bool ->(1)words$word ->(regstate)sail2_state_monad$sequential_state ->((((64)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) ptr modifier K1 data keynumber=  (sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (PAC : 64 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (result : 64 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (original_ptr : 64 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 2 : int):ii)  : ( 2 words$word) M) (\ (error_code : 2 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (extfield : 64 bits) .  sail2_state_monad$bindS
   (CalculateTBI ptr data) (\ (tbi : bool) .  sail2_state_monad$bindS
   (CalculateBottomPACBit ptr (vec_of_bits [access_vec_dec ptr (( 55 : int):ii)]  :  1 words$word)) (\ (w__0 :
     ii) . 
   let bottom_PAC_bit = (ex_int w__0) in sail2_state_monad$seqS
   (sail2_state_monad$assert_expS T "")
   (let extfield =
     ((replicate_bits (vec_of_bits [access_vec_dec ptr (( 55 : int):ii)]  :  1 words$word) (( 64 : int):ii)  :  64 words$word)) in
   let (original_ptr : 64 bits) =
     (if tbi then
       (concat_vec ((subrange_vec_dec ptr (( 63 : int):ii) (( 56 : int):ii)  :  8 words$word))
          ((subrange_subrange_concat
              ((((((((((((~ bottom_PAC_bit)) + (( 56 : int):ii))) -
                              (( 1 : int):ii)))
                          - (((( 0 : int):ii) - (( 1 : int):ii)))))
                      +
                      ((bottom_PAC_bit - (( 1 : int):ii)))))
                  - (((( 0 : int):ii) - (( 1 : int):ii)))))
              extfield
              ((((((~ bottom_PAC_bit)) + (( 56 : int):ii))) - (( 1 : int):ii))) (( 0 : int):ii)
              ptr ((bottom_PAC_bit - (( 1 : int):ii))) (( 0 : int):ii)
             :  56 words$word))
         :  64 words$word)
     else
       (subrange_subrange_concat ((int_of_num (words$word_len PAC))) extfield
          ((((((~ bottom_PAC_bit)) + (( 64 : int):ii))) - (( 1 : int):ii))) (( 0 : int):ii) ptr
          ((bottom_PAC_bit - (( 1 : int):ii))) (( 0 : int):ii)
         :  64 words$word)) in sail2_state_monad$bindS
   (ComputePAC original_ptr modifier ((subrange_vec_dec K1 (( 127 : int):ii) (( 64 : int):ii)  :  64 words$word))
      ((subrange_vec_dec K1 (( 63 : int):ii) (( 0 : int):ii)  :  64 words$word))
     : ( 64 words$word) M) (\ (w__1 : 64 bits) . 
   let (PAC : 64 bits) = w__1 in
   let (result : 64 bits) =
     (if tbi then
       if ((subrange_subrange_eq PAC
              ((((((((~ bottom_PAC_bit)) + (( 55 : int):ii))) - (( 1 : int):ii)))
                  +
                  bottom_PAC_bit)) bottom_PAC_bit ptr
              ((((((((~ bottom_PAC_bit)) + (( 55 : int):ii))) - (( 1 : int):ii)))
                  +
                  bottom_PAC_bit)) bottom_PAC_bit)) then
         original_ptr
       else
         let (error_code : 2 bits) =
           ((concat_vec keynumber ((not_vec keynumber  :  1 words$word))  :  2 words$word)) in
         (concat_vec
            ((concat_vec ((subrange_vec_dec original_ptr (( 63 : int):ii) (( 55 : int):ii)  :  9 words$word)) error_code
               :  11 words$word)) ((subrange_vec_dec original_ptr (( 52 : int):ii) (( 0 : int):ii)  :  53 words$word))
           :  64 words$word)
     else if (((((subrange_subrange_eq PAC
                     ((((((((~ bottom_PAC_bit)) + (( 55 : int):ii))) -
                             (( 1 : int):ii)))
                         + bottom_PAC_bit)) bottom_PAC_bit ptr
                     ((((((((~ bottom_PAC_bit)) + (( 55 : int):ii))) -
                             (( 1 : int):ii)))
                         + bottom_PAC_bit)) bottom_PAC_bit)) /\ (((((subrange_vec_dec PAC (( 63 : int):ii) (( 56 : int):ii)  :  8 words$word)) = ((subrange_vec_dec ptr (( 63 : int):ii) (( 56 : int):ii)  :  8 words$word)))))))) then
       original_ptr
     else
       let (error_code : 2 bits) =
         ((concat_vec keynumber ((not_vec keynumber  :  1 words$word))  :  2 words$word)) in
       (concat_vec
          ((concat_vec (vec_of_bits [access_vec_dec original_ptr (( 63 : int):ii)]  :  1 words$word) error_code
             :  3 words$word)) ((subrange_vec_dec original_ptr (( 60 : int):ii) (( 0 : int):ii)  :  61 words$word))
         :  64 words$word)) in
   sail2_state_monad$returnS result)))))))))))`;


(*val HighestELUsingAArch32 : unit -> bool*)

val _ = Define `
 ((HighestELUsingAArch32:unit -> bool) () =  (if ((~ ((HaveAnyAArch32 () )))) then F else F))`;


(*val aget_SCR_GEN : unit -> M (mword ty32)*)

val _ = Define `
 ((aget_SCR_GEN:unit ->(regstate)sail2_state_monad$sequential_state ->((((32)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((HaveEL EL3)) "HaveEL(EL3)")
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (r : 32 bits) . 
   if ((HighestELUsingAArch32 () )) then (sail2_state_monad$read_regS SCR_ref  : ( 32 words$word) M)
   else (sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M))))`;


(*val IsSecureBelowEL3 : unit -> M bool*)

val _ = Define `
 ((IsSecureBelowEL3:unit ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (if ((HaveEL EL3)) then sail2_state_monad$bindS
     (aget_SCR_GEN ()   : ( 32 words$word) M) (\ (w__0 :  32 words$word) . 
     sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__0 (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))))
   else sail2_state_monad$returnS (if ((HaveEL EL2)) then F else F)))`;


(*val UsingAArch32 : unit -> M bool*)

val _ = Define `
 ((UsingAArch32:unit ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) . 
   let (aarch32 : bool) = (w__0.ProcState_nRW = (vec_of_bits [B1]  :  1 words$word)) in sail2_state_monad$seqS (sail2_state_monad$seqS
   (if ((~ ((HaveAnyAArch32 () )))) then sail2_state_monad$assert_expS ((~ aarch32)) "!(aarch32)"
    else sail2_state_monad$returnS () )
   (if ((HighestELUsingAArch32 () )) then sail2_state_monad$assert_expS aarch32 "aarch32"
    else sail2_state_monad$returnS () ))
   (sail2_state_monad$returnS aarch32))))`;


(*val aset_SPSR : mword ty32 -> M unit*)

val _ = Define `
 ((aset_SPSR:(32)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) value_name=  (sail2_state_monad$bindS
   (UsingAArch32 () ) (\ (w__0 : bool) . 
   if w__0 then sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__1 : ProcState) . 
     let p__298 = (w__1.ProcState_M) in
     let pat_0 = p__298 in
     if (((pat_0 = M32_FIQ))) then sail2_state_monad$write_regS SPSR_fiq_ref value_name
     else if (((pat_0 = M32_IRQ))) then sail2_state_monad$write_regS SPSR_irq_ref value_name
     else if (((pat_0 = M32_Svc))) then sail2_state_monad$write_regS SPSR_svc_ref value_name
     else if (((pat_0 = M32_Monitor))) then sail2_state_monad$write_regS SPSR_mon_ref value_name
     else if (((pat_0 = M32_Abort))) then sail2_state_monad$write_regS SPSR_abt_ref value_name
     else if (((pat_0 = M32_Hyp))) then sail2_state_monad$write_regS SPSR_hyp_ref value_name
     else if (((pat_0 = M32_Undef))) then sail2_state_monad$write_regS SPSR_und_ref value_name
     else Unreachable () )
   else sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) . 
     let p__297 = (w__2.ProcState_EL) in
     let pat_0 = p__297 in
     if (((pat_0 = EL1))) then sail2_state_monad$write_regS SPSR_EL1_ref value_name
     else if (((pat_0 = EL2))) then sail2_state_monad$write_regS SPSR_EL2_ref value_name
     else if (((pat_0 = EL3))) then sail2_state_monad$write_regS SPSR_EL3_ref value_name
     else Unreachable () ))))`;


(*val aget_SPSR : unit -> M (mword ty32)*)

val _ = Define `
 ((aget_SPSR:unit ->(regstate)sail2_state_monad$sequential_state ->((((32)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (result : 32 bits) .  sail2_state_monad$bindS
   (UsingAArch32 () ) (\ (w__0 : bool) . 
   if w__0 then sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__1 : ProcState) . 
     let p__296 = (w__1.ProcState_M) in
     let pat_0 = p__296 in
     if (((pat_0 = M32_FIQ))) then (sail2_state_monad$read_regS SPSR_fiq_ref  : ( 32 words$word) M)
     else if (((pat_0 = M32_IRQ))) then (sail2_state_monad$read_regS SPSR_irq_ref  : ( 32 words$word) M)
     else if (((pat_0 = M32_Svc))) then (sail2_state_monad$read_regS SPSR_svc_ref  : ( 32 words$word) M)
     else if (((pat_0 = M32_Monitor))) then (sail2_state_monad$read_regS SPSR_mon_ref  : ( 32 words$word) M)
     else if (((pat_0 = M32_Abort))) then (sail2_state_monad$read_regS SPSR_abt_ref  : ( 32 words$word) M)
     else if (((pat_0 = M32_Hyp))) then (sail2_state_monad$read_regS SPSR_hyp_ref  : ( 32 words$word) M)
     else if (((pat_0 = M32_Undef))) then (sail2_state_monad$read_regS SPSR_und_ref  : ( 32 words$word) M)
     else sail2_state_monad$seqS (Unreachable () ) (sail2_state_monad$returnS result))
   else sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__9 : ProcState) . 
     let p__295 = (w__9.ProcState_EL) in
     let pat_0 = p__295 in
     if (((pat_0 = EL1))) then (sail2_state_monad$read_regS SPSR_EL1_ref  : ( 32 words$word) M)
     else if (((pat_0 = EL2))) then (sail2_state_monad$read_regS SPSR_EL2_ref  : ( 32 words$word) M)
     else if (((pat_0 = EL3))) then (sail2_state_monad$read_regS SPSR_EL3_ref  : ( 32 words$word) M)
     else sail2_state_monad$seqS (Unreachable () ) (sail2_state_monad$returnS result))))))`;


(*val IsSecure : unit -> M bool*)

val _ = Define `
 ((IsSecure:unit ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (sail2_state$and_boolS
     (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(UsingAArch32 () ) (\ (w__0 : bool) .  sail2_state_monad$returnS ((~ w__0)))))
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) .  sail2_state_monad$returnS (((w__2.ProcState_EL = EL3)))))) (\ (w__3 :
     bool) . 
   if w__3 then sail2_state_monad$returnS T
   else sail2_state_monad$bindS
     (sail2_state$and_boolS (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3))) ((UsingAArch32 () )))
       ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__6 : ProcState) . 
        sail2_state_monad$returnS (((w__6.ProcState_M = M32_Monitor)))))) (\ (w__7 : bool) . 
     if w__7 then sail2_state_monad$returnS T
     else IsSecureBelowEL3 () ))))`;


(*val FPProcessException : FPExc -> mword ty32 -> M unit*)

val _ = Define `
 ((FPProcessException:FPExc ->(32)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) exception fpcr=  (sail2_state_monad$bindS
   (undefined_int () ) (\ (cumul : ii) . 
   let (cumul : ii) =
     ((case exception of
       FPExc_InvalidOp => (( 0 : int):ii)
     | FPExc_DivideByZero => (( 1 : int):ii)
     | FPExc_Overflow => (( 2 : int):ii)
     | FPExc_Underflow => (( 3 : int):ii)
     | FPExc_Inexact => (( 4 : int):ii)
     | FPExc_InputDenorm => (( 7 : int):ii)
     )) in
   let (enable : ii) = (((ex_int cumul)) + (( 8 : int):ii)) in
   if ((((vec_of_bits [access_vec_dec fpcr enable]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
     sail2_state_monad$throwS (Error_Implementation_Defined "floating-point trap handling")
   else sail2_state_monad$bindS
     (UsingAArch32 () ) (\ (w__0 : bool) . 
     if w__0 then sail2_state_monad$bindS
       (sail2_state_monad$read_regS FPSCR_ref  : ( 32 words$word) M) (\ (w__1 :  32 words$word) . 
       sail2_state_monad$write_regS
         FPSCR_ref
         ((set_slice (( 32 : int):ii) (( 1 : int):ii) w__1 cumul (vec_of_bits [B1]  :  1 words$word)  :  32 words$word)))
     else sail2_state_monad$bindS
       (sail2_state_monad$read_regS FPSR_ref  : ( 32 words$word) M) (\ (w__2 :  32 words$word) . 
       sail2_state_monad$write_regS
         FPSR_ref
         ((set_slice (( 32 : int):ii) (( 1 : int):ii) w__2 cumul (vec_of_bits [B1]  :  1 words$word)  :  32 words$word)))))))`;


(*val FPRoundBase : forall 'N . Size 'N => integer -> real -> mword ty32 -> FPRounding -> M (mword 'N)*)

val _ = Define `
 ((FPRoundBase:int -> real ->(32)words$word -> FPRounding ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) (N__tv : int) op fpcr rounding=
    (let p0_ = N__tv in
   if (((p0_ = (( 16 : int):ii)))) then sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (sail2_state_monad$assert_expS (((op <> (realFromFrac(( 0 : int))(( 10 : int)))))) ""))
     (sail2_state_monad$assert_expS (((rounding <> FPRounding_TIEAWAY))) ""))
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M)) (\ (result : 16 bits) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (F_mut : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (E_mut : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (minimum_exp : ii) . 
     let minimum_exp = (~ (( 14 : int):ii)) in
     let E_mut = ((( 5 : int):ii)) in
     let F_mut = ((( 10 : int):ii)) in sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (undefined_real () )) (\ (mantissa : real) .  sail2_state_monad$bindS
     (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (sign : 1 bits) . 
     let ((mantissa : real), (sign : 1 bits)) =
       (if ((op < (realFromFrac(( 0 : int))(( 10 : int))))) then
         let (sign : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
         let (mantissa : real) =((real_of_num 0) - op) in
         (mantissa, sign)
       else
         let (sign : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in
         let (mantissa : real) = op in
         (mantissa, sign)) in
     let (exponent : ii) = ((( 0 : int):ii)) in
     let ((exponent : ii), (mantissa : real)) =
       (while (exponent, mantissa)
         (\ varstup .  let (exponent, mantissa) = varstup in mantissa < (realFromFrac(( 10 : int))(( 10 : int))))
         (\ varstup .  let (exponent, mantissa) = varstup in
           let (mantissa : real) = (mantissa * (realFromFrac(( 20 : int))(( 10 : int)))) in
           let (exponent : ii) = (((ex_int exponent)) - (( 1 : int):ii)) in
           (exponent, mantissa))) in
     let ((exponent : ii), (mantissa : real)) =
       (while (exponent, mantissa)
         (\ varstup .  let (exponent, mantissa) = varstup in mantissa >= (realFromFrac(( 20 : int))(( 10 : int))))
         (\ varstup .  let (exponent, mantissa) = varstup in
           let (mantissa : real) = (mantissa / (realFromFrac(( 20 : int))(( 10 : int)))) in
           let (exponent : ii) = (((ex_int exponent)) + (( 1 : int):ii)) in
           (exponent, mantissa))) in
     if (((((((((((((vec_of_bits [access_vec_dec fpcr (( 24 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) /\ F))) \/ (((((((vec_of_bits [access_vec_dec fpcr (( 19 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) /\ T)))))) /\ ((((ex_int exponent)) < ((ex_int minimum_exp))))))) then sail2_state_monad$bindS
       (UsingAArch32 () ) (\ (w__0 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
       (if w__0 then sail2_state_monad$bindS
          (sail2_state_monad$read_regS FPSCR_ref  : ( 32 words$word) M) (\ (w__1 :  32 words$word) . 
          sail2_state_monad$write_regS
            FPSCR_ref
            ((set_slice (( 32 : int):ii) (( 1 : int):ii) w__1 (( 3 : int):ii) (vec_of_bits [B1]  :  1 words$word)  :  32 words$word)))
        else sail2_state_monad$bindS
          (sail2_state_monad$read_regS FPSR_ref  : ( 32 words$word) M) (\ (w__2 :  32 words$word) . 
          sail2_state_monad$write_regS
            FPSR_ref
            ((set_slice (( 32 : int):ii) (( 1 : int):ii) w__2 (( 3 : int):ii) (vec_of_bits [B1]  :  1 words$word)  :  32 words$word))))
       (FPZero (( 16 : int):ii) sign  : ( 'N words$word) M)) (\ (w__3 :  'N words$word) . 
       sail2_state_monad$returnS ((words$w2w w__3  :  'N words$word))))
     else
       let (biased_exp : ii) =
         (int_max ((((((ex_int exponent)) - ((ex_int minimum_exp)))) + (( 1 : int):ii)))
           (( 0 : int):ii)) in
       let (mantissa : real) =
         (if (((((ex_int biased_exp)) = (( 0 : int):ii)))) then
           mantissa /
             ((realPowInteger (realFromFrac(( 20 : int))(( 10 : int)))
                 ((((ex_int minimum_exp)) - ((ex_int exponent))))))
         else mantissa) in
       let (int_mant : ii) =
         (flr ((mantissa * ((realPowInteger (realFromFrac(( 20 : int))(( 10 : int))) (( 10 : int):ii)))))) in
       let (error : real) =
         (((mantissa * ((realPowInteger (realFromFrac(( 20 : int))(( 10 : int))) (( 10 : int):ii))))) -
           (((real_of_int int_mant)))) in sail2_state_monad$bindS (sail2_state_monad$seqS
       (if ((((((((ex_int biased_exp)) = (( 0 : int):ii)))) /\ ((((((error <> (realFromFrac(( 0 : int))(( 10 : int)))))) \/ ((((vec_of_bits [access_vec_dec fpcr (( 11 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))))) then
          FPProcessException FPExc_Underflow fpcr
        else sail2_state_monad$returnS () )
       (sail2_state_monad$undefined_boolS () )) (\ (overflow_to_inf : bool) .  sail2_state_monad$bindS
       (sail2_state_monad$undefined_boolS () ) (\ (round_up : bool) . 
       let ((overflow_to_inf : bool), (round_up : bool)) =
         ((case rounding of
           FPRounding_TIEEVEN =>
            let (round_up : bool) =
              (((error > (realFromFrac(( 5 : int))(( 10 : int))))) \/ ((((((error = (realFromFrac(( 5 : int))(( 10 : int)))))) /\ (((((GetSlice_int ((make_the_value (( 1 : int):ii)  :  1 itself)) int_mant (( 0 : int):ii)
                           :  1 words$word)) = (vec_of_bits [B1]  :  1 words$word)))))))) in
            let (overflow_to_inf : bool) = T in
            (overflow_to_inf, round_up)
         | FPRounding_POSINF =>
            let (round_up : bool) =
              ((((error <> (realFromFrac(( 0 : int))(( 10 : int)))))) /\ (((sign = (vec_of_bits [B0]  :  1 words$word))))) in
            let (overflow_to_inf : bool) = (sign = (vec_of_bits [B0]  :  1 words$word)) in
            (overflow_to_inf, round_up)
         | FPRounding_NEGINF =>
            let (round_up : bool) =
              ((((error <> (realFromFrac(( 0 : int))(( 10 : int)))))) /\ (((sign = (vec_of_bits [B1]  :  1 words$word))))) in
            let (overflow_to_inf : bool) = (sign = (vec_of_bits [B1]  :  1 words$word)) in
            (overflow_to_inf, round_up)
         | FPRounding_ZERO =>
            let (round_up : bool) = F in
            let (overflow_to_inf : bool) = F in
            (overflow_to_inf, round_up)
         | FPRounding_ODD =>
            let (round_up : bool) = F in
            let (overflow_to_inf : bool) = F in
            (overflow_to_inf, round_up)
         )) in
       let ((biased_exp : ii), (int_mant : ii)) =
         (if round_up then
           let (int_mant : ii) = (((ex_int int_mant)) + (( 1 : int):ii)) in
           let (biased_exp : ii) =
             (if (((((ex_int int_mant)) = ((pow2 (( 10 : int):ii)))))) then (( 1 : int):ii)
             else biased_exp) in
           let ((biased_exp : ii), (int_mant : ii)) =
             (if (((((ex_int int_mant)) = ((pow2 (( 11 : int):ii)))))) then
               let (biased_exp : ii) = (((ex_int biased_exp)) + (( 1 : int):ii)) in
               let (int_mant : ii) = (((ex_int int_mant)) / (( 2 : int):ii)) in
               (biased_exp, int_mant)
             else (biased_exp, int_mant)) in
           (biased_exp, int_mant)
         else (biased_exp, int_mant)) in
       let (int_mant : ii) =
         (if ((((((error <> (realFromFrac(( 0 : int))(( 10 : int)))))) /\ (((rounding = FPRounding_ODD)))))) then
           set_slice_int (( 1 : int):ii) int_mant (( 0 : int):ii) (vec_of_bits [B1]  :  1 words$word)
         else int_mant) in sail2_state_monad$bindS
       (if (((F \/ ((((vec_of_bits [access_vec_dec fpcr (( 26 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) then
          if ((((ex_int biased_exp)) >= ((((pow2 (( 5 : int):ii))) - (( 1 : int):ii))))) then sail2_state_monad$bindS
            (if overflow_to_inf then (FPInfinity (( 16 : int):ii) sign  : ( 16 words$word) M)
             else (FPMaxNormal (( 16 : int):ii) sign  : ( 16 words$word) M)) (\ (w__6 :  16 words$word) . 
            let result = w__6 in sail2_state_monad$seqS
            (FPProcessException FPExc_Overflow fpcr)
            (let (error : real) = (realFromFrac(( 10 : int))(( 10 : int))) in
            sail2_state_monad$returnS (error, result)))
          else
            let (result : 16 bits) =
              ((concat_vec
                 ((concat_vec sign
                     ((GetSlice_int
                         ((make_the_value (((((( 16 : int):ii) - (( 10 : int):ii))) - (( 1 : int):ii)))
                            :  5 itself)) biased_exp (( 0 : int):ii)
                        :  5 words$word))
                    :  6 words$word))
                 ((GetSlice_int ((make_the_value (( 10 : int):ii)  :  10 itself)) int_mant (( 0 : int):ii)
                    :  10 words$word))
                :  16 words$word)) in
            sail2_state_monad$returnS (error, result)
        else if ((((ex_int biased_exp)) >= ((pow2 (( 5 : int):ii))))) then
          let result =
            ((concat_vec sign
               ((Ones__0 ((make_the_value (((( 16 : int):ii) - (( 1 : int):ii)))  :  15 itself))
                  :  15 words$word))
              :  16 words$word)) in sail2_state_monad$seqS
          (FPProcessException FPExc_InvalidOp fpcr)
          (let (error : real) = (realFromFrac(( 0 : int))(( 10 : int))) in
          sail2_state_monad$returnS (error, result))
        else
          let (result : 16 bits) =
            ((concat_vec
               ((concat_vec sign
                   ((GetSlice_int
                       ((make_the_value (((((( 16 : int):ii) - (( 10 : int):ii))) - (( 1 : int):ii)))
                          :  5 itself)) biased_exp (( 0 : int):ii)
                      :  5 words$word))
                  :  6 words$word))
               ((GetSlice_int ((make_the_value (( 10 : int):ii)  :  10 itself)) int_mant (( 0 : int):ii)
                  :  10 words$word))
              :  16 words$word)) in
          sail2_state_monad$returnS (error, result)) (\ varstup .  let ((error : real), (result : 16 bits)) = varstup in sail2_state_monad$seqS
       (if (((error <> (realFromFrac(( 0 : int))(( 10 : int)))))) then FPProcessException FPExc_Inexact fpcr
        else sail2_state_monad$returnS () )
       (sail2_state_monad$returnS ((words$w2w result  :  'N words$word))))))))))))
   else if (((p0_ = (( 32 : int):ii)))) then sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (sail2_state_monad$assert_expS (((op <> (realFromFrac(( 0 : int))(( 10 : int)))))) ""))
     (sail2_state_monad$assert_expS (((rounding <> FPRounding_TIEAWAY))) ""))
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (result : 32 bits) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (F_mut : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (E_mut : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (minimum_exp : ii) . 
     let minimum_exp = (~ (( 126 : int):ii)) in
     let E_mut = ((( 8 : int):ii)) in
     let F_mut = ((( 23 : int):ii)) in sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (undefined_real () )) (\ (mantissa : real) .  sail2_state_monad$bindS
     (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (sign : 1 bits) . 
     let ((mantissa : real), (sign : 1 bits)) =
       (if ((op < (realFromFrac(( 0 : int))(( 10 : int))))) then
         let (sign : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
         let (mantissa : real) =((real_of_num 0) - op) in
         (mantissa, sign)
       else
         let (sign : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in
         let (mantissa : real) = op in
         (mantissa, sign)) in
     let (exponent : ii) = ((( 0 : int):ii)) in
     let ((exponent : ii), (mantissa : real)) =
       (while (exponent, mantissa)
         (\ varstup .  let (exponent, mantissa) = varstup in mantissa < (realFromFrac(( 10 : int))(( 10 : int))))
         (\ varstup .  let (exponent, mantissa) = varstup in
           let (mantissa : real) = (mantissa * (realFromFrac(( 20 : int))(( 10 : int)))) in
           let (exponent : ii) = (((ex_int exponent)) - (( 1 : int):ii)) in
           (exponent, mantissa))) in
     let ((exponent : ii), (mantissa : real)) =
       (while (exponent, mantissa)
         (\ varstup .  let (exponent, mantissa) = varstup in mantissa >= (realFromFrac(( 20 : int))(( 10 : int))))
         (\ varstup .  let (exponent, mantissa) = varstup in
           let (mantissa : real) = (mantissa / (realFromFrac(( 20 : int))(( 10 : int)))) in
           let (exponent : ii) = (((ex_int exponent)) + (( 1 : int):ii)) in
           (exponent, mantissa))) in
     if (((((((((((((vec_of_bits [access_vec_dec fpcr (( 24 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) /\ T))) \/ (((((((vec_of_bits [access_vec_dec fpcr (( 19 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) /\ F)))))) /\ ((((ex_int exponent)) < ((ex_int minimum_exp))))))) then sail2_state_monad$bindS
       (UsingAArch32 () ) (\ (w__8 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
       (if w__8 then sail2_state_monad$bindS
          (sail2_state_monad$read_regS FPSCR_ref  : ( 32 words$word) M) (\ (w__9 :  32 words$word) . 
          sail2_state_monad$write_regS
            FPSCR_ref
            ((set_slice (( 32 : int):ii) (( 1 : int):ii) w__9 (( 3 : int):ii) (vec_of_bits [B1]  :  1 words$word)  :  32 words$word)))
        else sail2_state_monad$bindS
          (sail2_state_monad$read_regS FPSR_ref  : ( 32 words$word) M) (\ (w__10 :  32 words$word) . 
          sail2_state_monad$write_regS
            FPSR_ref
            ((set_slice (( 32 : int):ii) (( 1 : int):ii) w__10 (( 3 : int):ii) (vec_of_bits [B1]  :  1 words$word)  :  32 words$word))))
       (FPZero (( 32 : int):ii) sign  : ( 'N words$word) M)) (\ (w__11 :  'N words$word) . 
       sail2_state_monad$returnS ((words$w2w w__11  :  'N words$word))))
     else
       let (biased_exp : ii) =
         (int_max ((((((ex_int exponent)) - ((ex_int minimum_exp)))) + (( 1 : int):ii)))
           (( 0 : int):ii)) in
       let (mantissa : real) =
         (if (((((ex_int biased_exp)) = (( 0 : int):ii)))) then
           mantissa /
             ((realPowInteger (realFromFrac(( 20 : int))(( 10 : int)))
                 ((((ex_int minimum_exp)) - ((ex_int exponent))))))
         else mantissa) in
       let (int_mant : ii) =
         (flr ((mantissa * ((realPowInteger (realFromFrac(( 20 : int))(( 10 : int))) (( 23 : int):ii)))))) in
       let (error : real) =
         (((mantissa * ((realPowInteger (realFromFrac(( 20 : int))(( 10 : int))) (( 23 : int):ii))))) -
           (((real_of_int int_mant)))) in sail2_state_monad$bindS (sail2_state_monad$seqS
       (if ((((((((ex_int biased_exp)) = (( 0 : int):ii)))) /\ ((((((error <> (realFromFrac(( 0 : int))(( 10 : int)))))) \/ ((((vec_of_bits [access_vec_dec fpcr (( 11 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))))) then
          FPProcessException FPExc_Underflow fpcr
        else sail2_state_monad$returnS () )
       (sail2_state_monad$undefined_boolS () )) (\ (overflow_to_inf : bool) .  sail2_state_monad$bindS
       (sail2_state_monad$undefined_boolS () ) (\ (round_up : bool) . 
       let ((overflow_to_inf : bool), (round_up : bool)) =
         ((case rounding of
           FPRounding_TIEEVEN =>
            let (round_up : bool) =
              (((error > (realFromFrac(( 5 : int))(( 10 : int))))) \/ ((((((error = (realFromFrac(( 5 : int))(( 10 : int)))))) /\ (((((GetSlice_int ((make_the_value (( 1 : int):ii)  :  1 itself)) int_mant (( 0 : int):ii)
                           :  1 words$word)) = (vec_of_bits [B1]  :  1 words$word)))))))) in
            let (overflow_to_inf : bool) = T in
            (overflow_to_inf, round_up)
         | FPRounding_POSINF =>
            let (round_up : bool) =
              ((((error <> (realFromFrac(( 0 : int))(( 10 : int)))))) /\ (((sign = (vec_of_bits [B0]  :  1 words$word))))) in
            let (overflow_to_inf : bool) = (sign = (vec_of_bits [B0]  :  1 words$word)) in
            (overflow_to_inf, round_up)
         | FPRounding_NEGINF =>
            let (round_up : bool) =
              ((((error <> (realFromFrac(( 0 : int))(( 10 : int)))))) /\ (((sign = (vec_of_bits [B1]  :  1 words$word))))) in
            let (overflow_to_inf : bool) = (sign = (vec_of_bits [B1]  :  1 words$word)) in
            (overflow_to_inf, round_up)
         | FPRounding_ZERO =>
            let (round_up : bool) = F in
            let (overflow_to_inf : bool) = F in
            (overflow_to_inf, round_up)
         | FPRounding_ODD =>
            let (round_up : bool) = F in
            let (overflow_to_inf : bool) = F in
            (overflow_to_inf, round_up)
         )) in
       let ((biased_exp : ii), (int_mant : ii)) =
         (if round_up then
           let (int_mant : ii) = (((ex_int int_mant)) + (( 1 : int):ii)) in
           let (biased_exp : ii) =
             (if (((((ex_int int_mant)) = ((pow2 (( 23 : int):ii)))))) then (( 1 : int):ii)
             else biased_exp) in
           let ((biased_exp : ii), (int_mant : ii)) =
             (if (((((ex_int int_mant)) = ((pow2 (( 24 : int):ii)))))) then
               let (biased_exp : ii) = (((ex_int biased_exp)) + (( 1 : int):ii)) in
               let (int_mant : ii) = (((ex_int int_mant)) / (( 2 : int):ii)) in
               (biased_exp, int_mant)
             else (biased_exp, int_mant)) in
           (biased_exp, int_mant)
         else (biased_exp, int_mant)) in
       let (int_mant : ii) =
         (if ((((((error <> (realFromFrac(( 0 : int))(( 10 : int)))))) /\ (((rounding = FPRounding_ODD)))))) then
           set_slice_int (( 1 : int):ii) int_mant (( 0 : int):ii) (vec_of_bits [B1]  :  1 words$word)
         else int_mant) in sail2_state_monad$bindS
       (if ((((ex_int biased_exp)) >= ((((pow2 (( 8 : int):ii))) - (( 1 : int):ii))))) then sail2_state_monad$bindS
          (if overflow_to_inf then (FPInfinity (( 32 : int):ii) sign  : ( 32 words$word) M)
           else (FPMaxNormal (( 32 : int):ii) sign  : ( 32 words$word) M)) (\ (w__14 :  32 words$word) . 
          let result = w__14 in sail2_state_monad$seqS
          (FPProcessException FPExc_Overflow fpcr)
          (let (error : real) = (realFromFrac(( 10 : int))(( 10 : int))) in
          sail2_state_monad$returnS (error, result)))
        else
          let (result : 32 bits) =
            ((concat_vec
               ((concat_vec sign
                   ((GetSlice_int
                       ((make_the_value (((((( 32 : int):ii) - (( 23 : int):ii))) - (( 1 : int):ii)))
                          :  8 itself)) biased_exp (( 0 : int):ii)
                      :  8 words$word))
                  :  9 words$word))
               ((GetSlice_int ((make_the_value (( 23 : int):ii)  :  23 itself)) int_mant (( 0 : int):ii)
                  :  23 words$word))
              :  32 words$word)) in
          sail2_state_monad$returnS (error, result)) (\ varstup .  let ((error : real), (result : 32 bits)) = varstup in sail2_state_monad$seqS
       (if (((error <> (realFromFrac(( 0 : int))(( 10 : int)))))) then FPProcessException FPExc_Inexact fpcr
        else sail2_state_monad$returnS () )
       (sail2_state_monad$returnS ((words$w2w result  :  'N words$word))))))))))))
   else if (((p0_ = (( 64 : int):ii)))) then sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (sail2_state_monad$assert_expS (((op <> (realFromFrac(( 0 : int))(( 10 : int)))))) ""))
     (sail2_state_monad$assert_expS (((rounding <> FPRounding_TIEAWAY))) ""))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (result : 64 bits) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (F_mut : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (E_mut : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (minimum_exp : ii) . 
     let minimum_exp = (~ (( 1022 : int):ii)) in
     let E_mut = ((( 11 : int):ii)) in
     let F_mut = ((( 52 : int):ii)) in sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (undefined_real () )) (\ (mantissa : real) .  sail2_state_monad$bindS
     (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (sign : 1 bits) . 
     let ((mantissa : real), (sign : 1 bits)) =
       (if ((op < (realFromFrac(( 0 : int))(( 10 : int))))) then
         let (sign : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
         let (mantissa : real) =((real_of_num 0) - op) in
         (mantissa, sign)
       else
         let (sign : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in
         let (mantissa : real) = op in
         (mantissa, sign)) in
     let (exponent : ii) = ((( 0 : int):ii)) in
     let ((exponent : ii), (mantissa : real)) =
       (while (exponent, mantissa)
         (\ varstup .  let (exponent, mantissa) = varstup in mantissa < (realFromFrac(( 10 : int))(( 10 : int))))
         (\ varstup .  let (exponent, mantissa) = varstup in
           let (mantissa : real) = (mantissa * (realFromFrac(( 20 : int))(( 10 : int)))) in
           let (exponent : ii) = (((ex_int exponent)) - (( 1 : int):ii)) in
           (exponent, mantissa))) in
     let ((exponent : ii), (mantissa : real)) =
       (while (exponent, mantissa)
         (\ varstup .  let (exponent, mantissa) = varstup in mantissa >= (realFromFrac(( 20 : int))(( 10 : int))))
         (\ varstup .  let (exponent, mantissa) = varstup in
           let (mantissa : real) = (mantissa / (realFromFrac(( 20 : int))(( 10 : int)))) in
           let (exponent : ii) = (((ex_int exponent)) + (( 1 : int):ii)) in
           (exponent, mantissa))) in
     if (((((((((((((vec_of_bits [access_vec_dec fpcr (( 24 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) /\ T))) \/ (((((((vec_of_bits [access_vec_dec fpcr (( 19 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) /\ F)))))) /\ ((((ex_int exponent)) < ((ex_int minimum_exp))))))) then sail2_state_monad$bindS
       (UsingAArch32 () ) (\ (w__16 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
       (if w__16 then sail2_state_monad$bindS
          (sail2_state_monad$read_regS FPSCR_ref  : ( 32 words$word) M) (\ (w__17 :  32 words$word) . 
          sail2_state_monad$write_regS
            FPSCR_ref
            ((set_slice (( 32 : int):ii) (( 1 : int):ii) w__17 (( 3 : int):ii) (vec_of_bits [B1]  :  1 words$word)  :  32 words$word)))
        else sail2_state_monad$bindS
          (sail2_state_monad$read_regS FPSR_ref  : ( 32 words$word) M) (\ (w__18 :  32 words$word) . 
          sail2_state_monad$write_regS
            FPSR_ref
            ((set_slice (( 32 : int):ii) (( 1 : int):ii) w__18 (( 3 : int):ii) (vec_of_bits [B1]  :  1 words$word)  :  32 words$word))))
       (FPZero (( 64 : int):ii) sign  : ( 'N words$word) M)) (\ (w__19 :  'N words$word) . 
       sail2_state_monad$returnS ((words$w2w w__19  :  'N words$word))))
     else
       let (biased_exp : ii) =
         (int_max ((((((ex_int exponent)) - ((ex_int minimum_exp)))) + (( 1 : int):ii)))
           (( 0 : int):ii)) in
       let (mantissa : real) =
         (if (((((ex_int biased_exp)) = (( 0 : int):ii)))) then
           mantissa /
             ((realPowInteger (realFromFrac(( 20 : int))(( 10 : int)))
                 ((((ex_int minimum_exp)) - ((ex_int exponent))))))
         else mantissa) in
       let (int_mant : ii) =
         (flr ((mantissa * ((realPowInteger (realFromFrac(( 20 : int))(( 10 : int))) (( 52 : int):ii)))))) in
       let (error : real) =
         (((mantissa * ((realPowInteger (realFromFrac(( 20 : int))(( 10 : int))) (( 52 : int):ii))))) -
           (((real_of_int int_mant)))) in sail2_state_monad$bindS (sail2_state_monad$seqS
       (if ((((((((ex_int biased_exp)) = (( 0 : int):ii)))) /\ ((((((error <> (realFromFrac(( 0 : int))(( 10 : int)))))) \/ ((((vec_of_bits [access_vec_dec fpcr (( 11 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))))) then
          FPProcessException FPExc_Underflow fpcr
        else sail2_state_monad$returnS () )
       (sail2_state_monad$undefined_boolS () )) (\ (overflow_to_inf : bool) .  sail2_state_monad$bindS
       (sail2_state_monad$undefined_boolS () ) (\ (round_up : bool) . 
       let ((overflow_to_inf : bool), (round_up : bool)) =
         ((case rounding of
           FPRounding_TIEEVEN =>
            let (round_up : bool) =
              (((error > (realFromFrac(( 5 : int))(( 10 : int))))) \/ ((((((error = (realFromFrac(( 5 : int))(( 10 : int)))))) /\ (((((GetSlice_int ((make_the_value (( 1 : int):ii)  :  1 itself)) int_mant (( 0 : int):ii)
                           :  1 words$word)) = (vec_of_bits [B1]  :  1 words$word)))))))) in
            let (overflow_to_inf : bool) = T in
            (overflow_to_inf, round_up)
         | FPRounding_POSINF =>
            let (round_up : bool) =
              ((((error <> (realFromFrac(( 0 : int))(( 10 : int)))))) /\ (((sign = (vec_of_bits [B0]  :  1 words$word))))) in
            let (overflow_to_inf : bool) = (sign = (vec_of_bits [B0]  :  1 words$word)) in
            (overflow_to_inf, round_up)
         | FPRounding_NEGINF =>
            let (round_up : bool) =
              ((((error <> (realFromFrac(( 0 : int))(( 10 : int)))))) /\ (((sign = (vec_of_bits [B1]  :  1 words$word))))) in
            let (overflow_to_inf : bool) = (sign = (vec_of_bits [B1]  :  1 words$word)) in
            (overflow_to_inf, round_up)
         | FPRounding_ZERO =>
            let (round_up : bool) = F in
            let (overflow_to_inf : bool) = F in
            (overflow_to_inf, round_up)
         | FPRounding_ODD =>
            let (round_up : bool) = F in
            let (overflow_to_inf : bool) = F in
            (overflow_to_inf, round_up)
         )) in
       let ((biased_exp : ii), (int_mant : ii)) =
         (if round_up then
           let (int_mant : ii) = (((ex_int int_mant)) + (( 1 : int):ii)) in
           let (biased_exp : ii) =
             (if (((((ex_int int_mant)) = ((pow2 (( 52 : int):ii)))))) then (( 1 : int):ii)
             else biased_exp) in
           let ((biased_exp : ii), (int_mant : ii)) =
             (if (((((ex_int int_mant)) = ((pow2 (( 53 : int):ii)))))) then
               let (biased_exp : ii) = (((ex_int biased_exp)) + (( 1 : int):ii)) in
               let (int_mant : ii) = (((ex_int int_mant)) / (( 2 : int):ii)) in
               (biased_exp, int_mant)
             else (biased_exp, int_mant)) in
           (biased_exp, int_mant)
         else (biased_exp, int_mant)) in
       let (int_mant : ii) =
         (if ((((((error <> (realFromFrac(( 0 : int))(( 10 : int)))))) /\ (((rounding = FPRounding_ODD)))))) then
           set_slice_int (( 1 : int):ii) int_mant (( 0 : int):ii) (vec_of_bits [B1]  :  1 words$word)
         else int_mant) in sail2_state_monad$bindS
       (if ((((ex_int biased_exp)) >= ((((pow2 (( 11 : int):ii))) - (( 1 : int):ii))))) then sail2_state_monad$bindS
          (if overflow_to_inf then (FPInfinity (( 64 : int):ii) sign  : ( 64 words$word) M)
           else (FPMaxNormal (( 64 : int):ii) sign  : ( 64 words$word) M)) (\ (w__22 :  64 words$word) . 
          let result = w__22 in sail2_state_monad$seqS
          (FPProcessException FPExc_Overflow fpcr)
          (let (error : real) = (realFromFrac(( 10 : int))(( 10 : int))) in
          sail2_state_monad$returnS (error, result)))
        else
          let (result : 64 bits) =
            ((concat_vec
               ((concat_vec sign
                   ((GetSlice_int
                       ((make_the_value (((((( 64 : int):ii) - (( 52 : int):ii))) - (( 1 : int):ii)))
                          :  11 itself)) biased_exp (( 0 : int):ii)
                      :  11 words$word))
                  :  12 words$word))
               ((GetSlice_int ((make_the_value (( 52 : int):ii)  :  52 itself)) int_mant (( 0 : int):ii)
                  :  52 words$word))
              :  64 words$word)) in
          sail2_state_monad$returnS (error, result)) (\ varstup .  let ((error : real), (result : 64 bits)) = varstup in sail2_state_monad$seqS
       (if (((error <> (realFromFrac(( 0 : int))(( 10 : int)))))) then FPProcessException FPExc_Inexact fpcr
        else sail2_state_monad$returnS () )
       (sail2_state_monad$returnS ((words$w2w result  :  'N words$word))))))))))))
   else sail2_state_monad$seqS (sail2_state_monad$assert_expS F "") (sail2_state_monad$exitS () )))`;


(*val FPRoundCV : forall 'N . Size 'N => integer -> real -> mword ty32 -> FPRounding -> M (mword 'N)*)

val _ = Define `
 ((FPRoundCV:int -> real ->(32)words$word -> FPRounding ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) (N__tv : int) op fpcr__arg rounding=
    (let fpcr = fpcr__arg in
   let fpcr = ((set_slice (( 32 : int):ii) (( 1 : int):ii) fpcr (( 19 : int):ii) (vec_of_bits [B0]  :  1 words$word)  :  32 words$word)) in
   (FPRoundBase N__tv op fpcr rounding  : ( 'N words$word) M)))`;


(*val FPRound__0 : forall 'N . Size 'N => integer -> real -> mword ty32 -> FPRounding -> M (mword 'N)*)

(*val FPRound__1 : forall 'N . Size 'N => integer -> real -> mword ty32 -> M (mword 'N)*)

val _ = Define `
 ((FPRound__0:int -> real ->(32)words$word -> FPRounding ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) (N__tv : int) op fpcr__arg rounding=
    (let fpcr = fpcr__arg in
   let fpcr = ((set_slice (( 32 : int):ii) (( 1 : int):ii) fpcr (( 26 : int):ii) (vec_of_bits [B0]  :  1 words$word)  :  32 words$word)) in
   (FPRoundBase N__tv op fpcr rounding  : ( 'N words$word) M)))`;


val _ = Define `
 ((FPRound__1:int -> real ->(32)words$word ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) (N__tv : int) op fpcr=
    ((FPRound__0 N__tv op fpcr ((FPRoundingMode fpcr))  : ( 'N words$word) M)))`;


(*val FixedToFP : forall 'M 'N . Size 'M, Size 'N => integer -> mword 'M -> ii -> bool -> mword ty32 -> FPRounding -> M (mword 'N)*)

val _ = Define `
 ((FixedToFP:int -> 'M words$word -> int -> bool ->(32)words$word -> FPRounding ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) (N__tv : int) op fbits unsigned fpcr rounding=  (sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((((N__tv = (( 16 : int):ii)))) \/ ((((((N__tv = (( 32 : int):ii)))) \/ (((N__tv = (( 64 : int):ii)))))))))) "")
   (sail2_state_monad$assert_expS ((((((((int_of_num (words$word_len op))) = (( 16 : int):ii)))) \/ ((((((((int_of_num (words$word_len op))) = (( 32 : int):ii)))) \/ (((((int_of_num (words$word_len op))) = (( 64 : int):ii)))))))))) ""))
   (undefined_bitvector N__tv  : ( 'N words$word) M)) (\ (result : 'N bits) .  sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((fbits >= (( 0 : int):ii))) "")
   (sail2_state_monad$assert_expS (((rounding <> FPRounding_ODD))) ""))
   (let (int_operand : ii) = (asl_Int op unsigned) in
   let (real_operand : real) =
     ((((real_of_int int_operand))) / ((realPowInteger (realFromFrac(( 20 : int))(( 10 : int))) fbits))) in
   if (((real_operand = (realFromFrac(( 0 : int))(( 10 : int)))))) then
     (FPZero ((int_of_num (words$word_len result))) (vec_of_bits [B0]  :  1 words$word)  : ( 'N words$word) M)
   else (FPRound__0 ((int_of_num (words$word_len result))) real_operand fpcr rounding  : ( 'N words$word) M)))))`;


(*val FPProcessNaN : forall 'N . Size 'N => FPType -> mword 'N -> mword ty32 -> M (mword 'N)*)

val _ = Define `
 ((FPProcessNaN:FPType -> 'N words$word ->(32)words$word ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) typ op fpcr=  (sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((((((int_of_num (words$word_len op))) = (( 16 : int):ii)))) \/ ((((((((int_of_num (words$word_len op))) = (( 32 : int):ii)))) \/ (((((int_of_num (words$word_len op))) = (( 64 : int):ii)))))))))) "((N == 16) || ((N == 32) || (N == 64)))")
   (sail2_state_monad$assert_expS ((((((typ = FPType_QNaN))) \/ (((typ = FPType_SNaN)))))) "((type == FPType_QNaN) || (type == FPType_SNaN))"))
   (undefined_int () )) (\ (topfrac : ii) . 
   let p0_ = (int_of_num (words$word_len op)) in
   let (topfrac : ii) =
     (if (((p0_ = (( 16 : int):ii)))) then
       let (op :  16 words$word) = ((words$w2w op  :  16 words$word)) in
       (( 9 : int):ii)
     else if (((p0_ = (( 32 : int):ii)))) then
       let (op :  32 words$word) = ((words$w2w op  :  32 words$word)) in
       (( 22 : int):ii)
     else
       let (op :  64 words$word) = ((words$w2w op  :  64 words$word)) in
       (( 51 : int):ii)) in
   let (result : 'N bits) = op in sail2_state_monad$bindS
   (if (((typ = FPType_SNaN))) then
      let result =
        ((set_slice ((int_of_num (words$word_len op))) (( 1 : int):ii) result topfrac (vec_of_bits [B1]  :  1 words$word)  :  'N words$word)) in sail2_state_monad$seqS
      (FPProcessException FPExc_InvalidOp fpcr) (sail2_state_monad$returnS result)
    else sail2_state_monad$returnS result) (\ (result : 'N bits) . 
   if ((((vec_of_bits [access_vec_dec fpcr (( 25 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
     (FPDefaultNaN ((int_of_num (words$word_len op))) ()   : ( 'N words$word) M)
   else sail2_state_monad$returnS result))))`;


(*val FPProcessNaNs3 : forall 'N . Size 'N => FPType -> FPType -> FPType -> mword 'N -> mword 'N -> mword 'N -> mword ty32 -> M (bool * mword 'N)*)

val _ = Define `
 ((FPProcessNaNs3:FPType -> FPType -> FPType -> 'N words$word -> 'N words$word -> 'N words$word ->(32)words$word ->(regstate)sail2_state_monad$sequential_state ->(((bool#'N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) type1 type2 type3 op1 op2 op3 fpcr=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((((((int_of_num (words$word_len op1))) = (( 16 : int):ii)))) \/ ((((((((int_of_num (words$word_len op1))) = (( 32 : int):ii)))) \/ (((((int_of_num (words$word_len op1))) = (( 64 : int):ii)))))))))) "((N == 16) || ((N == 32) || (N == 64)))")
   (undefined_bitvector ((int_of_num (words$word_len op1)))  : ( 'N words$word) M)) (\ (result : 'N bits) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (done : bool) . 
   if (((type1 = FPType_SNaN))) then
     let done = T in sail2_state_monad$bindS
     (FPProcessNaN type1 op1 fpcr  : ( 'N words$word) M) (\ (w__0 : 'N bits) . 
     let (result : 'N bits) = w__0 in
     sail2_state_monad$returnS (done, result))
   else if (((type2 = FPType_SNaN))) then
     let done = T in sail2_state_monad$bindS
     (FPProcessNaN type2 op2 fpcr  : ( 'N words$word) M) (\ (w__1 : 'N bits) . 
     let (result : 'N bits) = w__1 in
     sail2_state_monad$returnS (done, result))
   else if (((type3 = FPType_SNaN))) then
     let done = T in sail2_state_monad$bindS
     (FPProcessNaN type3 op3 fpcr  : ( 'N words$word) M) (\ (w__2 : 'N bits) . 
     let (result : 'N bits) = w__2 in
     sail2_state_monad$returnS (done, result))
   else if (((type1 = FPType_QNaN))) then
     let done = T in sail2_state_monad$bindS
     (FPProcessNaN type1 op1 fpcr  : ( 'N words$word) M) (\ (w__3 : 'N bits) . 
     let (result : 'N bits) = w__3 in
     sail2_state_monad$returnS (done, result))
   else if (((type2 = FPType_QNaN))) then
     let done = T in sail2_state_monad$bindS
     (FPProcessNaN type2 op2 fpcr  : ( 'N words$word) M) (\ (w__4 : 'N bits) . 
     let (result : 'N bits) = w__4 in
     sail2_state_monad$returnS (done, result))
   else if (((type3 = FPType_QNaN))) then
     let done = T in sail2_state_monad$bindS
     (FPProcessNaN type3 op3 fpcr  : ( 'N words$word) M) (\ (w__5 : 'N bits) . 
     let (result : 'N bits) = w__5 in
     sail2_state_monad$returnS (done, result))
   else
     let (done : bool) = F in
     let (result : 'N bits) = ((Zeros__1 ((int_of_num (words$word_len op1))) ()   :  'N words$word)) in
     sail2_state_monad$returnS (done, result)))))`;


(*val FPProcessNaNs : forall 'N . Size 'N => FPType -> FPType -> mword 'N -> mword 'N -> mword ty32 -> M (bool * mword 'N)*)

val _ = Define `
 ((FPProcessNaNs:FPType -> FPType -> 'N words$word -> 'N words$word ->(32)words$word ->(regstate)sail2_state_monad$sequential_state ->(((bool#'N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) type1 type2 op1 op2 fpcr=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((((((int_of_num (words$word_len op1))) = (( 16 : int):ii)))) \/ ((((((((int_of_num (words$word_len op1))) = (( 32 : int):ii)))) \/ (((((int_of_num (words$word_len op1))) = (( 64 : int):ii)))))))))) "((N == 16) || ((N == 32) || (N == 64)))")
   (undefined_bitvector ((int_of_num (words$word_len op1)))  : ( 'N words$word) M)) (\ (result : 'N bits) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (done : bool) . 
   if (((type1 = FPType_SNaN))) then
     let done = T in sail2_state_monad$bindS
     (FPProcessNaN type1 op1 fpcr  : ( 'N words$word) M) (\ (w__0 : 'N bits) . 
     let (result : 'N bits) = w__0 in
     sail2_state_monad$returnS (done, result))
   else if (((type2 = FPType_SNaN))) then
     let done = T in sail2_state_monad$bindS
     (FPProcessNaN type2 op2 fpcr  : ( 'N words$word) M) (\ (w__1 : 'N bits) . 
     let (result : 'N bits) = w__1 in
     sail2_state_monad$returnS (done, result))
   else if (((type1 = FPType_QNaN))) then
     let done = T in sail2_state_monad$bindS
     (FPProcessNaN type1 op1 fpcr  : ( 'N words$word) M) (\ (w__2 : 'N bits) . 
     let (result : 'N bits) = w__2 in
     sail2_state_monad$returnS (done, result))
   else if (((type2 = FPType_QNaN))) then
     let done = T in sail2_state_monad$bindS
     (FPProcessNaN type2 op2 fpcr  : ( 'N words$word) M) (\ (w__3 : 'N bits) . 
     let (result : 'N bits) = w__3 in
     sail2_state_monad$returnS (done, result))
   else
     let (done : bool) = F in
     let (result : 'N bits) = ((Zeros__1 ((int_of_num (words$word_len op1))) ()   :  'N words$word)) in
     sail2_state_monad$returnS (done, result)))))`;


(*val CurrentInstrSet : unit -> M InstrSet*)

val _ = Define `
 ((CurrentInstrSet:unit ->(regstate)sail2_state_monad$sequential_state ->(((InstrSet),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (undefined_InstrSet () ) (\ (result : InstrSet) .  sail2_state_monad$bindS
   (UsingAArch32 () ) (\ (w__0 : bool) . 
   if w__0 then sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__1 : ProcState) . 
     let (result : InstrSet) =
       (if (((w__1.ProcState_T = (vec_of_bits [B0]  :  1 words$word)))) then InstrSet_A32
       else InstrSet_T32) in
     sail2_state_monad$returnS result)
   else sail2_state_monad$returnS InstrSet_A64))))`;


(*val AArch32_ExecutingLSMInstr : unit -> M bool*)

val _ = Define `
 ((AArch32_ExecutingLSMInstr:unit ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (ThisInstr0 ()   : ( 32 words$word) M) (\ (instr : 32 bits) .  sail2_state_monad$bindS
   (CurrentInstrSet () ) (\ (instr_set : InstrSet) .  sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((((instr_set = InstrSet_A32))) \/ (((instr_set = InstrSet_T32)))))) "((instr_set == InstrSet_A32) || (instr_set == InstrSet_T32))")
   (if (((instr_set = InstrSet_A32))) then
     sail2_state_monad$returnS ((((((((slice instr (( 28 : int):ii) (( 4 : int):ii)  :  4 words$word)) <> (vec_of_bits [B1;B1;B1;B1]  :  4 words$word)))) /\ (((((slice instr (( 25 : int):ii) (( 3 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B0]  :  3 words$word)))))))
   else sail2_state_monad$bindS
     (ThisInstrLength () ) (\ (w__0 : ii) . 
     sail2_state_monad$returnS (if (((((ex_int w__0)) = (( 16 : int):ii)))) then
               (((slice instr (( 12 : int):ii) (( 4 : int):ii)  :  4 words$word)) = (vec_of_bits [B1;B1;B0;B0]  :  4 words$word))
             else
               ((((((slice instr (( 25 : int):ii) (( 7 : int):ii)  :  7 words$word)) = (vec_of_bits [B1;B1;B1;B0;B1;B0;B0]  :  7 words$word)))) /\ ((((vec_of_bits [access_vec_dec instr (( 22 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))))))))`;


(*val AArch32_ExecutingCP10or11Instr : unit -> M bool*)

val _ = Define `
 ((AArch32_ExecutingCP10or11Instr:unit ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (ThisInstr0 ()   : ( 32 words$word) M) (\ (instr : 32 bits) .  sail2_state_monad$bindS
   (CurrentInstrSet () ) (\ (instr_set : InstrSet) .  sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((((instr_set = InstrSet_A32))) \/ (((instr_set = InstrSet_T32)))))) "((instr_set == InstrSet_A32) || (instr_set == InstrSet_T32))")
   (sail2_state_monad$returnS (if (((instr_set = InstrSet_A32))) then
             (((((((((slice instr (( 24 : int):ii) (( 4 : int):ii)  :  4 words$word)) = (vec_of_bits [B1;B1;B1;B0]  :  4 words$word)))) \/ (((((slice instr (( 25 : int):ii) (( 3 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B0]  :  3 words$word))))))) /\ (((((and_vec ((slice instr (( 8 : int):ii) (( 4 : int):ii)  :  4 words$word))
                       (vec_of_bits [B1;B1;B1;B0]  :  4 words$word)
                      :  4 words$word)) = (vec_of_bits [B1;B0;B1;B0]  :  4 words$word)))))
           else
             (((((((((and_vec ((slice instr (( 28 : int):ii) (( 4 : int):ii)  :  4 words$word))
                           (vec_of_bits [B1;B1;B1;B0]  :  4 words$word)
                          :  4 words$word)) = (vec_of_bits [B1;B1;B1;B0]  :  4 words$word)))) /\ ((((((((slice instr (( 24 : int):ii) (( 4 : int):ii)  :  4 words$word)) = (vec_of_bits [B1;B1;B1;B0]  :  4 words$word)))) \/ (((((slice instr (( 25 : int):ii) (( 3 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B0]  :  3 words$word)))))))))) /\ (((((and_vec ((slice instr (( 8 : int):ii) (( 4 : int):ii)  :  4 words$word))
                       (vec_of_bits [B1;B1;B1;B0]  :  4 words$word)
                      :  4 words$word)) = (vec_of_bits [B1;B0;B1;B0]  :  4 words$word)))))))))))`;


(*val HaveAnyAArch64 : unit -> bool*)

val _ = Define `
 ((HaveAnyAArch64:unit -> bool) () =  (~ ((HighestELUsingAArch32 () ))))`;


(*val AArch32_ReportDeferredSError : mword ty2 -> mword ty1 -> M (mword ty32)*)

val _ = Define `
 ((AArch32_ReportDeferredSError:(2)words$word ->(1)words$word ->(regstate)sail2_state_monad$sequential_state ->((((32)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) AET ExT=  (sail2_state_monad$bindS
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (target : 32 bits) . 
   let (target : 32 bits) =
     ((set_slice (( 32 : int):ii) (( 1 : int):ii) target (( 31 : int):ii) (vec_of_bits [B1]  :  1 words$word)  :  32 words$word)) in
   let (syndrome : 16 bits) = ((Zeros__0 ((make_the_value (( 16 : int):ii)  :  16 itself))  :  16 words$word)) in sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) .  sail2_state_monad$bindS
   (if (((w__0.ProcState_EL = EL2))) then
      let (syndrome : 16 bits) =
        ((update_subrange_vec_dec syndrome (( 11 : int):ii) (( 10 : int):ii) AET  :  16 words$word)) in
      let (syndrome : 16 bits) =
        ((update_subrange_vec_dec syndrome (( 9 : int):ii) (( 9 : int):ii) ExT  :  16 words$word)) in
      let (syndrome : 16 bits) =
        ((update_subrange_vec_dec syndrome (( 5 : int):ii) (( 0 : int):ii)
           (vec_of_bits [B0;B1;B0;B0;B0;B1]  :  6 words$word)
          :  16 words$word)) in
      sail2_state_monad$returnS syndrome
    else
      let syndrome = ((update_subrange_vec_dec syndrome (( 15 : int):ii) (( 14 : int):ii) AET  :  16 words$word)) in
      let syndrome = ((update_subrange_vec_dec syndrome (( 12 : int):ii) (( 12 : int):ii) ExT  :  16 words$word)) in sail2_state_monad$bindS
      (sail2_state_monad$read_regS TTBCR_ref  : ( 32 words$word) M) (\ (w__1 : 32 bits) . 
      let syndrome =
        ((update_subrange_vec_dec syndrome (( 9 : int):ii) (( 9 : int):ii)
           (vec_of_bits [access_vec_dec w__1 (( 31 : int):ii)]  :  1 words$word)
          :  16 words$word)) in sail2_state_monad$bindS
      (sail2_state_monad$read_regS TTBCR_ref  : ( 32 words$word) M) (\ (w__2 : 32 bits) . 
      let (syndrome : 16 bits) =
        (if ((((vec_of_bits [access_vec_dec w__2 (( 31 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
          (update_subrange_vec_dec syndrome (( 5 : int):ii) (( 0 : int):ii)
             (vec_of_bits [B0;B1;B0;B0;B0;B1]  :  6 words$word)
            :  16 words$word)
        else
          let (tup__0, tup__1) =
            ((vec_of_bits [B1]  :  1 words$word), (vec_of_bits [B0;B1;B1;B0]  :  4 words$word)) in
          let (syndrome : 16 bits) =
            ((update_subrange_vec_dec syndrome (( 10 : int):ii) (( 10 : int):ii) tup__0  :  16 words$word)) in
          (update_subrange_vec_dec syndrome (( 3 : int):ii) (( 0 : int):ii) tup__1  :  16 words$word)) in
      sail2_state_monad$returnS syndrome))) (\ (syndrome : 16 bits) . 
   if ((HaveAnyAArch64 () )) then sail2_state_monad$bindS
     (ZeroExtend__0 syndrome ((make_the_value (( 25 : int):ii)  :  25 itself))  : ( 25 words$word) M) (\ (w__3 :
        25 words$word) . 
     let (target : 32 bits) = ((update_subrange_vec_dec target (( 24 : int):ii) (( 0 : int):ii) w__3  :  32 words$word)) in
     sail2_state_monad$returnS target)
   else
     let (target : 32 bits) =
       ((update_subrange_vec_dec target (( 15 : int):ii) (( 0 : int):ii) syndrome  :  32 words$word)) in
     sail2_state_monad$returnS target)))))`;


(*val HaveAArch32EL : mword ty2 -> bool*)

val _ = Define `
 ((HaveAArch32EL:(2)words$word -> bool) el=
    (if ((~ ((HaveEL el)))) then F
   else if ((~ ((HaveAnyAArch32 () )))) then F
   else if ((HighestELUsingAArch32 () )) then T
   else if (((el = ((HighestEL ()   :  2 words$word))))) then F
   else if (((el = EL0))) then T
   else T))`;


(*val AArch64_ResetSpecialRegisters : unit -> M unit*)

val _ = Define `
 ((AArch64_ResetSpecialRegisters:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (w__0 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS SP_EL0_ref w__0)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__1 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS SP_EL1_ref w__1)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__2 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS SPSR_EL1_ref w__2)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__3 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS ELR_EL1_ref w__3)
   (if ((HaveEL EL2)) then sail2_state_monad$bindS
      (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (w__4 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS SP_EL2_ref w__4)
      (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__5 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS SPSR_EL2_ref w__5)
      (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__6 : 64 bits) . 
      sail2_state_monad$write_regS ELR_EL2_ref w__6)))
    else sail2_state_monad$returnS () ))
   (if ((HaveEL EL3)) then sail2_state_monad$bindS
      (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (w__7 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS SP_EL3_ref w__7)
      (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__8 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS SPSR_EL3_ref w__8)
      (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__9 : 64 bits) . 
      sail2_state_monad$write_regS ELR_EL3_ref w__9)))
    else sail2_state_monad$returnS () ))
   (if ((HaveAArch32EL EL1)) then sail2_state_monad$bindS
      (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (w__10 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS SPSR_fiq_ref w__10)
      (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__11 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS SPSR_irq_ref w__11)
      (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__12 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS SPSR_abt_ref w__12)
      (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__13 : 32 bits) . 
      sail2_state_monad$write_regS SPSR_und_ref w__13))))
    else sail2_state_monad$returnS () ))
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__14 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS DLR_EL0_ref w__14)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__15 : 32 bits) . 
   sail2_state_monad$write_regS DSPSR_EL0_ref w__15))))))))`;


(*val Halted : unit -> M bool*)

val _ = Define `
 ((Halted:unit ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (sail2_state$or_boolS
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS EDSCR_ref  : ( 32 words$word) M) (\ (w__0 : 32 bits) . 
      sail2_state_monad$returnS (((((slice w__0 (( 0 : int):ii) (( 6 : int):ii)  :  6 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B1]  :  6 words$word))))))
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS EDSCR_ref  : ( 32 words$word) M) (\ (w__1 : 32 bits) . 
      sail2_state_monad$returnS (((((slice w__1 (( 0 : int):ii) (( 6 : int):ii)  :  6 words$word)) = (vec_of_bits [B0;B0;B0;B0;B1;B0]  :  6 words$word))))))) (\ (w__2 : bool) . 
   sail2_state_monad$returnS ((~ w__2)))))`;


(*val FPUnpackBase : forall 'N . Size 'N => mword 'N -> mword ty32 -> M (FPType * mword ty1 * real)*)

val _ = Define `
 ((FPUnpackBase:'N words$word ->(32)words$word ->(regstate)sail2_state_monad$sequential_state ->(((FPType#(1)words$word#real),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) fpval fpcr=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((((((int_of_num (words$word_len fpval))) = (( 16 : int):ii)))) \/ ((((((((int_of_num (words$word_len fpval))) = (( 32 : int):ii)))) \/ (((((int_of_num (words$word_len fpval))) = (( 64 : int):ii)))))))))) "((N == 16) || ((N == 32) || (N == 64)))")
   (undefined_bitvector (( 52 : int):ii)  : ( 52 words$word) M)) (\ (frac64 : 52 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 11 : int):ii)  : ( 11 words$word) M) (\ (exp64 : 11 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 23 : int):ii)  : ( 23 words$word) M) (\ (frac32 : 23 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M) (\ (exp32 : 8 bits) .  sail2_state_monad$bindS
   (undefined_real () ) (\ (value_name : real) .  sail2_state_monad$bindS
   (undefined_FPType () ) (\ (typ : FPType) .  sail2_state_monad$bindS
   (undefined_bitvector (( 10 : int):ii)  : ( 10 words$word) M) (\ (frac16 : 10 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 5 : int):ii)  : ( 5 words$word) M) (\ (exp16 : 5 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (sign : 1 bits) .  sail2_state_monad$bindS
   (if (((((int_of_num (words$word_len fpval))) = (( 16 : int):ii)))) then
      let (sign : 1 bits) = ((vec_of_bits [access_vec_dec fpval (( 15 : int):ii)]  :  1 words$word)) in
      let (exp16 : 5 bits) = ((slice fpval (( 10 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
      let (frac16 : 10 bits) = ((slice fpval (( 0 : int):ii) (( 10 : int):ii)  :  10 words$word)) in
      let ((typ : FPType), (value_name : real)) =
        (if ((IsZero exp16)) then
          let ((typ : FPType), (value_name : real)) =
            (if (((((IsZero frac16)) \/ ((((vec_of_bits [access_vec_dec fpcr (( 19 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) then
              let (typ : FPType) = FPType_Zero in
              let (value_name : real) = (realFromFrac(( 0 : int))(( 10 : int))) in
              (typ, value_name)
            else
              let (typ : FPType) = FPType_Nonzero in
              let (value_name : real) =
                (((realPowInteger (realFromFrac(( 20 : int))(( 10 : int))) ((~ (( 14 : int):ii))))) *
                  (((((real_of_int ((lem$w2ui frac16))))) *
                      ((realPowInteger (realFromFrac(( 20 : int))(( 10 : int))) ((~ (( 10 : int):ii)))))))) in
              (typ, value_name)) in
          (typ, value_name)
        else
          let ((typ : FPType), (value_name : real)) =
            (if (((((IsOnes exp16)) /\ ((((vec_of_bits [access_vec_dec fpcr (( 26 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) then
              let ((typ : FPType), (value_name : real)) =
                (if ((IsZero frac16)) then
                  let (typ : FPType) = FPType_Infinity in
                  let (value_name : real) = (realPowInteger (realFromFrac(( 20 : int))(( 10 : int))) (( 1000000 : int):ii)) in
                  (typ, value_name)
                else
                  let (typ : FPType) =
                    (if ((((vec_of_bits [access_vec_dec frac16 (( 9 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
                      FPType_QNaN
                    else FPType_SNaN) in
                  let (value_name : real) = (realFromFrac(( 0 : int))(( 10 : int))) in
                  (typ, value_name)) in
              (typ, value_name)
            else
              let (typ : FPType) = FPType_Nonzero in
              let (value_name : real) =
                (((realPowInteger (realFromFrac(( 20 : int))(( 10 : int))) ((((lem$w2ui exp16)) - (( 15 : int):ii)))))
                  *
                  (((realFromFrac(( 10 : int))(( 10 : int))) +
                      (((((real_of_int ((lem$w2ui frac16))))) *
                          ((realPowInteger (realFromFrac(( 20 : int))(( 10 : int))) ((~ (( 10 : int):ii)))))))))) in
              (typ, value_name)) in
          (typ, value_name)) in
      sail2_state_monad$returnS (sign, typ, value_name)
    else if (((((int_of_num (words$word_len fpval))) = (( 32 : int):ii)))) then
      let sign = ((vec_of_bits [access_vec_dec fpval (( 31 : int):ii)]  :  1 words$word)) in
      let exp32 = ((slice fpval (( 23 : int):ii) (( 8 : int):ii)  :  8 words$word)) in
      let frac32 = ((slice fpval (( 0 : int):ii) (( 23 : int):ii)  :  23 words$word)) in sail2_state_monad$bindS
      (if ((IsZero exp32)) then
         if (((((IsZero frac32)) \/ ((((vec_of_bits [access_vec_dec fpcr (( 24 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) then
           let typ = FPType_Zero in
           let value_name = (realFromFrac(( 0 : int))(( 10 : int))) in sail2_state_monad$seqS
           (if ((~ ((IsZero frac32)))) then FPProcessException FPExc_InputDenorm fpcr
            else sail2_state_monad$returnS () )
           (sail2_state_monad$returnS (typ, value_name))
         else
           let (typ : FPType) = FPType_Nonzero in
           let (value_name : real) =
             (((realPowInteger (realFromFrac(( 20 : int))(( 10 : int))) ((~ (( 126 : int):ii))))) *
               (((((real_of_int ((lem$w2ui frac32))))) *
                   ((realPowInteger (realFromFrac(( 20 : int))(( 10 : int))) ((~ (( 23 : int):ii)))))))) in
           sail2_state_monad$returnS (typ, value_name)
       else
         let ((typ : FPType), (value_name : real)) =
           (if ((IsOnes exp32)) then
             let ((typ : FPType), (value_name : real)) =
               (if ((IsZero frac32)) then
                 let (typ : FPType) = FPType_Infinity in
                 let (value_name : real) = (realPowInteger (realFromFrac(( 20 : int))(( 10 : int))) (( 1000000 : int):ii)) in
                 (typ, value_name)
               else
                 let (typ : FPType) =
                   (if ((((vec_of_bits [access_vec_dec frac32 (( 22 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
                     FPType_QNaN
                   else FPType_SNaN) in
                 let (value_name : real) = (realFromFrac(( 0 : int))(( 10 : int))) in
                 (typ, value_name)) in
             (typ, value_name)
           else
             let (typ : FPType) = FPType_Nonzero in
             let (value_name : real) =
               (((realPowInteger (realFromFrac(( 20 : int))(( 10 : int))) ((((lem$w2ui exp32)) - (( 127 : int):ii)))))
                 *
                 (((realFromFrac(( 10 : int))(( 10 : int))) +
                     (((((real_of_int ((lem$w2ui frac32))))) *
                         ((realPowInteger (realFromFrac(( 20 : int))(( 10 : int))) ((~ (( 23 : int):ii)))))))))) in
             (typ, value_name)) in
         sail2_state_monad$returnS (typ, value_name)) (\ varstup .  let ((typ : FPType), (value_name : real)) = varstup in
      sail2_state_monad$returnS (sign, typ, value_name))
    else
      let sign = ((vec_of_bits [access_vec_dec fpval (( 63 : int):ii)]  :  1 words$word)) in
      let exp64 = ((slice fpval (( 52 : int):ii) (( 11 : int):ii)  :  11 words$word)) in
      let frac64 = ((slice fpval (( 0 : int):ii) (( 52 : int):ii)  :  52 words$word)) in sail2_state_monad$bindS
      (if ((IsZero exp64)) then
         if (((((IsZero frac64)) \/ ((((vec_of_bits [access_vec_dec fpcr (( 24 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) then
           let typ = FPType_Zero in
           let value_name = (realFromFrac(( 0 : int))(( 10 : int))) in sail2_state_monad$seqS
           (if ((~ ((IsZero frac64)))) then FPProcessException FPExc_InputDenorm fpcr
            else sail2_state_monad$returnS () )
           (sail2_state_monad$returnS (typ, value_name))
         else
           let (typ : FPType) = FPType_Nonzero in
           let (value_name : real) =
             (((realPowInteger (realFromFrac(( 20 : int))(( 10 : int))) ((~ (( 1022 : int):ii))))) *
               (((((real_of_int ((lem$w2ui frac64))))) *
                   ((realPowInteger (realFromFrac(( 20 : int))(( 10 : int))) ((~ (( 52 : int):ii)))))))) in
           sail2_state_monad$returnS (typ, value_name)
       else
         let ((typ : FPType), (value_name : real)) =
           (if ((IsOnes exp64)) then
             let ((typ : FPType), (value_name : real)) =
               (if ((IsZero frac64)) then
                 let (typ : FPType) = FPType_Infinity in
                 let (value_name : real) = (realPowInteger (realFromFrac(( 20 : int))(( 10 : int))) (( 1000000 : int):ii)) in
                 (typ, value_name)
               else
                 let (typ : FPType) =
                   (if ((((vec_of_bits [access_vec_dec frac64 (( 51 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
                     FPType_QNaN
                   else FPType_SNaN) in
                 let (value_name : real) = (realFromFrac(( 0 : int))(( 10 : int))) in
                 (typ, value_name)) in
             (typ, value_name)
           else
             let (typ : FPType) = FPType_Nonzero in
             let (value_name : real) =
               (((realPowInteger (realFromFrac(( 20 : int))(( 10 : int))) ((((lem$w2ui exp64)) - (( 1023 : int):ii)))))
                 *
                 (((realFromFrac(( 10 : int))(( 10 : int))) +
                     (((((real_of_int ((lem$w2ui frac64))))) *
                         ((realPowInteger (realFromFrac(( 20 : int))(( 10 : int))) ((~ (( 52 : int):ii)))))))))) in
             (typ, value_name)) in
         sail2_state_monad$returnS (typ, value_name)) (\ varstup .  let ((typ : FPType), (value_name : real)) = varstup in
      sail2_state_monad$returnS (sign, typ, value_name))) (\ varstup .  let ((sign : 1 bits), (typ : FPType), (value_name :
     real)) = varstup in
   let (value_name : real) =
     (if (((sign = (vec_of_bits [B1]  :  1 words$word)))) then(real_of_num 0) - value_name
     else value_name) in
   sail2_state_monad$returnS (typ, sign, value_name)))))))))))))`;


(*val FPUnpackCV : forall 'N . Size 'N => mword 'N -> mword ty32 -> M (FPType * mword ty1 * real)*)

val _ = Define `
 ((FPUnpackCV:'N words$word ->(32)words$word ->(regstate)sail2_state_monad$sequential_state ->(((FPType#(1)words$word#real),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) fpval fpcr__arg=
    (let fpcr = fpcr__arg in
   let fpcr = ((set_slice (( 32 : int):ii) (( 1 : int):ii) fpcr (( 19 : int):ii) (vec_of_bits [B0]  :  1 words$word)  :  32 words$word)) in sail2_state_monad$bindS
   (undefined_real () ) (\ (value_name : real) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (sign : 1 bits) .  sail2_state_monad$bindS
   (undefined_FPType () ) (\ (fp_type : FPType) .  sail2_state_monad$bindS
   (FPUnpackBase fpval fpcr  : ((FPType #  1 words$word # real)) M) (\ varstup .  let (tup__0, tup__1, tup__2) = varstup in
   let (fp_type : FPType) = tup__0 in
   let (sign : 1 bits) = tup__1 in
   let (value_name : real) = tup__2 in
   sail2_state_monad$returnS (fp_type, sign, value_name)))))))`;


(*val FPConvert__0 : forall 'N 'M . Size 'M, Size 'N => integer -> mword 'N -> mword ty32 -> FPRounding -> M (mword 'M)*)

(*val FPConvert__1 : forall 'N 'M . Size 'M, Size 'N => integer -> mword 'N -> mword ty32 -> M (mword 'M)*)

val _ = Define `
 ((FPConvert__0:int -> 'N words$word ->(32)words$word -> FPRounding ->(regstate)sail2_state_monad$sequential_state ->((('M words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) (M__tv : int) op fpcr rounding=
    (let p0_ = M__tv in
   if (((p0_ = (( 16 : int):ii)))) then sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (sail2_state_monad$assert_expS ((((((((int_of_num (words$word_len op))) = (( 16 : int):ii)))) \/ ((((((((int_of_num (words$word_len op))) = (( 32 : int):ii)))) \/ (((((int_of_num (words$word_len op))) = (( 64 : int):ii)))))))))) ""))
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M)) (\ (result : 16 bits) .  sail2_state_monad$bindS
     (undefined_real () ) (\ (value_name : real) .  sail2_state_monad$bindS
     (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (sign : 1 bits) .  sail2_state_monad$bindS
     (undefined_FPType () ) (\ (typ : FPType) .  sail2_state_monad$bindS
     (FPUnpackCV op fpcr  : ((FPType #  1 words$word # real)) M) (\ varstup .  let (tup__0, tup__1, tup__2) = varstup in
     let typ = tup__0 in
     let sign = tup__1 in
     let value_name = tup__2 in
     let (alt_hp : bool) =
       (T /\ ((((vec_of_bits [access_vec_dec fpcr (( 26 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))) in sail2_state_monad$bindS
     (if ((((((typ = FPType_SNaN))) \/ (((typ = FPType_QNaN)))))) then sail2_state_monad$bindS
        (if alt_hp then (FPZero (( 16 : int):ii) sign  : ( 16 words$word) M)
         else if ((((vec_of_bits [access_vec_dec fpcr (( 25 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
           (FPDefaultNaN (( 16 : int):ii) ()   : ( 16 words$word) M)
         else (FPConvertNaN (( 16 : int):ii) op  : ( 16 words$word) M)) (\ (result : 16 bits) .  sail2_state_monad$seqS
        (if ((((((typ = FPType_SNaN))) \/ alt_hp))) then FPProcessException FPExc_InvalidOp fpcr
         else sail2_state_monad$returnS () )
        (sail2_state_monad$returnS result))
      else if (((typ = FPType_Infinity))) then
        if alt_hp then
          let result =
            ((concat_vec sign
               ((Ones__0 ((make_the_value (((( 16 : int):ii) - (( 1 : int):ii)))  :  15 itself))
                  :  15 words$word))
              :  16 words$word)) in sail2_state_monad$seqS
          (FPProcessException FPExc_InvalidOp fpcr) (sail2_state_monad$returnS result)
        else (FPInfinity (( 16 : int):ii) sign  : ( 16 words$word) M)
      else if (((typ = FPType_Zero))) then (FPZero (( 16 : int):ii) sign  : ( 16 words$word) M)
      else (FPRoundCV (( 16 : int):ii) value_name fpcr rounding  : ( 16 words$word) M)) (\ (result : 16
       bits) . 
     sail2_state_monad$returnS ((words$w2w result  :  'M words$word))))))))
   else if (((p0_ = (( 32 : int):ii)))) then sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (sail2_state_monad$assert_expS ((((((((int_of_num (words$word_len op))) = (( 16 : int):ii)))) \/ ((((((((int_of_num (words$word_len op))) = (( 32 : int):ii)))) \/ (((((int_of_num (words$word_len op))) = (( 64 : int):ii)))))))))) ""))
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (result : 32 bits) .  sail2_state_monad$bindS
     (undefined_real () ) (\ (value_name : real) .  sail2_state_monad$bindS
     (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (sign : 1 bits) .  sail2_state_monad$bindS
     (undefined_FPType () ) (\ (typ : FPType) .  sail2_state_monad$bindS
     (FPUnpackCV op fpcr  : ((FPType #  1 words$word # real)) M) (\ varstup .  let (tup__0, tup__1, tup__2) = varstup in
     let typ = tup__0 in
     let sign = tup__1 in
     let value_name = tup__2 in
     let (alt_hp : bool) =
       (F /\ ((((vec_of_bits [access_vec_dec fpcr (( 26 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))) in sail2_state_monad$bindS
     (if ((((((typ = FPType_SNaN))) \/ (((typ = FPType_QNaN)))))) then sail2_state_monad$bindS
        (if alt_hp then (FPZero (( 32 : int):ii) sign  : ( 32 words$word) M)
         else if ((((vec_of_bits [access_vec_dec fpcr (( 25 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
           (FPDefaultNaN (( 32 : int):ii) ()   : ( 32 words$word) M)
         else (FPConvertNaN (( 32 : int):ii) op  : ( 32 words$word) M)) (\ (result : 32 bits) .  sail2_state_monad$seqS
        (if ((((((typ = FPType_SNaN))) \/ alt_hp))) then FPProcessException FPExc_InvalidOp fpcr
         else sail2_state_monad$returnS () )
        (sail2_state_monad$returnS result))
      else if (((typ = FPType_Infinity))) then
        if alt_hp then
          let result =
            ((concat_vec sign
               ((Ones__0 ((make_the_value (((( 32 : int):ii) - (( 1 : int):ii)))  :  31 itself))
                  :  31 words$word))
              :  32 words$word)) in sail2_state_monad$seqS
          (FPProcessException FPExc_InvalidOp fpcr) (sail2_state_monad$returnS result)
        else (FPInfinity (( 32 : int):ii) sign  : ( 32 words$word) M)
      else if (((typ = FPType_Zero))) then (FPZero (( 32 : int):ii) sign  : ( 32 words$word) M)
      else (FPRoundCV (( 32 : int):ii) value_name fpcr rounding  : ( 32 words$word) M)) (\ (result : 32
       bits) . 
     sail2_state_monad$returnS ((words$w2w result  :  'M words$word))))))))
   else if (((p0_ = (( 64 : int):ii)))) then sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (sail2_state_monad$assert_expS ((((((((int_of_num (words$word_len op))) = (( 16 : int):ii)))) \/ ((((((((int_of_num (words$word_len op))) = (( 32 : int):ii)))) \/ (((((int_of_num (words$word_len op))) = (( 64 : int):ii)))))))))) ""))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (result : 64 bits) .  sail2_state_monad$bindS
     (undefined_real () ) (\ (value_name : real) .  sail2_state_monad$bindS
     (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (sign : 1 bits) .  sail2_state_monad$bindS
     (undefined_FPType () ) (\ (typ : FPType) .  sail2_state_monad$bindS
     (FPUnpackCV op fpcr  : ((FPType #  1 words$word # real)) M) (\ varstup .  let (tup__0, tup__1, tup__2) = varstup in
     let typ = tup__0 in
     let sign = tup__1 in
     let value_name = tup__2 in
     let (alt_hp : bool) =
       (F /\ ((((vec_of_bits [access_vec_dec fpcr (( 26 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))) in sail2_state_monad$bindS
     (if ((((((typ = FPType_SNaN))) \/ (((typ = FPType_QNaN)))))) then sail2_state_monad$bindS
        (if alt_hp then (FPZero (( 64 : int):ii) sign  : ( 64 words$word) M)
         else if ((((vec_of_bits [access_vec_dec fpcr (( 25 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
           (FPDefaultNaN (( 64 : int):ii) ()   : ( 64 words$word) M)
         else (FPConvertNaN (( 64 : int):ii) op  : ( 64 words$word) M)) (\ (result : 64 bits) .  sail2_state_monad$seqS
        (if ((((((typ = FPType_SNaN))) \/ alt_hp))) then FPProcessException FPExc_InvalidOp fpcr
         else sail2_state_monad$returnS () )
        (sail2_state_monad$returnS result))
      else if (((typ = FPType_Infinity))) then
        if alt_hp then
          let result =
            ((concat_vec sign
               ((Ones__0 ((make_the_value (((( 64 : int):ii) - (( 1 : int):ii)))  :  63 itself))
                  :  63 words$word))
              :  64 words$word)) in sail2_state_monad$seqS
          (FPProcessException FPExc_InvalidOp fpcr) (sail2_state_monad$returnS result)
        else (FPInfinity (( 64 : int):ii) sign  : ( 64 words$word) M)
      else if (((typ = FPType_Zero))) then (FPZero (( 64 : int):ii) sign  : ( 64 words$word) M)
      else (FPRoundCV (( 64 : int):ii) value_name fpcr rounding  : ( 64 words$word) M)) (\ (result : 64
       bits) . 
     sail2_state_monad$returnS ((words$w2w result  :  'M words$word))))))))
   else sail2_state_monad$seqS (sail2_state_monad$assert_expS F "") (sail2_state_monad$exitS () )))`;


val _ = Define `
 ((FPConvert__1:int -> 'N words$word ->(32)words$word ->(regstate)sail2_state_monad$sequential_state ->((('M words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) (M__tv : int) op fpcr=
    ((FPConvert__0 M__tv op fpcr ((FPRoundingMode fpcr))  : ( 'M words$word) M)))`;


(*val FPUnpack : forall 'N . Size 'N => mword 'N -> mword ty32 -> M (FPType * mword ty1 * real)*)

val _ = Define `
 ((FPUnpack:'N words$word ->(32)words$word ->(regstate)sail2_state_monad$sequential_state ->(((FPType#(1)words$word#real),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) fpval fpcr__arg=
    (let fpcr = fpcr__arg in
   let fpcr = ((set_slice (( 32 : int):ii) (( 1 : int):ii) fpcr (( 26 : int):ii) (vec_of_bits [B0]  :  1 words$word)  :  32 words$word)) in sail2_state_monad$bindS
   (undefined_real () ) (\ (value_name : real) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (sign : 1 bits) .  sail2_state_monad$bindS
   (undefined_FPType () ) (\ (fp_type : FPType) .  sail2_state_monad$bindS
   (FPUnpackBase fpval fpcr  : ((FPType #  1 words$word # real)) M) (\ varstup .  let (tup__0, tup__1, tup__2) = varstup in
   let (fp_type : FPType) = tup__0 in
   let (sign : 1 bits) = tup__1 in
   let (value_name : real) = tup__2 in
   sail2_state_monad$returnS (fp_type, sign, value_name)))))))`;


(*val FPToFixedJS : forall 'M 'N . Size 'M, Size 'N => integer -> mword 'M -> mword ty32 -> bool -> M (mword 'N)*)

val _ = Define `
 ((FPToFixedJS:int -> 'M words$word ->(32)words$word -> bool ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) (N__tv : int) op fpcr Is64=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((((((int_of_num (words$word_len op))) = (( 64 : int):ii)))) /\ (((N__tv = (( 32 : int):ii))))))) "((M == 64) && (N == 32))")
   (undefined_real () )) (\ (value_name : real) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (sign : 1 bits) .  sail2_state_monad$bindS
   (undefined_FPType () ) (\ (typ : FPType) .  sail2_state_monad$bindS
   (FPUnpack op fpcr  : ((FPType #  1 words$word # real)) M) (\ varstup .  let (tup__0, tup__1, tup__2) = varstup in
   let typ = tup__0 in
   let sign = tup__1 in
   let value_name = tup__2 in
   let (Z : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in sail2_state_monad$bindS
   (if ((((((typ = FPType_SNaN))) \/ (((typ = FPType_QNaN)))))) then sail2_state_monad$seqS
      (FPProcessException FPExc_InvalidOp fpcr)
      (let (Z : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in
      sail2_state_monad$returnS Z)
    else sail2_state_monad$returnS Z) (\ (Z : 1 bits) . 
   let (int_result : ii) = (flr value_name) in
   let (error : real) = (value_name - (((real_of_int int_result)))) in
   let (round_it_up : bool) =
     ((((error <> (realFromFrac(( 0 : int))(( 10 : int)))))) /\ ((((ex_int int_result)) < (( 0 : int):ii)))) in
   let (int_result : ii) =
     (if round_it_up then ((ex_int int_result)) + (( 1 : int):ii)
     else int_result) in sail2_state_monad$bindS
   (undefined_int () ) (\ (result : ii) . 
   let (result : ii) =
     (if ((((ex_int int_result)) < (( 0 : int):ii))) then
       ((ex_int int_result)) -
         ((((pow2 (( 32 : int):ii))) *
             ((ex_int
                 ((clg
                     (((((real_of_int int_result))) / (((real_of_int ((pow2 (( 32 : int):ii))))))))))))))
     else
       ((ex_int int_result)) -
         ((((pow2 (( 32 : int):ii))) *
             ((ex_int
                 ((flr
                     (((((real_of_int int_result))) / (((real_of_int ((pow2 (( 32 : int):ii))))))))))))))) in sail2_state_monad$bindS
   (if (((((((ex_int int_result)) < ((~ ((pow2 (( 31 : int):ii))))))) \/ ((((ex_int int_result)) > ((((pow2 (( 31 : int):ii))) - (( 1 : int):ii)))))))) then sail2_state_monad$seqS
      (FPProcessException FPExc_InvalidOp fpcr)
      (let (Z : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in
      sail2_state_monad$returnS Z)
    else if (((error <> (realFromFrac(( 0 : int))(( 10 : int)))))) then sail2_state_monad$seqS
      (FPProcessException FPExc_Inexact fpcr)
      (let (Z : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in
      sail2_state_monad$returnS Z)
    else sail2_state_monad$returnS Z) (\ (Z : 1 bits) . 
   let (Z : 1 bits) =
     (if ((((((sign = (vec_of_bits [B1]  :  1 words$word)))) /\ (((value_name = (realFromFrac(( 0 : int))(( 10 : int))))))))) then
       (vec_of_bits [B0]  :  1 words$word)
     else Z) in
   let (result : ii) = (if (((typ = FPType_Infinity))) then (( 0 : int):ii) else result) in sail2_state_monad$seqS
   (if Is64 then
      let split_vec =
        ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) Z  :  2 words$word))
           (vec_of_bits [B0;B0]  :  2 words$word)
          :  4 words$word)) in
      let (tup__0, tup__1, tup__2, tup__3) =
        ((subrange_vec_dec split_vec (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__0 with<| ProcState_N := tup__0|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__1 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__1 with<| ProcState_Z := tup__1|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__2 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__2 with<| ProcState_C := tup__2|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__3 : ProcState) . 
      sail2_state_monad$write_regS PSTATE_ref (w__3 with<| ProcState_V := tup__3|>)))))
    else sail2_state_monad$bindS
      (sail2_state_monad$read_regS FPSCR_ref  : ( 32 words$word) M) (\ (w__4 :  32 words$word) . 
      sail2_state_monad$write_regS
        FPSCR_ref
        ((set_slice (( 32 : int):ii) (( 4 : int):ii) w__4 (( 28 : int):ii)
            ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) Z  :  2 words$word))
                (vec_of_bits [B0;B0]  :  2 words$word)
               :  4 words$word))
           :  32 words$word))))
   (sail2_state_monad$returnS ((words$w2w
              ((GetSlice_int ((make_the_value (( 32 : int):ii)  :  'N itself)) result (( 0 : int):ii)  :  'N words$word))
             :  'N words$word))))))))))))`;


(*val FPToFixed : forall 'N 'M . Size 'M, Size 'N => integer -> mword 'N -> ii -> bool -> mword ty32 -> FPRounding -> M (mword 'M)*)

val _ = Define `
 ((FPToFixed:int -> 'N words$word -> int -> bool ->(32)words$word -> FPRounding ->(regstate)sail2_state_monad$sequential_state ->((('M words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) (M__tv : int) op fbits unsigned fpcr rounding=  (sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((((((int_of_num (words$word_len op))) = (( 16 : int):ii)))) \/ ((((((((int_of_num (words$word_len op))) = (( 32 : int):ii)))) \/ (((((int_of_num (words$word_len op))) = (( 64 : int):ii)))))))))) "((N == 16) || ((N == 32) || (N == 64)))")
   (sail2_state_monad$assert_expS ((((((M__tv = (( 16 : int):ii)))) \/ ((((((M__tv = (( 32 : int):ii)))) \/ (((M__tv = (( 64 : int):ii)))))))))) "((M == 16) || ((M == 32) || (M == 64)))"))
   (sail2_state_monad$assert_expS ((fbits >= (( 0 : int):ii))) "(fbits >= 0)"))
   (sail2_state_monad$assert_expS (((rounding <> FPRounding_ODD))) "(rounding != FPRounding_ODD)"))
   (undefined_real () )) (\ (value_name : real) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (sign : 1 bits) .  sail2_state_monad$bindS
   (undefined_FPType () ) (\ (typ : FPType) .  sail2_state_monad$bindS
   (FPUnpack op fpcr  : ((FPType #  1 words$word # real)) M) (\ varstup .  let (tup__0, tup__1, tup__2) = varstup in
   let typ = tup__0 in
   let sign = tup__1 in
   let value_name = tup__2 in sail2_state_monad$seqS
   (if ((((((typ = FPType_SNaN))) \/ (((typ = FPType_QNaN)))))) then
      FPProcessException FPExc_InvalidOp fpcr
    else sail2_state_monad$returnS () )
   (let value_name = (value_name * ((realPowInteger (realFromFrac(( 20 : int))(( 10 : int))) fbits))) in
   let (int_result : ii) = (flr value_name) in
   let (error : real) = (value_name - (((real_of_int int_result)))) in sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (round_up : bool) . 
   let (round_up : bool) =
     ((case rounding of
       FPRounding_TIEEVEN =>
        (((error > (realFromFrac(( 5 : int))(( 10 : int))))) \/ ((((((error = (realFromFrac(( 5 : int))(( 10 : int)))))) /\ (((((GetSlice_int ((make_the_value (( 1 : int):ii)  :  1 itself)) int_result (( 0 : int):ii)
                     :  1 words$word)) = (vec_of_bits [B1]  :  1 words$word))))))))
     | FPRounding_POSINF => (error <> (realFromFrac(( 0 : int))(( 10 : int))))
     | FPRounding_NEGINF => F
     | FPRounding_ZERO =>
        ((((error <> (realFromFrac(( 0 : int))(( 10 : int)))))) /\ ((((ex_int int_result)) < (( 0 : int):ii))))
     | FPRounding_TIEAWAY =>
        (((error > (realFromFrac(( 5 : int))(( 10 : int))))) \/ ((((((error = (realFromFrac(( 5 : int))(( 10 : int)))))) /\ ((((ex_int int_result)) >= (( 0 : int):ii)))))))
     )) in
   let (int_result : ii) = (if round_up then ((ex_int int_result)) + (( 1 : int):ii) else int_result) in sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (overflow : bool) .  sail2_state_monad$bindS
   (undefined_bitvector M__tv  : ( 'M words$word) M) (\ (result : 'M bits) .  sail2_state_monad$bindS
   (SatQ int_result ((make_the_value ((int_of_num (words$word_len result)))  :  'M itself)) unsigned
     : (( 'M words$word # bool)) M) (\ varstup .  let (tup__0, tup__1) = varstup in
   let result = tup__0 in
   let overflow = tup__1 in sail2_state_monad$seqS
   (if overflow then FPProcessException FPExc_InvalidOp fpcr
    else if (((error <> (realFromFrac(( 0 : int))(( 10 : int)))))) then FPProcessException FPExc_Inexact fpcr
    else sail2_state_monad$returnS () )
   (sail2_state_monad$returnS result))))))))))))`;


(*val FPSqrt : forall 'N . Size 'N => mword 'N -> mword ty32 -> M (mword 'N)*)

val _ = Define `
 ((FPSqrt:'N words$word ->(32)words$word ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) op fpcr=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((((((int_of_num (words$word_len op))) = (( 16 : int):ii)))) \/ ((((((((int_of_num (words$word_len op))) = (( 32 : int):ii)))) \/ (((((int_of_num (words$word_len op))) = (( 64 : int):ii)))))))))) "((N == 16) || ((N == 32) || (N == 64)))")
   (undefined_real () )) (\ (value_name : real) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (sign : 1 bits) .  sail2_state_monad$bindS
   (undefined_FPType () ) (\ (typ : FPType) .  sail2_state_monad$bindS
   (FPUnpack op fpcr  : ((FPType #  1 words$word # real)) M) (\ varstup .  let (tup__0, tup__1, tup__2) = varstup in
   let typ = tup__0 in
   let sign = tup__1 in
   let value_name = tup__2 in sail2_state_monad$bindS
   (undefined_bitvector ((int_of_num (words$word_len op)))  : ( 'N words$word) M) (\ (result : 'N bits) . 
   if ((((((typ = FPType_SNaN))) \/ (((typ = FPType_QNaN)))))) then
     (FPProcessNaN typ op fpcr  : ( 'N words$word) M)
   else if (((typ = FPType_Zero))) then (FPZero ((int_of_num (words$word_len op))) sign  : ( 'N words$word) M)
   else if ((((((typ = FPType_Infinity))) /\ (((sign = (vec_of_bits [B0]  :  1 words$word)))))))
   then
     (FPInfinity ((int_of_num (words$word_len op))) sign  : ( 'N words$word) M)
   else if (((sign = (vec_of_bits [B1]  :  1 words$word)))) then sail2_state_monad$bindS
     (FPDefaultNaN ((int_of_num (words$word_len op))) ()   : ( 'N words$word) M) (\ (w__3 : 'N bits) . 
     let result = w__3 in sail2_state_monad$seqS
     (FPProcessException FPExc_InvalidOp fpcr) (sail2_state_monad$returnS result))
   else (FPRound__1 ((int_of_num (words$word_len op))) ((sqrt value_name)) fpcr  : ( 'N words$word) M))))))))`;


(*val FPRoundInt : forall 'N . Size 'N => mword 'N -> mword ty32 -> FPRounding -> bool -> M (mword 'N)*)

val _ = Define `
 ((FPRoundInt:'N words$word ->(32)words$word -> FPRounding -> bool ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) op fpcr rounding exact=  (sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS (((rounding <> FPRounding_ODD))) "(rounding != FPRounding_ODD)")
   (sail2_state_monad$assert_expS ((((((((int_of_num (words$word_len op))) = (( 16 : int):ii)))) \/ ((((((((int_of_num (words$word_len op))) = (( 32 : int):ii)))) \/ (((((int_of_num (words$word_len op))) = (( 64 : int):ii)))))))))) "((N == 16) || ((N == 32) || (N == 64)))"))
   (undefined_real () )) (\ (value_name : real) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (sign : 1 bits) .  sail2_state_monad$bindS
   (undefined_FPType () ) (\ (typ : FPType) .  sail2_state_monad$bindS
   (FPUnpack op fpcr  : ((FPType #  1 words$word # real)) M) (\ varstup .  let (tup__0, tup__1, tup__2) = varstup in
   let typ = tup__0 in
   let sign = tup__1 in
   let value_name = tup__2 in sail2_state_monad$bindS
   (undefined_real () ) (\ (real_result : real) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (round_up : bool) .  sail2_state_monad$bindS
   (undefined_real () ) (\ (error : real) .  sail2_state_monad$bindS
   (undefined_int () ) (\ (int_result : ii) .  sail2_state_monad$bindS
   (undefined_bitvector ((int_of_num (words$word_len op)))  : ( 'N words$word) M) (\ (result : 'N bits) . 
   if ((((((typ = FPType_SNaN))) \/ (((typ = FPType_QNaN)))))) then
     (FPProcessNaN typ op fpcr  : ( 'N words$word) M)
   else if (((typ = FPType_Infinity))) then (FPInfinity ((int_of_num (words$word_len op))) sign  : ( 'N words$word) M)
   else if (((typ = FPType_Zero))) then (FPZero ((int_of_num (words$word_len op))) sign  : ( 'N words$word) M)
   else
     let int_result = (flr value_name) in
     let error = (value_name - (((real_of_int int_result)))) in
     let (round_up : bool) =
       ((case rounding of
         FPRounding_TIEEVEN =>
          (((error > (realFromFrac(( 5 : int))(( 10 : int))))) \/ ((((((error = (realFromFrac(( 5 : int))(( 10 : int)))))) /\ (((((GetSlice_int ((make_the_value (( 1 : int):ii)  :  1 itself)) int_result (( 0 : int):ii)
                       :  1 words$word)) = (vec_of_bits [B1]  :  1 words$word))))))))
       | FPRounding_POSINF => (error <> (realFromFrac(( 0 : int))(( 10 : int))))
       | FPRounding_NEGINF => F
       | FPRounding_ZERO =>
          ((((error <> (realFromFrac(( 0 : int))(( 10 : int)))))) /\ ((((ex_int int_result)) < (( 0 : int):ii))))
       | FPRounding_TIEAWAY =>
          (((error > (realFromFrac(( 5 : int))(( 10 : int))))) \/ ((((((error = (realFromFrac(( 5 : int))(( 10 : int)))))) /\ ((((ex_int int_result)) >= (( 0 : int):ii)))))))
       )) in
     let (int_result : ii) =
       (if round_up then ((ex_int int_result)) + (( 1 : int):ii)
       else int_result) in
     let real_result = ((real_of_int int_result)) in sail2_state_monad$bindS
     (if (((real_result = (realFromFrac(( 0 : int))(( 10 : int)))))) then (FPZero ((int_of_num (words$word_len op))) sign  : ( 'N words$word) M)
      else (FPRound__0 ((int_of_num (words$word_len op))) real_result fpcr FPRounding_ZERO  : ( 'N words$word) M)) (\ (result : 'N
       bits) .  sail2_state_monad$seqS
     (if ((((((error <> (realFromFrac(( 0 : int))(( 10 : int)))))) /\ exact))) then
        FPProcessException FPExc_Inexact fpcr
      else sail2_state_monad$returnS () )
     (sail2_state_monad$returnS result)))))))))))))`;


(*val FPCompare : forall 'N . Size 'N => mword 'N -> mword 'N -> bool -> mword ty32 -> M (mword ty4)*)

val _ = Define `
 ((FPCompare:'N words$word -> 'N words$word -> bool ->(32)words$word ->(regstate)sail2_state_monad$sequential_state ->((((4)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) op1 op2 signal_nans fpcr=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((((((int_of_num (words$word_len op1))) = (( 16 : int):ii)))) \/ ((((((((int_of_num (words$word_len op1))) = (( 32 : int):ii)))) \/ (((((int_of_num (words$word_len op1))) = (( 64 : int):ii)))))))))) "((N == 16) || ((N == 32) || (N == 64)))")
   (undefined_real () )) (\ (value1_name : real) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (sign1 : 1 bits) .  sail2_state_monad$bindS
   (undefined_FPType () ) (\ (type1 : FPType) .  sail2_state_monad$bindS
   (FPUnpack op1 fpcr  : ((FPType #  1 words$word # real)) M) (\ varstup .  let (tup__0, tup__1, tup__2) = varstup in
   let type1 = tup__0 in
   let sign1 = tup__1 in
   let value1_name = tup__2 in sail2_state_monad$bindS
   (undefined_real () ) (\ (value2_name : real) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (sign2 : 1 bits) .  sail2_state_monad$bindS
   (undefined_FPType () ) (\ (type2 : FPType) .  sail2_state_monad$bindS
   (FPUnpack op2 fpcr  : ((FPType #  1 words$word # real)) M) (\ varstup .  let (tup__0, tup__1, tup__2) = varstup in
   let type2 = tup__0 in
   let sign2 = tup__1 in
   let value2_name = tup__2 in sail2_state_monad$bindS
   (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (result : 4 bits) . 
   if ((((((((((((type1 = FPType_SNaN))) \/ (((type1 = FPType_QNaN)))))) \/ (((type2 = FPType_SNaN)))))) \/ (((type2 = FPType_QNaN)))))) then
     let result = ((vec_of_bits [B0;B0;B1;B1]  :  4 words$word)) in sail2_state_monad$seqS
     (if (((((((((type1 = FPType_SNaN))) \/ (((type2 = FPType_SNaN)))))) \/ signal_nans))) then
        FPProcessException FPExc_InvalidOp fpcr
      else sail2_state_monad$returnS () )
     (sail2_state_monad$returnS result)
   else
     let (result : 4 bits) =
       (if (((value1_name = value2_name))) then (vec_of_bits [B0;B1;B1;B0]  :  4 words$word)
       else if ((value1_name < value2_name)) then (vec_of_bits [B1;B0;B0;B0]  :  4 words$word)
       else (vec_of_bits [B0;B0;B1;B0]  :  4 words$word)) in
     sail2_state_monad$returnS result)))))))))))`;


(*val FPSub : forall 'N . Size 'N => mword 'N -> mword 'N -> mword ty32 -> M (mword 'N)*)

val _ = Define `
 ((FPSub:'N words$word -> 'N words$word ->(32)words$word ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) op1 op2 fpcr=  (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((((((int_of_num (words$word_len op1))) = (( 16 : int):ii)))) \/ ((((((((int_of_num (words$word_len op1))) = (( 32 : int):ii)))) \/ (((((int_of_num (words$word_len op1))) = (( 64 : int):ii)))))))))) "((N == 16) || ((N == 32) || (N == 64)))")
   (let (rounding : FPRounding) = (FPRoundingMode fpcr) in sail2_state_monad$bindS
   (undefined_real () ) (\ (value1_name : real) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (sign1 : 1 bits) .  sail2_state_monad$bindS
   (undefined_FPType () ) (\ (type1 : FPType) .  sail2_state_monad$bindS
   (FPUnpack op1 fpcr  : ((FPType #  1 words$word # real)) M) (\ varstup .  let (tup__0, tup__1, tup__2) = varstup in
   let type1 = tup__0 in
   let sign1 = tup__1 in
   let value1_name = tup__2 in sail2_state_monad$bindS
   (undefined_real () ) (\ (value2_name : real) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (sign2 : 1 bits) .  sail2_state_monad$bindS
   (undefined_FPType () ) (\ (type2 : FPType) .  sail2_state_monad$bindS
   (FPUnpack op2 fpcr  : ((FPType #  1 words$word # real)) M) (\ varstup .  let (tup__0, tup__1, tup__2) = varstup in
   let type2 = tup__0 in
   let sign2 = tup__1 in
   let value2_name = tup__2 in sail2_state_monad$bindS
   (undefined_bitvector ((int_of_num (words$word_len op1)))  : ( 'N words$word) M) (\ (result : 'N bits) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (done : bool) .  sail2_state_monad$bindS
   (FPProcessNaNs type1 type2 op1 op2 fpcr  : ((bool #  'N words$word)) M) (\ varstup .  let (tup__0, tup__1) = varstup in
   let done = tup__0 in
   let result = tup__1 in sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (result_sign : 1 bits) .  sail2_state_monad$bindS
   (undefined_real () ) (\ (result_value : real) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (zero2 : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (zero1 : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (inf2 : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (inf1 : bool) . 
   if ((~ done)) then
     let inf1 = (type1 = FPType_Infinity) in
     let inf2 = (type2 = FPType_Infinity) in
     let zero1 = (type1 = FPType_Zero) in
     let zero2 = (type2 = FPType_Zero) in
     if ((((((inf1 /\ inf2))) /\ (((sign1 = sign2)))))) then sail2_state_monad$bindS
       (FPDefaultNaN ((int_of_num (words$word_len op1))) ()   : ( 'N words$word) M) (\ (w__0 : 'N bits) . 
       let result = w__0 in sail2_state_monad$seqS
       (FPProcessException FPExc_InvalidOp fpcr) (sail2_state_monad$returnS result))
     else if ((((((inf1 /\ (((sign1 = (vec_of_bits [B0]  :  1 words$word))))))) \/ (((inf2 /\ (((sign2 = (vec_of_bits [B1]  :  1 words$word)))))))))) then
       (FPInfinity ((int_of_num (words$word_len op1))) (vec_of_bits [B0]  :  1 words$word)  : ( 'N words$word) M)
     else if ((((((inf1 /\ (((sign1 = (vec_of_bits [B1]  :  1 words$word))))))) \/ (((inf2 /\ (((sign2 = (vec_of_bits [B0]  :  1 words$word)))))))))) then
       (FPInfinity ((int_of_num (words$word_len op1))) (vec_of_bits [B1]  :  1 words$word)  : ( 'N words$word) M)
     else if ((((((zero1 /\ zero2))) /\ (((sign1 = ((not_vec sign2  :  1 words$word))))))))
     then
       (FPZero ((int_of_num (words$word_len op1))) sign1  : ( 'N words$word) M)
     else
       let result_value = (value1_name - value2_name) in
       if (((result_value = (realFromFrac(( 0 : int))(( 10 : int)))))) then
         let result_sign =
           (if (((rounding = FPRounding_NEGINF))) then (vec_of_bits [B1]  :  1 words$word)
           else (vec_of_bits [B0]  :  1 words$word)) in
         (FPZero ((int_of_num (words$word_len op1))) result_sign  : ( 'N words$word) M)
       else (FPRound__0 ((int_of_num (words$word_len op1))) result_value fpcr rounding  : ( 'N words$word) M)
   else sail2_state_monad$returnS result))))))))))))))))))))`;


(*val FPMulAdd : forall 'N . Size 'N => mword 'N -> mword 'N -> mword 'N -> mword ty32 -> M (mword 'N)*)

val _ = Define `
 ((FPMulAdd:'N words$word -> 'N words$word -> 'N words$word ->(32)words$word ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) addend op1 op2 fpcr=  (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((((((int_of_num (words$word_len addend))) = (( 16 : int):ii)))) \/ ((((((((int_of_num (words$word_len addend))) = (( 32 : int):ii)))) \/ (((((int_of_num (words$word_len addend))) = (( 64 : int):ii)))))))))) "((N == 16) || ((N == 32) || (N == 64)))")
   (let (rounding : FPRounding) = (FPRoundingMode fpcr) in sail2_state_monad$bindS
   (undefined_real () ) (\ (valueA_name : real) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (signA : 1 bits) .  sail2_state_monad$bindS
   (undefined_FPType () ) (\ (typeA : FPType) .  sail2_state_monad$bindS
   (FPUnpack addend fpcr  : ((FPType #  1 words$word # real)) M) (\ varstup .  let (tup__0, tup__1, tup__2) = varstup in
   let typeA = tup__0 in
   let signA = tup__1 in
   let valueA_name = tup__2 in sail2_state_monad$bindS
   (undefined_real () ) (\ (value1_name : real) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (sign1 : 1 bits) .  sail2_state_monad$bindS
   (undefined_FPType () ) (\ (type1 : FPType) .  sail2_state_monad$bindS
   (FPUnpack op1 fpcr  : ((FPType #  1 words$word # real)) M) (\ varstup .  let (tup__0, tup__1, tup__2) = varstup in
   let type1 = tup__0 in
   let sign1 = tup__1 in
   let value1_name = tup__2 in sail2_state_monad$bindS
   (undefined_real () ) (\ (value2_name : real) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (sign2 : 1 bits) .  sail2_state_monad$bindS
   (undefined_FPType () ) (\ (type2 : FPType) .  sail2_state_monad$bindS
   (FPUnpack op2 fpcr  : ((FPType #  1 words$word # real)) M) (\ varstup .  let (tup__0, tup__1, tup__2) = varstup in
   let type2 = tup__0 in
   let sign2 = tup__1 in
   let value2_name = tup__2 in
   let (inf1 : bool) = (type1 = FPType_Infinity) in
   let (zero1 : bool) = (type1 = FPType_Zero) in
   let (inf2 : bool) = (type2 = FPType_Infinity) in
   let (zero2 : bool) = (type2 = FPType_Zero) in sail2_state_monad$bindS
   (undefined_bitvector ((int_of_num (words$word_len addend)))  : ( 'N words$word) M) (\ (result : 'N bits) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (done : bool) .  sail2_state_monad$bindS
   (FPProcessNaNs3 typeA type1 type2 addend op1 op2 fpcr  : ((bool #  'N words$word)) M) (\ varstup .  let (tup__0, tup__1) = varstup in
   let done = tup__0 in
   let result = tup__1 in sail2_state_monad$bindS
   (if ((((((typeA = FPType_QNaN))) /\ ((((((inf1 /\ zero2))) \/ (((zero1 /\ inf2))))))))) then sail2_state_monad$bindS
      (FPDefaultNaN ((int_of_num (words$word_len addend))) ()   : ( 'N words$word) M) (\ (w__0 : 'N bits) . 
      let result = w__0 in sail2_state_monad$seqS
      (FPProcessException FPExc_InvalidOp fpcr) (sail2_state_monad$returnS result))
    else sail2_state_monad$returnS result) (\ (result : 'N bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (result_sign : 1 bits) .  sail2_state_monad$bindS
   (undefined_real () ) (\ (result_value : real) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (zeroP : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (infP : bool) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (signP : 1 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (zeroA : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (infA : bool) . 
   if ((~ done)) then
     let infA = (typeA = FPType_Infinity) in
     let zeroA = (typeA = FPType_Zero) in
     let signP = ((xor_vec sign1 sign2  :  1 words$word)) in
     let infP = (inf1 \/ inf2) in
     let zeroP = (zero1 \/ zero2) in
     if (((((((((inf1 /\ zero2))) \/ (((zero1 /\ inf2)))))) \/ ((((((infA /\ infP))) /\ (((signA <> signP))))))))) then sail2_state_monad$bindS
       (FPDefaultNaN ((int_of_num (words$word_len addend))) ()   : ( 'N words$word) M) (\ (w__1 : 'N bits) . 
       let result = w__1 in sail2_state_monad$seqS
       (FPProcessException FPExc_InvalidOp fpcr) (sail2_state_monad$returnS result))
     else if ((((((infA /\ (((signA = (vec_of_bits [B0]  :  1 words$word))))))) \/ (((infP /\ (((signP = (vec_of_bits [B0]  :  1 words$word)))))))))) then
       (FPInfinity ((int_of_num (words$word_len addend))) (vec_of_bits [B0]  :  1 words$word)  : ( 'N words$word) M)
     else if ((((((infA /\ (((signA = (vec_of_bits [B1]  :  1 words$word))))))) \/ (((infP /\ (((signP = (vec_of_bits [B1]  :  1 words$word)))))))))) then
       (FPInfinity ((int_of_num (words$word_len addend))) (vec_of_bits [B1]  :  1 words$word)  : ( 'N words$word) M)
     else if ((((((zeroA /\ zeroP))) /\ (((signA = signP)))))) then
       (FPZero ((int_of_num (words$word_len addend))) signA  : ( 'N words$word) M)
     else
       let result_value = (valueA_name + ((value1_name * value2_name))) in
       if (((result_value = (realFromFrac(( 0 : int))(( 10 : int)))))) then
         let result_sign =
           (if (((rounding = FPRounding_NEGINF))) then (vec_of_bits [B1]  :  1 words$word)
           else (vec_of_bits [B0]  :  1 words$word)) in
         (FPZero ((int_of_num (words$word_len addend))) result_sign  : ( 'N words$word) M)
       else (FPRound__1 ((int_of_num (words$word_len addend))) result_value fpcr  : ( 'N words$word) M)
   else sail2_state_monad$returnS result))))))))))))))))))))))))))`;


(*val FPMul : forall 'N . Size 'N => mword 'N -> mword 'N -> mword ty32 -> M (mword 'N)*)

val _ = Define `
 ((FPMul:'N words$word -> 'N words$word ->(32)words$word ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) op1 op2 fpcr=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((((((int_of_num (words$word_len op1))) = (( 16 : int):ii)))) \/ ((((((((int_of_num (words$word_len op1))) = (( 32 : int):ii)))) \/ (((((int_of_num (words$word_len op1))) = (( 64 : int):ii)))))))))) "((N == 16) || ((N == 32) || (N == 64)))")
   (undefined_real () )) (\ (value1_name : real) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (sign1 : 1 bits) .  sail2_state_monad$bindS
   (undefined_FPType () ) (\ (type1 : FPType) .  sail2_state_monad$bindS
   (FPUnpack op1 fpcr  : ((FPType #  1 words$word # real)) M) (\ varstup .  let (tup__0, tup__1, tup__2) = varstup in
   let type1 = tup__0 in
   let sign1 = tup__1 in
   let value1_name = tup__2 in sail2_state_monad$bindS
   (undefined_real () ) (\ (value2_name : real) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (sign2 : 1 bits) .  sail2_state_monad$bindS
   (undefined_FPType () ) (\ (type2 : FPType) .  sail2_state_monad$bindS
   (FPUnpack op2 fpcr  : ((FPType #  1 words$word # real)) M) (\ varstup .  let (tup__0, tup__1, tup__2) = varstup in
   let type2 = tup__0 in
   let sign2 = tup__1 in
   let value2_name = tup__2 in sail2_state_monad$bindS
   (undefined_bitvector ((int_of_num (words$word_len op1)))  : ( 'N words$word) M) (\ (result : 'N bits) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (done : bool) .  sail2_state_monad$bindS
   (FPProcessNaNs type1 type2 op1 op2 fpcr  : ((bool #  'N words$word)) M) (\ varstup .  let (tup__0, tup__1) = varstup in
   let done = tup__0 in
   let result = tup__1 in sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (zero2 : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (zero1 : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (inf2 : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (inf1 : bool) . 
   if ((~ done)) then
     let inf1 = (type1 = FPType_Infinity) in
     let inf2 = (type2 = FPType_Infinity) in
     let zero1 = (type1 = FPType_Zero) in
     let zero2 = (type2 = FPType_Zero) in
     if ((((((inf1 /\ zero2))) \/ (((zero1 /\ inf2)))))) then sail2_state_monad$bindS
       (FPDefaultNaN ((int_of_num (words$word_len op1))) ()   : ( 'N words$word) M) (\ (w__0 : 'N bits) . 
       let result = w__0 in sail2_state_monad$seqS
       (FPProcessException FPExc_InvalidOp fpcr) (sail2_state_monad$returnS result))
     else if (((inf1 \/ inf2))) then
       (FPInfinity ((int_of_num (words$word_len op1))) ((xor_vec sign1 sign2  :  1 words$word))  : ( 'N words$word) M)
     else if (((zero1 \/ zero2))) then
       (FPZero ((int_of_num (words$word_len op1))) ((xor_vec sign1 sign2  :  1 words$word))  : ( 'N words$word) M)
     else (FPRound__1 ((int_of_num (words$word_len op1))) ((value1_name * value2_name)) fpcr  : ( 'N words$word) M)
   else sail2_state_monad$returnS result)))))))))))))))))`;


(*val FPMin : forall 'N . Size 'N => mword 'N -> mword 'N -> mword ty32 -> M (mword 'N)*)

val _ = Define `
 ((FPMin:'N words$word -> 'N words$word ->(32)words$word ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) op1 op2 fpcr=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((((((int_of_num (words$word_len op1))) = (( 16 : int):ii)))) \/ ((((((((int_of_num (words$word_len op1))) = (( 32 : int):ii)))) \/ (((((int_of_num (words$word_len op1))) = (( 64 : int):ii)))))))))) "((N == 16) || ((N == 32) || (N == 64)))")
   (undefined_real () )) (\ (value1_name : real) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (sign1 : 1 bits) .  sail2_state_monad$bindS
   (undefined_FPType () ) (\ (type1 : FPType) .  sail2_state_monad$bindS
   (FPUnpack op1 fpcr  : ((FPType #  1 words$word # real)) M) (\ varstup .  let (tup__0, tup__1, tup__2) = varstup in
   let type1 = tup__0 in
   let sign1 = tup__1 in
   let value1_name = tup__2 in sail2_state_monad$bindS
   (undefined_real () ) (\ (value2_name : real) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (sign2 : 1 bits) .  sail2_state_monad$bindS
   (undefined_FPType () ) (\ (type2 : FPType) .  sail2_state_monad$bindS
   (FPUnpack op2 fpcr  : ((FPType #  1 words$word # real)) M) (\ varstup .  let (tup__0, tup__1, tup__2) = varstup in
   let type2 = tup__0 in
   let sign2 = tup__1 in
   let value2_name = tup__2 in sail2_state_monad$bindS
   (undefined_bitvector ((int_of_num (words$word_len op1)))  : ( 'N words$word) M) (\ (result : 'N bits) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (done : bool) .  sail2_state_monad$bindS
   (FPProcessNaNs type1 type2 op1 op2 fpcr  : ((bool #  'N words$word)) M) (\ varstup .  let (tup__0, tup__1) = varstup in
   let done = tup__0 in
   let result = tup__1 in sail2_state_monad$bindS
   (undefined_real () ) (\ (value_name : real) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (sign : 1 bits) .  sail2_state_monad$bindS
   (undefined_FPType () ) (\ (typ : FPType) . 
   if ((~ done)) then
     let ((sign : 1 bits), (typ : FPType), (value_name : real)) =
       (if ((value1_name < value2_name)) then
         let (tup__0, tup__1, tup__2) = (type1, sign1, value1_name) in
         let (typ : FPType) = tup__0 in
         let (sign : 1 bits) = tup__1 in
         let (value_name : real) = tup__2 in
         (sign, typ, value_name)
       else
         let (tup__0, tup__1, tup__2) = (type2, sign2, value2_name) in
         let (typ : FPType) = tup__0 in
         let (sign : 1 bits) = tup__1 in
         let (value_name : real) = tup__2 in
         (sign, typ, value_name)) in
     if (((typ = FPType_Infinity))) then (FPInfinity ((int_of_num (words$word_len op1))) sign  : ( 'N words$word) M)
     else if (((typ = FPType_Zero))) then
       let sign = ((or_vec sign1 sign2  :  1 words$word)) in
       (FPZero ((int_of_num (words$word_len op1))) sign  : ( 'N words$word) M)
     else (FPRound__1 ((int_of_num (words$word_len op1))) value_name fpcr  : ( 'N words$word) M)
   else sail2_state_monad$returnS result))))))))))))))))`;


(*val FPMinNum : forall 'N . Size 'N => mword 'N -> mword 'N -> mword ty32 -> M (mword 'N)*)

val _ = Define `
 ((FPMinNum:'N words$word -> 'N words$word ->(32)words$word ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) op1__arg op2__arg fpcr=
    (let op1 = op1__arg in
   let op2 = op2__arg in sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((((((int_of_num (words$word_len op1))) = (( 16 : int):ii)))) \/ ((((((((int_of_num (words$word_len op1))) = (( 32 : int):ii)))) \/ (((((int_of_num (words$word_len op1))) = (( 64 : int):ii)))))))))) "((N == 16) || ((N == 32) || (N == 64)))")
   (undefined_real () )) (\ (anon20 : real) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (anon10 : 1 bits) .  sail2_state_monad$bindS
   (undefined_FPType () ) (\ (type1 : FPType) .  sail2_state_monad$bindS
   (FPUnpack op1 fpcr  : ((FPType #  1 words$word # real)) M) (\ varstup .  let (tup__0, tup__1, tup__2) = varstup in
   let type1 = tup__0 in
   let anon10 = tup__1 in
   let anon20 = tup__2 in sail2_state_monad$bindS
   (undefined_real () ) (\ (anon40 : real) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (anon30 : 1 bits) .  sail2_state_monad$bindS
   (undefined_FPType () ) (\ (type2 : FPType) .  sail2_state_monad$bindS
   (FPUnpack op2 fpcr  : ((FPType #  1 words$word # real)) M) (\ varstup .  let (tup__0, tup__1, tup__2) = varstup in
   let type2 = tup__0 in
   let anon30 = tup__1 in
   let anon40 = tup__2 in sail2_state_monad$bindS
   (if ((((((type1 = FPType_QNaN))) /\ (((type2 <> FPType_QNaN)))))) then sail2_state_monad$bindS
      (FPInfinity ((int_of_num (words$word_len op1))) (vec_of_bits [B0]  :  1 words$word)  : ( 'N words$word) M) (\ (w__0 :
         'N words$word) . 
      let (op1 :  'N words$word) = w__0 in
      sail2_state_monad$returnS (op1, op2))
    else sail2_state_monad$bindS
      (if ((((((type1 <> FPType_QNaN))) /\ (((type2 = FPType_QNaN)))))) then
         (FPInfinity ((int_of_num (words$word_len op1))) (vec_of_bits [B0]  :  1 words$word)  : ( 'N words$word) M)
       else sail2_state_monad$returnS op2) (\ (op2 :  'N words$word) . 
      sail2_state_monad$returnS (op1, op2))) (\ varstup .  let ((op1 :  'N words$word), (op2 :  'N words$word)) = varstup in
   (FPMin op1 op2 fpcr  : ( 'N words$word) M))))))))))))`;


(*val FPMax : forall 'N . Size 'N => mword 'N -> mword 'N -> mword ty32 -> M (mword 'N)*)

val _ = Define `
 ((FPMax:'N words$word -> 'N words$word ->(32)words$word ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) op1 op2 fpcr=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((((((int_of_num (words$word_len op1))) = (( 16 : int):ii)))) \/ ((((((((int_of_num (words$word_len op1))) = (( 32 : int):ii)))) \/ (((((int_of_num (words$word_len op1))) = (( 64 : int):ii)))))))))) "((N == 16) || ((N == 32) || (N == 64)))")
   (undefined_real () )) (\ (value1_name : real) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (sign1 : 1 bits) .  sail2_state_monad$bindS
   (undefined_FPType () ) (\ (type1 : FPType) .  sail2_state_monad$bindS
   (FPUnpack op1 fpcr  : ((FPType #  1 words$word # real)) M) (\ varstup .  let (tup__0, tup__1, tup__2) = varstup in
   let type1 = tup__0 in
   let sign1 = tup__1 in
   let value1_name = tup__2 in sail2_state_monad$bindS
   (undefined_real () ) (\ (value2_name : real) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (sign2 : 1 bits) .  sail2_state_monad$bindS
   (undefined_FPType () ) (\ (type2 : FPType) .  sail2_state_monad$bindS
   (FPUnpack op2 fpcr  : ((FPType #  1 words$word # real)) M) (\ varstup .  let (tup__0, tup__1, tup__2) = varstup in
   let type2 = tup__0 in
   let sign2 = tup__1 in
   let value2_name = tup__2 in sail2_state_monad$bindS
   (undefined_bitvector ((int_of_num (words$word_len op1)))  : ( 'N words$word) M) (\ (result : 'N bits) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (done : bool) .  sail2_state_monad$bindS
   (FPProcessNaNs type1 type2 op1 op2 fpcr  : ((bool #  'N words$word)) M) (\ varstup .  let (tup__0, tup__1) = varstup in
   let done = tup__0 in
   let result = tup__1 in sail2_state_monad$bindS
   (undefined_real () ) (\ (value_name : real) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (sign : 1 bits) .  sail2_state_monad$bindS
   (undefined_FPType () ) (\ (typ : FPType) . 
   if ((~ done)) then
     let ((sign : 1 bits), (typ : FPType), (value_name : real)) =
       (if ((value1_name > value2_name)) then
         let (tup__0, tup__1, tup__2) = (type1, sign1, value1_name) in
         let (typ : FPType) = tup__0 in
         let (sign : 1 bits) = tup__1 in
         let (value_name : real) = tup__2 in
         (sign, typ, value_name)
       else
         let (tup__0, tup__1, tup__2) = (type2, sign2, value2_name) in
         let (typ : FPType) = tup__0 in
         let (sign : 1 bits) = tup__1 in
         let (value_name : real) = tup__2 in
         (sign, typ, value_name)) in
     if (((typ = FPType_Infinity))) then (FPInfinity ((int_of_num (words$word_len op1))) sign  : ( 'N words$word) M)
     else if (((typ = FPType_Zero))) then
       let sign = ((and_vec sign1 sign2  :  1 words$word)) in
       (FPZero ((int_of_num (words$word_len op1))) sign  : ( 'N words$word) M)
     else (FPRound__1 ((int_of_num (words$word_len op1))) value_name fpcr  : ( 'N words$word) M)
   else sail2_state_monad$returnS result))))))))))))))))`;


(*val FPMaxNum : forall 'N . Size 'N => mword 'N -> mword 'N -> mword ty32 -> M (mword 'N)*)

val _ = Define `
 ((FPMaxNum:'N words$word -> 'N words$word ->(32)words$word ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) op1__arg op2__arg fpcr=
    (let op1 = op1__arg in
   let op2 = op2__arg in sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((((((int_of_num (words$word_len op1))) = (( 16 : int):ii)))) \/ ((((((((int_of_num (words$word_len op1))) = (( 32 : int):ii)))) \/ (((((int_of_num (words$word_len op1))) = (( 64 : int):ii)))))))))) "((N == 16) || ((N == 32) || (N == 64)))")
   (undefined_real () )) (\ (anon20 : real) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (anon10 : 1 bits) .  sail2_state_monad$bindS
   (undefined_FPType () ) (\ (type1 : FPType) .  sail2_state_monad$bindS
   (FPUnpack op1 fpcr  : ((FPType #  1 words$word # real)) M) (\ varstup .  let (tup__0, tup__1, tup__2) = varstup in
   let type1 = tup__0 in
   let anon10 = tup__1 in
   let anon20 = tup__2 in sail2_state_monad$bindS
   (undefined_real () ) (\ (anon40 : real) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (anon30 : 1 bits) .  sail2_state_monad$bindS
   (undefined_FPType () ) (\ (type2 : FPType) .  sail2_state_monad$bindS
   (FPUnpack op2 fpcr  : ((FPType #  1 words$word # real)) M) (\ varstup .  let (tup__0, tup__1, tup__2) = varstup in
   let type2 = tup__0 in
   let anon30 = tup__1 in
   let anon40 = tup__2 in sail2_state_monad$bindS
   (if ((((((type1 = FPType_QNaN))) /\ (((type2 <> FPType_QNaN)))))) then sail2_state_monad$bindS
      (FPInfinity ((int_of_num (words$word_len op1))) (vec_of_bits [B1]  :  1 words$word)  : ( 'N words$word) M) (\ (w__0 :
         'N words$word) . 
      let (op1 :  'N words$word) = w__0 in
      sail2_state_monad$returnS (op1, op2))
    else sail2_state_monad$bindS
      (if ((((((type1 <> FPType_QNaN))) /\ (((type2 = FPType_QNaN)))))) then
         (FPInfinity ((int_of_num (words$word_len op1))) (vec_of_bits [B1]  :  1 words$word)  : ( 'N words$word) M)
       else sail2_state_monad$returnS op2) (\ (op2 :  'N words$word) . 
      sail2_state_monad$returnS (op1, op2))) (\ varstup .  let ((op1 :  'N words$word), (op2 :  'N words$word)) = varstup in
   (FPMax op1 op2 fpcr  : ( 'N words$word) M))))))))))))`;


(*val FPDiv : forall 'N . Size 'N => mword 'N -> mword 'N -> mword ty32 -> M (mword 'N)*)

val _ = Define `
 ((FPDiv:'N words$word -> 'N words$word ->(32)words$word ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) op1 op2 fpcr=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((((((int_of_num (words$word_len op1))) = (( 16 : int):ii)))) \/ ((((((((int_of_num (words$word_len op1))) = (( 32 : int):ii)))) \/ (((((int_of_num (words$word_len op1))) = (( 64 : int):ii)))))))))) "((N == 16) || ((N == 32) || (N == 64)))")
   (undefined_real () )) (\ (value1_name : real) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (sign1 : 1 bits) .  sail2_state_monad$bindS
   (undefined_FPType () ) (\ (type1 : FPType) .  sail2_state_monad$bindS
   (FPUnpack op1 fpcr  : ((FPType #  1 words$word # real)) M) (\ varstup .  let (tup__0, tup__1, tup__2) = varstup in
   let type1 = tup__0 in
   let sign1 = tup__1 in
   let value1_name = tup__2 in sail2_state_monad$bindS
   (undefined_real () ) (\ (value2_name : real) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (sign2 : 1 bits) .  sail2_state_monad$bindS
   (undefined_FPType () ) (\ (type2 : FPType) .  sail2_state_monad$bindS
   (FPUnpack op2 fpcr  : ((FPType #  1 words$word # real)) M) (\ varstup .  let (tup__0, tup__1, tup__2) = varstup in
   let type2 = tup__0 in
   let sign2 = tup__1 in
   let value2_name = tup__2 in sail2_state_monad$bindS
   (undefined_bitvector ((int_of_num (words$word_len op1)))  : ( 'N words$word) M) (\ (result : 'N bits) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (done : bool) .  sail2_state_monad$bindS
   (FPProcessNaNs type1 type2 op1 op2 fpcr  : ((bool #  'N words$word)) M) (\ varstup .  let (tup__0, tup__1) = varstup in
   let done = tup__0 in
   let result = tup__1 in sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (zero2 : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (zero1 : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (inf2 : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (inf1 : bool) . 
   if ((~ done)) then
     let inf1 = (type1 = FPType_Infinity) in
     let inf2 = (type2 = FPType_Infinity) in
     let zero1 = (type1 = FPType_Zero) in
     let zero2 = (type2 = FPType_Zero) in
     if ((((((inf1 /\ inf2))) \/ (((zero1 /\ zero2)))))) then sail2_state_monad$bindS
       (FPDefaultNaN ((int_of_num (words$word_len op1))) ()   : ( 'N words$word) M) (\ (w__0 : 'N bits) . 
       let result = w__0 in sail2_state_monad$seqS
       (FPProcessException FPExc_InvalidOp fpcr) (sail2_state_monad$returnS result))
     else if (((inf1 \/ zero2))) then sail2_state_monad$bindS
       (FPInfinity ((int_of_num (words$word_len op1))) ((xor_vec sign1 sign2  :  1 words$word))  : ( 'N words$word) M) (\ (w__1 : 'N
         bits) . 
       let result = w__1 in sail2_state_monad$seqS
       (if ((~ inf1)) then FPProcessException FPExc_DivideByZero fpcr
        else sail2_state_monad$returnS () )
       (sail2_state_monad$returnS result))
     else if (((zero1 \/ inf2))) then
       (FPZero ((int_of_num (words$word_len op1))) ((xor_vec sign1 sign2  :  1 words$word))  : ( 'N words$word) M)
     else (FPRound__1 ((int_of_num (words$word_len op1))) ((value1_name / value2_name)) fpcr  : ( 'N words$word) M)
   else sail2_state_monad$returnS result)))))))))))))))))`;


(*val FPAdd : forall 'N . Size 'N => mword 'N -> mword 'N -> mword ty32 -> M (mword 'N)*)

val _ = Define `
 ((FPAdd:'N words$word -> 'N words$word ->(32)words$word ->(regstate)sail2_state_monad$sequential_state ->((('N words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) op1 op2 fpcr=  (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((((((int_of_num (words$word_len op1))) = (( 16 : int):ii)))) \/ ((((((((int_of_num (words$word_len op1))) = (( 32 : int):ii)))) \/ (((((int_of_num (words$word_len op1))) = (( 64 : int):ii)))))))))) "((N == 16) || ((N == 32) || (N == 64)))")
   (let (rounding : FPRounding) = (FPRoundingMode fpcr) in sail2_state_monad$bindS
   (undefined_real () ) (\ (value1_name : real) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (sign1 : 1 bits) .  sail2_state_monad$bindS
   (undefined_FPType () ) (\ (type1 : FPType) .  sail2_state_monad$bindS
   (FPUnpack op1 fpcr  : ((FPType #  1 words$word # real)) M) (\ varstup .  let (tup__0, tup__1, tup__2) = varstup in
   let type1 = tup__0 in
   let sign1 = tup__1 in
   let value1_name = tup__2 in sail2_state_monad$bindS
   (undefined_real () ) (\ (value2_name : real) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (sign2 : 1 bits) .  sail2_state_monad$bindS
   (undefined_FPType () ) (\ (type2 : FPType) .  sail2_state_monad$bindS
   (FPUnpack op2 fpcr  : ((FPType #  1 words$word # real)) M) (\ varstup .  let (tup__0, tup__1, tup__2) = varstup in
   let type2 = tup__0 in
   let sign2 = tup__1 in
   let value2_name = tup__2 in sail2_state_monad$bindS
   (undefined_bitvector ((int_of_num (words$word_len op1)))  : ( 'N words$word) M) (\ (result : 'N bits) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (done : bool) .  sail2_state_monad$bindS
   (FPProcessNaNs type1 type2 op1 op2 fpcr  : ((bool #  'N words$word)) M) (\ varstup .  let (tup__0, tup__1) = varstup in
   let done = tup__0 in
   let result = tup__1 in sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (result_sign : 1 bits) .  sail2_state_monad$bindS
   (undefined_real () ) (\ (result_value : real) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (zero2 : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (zero1 : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (inf2 : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (inf1 : bool) . 
   if ((~ done)) then
     let inf1 = (type1 = FPType_Infinity) in
     let inf2 = (type2 = FPType_Infinity) in
     let zero1 = (type1 = FPType_Zero) in
     let zero2 = (type2 = FPType_Zero) in
     if ((((((inf1 /\ inf2))) /\ (((sign1 = ((not_vec sign2  :  1 words$word)))))))) then sail2_state_monad$bindS
       (FPDefaultNaN ((int_of_num (words$word_len op1))) ()   : ( 'N words$word) M) (\ (w__0 : 'N bits) . 
       let result = w__0 in sail2_state_monad$seqS
       (FPProcessException FPExc_InvalidOp fpcr) (sail2_state_monad$returnS result))
     else if ((((((inf1 /\ (((sign1 = (vec_of_bits [B0]  :  1 words$word))))))) \/ (((inf2 /\ (((sign2 = (vec_of_bits [B0]  :  1 words$word)))))))))) then
       (FPInfinity ((int_of_num (words$word_len op1))) (vec_of_bits [B0]  :  1 words$word)  : ( 'N words$word) M)
     else if ((((((inf1 /\ (((sign1 = (vec_of_bits [B1]  :  1 words$word))))))) \/ (((inf2 /\ (((sign2 = (vec_of_bits [B1]  :  1 words$word)))))))))) then
       (FPInfinity ((int_of_num (words$word_len op1))) (vec_of_bits [B1]  :  1 words$word)  : ( 'N words$word) M)
     else if ((((((zero1 /\ zero2))) /\ (((sign1 = sign2)))))) then
       (FPZero ((int_of_num (words$word_len op1))) sign1  : ( 'N words$word) M)
     else
       let result_value = (value1_name + value2_name) in
       if (((result_value = (realFromFrac(( 0 : int))(( 10 : int)))))) then
         let result_sign =
           (if (((rounding = FPRounding_NEGINF))) then (vec_of_bits [B1]  :  1 words$word)
           else (vec_of_bits [B0]  :  1 words$word)) in
         (FPZero ((int_of_num (words$word_len op1))) result_sign  : ( 'N words$word) M)
       else (FPRound__0 ((int_of_num (words$word_len op1))) result_value fpcr rounding  : ( 'N words$word) M)
   else sail2_state_monad$returnS result))))))))))))))))))))`;


(*val ExternalSecureInvasiveDebugEnabled : unit -> M bool*)

val _ = Define `
 ((ExternalSecureInvasiveDebugEnabled:unit ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (sail2_state$and_boolS (sail2_state_monad$returnS ((~ ((HaveEL EL3)))))
     ( sail2_state_monad$bindS(IsSecure () ) (\ (w__0 : bool) .  sail2_state_monad$returnS ((~ w__0))))) (\ (w__1 : bool) . 
   if w__1 then sail2_state_monad$returnS F
   else
     sail2_state$and_boolS ((ExternalInvasiveDebugEnabled () ))
       ( sail2_state_monad$bindS(sail2_state_monad$read_regS SPIDEN_ref) (\ (w__3 : signal) .  sail2_state_monad$returnS (((w__3 = HIGH))))))))`;


(*val ExternalDebugInterruptsDisabled : mword ty2 -> M bool*)

val _ = Define `
 ((ExternalDebugInterruptsDisabled:(2)words$word ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) target=  (sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (int_dis : bool) . 
   let pat_0 = target in
   if (((pat_0 = EL3))) then
     sail2_state$and_boolS
       ( sail2_state_monad$bindS(sail2_state_monad$read_regS EDSCR_ref  : ( 32 words$word) M) (\ (w__0 : 32 bits) . 
        sail2_state_monad$returnS (((((slice w__0 (( 22 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B1]  :  2 words$word)))))) ((ExternalSecureInvasiveDebugEnabled () ))
   else if (((pat_0 = EL2))) then
     sail2_state$and_boolS
       ( sail2_state_monad$bindS(sail2_state_monad$read_regS EDSCR_ref  : ( 32 words$word) M) (\ (w__3 : 32 bits) . 
        sail2_state_monad$returnS (((((and_vec ((slice w__3 (( 22 : int):ii) (( 2 : int):ii)  :  2 words$word))
                       (vec_of_bits [B1;B0]  :  2 words$word)
                      :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word))))))
       ((ExternalInvasiveDebugEnabled () ))
   else sail2_state_monad$bindS
     (IsSecure () ) (\ (w__6 : bool) . 
     if w__6 then
       sail2_state$and_boolS
         ( sail2_state_monad$bindS(sail2_state_monad$read_regS EDSCR_ref  : ( 32 words$word) M) (\ (w__7 : 32 bits) . 
          sail2_state_monad$returnS (((((and_vec ((slice w__7 (( 22 : int):ii) (( 2 : int):ii)  :  2 words$word))
                         (vec_of_bits [B1;B0]  :  2 words$word)
                        :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word))))))
         ((ExternalSecureInvasiveDebugEnabled () ))
     else
       sail2_state$and_boolS
         ( sail2_state_monad$bindS(sail2_state_monad$read_regS EDSCR_ref  : ( 32 words$word) M) (\ (w__10 : 32 bits) . 
          sail2_state_monad$returnS (((((slice w__10 (( 22 : int):ii) (( 2 : int):ii)  :  2 words$word)) <> (vec_of_bits [B0;B0]  :  2 words$word)))))) ((ExternalInvasiveDebugEnabled () ))))))`;


(*val ELStateUsingAArch32K : mword ty2 -> bool -> M (bool * bool)*)

val _ = Define `
 ((ELStateUsingAArch32K:(2)words$word -> bool ->(regstate)sail2_state_monad$sequential_state ->(((bool#bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) el secure=  (sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (aarch32 : bool) . 
   let (known : bool) = T in sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (aarch32_at_el1 : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (aarch32_below_el3 : bool) .  sail2_state_monad$bindS
   (if ((~ ((HaveAArch32EL el)))) then
      let (aarch32 : bool) = F in
      sail2_state_monad$returnS (aarch32, known)
    else if ((HighestELUsingAArch32 () )) then
      let (aarch32 : bool) = T in
      sail2_state_monad$returnS (aarch32, known)
    else sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__0 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__0 (( 10 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__1 : bool) . 
      let aarch32_below_el3 = w__1 in sail2_state_monad$bindS
      (sail2_state$or_boolS (sail2_state_monad$returnS aarch32_below_el3)
        (sail2_state$and_boolS
           (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveEL EL2)) /\ ((~ secure))))))
              ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__2 : 64 bits) . 
               sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__2 (( 31 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))))))
           ( sail2_state_monad$bindS(sail2_state$and_boolS
              (sail2_state$and_boolS
                 ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__4 : 64 bits) . 
                  sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__4 (( 34 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))
                 ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__5 : 64 bits) . 
                  sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__5 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (sail2_state_monad$returnS ((HaveVirtHostExt () )))) (\ (w__7 :
              bool) . 
            sail2_state_monad$returnS ((~ w__7)))))) (\ (w__9 : bool) . 
      let aarch32_at_el1 = w__9 in
      if ((((((el = EL0))) /\ ((~ aarch32_at_el1))))) then sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__10 : ProcState) . 
        if (((w__10.ProcState_EL = EL0))) then sail2_state_monad$bindS
          (sail2_state_monad$read_regS PSTATE_ref) (\ (w__11 : ProcState) . 
          let (aarch32 : bool) = (w__11.ProcState_nRW = (vec_of_bits [B1]  :  1 words$word)) in
          sail2_state_monad$returnS (aarch32, known))
        else
          let (known : bool) = F in
          sail2_state_monad$returnS (aarch32, known))
      else
        let (aarch32 : bool) =
          ((((aarch32_below_el3 /\ (((el <> EL3)))))) \/ (((aarch32_at_el1 /\ ((((((el = EL1))) \/ (((el = EL0)))))))))) in
        sail2_state_monad$returnS (aarch32, known)))) (\ varstup .  let ((aarch32 : bool), (known : bool)) = varstup in sail2_state_monad$bindS
   (if ((~ known)) then sail2_state_monad$undefined_boolS () 
    else sail2_state_monad$returnS aarch32) (\ (aarch32 : bool) . 
   sail2_state_monad$returnS (known, aarch32))))))))`;


(*val ELUsingAArch32K : mword ty2 -> M (bool * bool)*)

val _ = Define `
 ((ELUsingAArch32K:(2)words$word ->(regstate)sail2_state_monad$sequential_state ->(((bool#bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) el=  (sail2_state_monad$bindS (IsSecureBelowEL3 () ) (\ (w__0 : bool) .  ELStateUsingAArch32K el w__0)))`;


(*val ELStateUsingAArch32 : mword ty2 -> bool -> M bool*)

val _ = Define `
 ((ELStateUsingAArch32:(2)words$word -> bool ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) el secure=  (sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (aarch32 : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (known : bool) .  sail2_state_monad$bindS
   (ELStateUsingAArch32K el secure) (\ varstup .  let (tup__0, tup__1) = varstup in
   let known = tup__0 in
   let aarch32 = tup__1 in sail2_state_monad$seqS
   (sail2_state_monad$assert_expS known "known") (sail2_state_monad$returnS aarch32))))))`;


(*val ELUsingAArch32 : mword ty2 -> M bool*)

val _ = Define `
 ((ELUsingAArch32:(2)words$word ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) el=  (sail2_state_monad$bindS (IsSecureBelowEL3 () ) (\ (w__0 : bool) .  ELStateUsingAArch32 el w__0)))`;


(*val UpdateEDSCRFields : unit -> M unit*)

val _ = Define `
 ((UpdateEDSCRFields:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (Halted () ) (\ (w__0 : bool) . 
   if ((~ w__0)) then sail2_state_monad$bindS
     (sail2_state_monad$read_regS EDSCR_ref  : ( 32 words$word) M) (\ (w__1 :  32 words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS
       EDSCR_ref
       ((set_slice (( 32 : int):ii) (( 2 : int):ii) w__1 (( 8 : int):ii) (vec_of_bits [B0;B0]  :  2 words$word)  :  32 words$word)))
     (sail2_state_monad$read_regS EDSCR_ref  : ( 32 words$word) M)) (\ (w__2 :  32 words$word) .  sail2_state_monad$bindS
     (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__3 :  1 words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS EDSCR_ref ((set_slice (( 32 : int):ii) (( 1 : int):ii) w__2 (( 18 : int):ii) w__3  :  32 words$word)))
     (sail2_state_monad$read_regS EDSCR_ref  : ( 32 words$word) M)) (\ (w__4 :  32 words$word) . 
     sail2_state_monad$write_regS
       EDSCR_ref
       ((set_slice (( 32 : int):ii) (( 4 : int):ii) w__4 (( 10 : int):ii) (vec_of_bits [B1;B1;B1;B1]  :  4 words$word)
          :  32 words$word))))))
   else sail2_state_monad$bindS
     (sail2_state_monad$read_regS EDSCR_ref  : ( 32 words$word) M) (\ (w__5 :  32 words$word) .  sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__6 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS EDSCR_ref ((set_slice (( 32 : int):ii) (( 2 : int):ii) w__5 (( 8 : int):ii) w__6.ProcState_EL  :  32 words$word)))
     (sail2_state_monad$read_regS EDSCR_ref  : ( 32 words$word) M)) (\ (w__7 :  32 words$word) .  sail2_state_monad$bindS
     (IsSecure () ) (\ (w__8 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS
       EDSCR_ref
       ((set_slice (( 32 : int):ii) (( 1 : int):ii) w__7 (( 18 : int):ii)
           (if w__8 then (vec_of_bits [B0]  :  1 words$word)
            else (vec_of_bits [B1]  :  1 words$word))
          :  32 words$word)))
     (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M)) (\ (RW : 4 bits) .  sail2_state_monad$bindS
     (ELUsingAArch32 EL1) (\ (w__9 : bool) . 
     let (RW : 4 bits) =
       ((set_slice (( 4 : int):ii) (( 1 : int):ii) RW (( 1 : int):ii)
          (if w__9 then (vec_of_bits [B0]  :  1 words$word)
           else (vec_of_bits [B1]  :  1 words$word))
         :  4 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__10 : ProcState) .  sail2_state_monad$bindS
     (if (((w__10.ProcState_EL <> EL0))) then
        let (RW : 4 bits) =
          ((set_slice (( 4 : int):ii) (( 1 : int):ii) RW (( 0 : int):ii) (vec_of_bits [access_vec_dec RW (( 1 : int):ii)]  :  1 words$word)
            :  4 words$word)) in
        sail2_state_monad$returnS RW
      else sail2_state_monad$bindS
        (UsingAArch32 () ) (\ (w__11 : bool) . 
        let (RW : 4 bits) =
          ((set_slice (( 4 : int):ii) (( 1 : int):ii) RW (( 0 : int):ii)
             (if w__11 then (vec_of_bits [B0]  :  1 words$word)
              else (vec_of_bits [B1]  :  1 words$word))
            :  4 words$word)) in
        sail2_state_monad$returnS RW)) (\ (RW : 4 bits) .  sail2_state_monad$bindS
     (sail2_state$or_boolS (sail2_state_monad$returnS ((~ ((HaveEL EL2)))))
       (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
          ( sail2_state_monad$bindS(aget_SCR_GEN ()   : ( 32 words$word) M) (\ (w__12 :  32 words$word) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__12 (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))))))) (\ (w__14 : bool) .  sail2_state_monad$bindS
     (if w__14 then
        let (RW : 4 bits) =
          ((set_slice (( 4 : int):ii) (( 1 : int):ii) RW (( 2 : int):ii) (vec_of_bits [access_vec_dec RW (( 1 : int):ii)]  :  1 words$word)
            :  4 words$word)) in
        sail2_state_monad$returnS RW
      else sail2_state_monad$bindS
        (ELUsingAArch32 EL2) (\ (w__15 : bool) . 
        let (RW : 4 bits) =
          ((set_slice (( 4 : int):ii) (( 1 : int):ii) RW (( 2 : int):ii)
             (if w__15 then (vec_of_bits [B0]  :  1 words$word)
              else (vec_of_bits [B1]  :  1 words$word))
            :  4 words$word)) in
        sail2_state_monad$returnS RW)) (\ (RW : 4 bits) .  sail2_state_monad$bindS
     (if ((~ ((HaveEL EL3)))) then
        let (RW : 4 bits) =
          ((set_slice (( 4 : int):ii) (( 1 : int):ii) RW (( 3 : int):ii) (vec_of_bits [access_vec_dec RW (( 2 : int):ii)]  :  1 words$word)
            :  4 words$word)) in
        sail2_state_monad$returnS RW
      else sail2_state_monad$bindS
        (ELUsingAArch32 EL3) (\ (w__16 : bool) . 
        let (RW : 4 bits) =
          ((set_slice (( 4 : int):ii) (( 1 : int):ii) RW (( 3 : int):ii)
             (if w__16 then (vec_of_bits [B0]  :  1 words$word)
              else (vec_of_bits [B1]  :  1 words$word))
            :  4 words$word)) in
        sail2_state_monad$returnS RW)) (\ (RW : 4 bits) .  sail2_state_monad$bindS
     (if ((((vec_of_bits [access_vec_dec RW (( 3 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))) then sail2_state_monad$bindS
        (undefined_bitvector (( 3 : int):ii)  : ( 3 words$word) M) (\ (w__17 :  3 words$word) . 
        let (RW : 4 bits) = ((set_slice (( 4 : int):ii) (( 3 : int):ii) RW (( 0 : int):ii) w__17  :  4 words$word)) in
        sail2_state_monad$returnS RW)
      else if ((((vec_of_bits [access_vec_dec RW (( 2 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))) then sail2_state_monad$bindS
        (undefined_bitvector (( 2 : int):ii)  : ( 2 words$word) M) (\ (w__18 :  2 words$word) . 
        let (RW : 4 bits) = ((set_slice (( 4 : int):ii) (( 2 : int):ii) RW (( 0 : int):ii) w__18  :  4 words$word)) in
        sail2_state_monad$returnS RW)
      else if ((((vec_of_bits [access_vec_dec RW (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))) then sail2_state_monad$bindS
        (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__19 :  1 words$word) . 
        let (RW : 4 bits) = ((set_slice (( 4 : int):ii) (( 1 : int):ii) RW (( 0 : int):ii) w__19  :  4 words$word)) in
        sail2_state_monad$returnS RW)
      else sail2_state_monad$returnS RW) (\ (RW : 4 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$read_regS EDSCR_ref  : ( 32 words$word) M) (\ (w__20 :  32 words$word) . 
     sail2_state_monad$write_regS EDSCR_ref ((set_slice (( 32 : int):ii) (( 4 : int):ii) w__20 (( 10 : int):ii) RW  :  32 words$word))))))))))))))))))`;


(*val Halt : mword ty6 -> M unit*)

val _ = Define `
 ((Halt:(6)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) reason=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (CTI_SignalEvent CrossTriggerIn_CrossHalt)
   (UsingAArch32 () )) (\ (w__0 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (if w__0 then sail2_state_monad$bindS
      (ThisInstrAddr (( 32 : int):ii) ()   : ( 32 words$word) M) (\ (w__1 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS DLR_ref w__1)
      (GetPSRFromPSTATE ()   : ( 32 words$word) M)) (\ (w__2 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS DSPSR_ref w__2)
      (sail2_state_monad$read_regS DSPSR_ref  : ( 32 words$word) M)) (\ (w__3 :  32 words$word) .  sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__4 : ProcState) . 
      sail2_state_monad$write_regS
        DSPSR_ref
        ((update_subrange_vec_dec w__3 (( 21 : int):ii) (( 21 : int):ii) w__4.ProcState_SS  :  32 words$word))))))
    else sail2_state_monad$bindS
      (ThisInstrAddr (( 64 : int):ii) ()   : ( 64 words$word) M) (\ (w__5 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS DLR_EL0_ref w__5)
      (GetPSRFromPSTATE ()   : ( 32 words$word) M)) (\ (w__6 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS DSPSR_EL0_ref w__6)
      (sail2_state_monad$read_regS DSPSR_EL0_ref  : ( 32 words$word) M)) (\ (w__7 :  32 words$word) .  sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__8 : ProcState) . 
      sail2_state_monad$write_regS
        DSPSR_EL0_ref
        ((update_subrange_vec_dec w__7 (( 21 : int):ii) (( 21 : int):ii) w__8.ProcState_SS  :  32 words$word)))))))
   (sail2_state_monad$read_regS EDSCR_ref  : ( 32 words$word) M)) (\ (w__9 :  32 words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS
     EDSCR_ref
     ((update_subrange_vec_dec w__9 (( 24 : int):ii) (( 24 : int):ii) (vec_of_bits [B1]  :  1 words$word)  :  32 words$word)))
   (sail2_state_monad$read_regS EDSCR_ref  : ( 32 words$word) M)) (\ (w__10 :  32 words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS
     EDSCR_ref
     ((update_subrange_vec_dec w__10 (( 28 : int):ii) (( 28 : int):ii) (vec_of_bits [B0]  :  1 words$word)  :  32 words$word)))
   (IsSecure () )) (\ (w__11 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (if w__11 then sail2_state_monad$bindS
      (sail2_state_monad$read_regS EDSCR_ref  : ( 32 words$word) M) (\ (w__12 :  32 words$word) . 
      sail2_state_monad$write_regS
        EDSCR_ref
        ((update_subrange_vec_dec w__12 (( 16 : int):ii) (( 16 : int):ii) (vec_of_bits [B0]  :  1 words$word)
           :  32 words$word)))
    else if ((HaveEL EL3)) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS EDSCR_ref  : ( 32 words$word) M) (\ (w__13 :  32 words$word) .  sail2_state_monad$bindS
      (ExternalSecureInvasiveDebugEnabled () ) (\ (w__14 : bool) . 
      sail2_state_monad$write_regS
        EDSCR_ref
        ((update_subrange_vec_dec w__13 (( 16 : int):ii) (( 16 : int):ii)
            (if w__14 then (vec_of_bits [B0]  :  1 words$word)
             else (vec_of_bits [B1]  :  1 words$word))
           :  32 words$word))))
    else sail2_state_monad$bindS
      (sail2_state_monad$read_regS EDSCR_ref  : ( 32 words$word) M) (\ (w__15 : 32 bits) . 
      sail2_state_monad$assert_expS ((((vec_of_bits [access_vec_dec w__15 (( 16 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) "((EDSCR).SDD == '1')"))
   (sail2_state_monad$read_regS EDSCR_ref  : ( 32 words$word) M)) (\ (w__16 :  32 words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS
     EDSCR_ref
     ((update_subrange_vec_dec w__16 (( 20 : int):ii) (( 20 : int):ii) (vec_of_bits [B0]  :  1 words$word)  :  32 words$word)))
   (UsingAArch32 () )) (\ (w__17 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (if w__17 then sail2_state_monad$bindS
      (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (w__18 : 4 bits) . 
      let split_vec = w__18 in
      let (tup__0, tup__1, tup__2, tup__3) =
        ((subrange_vec_dec split_vec (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__19 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__19 with<| ProcState_SS := tup__0|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__20 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__20 with<| ProcState_A := tup__1|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__21 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__21 with<| ProcState_I := tup__2|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__22 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__22 with<| ProcState_F := tup__3|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__23 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS
        PSTATE_ref
        (w__23 with<| ProcState_IT := ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0]  :  8 words$word))|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__24 : ProcState) . 
      sail2_state_monad$write_regS PSTATE_ref (w__24 with<| ProcState_T := ((vec_of_bits [B1]  :  1 words$word))|>))))))))
    else sail2_state_monad$bindS
      (undefined_bitvector (( 5 : int):ii)  : ( 5 words$word) M) (\ (w__25 : 5 bits) . 
      let split_vec = w__25 in
      let (tup__0, tup__1, tup__2, tup__3, tup__4) =
        ((subrange_vec_dec split_vec (( 4 : int):ii) (( 4 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__26 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__26 with<| ProcState_SS := tup__0|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__27 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__27 with<| ProcState_D := tup__1|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__28 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__28 with<| ProcState_A := tup__2|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__29 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__29 with<| ProcState_I := tup__3|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__30 : ProcState) . 
      sail2_state_monad$write_regS PSTATE_ref (w__30 with<| ProcState_F := tup__4|>))))))))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__31 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__31 with<| ProcState_IL := ((vec_of_bits [B0]  :  1 words$word))|>))
   (StopInstructionPrefetchAndEnableITR () ))
   (sail2_state_monad$read_regS EDSCR_ref  : ( 32 words$word) M)) (\ (w__32 :  32 words$word) .  sail2_state_monad$seqS
   (sail2_state_monad$write_regS EDSCR_ref ((update_subrange_vec_dec w__32 (( 5 : int):ii) (( 0 : int):ii) reason  :  32 words$word)))
   (UpdateEDSCRFields () )))))))))))`;


(*val aarch64_system_exceptions_debug_halt : unit -> M unit*)

val _ = Define `
 ((aarch64_system_exceptions_debug_halt:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (Halt DebugHalt_HaltInstruction))`;


(*val S2CacheDisabled : AccType -> M bool*)

val _ = Define `
 ((S2CacheDisabled:AccType ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) acctype=  (sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (disable : 1 bits) .  sail2_state_monad$bindS
   (ELUsingAArch32 EL2) (\ (w__0 : bool) .  sail2_state_monad$bindS
   (if w__0 then
      if (((acctype = AccType_IFETCH))) then sail2_state_monad$bindS
        (sail2_state_monad$read_regS HCR2_ref  : ( 32 words$word) M) (\ (w__1 : 32 bits) . 
        sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__1 (( 1 : int):ii)]  :  1 words$word))
      else sail2_state_monad$bindS
        (sail2_state_monad$read_regS HCR2_ref  : ( 32 words$word) M) (\ (w__2 : 32 bits) . 
        sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__2 (( 0 : int):ii)]  :  1 words$word))
    else if (((acctype = AccType_IFETCH))) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__4 : 64 bits) . 
      sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__4 (( 33 : int):ii)]  :  1 words$word))
    else sail2_state_monad$bindS
      (sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__5 : 64 bits) . 
      sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__5 (( 32 : int):ii)]  :  1 words$word))) (\ (disable : 1 bits) . 
   sail2_state_monad$returnS (((disable = (vec_of_bits [B1]  :  1 words$word)))))))))`;


(*val S2ConvertAttrsHints : mword ty2 -> AccType -> M MemAttrHints*)

val _ = Define `
 ((S2ConvertAttrsHints:(2)words$word -> AccType ->(regstate)sail2_state_monad$sequential_state ->(((MemAttrHints),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) attr acctype=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((~ ((IsZero attr)))) "!(IsZero(attr))")
   (undefined_MemAttrHints () )) (\ (result : MemAttrHints) .  sail2_state_monad$bindS
   (S2CacheDisabled acctype) (\ (w__0 : bool) . 
   let (result : MemAttrHints) =
     (if w__0 then
       let (result : MemAttrHints) = ((result with<| MemAttrHints_attrs := MemAttr_NC|>)) in
       (result with<| MemAttrHints_hints := MemHint_No|>)
     else
       let b__0 = attr in
       if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then
         let (result : MemAttrHints) = ((result with<| MemAttrHints_attrs := MemAttr_NC|>)) in
         (result with<| MemAttrHints_hints := MemHint_No|>)
       else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then
         let (result : MemAttrHints) = ((result with<| MemAttrHints_attrs := MemAttr_WT|>)) in
         (result with<| MemAttrHints_hints := MemHint_RWA|>)
       else
         let (result : MemAttrHints) = ((result with<| MemAttrHints_attrs := MemAttr_WB|>)) in
         (result with<| MemAttrHints_hints := MemHint_RWA|>)) in
   let (result : MemAttrHints) = ((result with<| MemAttrHints_transient := F|>)) in
   sail2_state_monad$returnS result))))`;


(*val S2AttrDecode : mword ty2 -> mword ty4 -> AccType -> M MemoryAttributes*)

val _ = Define `
 ((S2AttrDecode:(2)words$word ->(4)words$word -> AccType ->(regstate)sail2_state_monad$sequential_state ->(((MemoryAttributes),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) SH attr acctype=  (sail2_state_monad$bindS
   (undefined_MemoryAttributes () ) (\ (memattrs : MemoryAttributes) .  sail2_state_monad$bindS
   (if (((((slice attr (( 2 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B0]  :  2 words$word)))) then
      let (memattrs : MemoryAttributes) = ((memattrs with<| MemoryAttributes_typ := MemType_Device|>)) in
      let b__0 = ((slice attr (( 0 : int):ii) (( 2 : int):ii)  :  2 words$word)) in
      let (memattrs : MemoryAttributes) =
        (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then
          (memattrs with<| MemoryAttributes_device := DeviceType_nGnRnE|>)
        else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then
          (memattrs with<| MemoryAttributes_device := DeviceType_nGnRE|>)
        else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then
          (memattrs with<| MemoryAttributes_device := DeviceType_nGRE|>)
        else (memattrs with<| MemoryAttributes_device := DeviceType_GRE|>)) in
      sail2_state_monad$returnS memattrs
    else if (((((slice attr (( 0 : int):ii) (( 2 : int):ii)  :  2 words$word)) <> (vec_of_bits [B0;B0]  :  2 words$word))))
    then
      let memattrs = ((memattrs with<| MemoryAttributes_typ := MemType_Normal|>)) in sail2_state_monad$bindS
      (S2ConvertAttrsHints ((slice attr (( 2 : int):ii) (( 2 : int):ii)  :  2 words$word)) acctype) (\ (w__0 :
        MemAttrHints) . 
      let memattrs = ((memattrs with<| MemoryAttributes_outer := w__0|>)) in sail2_state_monad$bindS
      (S2ConvertAttrsHints ((slice attr (( 0 : int):ii) (( 2 : int):ii)  :  2 words$word)) acctype) (\ (w__1 :
        MemAttrHints) . 
      let (memattrs : MemoryAttributes) = ((memattrs with<| MemoryAttributes_inner := w__1|>)) in
      let (memattrs : MemoryAttributes) =
        ((memattrs with<|
          MemoryAttributes_shareable :=
            ((((vec_of_bits [access_vec_dec SH (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))|>)) in
      let (memattrs : MemoryAttributes) =
        ((memattrs with<|
          MemoryAttributes_outershareable := (((SH = (vec_of_bits [B1;B0]  :  2 words$word))))|>)) in
      sail2_state_monad$returnS memattrs))
    else undefined_MemoryAttributes () ) (\ (memattrs : MemoryAttributes) . 
   MemAttrDefaults memattrs))))`;


(*val ELIsInHost : mword ty2 -> M bool*)

val _ = Define `
 ((ELIsInHost:(2)words$word ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) el=
    (sail2_state$and_boolS
     (sail2_state$and_boolS
        (sail2_state$and_boolS
           (sail2_state$and_boolS ( sail2_state_monad$bindS(IsSecureBelowEL3 () ) (\ (w__0 : bool) .  sail2_state_monad$returnS ((~ w__0))))
              (sail2_state_monad$returnS ((HaveVirtHostExt () ))))
           ( sail2_state_monad$bindS(ELUsingAArch32 EL2) (\ (w__2 : bool) .  sail2_state_monad$returnS ((~ w__2)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__4 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__4 (( 34 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
     (sail2_state$or_boolS (sail2_state_monad$returnS (((el = EL2))))
        (sail2_state$and_boolS (sail2_state_monad$returnS (((el = EL0))))
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__6 : 64 bits) . 
            sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__6 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))))))`;


(*val S1TranslationRegime__0 : mword ty2 -> M (mword ty2)*)

(*val S1TranslationRegime__1 : unit -> M (mword ty2)*)

val _ = Define `
 ((S1TranslationRegime__0:(2)words$word ->(regstate)sail2_state_monad$sequential_state ->((((2)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) el=
    (if (((el <> EL0))) then sail2_state_monad$returnS el
   else sail2_state_monad$bindS
     (sail2_state$and_boolS (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3))) ((ELUsingAArch32 EL3)))
       ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_ref  : ( 32 words$word) M) (\ (w__2 : 32 bits) . 
        sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__2 (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__3 : bool) . 
     if w__3 then sail2_state_monad$returnS EL3
     else sail2_state_monad$bindS
       (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveVirtHostExt () ))) ((ELIsInHost el))) (\ (w__5 : bool) . 
       sail2_state_monad$returnS (if w__5 then EL2
               else EL1)))))`;


val _ = Define `
 ((S1TranslationRegime__1:unit ->(regstate)sail2_state_monad$sequential_state ->((((2)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) . 
   (S1TranslationRegime__0 w__0.ProcState_EL  : ( 2 words$word) M))))`;


(*val aset_FAR__0 : mword ty2 -> mword ty64 -> M unit*)

(*val aset_FAR__1 : mword ty64 -> M unit*)

val _ = Define `
 ((aset_FAR__0:(2)words$word ->(64)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) regime value_name=
    (let (r : 64 bits) = value_name in
   let pat_0 = regime in
   if (((pat_0 = EL1))) then sail2_state_monad$write_regS FAR_EL1_ref r
   else if (((pat_0 = EL2))) then sail2_state_monad$write_regS FAR_EL2_ref r
   else if (((pat_0 = EL3))) then sail2_state_monad$write_regS FAR_EL3_ref r
   else Unreachable () ))`;


val _ = Define `
 ((aset_FAR__1:(64)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) value_name=  (sail2_state_monad$bindS
   (S1TranslationRegime__1 ()   : ( 2 words$word) M) (\ (w__0 :  2 words$word) . 
   aset_FAR__0 w__0 value_name)))`;


(*val aset_ESR__0 : mword ty2 -> mword ty32 -> M unit*)

(*val aset_ESR__1 : mword ty32 -> M unit*)

val _ = Define `
 ((aset_ESR__0:(2)words$word ->(32)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) regime value_name=
    (let (r : 32 bits) = value_name in
   let pat_0 = regime in
   if (((pat_0 = EL1))) then sail2_state_monad$write_regS ESR_EL1_ref r
   else if (((pat_0 = EL2))) then sail2_state_monad$write_regS ESR_EL2_ref r
   else if (((pat_0 = EL3))) then sail2_state_monad$write_regS ESR_EL3_ref r
   else Unreachable () ))`;


val _ = Define `
 ((aset_ESR__1:(32)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) value_name=  (sail2_state_monad$bindS
   (S1TranslationRegime__1 ()   : ( 2 words$word) M) (\ (w__0 :  2 words$word) . 
   aset_ESR__0 w__0 value_name)))`;


(*val aget_VBAR__0 : mword ty2 -> M (mword ty64)*)

(*val aget_VBAR__1 : unit -> M (mword ty64)*)

val _ = Define `
 ((aget_VBAR__0:(2)words$word ->(regstate)sail2_state_monad$sequential_state ->((((64)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) regime=  (sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (r : 64 bits) . 
   let pat_0 = regime in
   if (((pat_0 = EL1))) then (sail2_state_monad$read_regS VBAR_EL1_ref  : ( 64 words$word) M)
   else if (((pat_0 = EL2))) then (sail2_state_monad$read_regS VBAR_EL2_ref  : ( 64 words$word) M)
   else if (((pat_0 = EL3))) then (sail2_state_monad$read_regS VBAR_EL3_ref  : ( 64 words$word) M)
   else sail2_state_monad$seqS (Unreachable () ) (sail2_state_monad$returnS r))))`;


val _ = Define `
 ((aget_VBAR__1:unit ->(regstate)sail2_state_monad$sequential_state ->((((64)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (S1TranslationRegime__1 ()   : ( 2 words$word) M) (\ (w__0 :  2 words$word) . 
   (aget_VBAR__0 w__0  : ( 64 words$word) M))))`;


(*val aget_SCTLR__0 : mword ty2 -> M (mword ty32)*)

(*val aget_SCTLR__1 : unit -> M (mword ty32)*)

val _ = Define `
 ((aget_SCTLR__0:(2)words$word ->(regstate)sail2_state_monad$sequential_state ->((((32)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) regime=  (sail2_state_monad$bindS
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (r : 32 bits) . 
   let pat_0 = regime in
   if (((pat_0 = EL1))) then (sail2_state_monad$read_regS SCTLR_EL1_ref  : ( 32 words$word) M)
   else if (((pat_0 = EL2))) then (sail2_state_monad$read_regS SCTLR_EL2_ref  : ( 32 words$word) M)
   else if (((pat_0 = EL3))) then (sail2_state_monad$read_regS SCTLR_EL3_ref  : ( 32 words$word) M)
   else sail2_state_monad$seqS (Unreachable () ) (sail2_state_monad$returnS r))))`;


val _ = Define `
 ((aget_SCTLR__1:unit ->(regstate)sail2_state_monad$sequential_state ->((((32)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (S1TranslationRegime__1 ()   : ( 2 words$word) M) (\ (w__0 :  2 words$word) . 
   (aget_SCTLR__0 w__0  : ( 32 words$word) M))))`;


(*val BigEndian : unit -> M bool*)

val _ = Define `
 ((BigEndian:unit ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (bigend : bool) .  sail2_state_monad$bindS
   (UsingAArch32 () ) (\ (w__0 : bool) . 
   if w__0 then sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__1 : ProcState) . 
     let (bigend : bool) = (w__1.ProcState_E <> (vec_of_bits [B0]  :  1 words$word)) in
     sail2_state_monad$returnS bigend)
   else sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) . 
     if (((w__2.ProcState_EL = EL0))) then sail2_state_monad$bindS
       (aget_SCTLR__1 ()   : ( 32 words$word) M) (\ (w__3 :  32 words$word) . 
       let (bigend : bool) =
         ((vec_of_bits [access_vec_dec w__3 (( 24 : int):ii)]  :  1 words$word) <> (vec_of_bits [B0]  :  1 words$word)) in
       sail2_state_monad$returnS bigend)
     else sail2_state_monad$bindS
       (aget_SCTLR__1 ()   : ( 32 words$word) M) (\ (w__4 :  32 words$word) . 
       let (bigend : bool) =
         ((vec_of_bits [access_vec_dec w__4 (( 25 : int):ii)]  :  1 words$word) <> (vec_of_bits [B0]  :  1 words$word)) in
       sail2_state_monad$returnS bigend))))))`;


(*val aget_MAIR__0 : mword ty2 -> M (mword ty64)*)

(*val aget_MAIR__1 : unit -> M (mword ty64)*)

val _ = Define `
 ((aget_MAIR__0:(2)words$word ->(regstate)sail2_state_monad$sequential_state ->((((64)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) regime=  (sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (r : 64 bits) . 
   let pat_0 = regime in
   if (((pat_0 = EL1))) then (sail2_state_monad$read_regS MAIR_EL1_ref  : ( 64 words$word) M)
   else if (((pat_0 = EL2))) then (sail2_state_monad$read_regS MAIR_EL2_ref  : ( 64 words$word) M)
   else if (((pat_0 = EL3))) then (sail2_state_monad$read_regS MAIR_EL3_ref  : ( 64 words$word) M)
   else sail2_state_monad$seqS (Unreachable () ) (sail2_state_monad$returnS r))))`;


val _ = Define `
 ((aget_MAIR__1:unit ->(regstate)sail2_state_monad$sequential_state ->((((64)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (S1TranslationRegime__1 ()   : ( 2 words$word) M) (\ (w__0 :  2 words$word) . 
   (aget_MAIR__0 w__0  : ( 64 words$word) M))))`;


(*val S1CacheDisabled : AccType -> M bool*)

val _ = Define `
 ((S1CacheDisabled:AccType ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) acctype=  (sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (enable : 1 bits) .  sail2_state_monad$bindS
   (S1TranslationRegime__1 ()   : ( 2 words$word) M) (\ (w__0 :  2 words$word) .  sail2_state_monad$bindS
   (ELUsingAArch32 w__0) (\ (w__1 : bool) .  sail2_state_monad$bindS
   (if w__1 then sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) . 
      if (((w__2.ProcState_EL = EL2))) then
        if (((acctype = AccType_IFETCH))) then sail2_state_monad$bindS
          (sail2_state_monad$read_regS HSCTLR_ref  : ( 32 words$word) M) (\ (w__3 : 32 bits) . 
          sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__3 (( 12 : int):ii)]  :  1 words$word))
        else sail2_state_monad$bindS
          (sail2_state_monad$read_regS HSCTLR_ref  : ( 32 words$word) M) (\ (w__4 : 32 bits) . 
          sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__4 (( 2 : int):ii)]  :  1 words$word))
      else if (((acctype = AccType_IFETCH))) then sail2_state_monad$bindS
        (sail2_state_monad$read_regS SCTLR_ref  : ( 32 words$word) M) (\ (w__6 : 32 bits) . 
        sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__6 (( 12 : int):ii)]  :  1 words$word))
      else sail2_state_monad$bindS
        (sail2_state_monad$read_regS SCTLR_ref  : ( 32 words$word) M) (\ (w__7 : 32 bits) . 
        sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__7 (( 2 : int):ii)]  :  1 words$word)))
    else if (((acctype = AccType_IFETCH))) then sail2_state_monad$bindS
      (aget_SCTLR__1 ()   : ( 32 words$word) M) (\ (w__9 :  32 words$word) . 
      sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__9 (( 12 : int):ii)]  :  1 words$word))
    else sail2_state_monad$bindS
      (aget_SCTLR__1 ()   : ( 32 words$word) M) (\ (w__10 :  32 words$word) . 
      sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__10 (( 2 : int):ii)]  :  1 words$word))) (\ (enable : 1 bits) . 
   sail2_state_monad$returnS (((enable = (vec_of_bits [B0]  :  1 words$word))))))))))`;


(*val ShortConvertAttrsHints : mword ty2 -> AccType -> bool -> M MemAttrHints*)

val _ = Define `
 ((ShortConvertAttrsHints:(2)words$word -> AccType -> bool ->(regstate)sail2_state_monad$sequential_state ->(((MemAttrHints),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) RGN acctype secondstage=  (sail2_state_monad$bindS
   (undefined_MemAttrHints () ) (\ (result : MemAttrHints) .  sail2_state_monad$bindS
   (sail2_state$or_boolS (sail2_state$and_boolS (sail2_state_monad$returnS ((~ secondstage))) ((S1CacheDisabled acctype)))
     (sail2_state$and_boolS (sail2_state_monad$returnS secondstage) ((S2CacheDisabled acctype)))) (\ (w__4 : bool) . 
   let (result : MemAttrHints) =
     (if w__4 then
       let (result : MemAttrHints) = ((result with<| MemAttrHints_attrs := MemAttr_NC|>)) in
       (result with<| MemAttrHints_hints := MemHint_No|>)
     else
       let b__0 = RGN in
       if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then
         let (result : MemAttrHints) = ((result with<| MemAttrHints_attrs := MemAttr_NC|>)) in
         (result with<| MemAttrHints_hints := MemHint_No|>)
       else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then
         let (result : MemAttrHints) = ((result with<| MemAttrHints_attrs := MemAttr_WB|>)) in
         (result with<| MemAttrHints_hints := MemHint_RWA|>)
       else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then
         let (result : MemAttrHints) = ((result with<| MemAttrHints_attrs := MemAttr_WT|>)) in
         (result with<| MemAttrHints_hints := MemHint_RA|>)
       else
         let (result : MemAttrHints) = ((result with<| MemAttrHints_attrs := MemAttr_WB|>)) in
         (result with<| MemAttrHints_hints := MemHint_RA|>)) in
   let (result : MemAttrHints) = ((result with<| MemAttrHints_transient := F|>)) in
   sail2_state_monad$returnS result))))`;


(*val WalkAttrDecode : mword ty2 -> mword ty2 -> mword ty2 -> bool -> M MemoryAttributes*)

val _ = Define `
 ((WalkAttrDecode:(2)words$word ->(2)words$word ->(2)words$word -> bool ->(regstate)sail2_state_monad$sequential_state ->(((MemoryAttributes),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) SH ORGN IRGN secondstage=  (sail2_state_monad$bindS
   (undefined_MemoryAttributes () ) (\ (memattrs : MemoryAttributes) . 
   let (acctype : AccType) = AccType_NORMAL in
   let memattrs = ((memattrs with<| MemoryAttributes_typ := MemType_Normal|>)) in sail2_state_monad$bindS
   (ShortConvertAttrsHints IRGN acctype secondstage) (\ (w__0 : MemAttrHints) . 
   let memattrs = ((memattrs with<| MemoryAttributes_inner := w__0|>)) in sail2_state_monad$bindS
   (ShortConvertAttrsHints ORGN acctype secondstage) (\ (w__1 : MemAttrHints) . 
   let memattrs = ((memattrs with<| MemoryAttributes_outer := w__1|>)) in
   let memattrs =
     ((memattrs with<|
       MemoryAttributes_shareable :=
         ((((vec_of_bits [access_vec_dec SH (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))|>)) in
   let memattrs =
     ((memattrs with<|
       MemoryAttributes_outershareable := (((SH = (vec_of_bits [B1;B0]  :  2 words$word))))|>)) in
   MemAttrDefaults memattrs)))))`;


(*val LongConvertAttrsHints : mword ty4 -> AccType -> M MemAttrHints*)

val _ = Define `
 ((LongConvertAttrsHints:(4)words$word -> AccType ->(regstate)sail2_state_monad$sequential_state ->(((MemAttrHints),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) attrfield acctype=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((~ ((IsZero attrfield)))) "!(IsZero(attrfield))")
   (undefined_MemAttrHints () )) (\ (result : MemAttrHints) .  sail2_state_monad$bindS
   (S1CacheDisabled acctype) (\ (w__0 : bool) . 
   let (result : MemAttrHints) =
     (if w__0 then
       let (result : MemAttrHints) = ((result with<| MemAttrHints_attrs := MemAttr_NC|>)) in
       (result with<| MemAttrHints_hints := MemHint_No|>)
     else if (((((slice attrfield (( 2 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B0]  :  2 words$word)))) then
       let (result : MemAttrHints) = ((result with<| MemAttrHints_attrs := MemAttr_WT|>)) in
       let (result : MemAttrHints) =
         ((result with<| MemAttrHints_hints := ((slice attrfield (( 0 : int):ii) (( 2 : int):ii)  :  2 words$word))|>)) in
       (result with<| MemAttrHints_transient := T|>)
     else if (((((slice attrfield (( 0 : int):ii) (( 4 : int):ii)  :  4 words$word)) = (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)))) then
       let (result : MemAttrHints) = ((result with<| MemAttrHints_attrs := MemAttr_NC|>)) in
       let (result : MemAttrHints) = ((result with<| MemAttrHints_hints := MemHint_No|>)) in
       (result with<| MemAttrHints_transient := F|>)
     else if (((((slice attrfield (( 2 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))) then
       let (result : MemAttrHints) =
         ((result with<| MemAttrHints_attrs := ((slice attrfield (( 0 : int):ii) (( 2 : int):ii)  :  2 words$word))|>)) in
       let (result : MemAttrHints) = ((result with<| MemAttrHints_hints := MemAttr_WB|>)) in
       (result with<| MemAttrHints_transient := T|>)
     else
       let (result : MemAttrHints) =
         ((result with<| MemAttrHints_attrs := ((slice attrfield (( 2 : int):ii) (( 2 : int):ii)  :  2 words$word))|>)) in
       let (result : MemAttrHints) =
         ((result with<| MemAttrHints_hints := ((slice attrfield (( 0 : int):ii) (( 2 : int):ii)  :  2 words$word))|>)) in
       (result with<| MemAttrHints_transient := F|>)) in
   sail2_state_monad$returnS result))))`;


(*val AArch64_S1AttrDecode : mword ty2 -> mword ty3 -> AccType -> M MemoryAttributes*)

val _ = Define `
 ((AArch64_S1AttrDecode:(2)words$word ->(3)words$word -> AccType ->(regstate)sail2_state_monad$sequential_state ->(((MemoryAttributes),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) SH attr acctype=
    (let uattr = (ex_nat ((lem$w2ui attr))) in sail2_state_monad$bindS
   (undefined_MemoryAttributes () ) (\ (memattrs : MemoryAttributes) .  sail2_state_monad$bindS
   (aget_MAIR__1 ()   : ( 64 words$word) M) (\ (mair : 64 bits) . 
   let (index : int) = ((( 8 : int):ii) * uattr) in
   let (attrfield : 8 bits) =
     ((subrange_vec_dec mair (((( 7 : int):ii) + index)) index  :  8 words$word)) in sail2_state_monad$bindS
   (undefined_Constraint () ) (\ (anon10 : Constraint) .  sail2_state_monad$bindS
   (if (((((((((((subrange_vec_dec attrfield (( 7 : int):ii) (( 4 : int):ii)  :  4 words$word)) <> (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)))) /\ (((((subrange_vec_dec attrfield (( 3 : int):ii) (( 0 : int):ii)  :  4 words$word)) = (vec_of_bits [B0;B0;B0;B0]  :  4 words$word))))))) \/ ((((((((subrange_vec_dec attrfield (( 7 : int):ii) (( 4 : int):ii)  :  4 words$word)) = (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)))) /\ (((((and_vec ((subrange_vec_dec attrfield (( 3 : int):ii) (( 0 : int):ii)  :  4 words$word))
                       (vec_of_bits [B0;B0;B1;B1]  :  4 words$word)
                      :  4 words$word)) <> (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)))))))))) then sail2_state_monad$bindS
      (ConstrainUnpredictableBits (( 8 : int):ii) Unpredictable_RESMAIR  : ((Constraint #  8 words$word)) M) (\ (w__0 :
        (Constraint # 8 bits)) . 
      let (tup__0, tup__1) = w__0 in
      let (anon10 : Constraint) = tup__0 in
      sail2_state_monad$returnS tup__1)
    else sail2_state_monad$returnS attrfield) (\ (attrfield : 8 bits) .  sail2_state_monad$bindS
   (if (((((subrange_vec_dec attrfield (( 7 : int):ii) (( 4 : int):ii)  :  4 words$word)) = (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)))) then
      let memattrs = ((memattrs with<| MemoryAttributes_typ := MemType_Device|>)) in
      let b__0 = ((subrange_vec_dec attrfield (( 3 : int):ii) (( 0 : int):ii)  :  4 words$word)) in
      if (((b__0 = (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)))) then
        let (memattrs : MemoryAttributes) =
          ((memattrs with<| MemoryAttributes_device := DeviceType_nGnRnE|>)) in
        sail2_state_monad$returnS memattrs
      else if (((b__0 = (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)))) then
        let (memattrs : MemoryAttributes) =
          ((memattrs with<| MemoryAttributes_device := DeviceType_nGnRE|>)) in
        sail2_state_monad$returnS memattrs
      else if (((b__0 = (vec_of_bits [B1;B0;B0;B0]  :  4 words$word)))) then
        let (memattrs : MemoryAttributes) =
          ((memattrs with<| MemoryAttributes_device := DeviceType_nGRE|>)) in
        sail2_state_monad$returnS memattrs
      else if (((b__0 = (vec_of_bits [B1;B1;B0;B0]  :  4 words$word)))) then
        let (memattrs : MemoryAttributes) =
          ((memattrs with<| MemoryAttributes_device := DeviceType_GRE|>)) in
        sail2_state_monad$returnS memattrs
      else sail2_state_monad$seqS (Unreachable () ) (sail2_state_monad$returnS memattrs)
    else if (((((subrange_vec_dec attrfield (( 3 : int):ii) (( 0 : int):ii)  :  4 words$word)) <> (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)))) then
      let memattrs = ((memattrs with<| MemoryAttributes_typ := MemType_Normal|>)) in sail2_state_monad$bindS
      (LongConvertAttrsHints ((subrange_vec_dec attrfield (( 7 : int):ii) (( 4 : int):ii)  :  4 words$word)) acctype) (\ (w__1 :
        MemAttrHints) . 
      let memattrs = ((memattrs with<| MemoryAttributes_outer := w__1|>)) in sail2_state_monad$bindS
      (LongConvertAttrsHints ((subrange_vec_dec attrfield (( 3 : int):ii) (( 0 : int):ii)  :  4 words$word)) acctype) (\ (w__2 :
        MemAttrHints) . 
      let (memattrs : MemoryAttributes) = ((memattrs with<| MemoryAttributes_inner := w__2|>)) in
      let (memattrs : MemoryAttributes) =
        ((memattrs with<|
          MemoryAttributes_shareable :=
            ((((vec_of_bits [access_vec_dec SH (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))|>)) in
      let (memattrs : MemoryAttributes) =
        ((memattrs with<|
          MemoryAttributes_outershareable := (((SH = (vec_of_bits [B1;B0]  :  2 words$word))))|>)) in
      sail2_state_monad$returnS memattrs))
    else sail2_state_monad$seqS (Unreachable () ) (sail2_state_monad$returnS memattrs)) (\ (memattrs : MemoryAttributes) . 
   MemAttrDefaults memattrs)))))))`;


(*val IsInHost : unit -> M bool*)

val _ = Define `
 ((IsInHost:unit ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS (sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) .  ELIsInHost w__0.ProcState_EL)))`;


(*val aget_CPACR : unit -> M (mword ty32)*)

val _ = Define `
 ((aget_CPACR:unit ->(regstate)sail2_state_monad$sequential_state ->((((32)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (IsInHost () ) (\ (w__0 : bool) . 
   if w__0 then (sail2_state_monad$read_regS CPTR_EL2_ref  : ( 32 words$word) M)
   else (sail2_state_monad$read_regS CPACR_EL1_ref  : ( 32 words$word) M))))`;


(*val HasS2Translation : unit -> M bool*)

val _ = Define `
 ((HasS2Translation:unit ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$and_boolS
     (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__0 : bool) .  sail2_state_monad$returnS ((~ w__0)))))
        ( sail2_state_monad$bindS(IsInHost () ) (\ (w__2 : bool) .  sail2_state_monad$returnS ((~ w__2)))))
     (sail2_state$or_boolS
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__4 : ProcState) .  sail2_state_monad$returnS (((w__4.ProcState_EL = EL0)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__5 : ProcState) .  sail2_state_monad$returnS (((w__5.ProcState_EL = EL1))))))))`;


(*val AArch64_SecondStageWalk : AddressDescriptor -> mword ty64 -> AccType -> bool -> ii -> bool -> M AddressDescriptor*)

val _ = Define `
 ((AArch64_CheckAndUpdateDescriptor_SecondStage:DescriptorUpdate -> FaultRecord ->(64)words$word -> AccType -> bool -> bool -> bool ->(regstate)sail2_state_monad$sequential_state ->(((FaultRecord),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) result fault vaddress acctype iswrite s2fs1walk hwupdatewalk__arg=
    (let hwupdatewalk = hwupdatewalk__arg in sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (hw_update_AF : bool) . 
   let (hw_update_AF : bool) =
     (if result.DescriptorUpdate_AF then
       if (((fault.FaultRecord_typ = Fault_None))) then T
       else if (((((ConstrainUnpredictable Unpredictable_AFUPDATE)) = Constraint_TRUE))) then T
       else F
     else hw_update_AF) in sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (hw_update_AP : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (write_perm_req : bool) . 
   let (hw_update_AP : bool) =
     (if (((result.DescriptorUpdate_AP /\ (((fault.FaultRecord_typ = Fault_None)))))) then
       let (write_perm_req : bool) =
         ((((iswrite \/ ((((((acctype = AccType_ATOMICRW))) \/ (((acctype = AccType_ORDEREDRW))))))))) /\ ((~ s2fs1walk))) in
       ((((write_perm_req /\ ((~ ((((((acctype = AccType_AT))) \/ (((acctype = AccType_DC))))))))))) \/ hwupdatewalk)
     else F) in sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (desc : 64 bits) .  sail2_state_monad$bindS
   (undefined_AccessDescriptor () ) (\ (accdesc : AccessDescriptor) .  sail2_state_monad$bindS
   (undefined_AddressDescriptor () ) (\ (descaddr2 : AddressDescriptor) .  sail2_state_monad$seqS
   (if (((hw_update_AF \/ hw_update_AP))) then
      let descaddr2 = (result.DescriptorUpdate_descaddr) in sail2_state_monad$bindS
      (CreateAccessDescriptor AccType_ATOMICRW) (\ (w__0 : AccessDescriptor) . 
      let accdesc = w__0 in sail2_state_monad$bindS
      (aget__Mem descaddr2 (( 8 : int):ii) accdesc  : ( 64 words$word) M) (\ (w__1 : 64 bits) . 
      let desc = w__1 in
      let (desc : 64 bits) =
        (if hw_update_AF then
          (set_slice (( 64 : int):ii) (( 1 : int):ii) desc (( 10 : int):ii) (vec_of_bits [B1]  :  1 words$word)  :  64 words$word)
        else desc) in
      let (desc : 64 bits) =
        (if hw_update_AP then
          (set_slice (( 64 : int):ii) (( 1 : int):ii) desc (( 7 : int):ii) (vec_of_bits [B1]  :  1 words$word)  :  64 words$word)
        else desc) in
      aset__Mem descaddr2 (( 8 : int):ii) accdesc desc))
    else sail2_state_monad$returnS () )
   (sail2_state_monad$returnS fault)))))))))`;


(*val AArch64_CheckS2Permission : Permissions -> mword ty64 -> mword ty52 -> ii -> AccType -> bool -> bool -> bool -> M FaultRecord*)

val _ = Define `
 ((AArch64_CheckS2Permission:Permissions ->(64)words$word ->(52)words$word -> int -> AccType -> bool -> bool -> bool ->(regstate)sail2_state_monad$sequential_state ->(((FaultRecord),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) perms vaddress ipaddress level acctype iswrite s2fs1walk hwupdatewalk=  (sail2_state_monad$bindS
   (sail2_state$and_boolS
     (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__0 : bool) .  sail2_state_monad$returnS ((~ w__0)))))
        ( sail2_state_monad$bindS(ELUsingAArch32 EL2) (\ (w__2 : bool) .  sail2_state_monad$returnS ((~ w__2))))) ((HasS2Translation () ))) (\ (w__5 :
     bool) .  sail2_state_monad$seqS
   (sail2_state_monad$assert_expS w__5 "(((HaveEL(EL2) && !(IsSecure())) && !(ELUsingAArch32(EL2))) && HasS2Translation())")
   (let (r : bool) =
     ((vec_of_bits [access_vec_dec perms.Permissions_ap (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
   let (w : bool) =
     ((vec_of_bits [access_vec_dec perms.Permissions_ap (( 2 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (xn : bool) .  sail2_state_monad$bindS
   (if ((HaveExtendedExecuteNeverExt () )) then
      let b__0 = ((concat_vec perms.Permissions_xn perms.Permissions_xxn  :  2 words$word)) in
      if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$returnS F
      else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__6 : ProcState) . 
        let (xn : bool) = (w__6.ProcState_EL = EL1) in
        sail2_state_monad$returnS xn)
      else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$returnS T
      else sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__7 : ProcState) . 
        let (xn : bool) = (w__7.ProcState_EL = EL0) in
        sail2_state_monad$returnS xn)
    else
      let (xn : bool) = (perms.Permissions_xn = (vec_of_bits [B1]  :  1 words$word)) in
      sail2_state_monad$returnS xn) (\ (xn : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (failedread : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (fail1 : bool) . 
   let ((fail1 : bool), (failedread : bool)) =
     (if ((((((acctype = AccType_IFETCH))) /\ ((~ s2fs1walk))))) then
       let (fail1 : bool) = xn in
       let (failedread : bool) = T in
       (fail1, failedread)
     else
       let ((fail1 : bool), (failedread : bool)) =
         (if (((((((((acctype = AccType_ATOMICRW))) \/ (((acctype = AccType_ORDEREDRW)))))) /\ ((~ s2fs1walk))))) then
           let (fail1 : bool) = (((~ r)) \/ ((~ w))) in
           let (failedread : bool) = (~ r) in
           (fail1, failedread)
         else
           let ((fail1 : bool), (failedread : bool)) =
             (if (((iswrite /\ ((~ s2fs1walk))))) then
               let (fail1 : bool) = (~ w) in
               let (failedread : bool) = F in
               (fail1, failedread)
             else
               let ((fail1 : bool), (failedread : bool)) =
                 (if hwupdatewalk then
                   let (fail1 : bool) = (~ w) in
                   let (failedread : bool) = (~ iswrite) in
                   (fail1, failedread)
                 else
                   let (fail1 : bool) = (~ r) in
                   let (failedread : bool) = (~ iswrite) in
                   (fail1, failedread)) in
               (fail1, failedread)) in
           (fail1, failedread)) in
       (fail1, failedread)) in sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (secondstage : bool) .  sail2_state_monad$bindS
   (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (domain1 : 4 bits) . 
   if fail1 then sail2_state_monad$bindS
     (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (w__8 : 4 bits) . 
     let domain1 = w__8 in
     let secondstage = T in
     AArch64_PermissionFault ipaddress level acctype ((~ failedread)) secondstage s2fs1walk)
   else AArch64_NoFault () ))))))))))`;


(*val IsZero_slice : forall 'n . Size 'n => mword 'n -> ii -> ii -> M bool*)

val _ = Define `
 ((IsZero_slice:'n words$word -> int -> int ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) xs i l=  (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS T "")
   (sail2_state_monad$returnS ((IsZero ((and_vec xs ((slice_mask ((int_of_num (words$word_len xs))) i l  :  'n words$word))  :  'n words$word)))))))`;


(*val ZeroExtend_slice_append : forall 'n 'm 'o . Size 'm, Size 'n, Size 'o => integer -> mword 'n -> ii -> ii -> mword 'm -> M (mword 'o)*)

val _ = Define `
 ((ZeroExtend_slice_append:int -> 'n words$word -> int -> int -> 'm words$word ->(regstate)sail2_state_monad$sequential_state ->((('o words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) (o__tv : int) xs i l ys=  (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS T "")
   (let xs = ((and_vec xs ((slice_mask ((int_of_num (words$word_len xs))) i l  :  'n words$word))  :  'n words$word)) in
   let (xs : 'o bits) =
     ((shiftl ((extzv o__tv ((shiftr xs i  :  'n words$word))  :  'o words$word)) ((int_of_num (words$word_len ys)))  :  'o words$word)) in
   let (ys : 'o bits) = ((extzv ((int_of_num (words$word_len xs))) ys  :  'o words$word)) in
   sail2_state_monad$returnS ((or_vec xs ys  :  'o words$word)))))`;


val _ = Define `
 ((AArch64_TranslationTableWalk_SecondStage:(52)words$word ->(64)words$word -> AccType -> bool -> bool -> int ->(regstate)sail2_state_monad$sequential_state ->(((TLBRecord),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) ipaddress vaddress acctype iswrite s2fs1walk size1=
    (sail2_state_monad$catch_early_returnS
     ( sail2_state_monad$bindS(sail2_state$and_boolS
        (sail2_state$and_boolS
           (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
              ( sail2_state_monad$bindS(sail2_state_monad$liftRS (IsSecure () )) (\ (w__0 : bool) .  sail2_state_monad$returnS ((~ w__0)))))
           ( sail2_state_monad$bindS(sail2_state_monad$liftRS (ELUsingAArch32 EL2)) (\ (w__2 : bool) .  sail2_state_monad$returnS ((~ w__2)))))
        (sail2_state_monad$liftRS ((HasS2Translation () )))) (\ (w__5 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$liftRS (sail2_state_monad$assert_expS w__5 ""))
      (sail2_state_monad$liftRS (undefined_TLBRecord () ))) (\ (result : TLBRecord) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (undefined_AddressDescriptor () )) (\ (descaddr : AddressDescriptor) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS ((undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M))) (\ (baseregister : 64 bits) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS ((undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M))) (\ (inputaddr : 64 bits) . 
      let (tmp_180 : MemoryAttributes) = (descaddr.AddressDescriptor_memattrs) in
      let tmp_180 = ((tmp_180 with<| MemoryAttributes_typ := MemType_Normal|>)) in
      let descaddr = ((descaddr with<| AddressDescriptor_memattrs := tmp_180|>)) in sail2_state_monad$bindS
      (sail2_state_monad$liftRS (undefined_int () )) (\ (startsizecheck : ii) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (undefined_int () )) (\ (inputsizecheck : ii) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (undefined_int () )) (\ (startlevel : ii) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (undefined_int () )) (\ (level : ii) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (undefined_int () )) (\ (stride : ii) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (undefined_int () )) (\ (firstblocklevel : ii) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (undefined_int () )) (\ (grainsize : ii) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (hierattrsdisabled : bool) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (update_AP : bool) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (update_AF : bool) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (singlepriv : bool) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (lookupsecure : bool) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (reversedescriptors : bool) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (disabled : bool) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (basefound : bool) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS ((undefined_bitvector (( 3 : int):ii)  : ( 3 words$word) M))) (\ (ps : 3 bits) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (undefined_int () )) (\ (inputsize_min : ii) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (undefined_Constraint () )) (\ (c : Constraint) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (undefined_int () )) (\ (inputsize_max : ii) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (undefined_int () )) (\ (inputsize : ii) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (midgrain : bool) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (largegrain : bool) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (undefined_int () )) (\ (top : ii) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS ((ZeroExtend__1 (( 64 : int):ii) ipaddress  : ( 64 words$word) M))) (\ (w__6 : 64 bits) . 
      let inputaddr = w__6 in sail2_state_monad$bindS
      (sail2_state_monad$liftRS ((sail2_state_monad$read_regS VTCR_EL2_ref  : ( 32 words$word) M))) (\ (w__7 : 32 bits) . 
      let inputsize = ((( 64 : int):ii) - ((lem$w2ui ((slice w__7 (( 0 : int):ii) (( 6 : int):ii)  :  6 words$word))))) in sail2_state_monad$bindS
      (sail2_state_monad$liftRS ((sail2_state_monad$read_regS VTCR_EL2_ref  : ( 32 words$word) M))) (\ (w__8 : 32 bits) . 
      let largegrain =
        (((slice w__8 (( 14 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)) in sail2_state_monad$bindS
      (sail2_state_monad$liftRS ((sail2_state_monad$read_regS VTCR_EL2_ref  : ( 32 words$word) M))) (\ (w__9 : 32 bits) . 
      let midgrain =
        (((slice w__9 (( 14 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word)) in
      let inputsize_max = (if (((((Have52BitVAExt () )) /\ largegrain))) then (( 52 : int):ii) else (( 48 : int):ii)) in sail2_state_monad$bindS
      (if ((((ex_int inputsize)) > ((ex_int inputsize_max)))) then
         let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in sail2_state_monad$seqS
         (sail2_state_monad$liftRS (sail2_state_monad$assert_expS ((((((c = Constraint_FORCE))) \/ (((c = Constraint_FAULT)))))) ""))
         (let (inputsize : ii) = (if (((c = Constraint_FORCE))) then inputsize_max else inputsize) in
         sail2_state_monad$returnS (c, inputsize))
       else sail2_state_monad$returnS (c, inputsize)) (\ varstup .  let ((c : Constraint), (inputsize : ii)) = varstup in
      let inputsize_min = ((( 64 : int):ii) - (( 39 : int):ii)) in sail2_state_monad$bindS
      (if ((((ex_int inputsize)) < ((ex_int inputsize_min)))) then
         let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in sail2_state_monad$seqS
         (sail2_state_monad$liftRS (sail2_state_monad$assert_expS ((((((c = Constraint_FORCE))) \/ (((c = Constraint_FAULT)))))) ""))
         (let (inputsize : ii) = (if (((c = Constraint_FORCE))) then inputsize_min else inputsize) in
         sail2_state_monad$returnS inputsize)
       else sail2_state_monad$returnS inputsize) (\ (inputsize : ii) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS ((sail2_state_monad$read_regS VTCR_EL2_ref  : ( 32 words$word) M))) (\ (w__10 : 32 bits) . 
      let ps = ((slice w__10 (( 16 : int):ii) (( 3 : int):ii)  :  3 words$word)) in sail2_state_monad$bindS
      (sail2_state$and_boolS
        (sail2_state_monad$returnS (((((((ex_int inputsize)) >= ((ex_int inputsize_min)))) /\ ((((ex_int inputsize)) <= ((ex_int inputsize_max))))))))
        (sail2_state_monad$liftRS ((IsZero_slice inputaddr inputsize
                   ((((~ ((ex_int inputsize)))) + (( 64 : int):ii))))))) (\ (w__12 :
        bool) . 
      let basefound = w__12 in
      let disabled = F in sail2_state_monad$bindS
      (sail2_state_monad$liftRS ((sail2_state_monad$read_regS VTTBR_EL2_ref  : ( 64 words$word) M))) (\ (w__13 : 64 bits) . 
      let baseregister = w__13 in sail2_state_monad$bindS
      (sail2_state_monad$liftRS ((sail2_state_monad$read_regS VTCR_EL2_ref  : ( 32 words$word) M))) (\ (w__14 : 32 bits) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS ((sail2_state_monad$read_regS VTCR_EL2_ref  : ( 32 words$word) M))) (\ (w__15 : 32 bits) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS ((sail2_state_monad$read_regS VTCR_EL2_ref  : ( 32 words$word) M))) (\ (w__16 : 32 bits) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (WalkAttrDecode ((slice w__14 (( 8 : int):ii) (( 2 : int):ii)  :  2 words$word))
               ((slice w__15 (( 10 : int):ii) (( 2 : int):ii)  :  2 words$word))
               ((slice w__16 (( 12 : int):ii) (( 2 : int):ii)  :  2 words$word)) T)) (\ (w__17 : MemoryAttributes) . 
      let descaddr = ((descaddr with<| AddressDescriptor_memattrs := w__17|>)) in sail2_state_monad$bindS
      (sail2_state_monad$liftRS ((sail2_state_monad$read_regS SCTLR_EL2_ref  : ( 32 words$word) M))) (\ (w__18 : 32 bits) . 
      let reversedescriptors =
        ((vec_of_bits [access_vec_dec w__18 (( 25 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
      let lookupsecure = F in
      let singlepriv = T in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveAccessFlagUpdateExt () )))
        ( sail2_state_monad$bindS(sail2_state_monad$liftRS ((sail2_state_monad$read_regS VTCR_EL2_ref  : ( 32 words$word) M))) (\ (w__19 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__19 (( 21 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__20 : bool) . 
      let update_AF = w__20 in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveDirtyBitModifierExt () )) /\ update_AF))))
        ( sail2_state_monad$bindS(sail2_state_monad$liftRS ((sail2_state_monad$read_regS VTCR_EL2_ref  : ( 32 words$word) M))) (\ (w__21 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__21 (( 22 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__22 : bool) . 
      let update_AP = w__22 in sail2_state_monad$bindS
      (sail2_state_monad$liftRS ((sail2_state_monad$read_regS VTCR_EL2_ref  : ( 32 words$word) M))) (\ (w__23 : 32 bits) . 
      let startlevel = (lem$w2ui ((slice w__23 (( 6 : int):ii) (( 2 : int):ii)  :  2 words$word))) in
      let ((firstblocklevel : ii), (grainsize : ii), (level : ii)) =
        (if largegrain then
          let (grainsize : ii) = ((( 16 : int):ii)) in
          let (level : ii) = ((( 3 : int):ii) - ((ex_int startlevel))) in
          let (firstblocklevel : ii) = (if ((Have52BitPAExt () )) then (( 1 : int):ii) else (( 2 : int):ii)) in
          (firstblocklevel, grainsize, level)
        else
          let ((firstblocklevel : ii), (grainsize : ii), (level : ii)) =
            (if midgrain then
              let (grainsize : ii) = ((( 14 : int):ii)) in
              let (level : ii) = ((( 3 : int):ii) - ((ex_int startlevel))) in
              let (firstblocklevel : ii) = ((( 2 : int):ii)) in
              (firstblocklevel, grainsize, level)
            else
              let (grainsize : ii) = ((( 12 : int):ii)) in
              let (level : ii) = ((( 2 : int):ii) - ((ex_int startlevel))) in
              let (firstblocklevel : ii) = ((( 1 : int):ii)) in
              (firstblocklevel, grainsize, level)) in
          (firstblocklevel, grainsize, level)) in
      let stride = (((ex_int grainsize)) - (( 3 : int):ii)) in
      let (basefound : bool) =
        (if largegrain then
          if ((((((((ex_int level)) = (( 0 : int):ii)))) \/ ((((((((ex_int level)) = (( 1 : int):ii)))) /\ ((((ex_int ((PAMax () )))) <= (( 42 : int):ii)))))))))
          then
            F
          else basefound
        else if midgrain then
          if ((((((((ex_int level)) = (( 0 : int):ii)))) \/ ((((((((ex_int level)) = (( 1 : int):ii)))) /\ ((((ex_int ((PAMax () )))) <= (( 40 : int):ii)))))))))
          then
            F
          else basefound
        else if (((((((ex_int level)) < (( 0 : int):ii))) \/ ((((((((ex_int level)) = (( 0 : int):ii)))) /\ ((((ex_int ((PAMax () )))) <= (( 42 : int):ii))))))))) then
          F
        else basefound) in
      let inputsizecheck = inputsize in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((((ex_int inputsize)) > ((ex_int ((PAMax () )))))))
        (sail2_state$or_boolS ( sail2_state_monad$bindS(sail2_state_monad$liftRS (ELUsingAArch32 EL1)) (\ (w__24 : bool) .  sail2_state_monad$returnS ((~ w__24))))
           (sail2_state_monad$returnS ((((ex_int inputsize)) > (( 40 : int):ii)))))) (\ (w__26 : bool) .  sail2_state_monad$bindS
      (if w__26 then
         (case ((ConstrainUnpredictable Unpredictable_LARGEIPA)) of
           Constraint_FORCE =>
            let (inputsize : ii) = (PAMax () ) in
            let (inputsizecheck : ii) = (PAMax () ) in
            sail2_state_monad$returnS (basefound, inputsize, inputsizecheck)
         | Constraint_FORCENOSLCHECK =>
            let (inputsize : ii) = (PAMax () ) in
            sail2_state_monad$returnS (basefound, inputsize, inputsizecheck)
         | Constraint_FAULT =>
            let (basefound : bool) = F in
            sail2_state_monad$returnS (basefound, inputsize, inputsizecheck)
         | _ => sail2_state_monad$seqS (sail2_state_monad$liftRS (Unreachable () )) (sail2_state_monad$returnS (basefound, inputsize, inputsizecheck))
         )
       else sail2_state_monad$returnS (basefound, inputsize, inputsizecheck)) (\ varstup .  let ((basefound : bool), (inputsize :
        ii), (inputsizecheck : ii)) = varstup in
      let startsizecheck =
        (((ex_int inputsizecheck)) -
          (((((((( 3 : int):ii) - ((ex_int level)))) * ((ex_int stride)))) +
              ((ex_int grainsize))))) in
      let (basefound : bool) =
        (if (((((((ex_int startsizecheck)) < (( 1 : int):ii))) \/ ((((ex_int startsizecheck)) > ((((ex_int stride)) + (( 4 : int):ii)))))))) then
          F
        else basefound) in
      if (((((~ basefound)) \/ disabled))) then
        let level = ((( 0 : int):ii)) in
        let (tmp_190 : AddressDescriptor) = (result.TLBRecord_addrdesc) in sail2_state_monad$bindS
        (sail2_state_monad$liftRS (AArch64_TranslationFault ipaddress level acctype iswrite T s2fs1walk)) (\ (w__27 :
          FaultRecord) . 
        let (tmp_190 : AddressDescriptor) = ((tmp_190 with<| AddressDescriptor_fault := w__27|>)) in
        let (result : TLBRecord) = ((result with<| TLBRecord_addrdesc := tmp_190|>)) in
        sail2_state_monad$returnS result)
      else sail2_state_monad$bindS
        (sail2_state_monad$liftRS (undefined_int () )) (\ (outputsize : ii) . 
        let b__0 = ps in
        let (outputsize : ii) =
          (if (((b__0 = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) then (( 32 : int):ii)
          else if (((b__0 = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) then (( 36 : int):ii)
          else if (((b__0 = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) then (( 40 : int):ii)
          else if (((b__0 = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) then (( 42 : int):ii)
          else if (((b__0 = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) then (( 44 : int):ii)
          else if (((b__0 = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) then (( 48 : int):ii)
          else if (((b__0 = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) then
            if (((((Have52BitPAExt () )) /\ largegrain))) then (( 52 : int):ii)
            else (( 48 : int):ii)
          else (( 48 : int):ii)) in
        let (outputsize : ii) =
          (if ((((ex_int outputsize)) > ((ex_int ((PAMax () )))))) then PAMax () 
          else outputsize) in sail2_state_monad$bindS
        (sail2_state$and_boolS (sail2_state_monad$returnS ((((ex_int outputsize)) < (( 48 : int):ii))))
          ( sail2_state_monad$bindS(sail2_state_monad$liftRS (IsZero_slice baseregister outputsize
                    ((((~ ((ex_int outputsize)))) + (( 48 : int):ii))))) (\ (w__28 :
             bool) . 
           sail2_state_monad$returnS ((~ w__28))))) (\ (w__29 : bool) . 
        if w__29 then
          let level = ((( 0 : int):ii)) in
          let (tmp_200 : AddressDescriptor) = (result.TLBRecord_addrdesc) in sail2_state_monad$bindS
          (sail2_state_monad$liftRS (AArch64_AddressSizeFault ipaddress level acctype iswrite T s2fs1walk)) (\ (w__30 :
            FaultRecord) . 
          let (tmp_200 : AddressDescriptor) = ((tmp_200 with<| AddressDescriptor_fault := w__30|>)) in
          let (result : TLBRecord) = ((result with<| TLBRecord_addrdesc := tmp_200|>)) in
          sail2_state_monad$returnS result)
        else
          let baselowerbound =
            ((((( 3 : int):ii) + ((ex_int inputsize)))) -
              (((((((( 3 : int):ii) - ((ex_int level)))) * ((ex_int stride))))
                  +
                  ((ex_int grainsize))))) in sail2_state_monad$bindS (sail2_state_monad$seqS
          (sail2_state_monad$liftRS (sail2_state_monad$assert_expS T ""))
          (sail2_state_monad$liftRS ((undefined_bitvector (( 52 : int):ii)  : ( 52 words$word) M)))) (\ (baseaddress : 52 bits) .  sail2_state_monad$bindS
          (if (((((ex_int outputsize)) = (( 52 : int):ii)))) then
             let z = (if ((baselowerbound < (( 6 : int):ii))) then (( 6 : int):ii) else baselowerbound) in sail2_state_monad$seqS
             (sail2_state_monad$liftRS (sail2_state_monad$assert_expS T ""))
             (let (baseaddress : 52 bits) =
               ((concat_vec ((slice baseregister (( 2 : int):ii) (( 4 : int):ii)  :  4 words$word))
                  ((slice_zeros_concat ((((((~ z)) + (( 48 : int):ii))) + z))
                      baseregister z ((((~ z)) + (( 48 : int):ii))) z
                     :  48 words$word))
                 :  52 words$word)) in
             sail2_state_monad$returnS baseaddress)
           else
             let (baseaddress : 52 bits) =
               ((place_slice (( 52 : int):ii) baseregister baselowerbound
                  ((((~ baselowerbound)) + (( 48 : int):ii))) baselowerbound
                 :  52 words$word)) in
             sail2_state_monad$returnS baseaddress) (\ (baseaddress : 52 bits) . 
          let (ns_table : 1 bits) =
            (if lookupsecure then (vec_of_bits [B0]  :  1 words$word)
            else (vec_of_bits [B1]  :  1 words$word)) in
          let (ap_table : 2 bits) = ((vec_of_bits [B0;B0]  :  2 words$word)) in
          let (xn_table : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in
          let (pxn_table : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in
          let (addrselecttop : ii) = (((ex_int inputsize)) - (( 1 : int):ii)) in sail2_state_monad$bindS
          (sail2_state$and_boolS
            (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveNVExt () )) /\ ((HaveEL EL2))))))
               ( sail2_state_monad$bindS(sail2_state_monad$liftRS ((sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M))) (\ (w__31 : 64 bits) . 
                sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__31 (( 42 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
            ( sail2_state_monad$bindS(sail2_state_monad$liftRS ((sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M))) (\ (w__33 : 64 bits) . 
             sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__33 (( 43 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (apply_nvnv1_effect : bool) .  sail2_state_monad$bindS
          (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (blocktranslate : bool) .  sail2_state_monad$bindS
          (sail2_state_monad$liftRS ((undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M))) (\ (desc : 64 bits) .  sail2_state_monad$bindS
          (sail2_state_monad$liftRS (undefined_AccessDescriptor () )) (\ (accdesc : AccessDescriptor) .  sail2_state_monad$bindS
          (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (hwupdatewalk : bool) .  sail2_state_monad$bindS
          (sail2_state_monad$liftRS (undefined_AddressDescriptor () )) (\ (descaddr2 : AddressDescriptor) .  sail2_state_monad$bindS
          (sail2_state_monad$liftRS (undefined_int () )) (\ (addrselectbottom : ii) .  sail2_state_monad$bindS
          (sail2_state$untilS (accdesc,
                   addrselectbottom,
                   addrselecttop,
                   baseaddress,
                   blocktranslate,
                   desc,
                   descaddr,
                   descaddr2,
                   level,
                   result)
            (\ varstup . 
            let (accdesc,
                 addrselectbottom,
                 addrselecttop,
                 baseaddress,
                 blocktranslate,
                 desc,
                 descaddr,
                 descaddr2,
                 level,
                 result) = varstup in
              sail2_state_monad$returnS blocktranslate)
            (\ varstup . 
            let (accdesc,
                 addrselectbottom,
                 addrselecttop,
                 baseaddress,
                 blocktranslate,
                 desc,
                 descaddr,
                 descaddr2,
                 level,
                 result) = varstup in
              let addrselectbottom =
                ((((((( 3 : int):ii) - ((ex_int level)))) * ((ex_int stride))))
                  +
                  ((ex_int grainsize))) in sail2_state_monad$bindS
              (sail2_state_monad$liftRS ((ZeroExtend_slice_append (( 52 : int):ii) inputaddr addrselectbottom
                        ((((((ex_int addrselecttop)) - ((ex_int addrselectbottom))))
                            +
                            (( 1 : int):ii))) (vec_of_bits [B0;B0;B0]  :  3 words$word)
                       : ( 52 words$word) M))) (\ (index : 52 bits) . 
              let (tmp_210 : FullAddress) = (descaddr.AddressDescriptor_paddress) in
              let tmp_210 =
                ((tmp_210 with<|
                  FullAddress_physicaladdress := ((or_vec baseaddress index  :  52 words$word))|>)) in
              let descaddr = ((descaddr with<| AddressDescriptor_paddress := tmp_210|>)) in
              let (tmp_220 : FullAddress) = (descaddr.AddressDescriptor_paddress) in
              let tmp_220 = ((tmp_220 with<| FullAddress_NS := ns_table|>)) in
              let descaddr = ((descaddr with<| AddressDescriptor_paddress := tmp_220|>)) in
              let descaddr2 = descaddr in sail2_state_monad$bindS
              (sail2_state_monad$liftRS ((ZeroExtend__1 (( 64 : int):ii) vaddress  : ( 64 words$word) M))) (\ (w__34 : 64 bits) . 
              let descaddr2 = ((descaddr2 with<| AddressDescriptor_vaddress := w__34|>)) in sail2_state_monad$bindS
              (sail2_state_monad$liftRS (CreateAccessDescriptorPTW acctype T s2fs1walk level)) (\ (w__35 :
                AccessDescriptor) . 
              let accdesc = w__35 in sail2_state_monad$bindS
              (sail2_state_monad$liftRS ((aget__Mem descaddr2 (( 8 : int):ii) accdesc  : ( 64 words$word) M))) (\ (w__36 : 64
                bits) . 
              let desc = w__36 in sail2_state_monad$bindS
              (if reversedescriptors then sail2_state_monad$liftRS ((BigEndianReverse desc  : ( 64 words$word) M))
               else sail2_state_monad$returnS desc) (\ (desc : 64 bits) .  sail2_state_monad$bindS
              (if (((((((vec_of_bits [access_vec_dec desc (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))) \/ ((((((((slice desc (( 0 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((((ex_int level)) = (( 3 : int):ii))))))))))
               then
                 let (tmp_240 : AddressDescriptor) = (result.TLBRecord_addrdesc) in sail2_state_monad$bindS
                 (sail2_state_monad$liftRS (AArch64_TranslationFault ipaddress level acctype iswrite T s2fs1walk)) (\ (w__38 :
                   FaultRecord) . 
                 let tmp_240 = ((tmp_240 with<| AddressDescriptor_fault := w__38|>)) in
                 let result = ((result with<| TLBRecord_addrdesc := tmp_240|>)) in sail2_state_monad$seqS
                 (sail2_state_monad$early_returnS result : (unit, TLBRecord) MR)
                 (sail2_state_monad$returnS (addrselecttop, baseaddress, blocktranslate, level, result)))
               else if ((((((((slice desc (( 0 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))) \/ (((((ex_int level)) = (( 3 : int):ii)))))))
               then
                 let (blocktranslate : bool) = T in
                 sail2_state_monad$returnS (addrselecttop, baseaddress, blocktranslate, level, result)
               else sail2_state_monad$bindS
                 (sail2_state$or_boolS
                   (sail2_state_monad$returnS ((((((((((ex_int outputsize)) < (( 52 : int):ii))) /\ largegrain))) /\ ((~ ((IsZero ((slice desc (( 12 : int):ii) (( 4 : int):ii)  :  4 words$word))))))))))
                   (sail2_state$and_boolS (sail2_state_monad$returnS ((((ex_int outputsize)) < (( 48 : int):ii))))
                      ( sail2_state_monad$bindS(sail2_state_monad$liftRS (IsZero_slice desc outputsize
                                ((((~ ((ex_int outputsize)))) + (( 48 : int):ii))))) (\ (w__39 :
                         bool) . 
                       sail2_state_monad$returnS ((~ w__39)))))) (\ (w__41 : bool) . 
                 if w__41 then
                   let (tmp_250 : AddressDescriptor) = (result.TLBRecord_addrdesc) in sail2_state_monad$bindS
                   (sail2_state_monad$liftRS (AArch64_AddressSizeFault ipaddress level acctype iswrite T s2fs1walk)) (\ (w__42 :
                     FaultRecord) . 
                   let tmp_250 = ((tmp_250 with<| AddressDescriptor_fault := w__42|>)) in
                   let result = ((result with<| TLBRecord_addrdesc := tmp_250|>)) in sail2_state_monad$seqS
                   (sail2_state_monad$early_returnS result : (unit, TLBRecord) MR)
                   (sail2_state_monad$returnS (addrselecttop, baseaddress, blocktranslate, level, result)))
                 else
                   let gsz = grainsize in sail2_state_monad$seqS
                   (sail2_state_monad$liftRS (sail2_state_monad$assert_expS T ""))
                   (let (baseaddress : 52 bits) =
                     (if (((((ex_int outputsize)) = (( 52 : int):ii)))) then
                       (concat_vec ((slice desc (( 12 : int):ii) (( 4 : int):ii)  :  4 words$word))
                          ((slice_zeros_concat
                              ((((((~ gsz)) + (( 48 : int):ii))) + gsz)) desc
                              gsz ((((~ gsz)) + (( 48 : int):ii))) gsz
                             :  48 words$word))
                         :  52 words$word)
                     else
                       (place_slice (( 52 : int):ii) desc gsz ((((~ gsz)) + (( 48 : int):ii)))
                          gsz
                         :  52 words$word)) in
                   let (level : ii) = (((ex_int level)) + (( 1 : int):ii)) in
                   let (addrselecttop : ii) = (((ex_int addrselectbottom)) - (( 1 : int):ii)) in
                   let (blocktranslate : bool) = F in
                   sail2_state_monad$returnS (addrselecttop, baseaddress, blocktranslate, level, result)))) (\ varstup .  let ((addrselecttop :
                ii), (baseaddress : 52 bits), (blocktranslate : bool), (level : ii), (result :
                TLBRecord)) = varstup in
              sail2_state_monad$returnS (accdesc,
                      addrselectbottom,
                      addrselecttop,
                      baseaddress,
                      blocktranslate,
                      desc,
                      descaddr,
                      descaddr2,
                      level,
                      result))))))))) (\ varstup .  let ((accdesc : AccessDescriptor), (addrselectbottom :
            ii), (addrselecttop : ii), (baseaddress : 52 bits), (blocktranslate : bool), (desc : 64
            bits), (descaddr : AddressDescriptor), (descaddr2 : AddressDescriptor), (level : ii), (result :
            TLBRecord)) = varstup in
          if ((((ex_int level)) < ((ex_int firstblocklevel)))) then
            let (tmp_260 : AddressDescriptor) = (result.TLBRecord_addrdesc) in sail2_state_monad$bindS
            (sail2_state_monad$liftRS (AArch64_TranslationFault ipaddress level acctype iswrite T s2fs1walk)) (\ (w__43 :
              FaultRecord) . 
            let (tmp_260 : AddressDescriptor) = ((tmp_260 with<| AddressDescriptor_fault := w__43|>)) in
            let (result : TLBRecord) = ((result with<| TLBRecord_addrdesc := tmp_260|>)) in
            sail2_state_monad$returnS result)
          else sail2_state_monad$bindS
            (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (contiguousbitcheck : bool) . 
            let (contiguousbitcheck : bool) =
              (if largegrain then
                ((((((ex_int level)) = (( 2 : int):ii)))) /\ ((((ex_int inputsize)) < (( 34 : int):ii))))
              else if midgrain then
                ((((((ex_int level)) = (( 2 : int):ii)))) /\ ((((ex_int inputsize)) < (( 30 : int):ii))))
              else ((((((ex_int level)) = (( 1 : int):ii)))) /\ ((((ex_int inputsize)) < (( 34 : int):ii))))) in sail2_state_monad$bindS
            (if (((contiguousbitcheck /\ ((((vec_of_bits [access_vec_dec desc (( 52 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) then sail2_state_monad$bindS
               (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (w__44 : bool) . 
               if w__44 then
                 let (tmp_270 : AddressDescriptor) = (result.TLBRecord_addrdesc) in sail2_state_monad$bindS
                 (sail2_state_monad$liftRS (AArch64_TranslationFault ipaddress level acctype iswrite T s2fs1walk)) (\ (w__45 :
                   FaultRecord) . 
                 let tmp_270 = ((tmp_270 with<| AddressDescriptor_fault := w__45|>)) in
                 let result = ((result with<| TLBRecord_addrdesc := tmp_270|>)) in sail2_state_monad$seqS
                 (sail2_state_monad$early_returnS result : (unit, TLBRecord) MR) (sail2_state_monad$returnS result))
               else sail2_state_monad$returnS result)
             else sail2_state_monad$returnS result) (\ (result : TLBRecord) .  sail2_state_monad$bindS
            (sail2_state$or_boolS
              (sail2_state_monad$returnS ((((((((((ex_int outputsize)) < (( 52 : int):ii))) /\ largegrain))) /\ ((~ ((IsZero ((slice desc (( 12 : int):ii) (( 4 : int):ii)  :  4 words$word))))))))))
              (sail2_state$and_boolS (sail2_state_monad$returnS ((((ex_int outputsize)) < (( 48 : int):ii))))
                 ( sail2_state_monad$bindS(sail2_state_monad$liftRS (IsZero_slice desc outputsize
                           ((((~ ((ex_int outputsize)))) + (( 48 : int):ii))))) (\ (w__46 :
                    bool) . 
                  sail2_state_monad$returnS ((~ w__46)))))) (\ (w__48 : bool) . 
            if w__48 then
              let (tmp_280 : AddressDescriptor) = (result.TLBRecord_addrdesc) in sail2_state_monad$bindS
              (sail2_state_monad$liftRS (AArch64_AddressSizeFault ipaddress level acctype iswrite T s2fs1walk)) (\ (w__49 :
                FaultRecord) . 
              let (tmp_280 : AddressDescriptor) = ((tmp_280 with<| AddressDescriptor_fault := w__49|>)) in
              let (result : TLBRecord) = ((result with<| TLBRecord_addrdesc := tmp_280|>)) in
              sail2_state_monad$returnS result)
            else sail2_state_monad$bindS
              (sail2_state_monad$liftRS ((undefined_bitvector (( 52 : int):ii)  : ( 52 words$word) M))) (\ (outputaddress : 52
                bits) . 
              let asb = addrselectbottom in sail2_state_monad$seqS
              (sail2_state_monad$liftRS (sail2_state_monad$assert_expS T ""))
              (let (outputaddress : 52 bits) =
                (if (((((ex_int outputsize)) = (( 52 : int):ii)))) then
                  (concat_vec ((slice desc (( 12 : int):ii) (( 4 : int):ii)  :  4 words$word))
                     ((slice_slice_concat (( 48 : int):ii) desc asb
                         ((((~ asb)) + (( 48 : int):ii))) inputaddr (( 0 : int):ii) asb
                        :  48 words$word))
                    :  52 words$word)
                else
                  (slice_slice_concat (( 52 : int):ii) desc asb ((((~ asb)) + (( 48 : int):ii)))
                     inputaddr (( 0 : int):ii) asb
                    :  52 words$word)) in sail2_state_monad$bindS
              (if ((((vec_of_bits [access_vec_dec desc (( 10 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))) then
                 if ((~ update_AF)) then
                   let (tmp_290 : AddressDescriptor) = (result.TLBRecord_addrdesc) in sail2_state_monad$bindS
                   (sail2_state_monad$liftRS (AArch64_AccessFlagFault ipaddress level acctype iswrite T s2fs1walk)) (\ (w__50 :
                     FaultRecord) . 
                   let tmp_290 = ((tmp_290 with<| AddressDescriptor_fault := w__50|>)) in
                   let result = ((result with<| TLBRecord_addrdesc := tmp_290|>)) in sail2_state_monad$seqS
                   (sail2_state_monad$early_returnS result : (unit, TLBRecord) MR) (sail2_state_monad$returnS result))
                 else
                   let (tmp_300 : DescriptorUpdate) = (result.TLBRecord_descupdate) in
                   let (tmp_300 : DescriptorUpdate) = ((tmp_300 with<| DescriptorUpdate_AF := T|>)) in
                   let (result : TLBRecord) = ((result with<| TLBRecord_descupdate := tmp_300|>)) in
                   sail2_state_monad$returnS result
               else sail2_state_monad$returnS result) (\ (result : TLBRecord) . 
              let ((desc : 64 bits), (result : TLBRecord)) =
                (if (((update_AP /\ ((((vec_of_bits [access_vec_dec desc (( 51 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) then
                  let ((desc : 64 bits), (result : TLBRecord)) =
                    (if ((((vec_of_bits [access_vec_dec desc (( 7 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))) then
                      let (desc : 64 bits) =
                        ((set_slice (( 64 : int):ii) (( 1 : int):ii) desc (( 7 : int):ii) (vec_of_bits [B1]  :  1 words$word)
                          :  64 words$word)) in
                      let (tmp_320 : DescriptorUpdate) = (result.TLBRecord_descupdate) in
                      let (tmp_320 : DescriptorUpdate) =
                        ((tmp_320 with<| DescriptorUpdate_AP := T|>)) in
                      let (result : TLBRecord) = ((result with<| TLBRecord_descupdate := tmp_320|>)) in
                      (desc, result)
                    else (desc, result)) in
                  (desc, result)
                else (desc, result)) in
              let (tmp_330 : DescriptorUpdate) = (result.TLBRecord_descupdate) in
              let tmp_330 = ((tmp_330 with<| DescriptorUpdate_descaddr := descaddr|>)) in
              let result = ((result with<| TLBRecord_descupdate := tmp_330|>)) in sail2_state_monad$bindS
              (sail2_state_monad$liftRS ((undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M))) (\ (xn : 1 bits) .  sail2_state_monad$bindS
              (sail2_state_monad$liftRS ((undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M))) (\ (pxn : 1 bits) . 
              let (xn : 1 bits) =
                (if apply_nvnv1_effect then
                  let (pxn : 1 bits) = ((vec_of_bits [access_vec_dec desc (( 54 : int):ii)]  :  1 words$word)) in
                  (vec_of_bits [B0]  :  1 words$word)
                else
                  let (xn : 1 bits) = ((vec_of_bits [access_vec_dec desc (( 54 : int):ii)]  :  1 words$word)) in
                  let (pxn : 1 bits) = ((vec_of_bits [access_vec_dec desc (( 53 : int):ii)]  :  1 words$word)) in
                  xn) in
              let (contiguousbit : 1 bits) =
                ((vec_of_bits [access_vec_dec desc (( 52 : int):ii)]  :  1 words$word)) in
              let (nG : 1 bits) = ((vec_of_bits [access_vec_dec desc (( 11 : int):ii)]  :  1 words$word)) in
              let (sh : 2 bits) = ((slice desc (( 8 : int):ii) (( 2 : int):ii)  :  2 words$word)) in sail2_state_monad$bindS
              (sail2_state_monad$liftRS ((undefined_bitvector (( 3 : int):ii)  : ( 3 words$word) M))) (\ (ap : 3 bits) . 
              let (ap : 3 bits) =
                (if apply_nvnv1_effect then
                  (concat_vec (vec_of_bits [access_vec_dec desc (( 7 : int):ii)]  :  1 words$word)
                     (vec_of_bits [B0;B1]  :  2 words$word)
                    :  3 words$word)
                else
                  (concat_vec ((slice desc (( 6 : int):ii) (( 2 : int):ii)  :  2 words$word))
                     (vec_of_bits [B1]  :  1 words$word)
                    :  3 words$word)) in
              let (memattr : 4 bits) = ((slice desc (( 2 : int):ii) (( 4 : int):ii)  :  4 words$word)) in sail2_state_monad$bindS
              (sail2_state_monad$liftRS ((undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M))) (\ (w__51 : 4 bits) . 
              let result = ((result with<| TLBRecord_domain := w__51|>)) in
              let result = ((result with<| TLBRecord_level := level|>)) in
              let result =
                ((result with<|
                  TLBRecord_blocksize :=
                    ((pow2
                        (((((((( 3 : int):ii) - ((ex_int level)))) * ((ex_int stride))))
                            +
                            ((ex_int grainsize))))))|>)) in
              let (tmp_480 : 3 bits) = (result.TLBRecord_perms.Permissions_ap) in
              let tmp_480 =
                ((set_slice (( 3 : int):ii) (( 2 : int):ii) tmp_480 (( 1 : int):ii) ((slice ap (( 1 : int):ii) (( 2 : int):ii)  :  2 words$word))
                  :  3 words$word)) in
              let (tmp_490 : Permissions) = (result.TLBRecord_perms) in
              let tmp_490 = ((tmp_490 with<| Permissions_ap := tmp_480|>)) in
              let result = ((result with<| TLBRecord_perms := tmp_490|>)) in
              let (tmp_500 : 3 bits) = (result.TLBRecord_perms.Permissions_ap) in
              let tmp_500 =
                ((set_slice (( 3 : int):ii) (( 1 : int):ii) tmp_500 (( 0 : int):ii) (vec_of_bits [B1]  :  1 words$word)
                  :  3 words$word)) in
              let (tmp_510 : Permissions) = (result.TLBRecord_perms) in
              let tmp_510 = ((tmp_510 with<| Permissions_ap := tmp_500|>)) in
              let result = ((result with<| TLBRecord_perms := tmp_510|>)) in
              let (tmp_520 : Permissions) = (result.TLBRecord_perms) in
              let tmp_520 = ((tmp_520 with<| Permissions_xn := xn|>)) in
              let result = ((result with<| TLBRecord_perms := tmp_520|>)) in
              let (result : TLBRecord) =
                (if ((HaveExtendedExecuteNeverExt () )) then
                  let (tmp_530 : Permissions) = (result.TLBRecord_perms) in
                  let (tmp_530 : Permissions) =
                    ((tmp_530 with<|
                      Permissions_xxn := ((vec_of_bits [access_vec_dec desc (( 53 : int):ii)]  :  1 words$word))|>)) in
                  (result with<| TLBRecord_perms := tmp_530|>)
                else result) in
              let (tmp_540 : Permissions) = (result.TLBRecord_perms) in
              let tmp_540 = ((tmp_540 with<| Permissions_pxn := ((vec_of_bits [B0]  :  1 words$word))|>)) in
              let result = ((result with<| TLBRecord_perms := tmp_540|>)) in
              let result = ((result with<| TLBRecord_nG := ((vec_of_bits [B0]  :  1 words$word))|>)) in
              let (tmp_550 : AddressDescriptor) = (result.TLBRecord_addrdesc) in sail2_state_monad$bindS
              (sail2_state_monad$liftRS (S2AttrDecode sh memattr acctype)) (\ (w__52 : MemoryAttributes) . 
              let tmp_550 = ((tmp_550 with<| AddressDescriptor_memattrs := w__52|>)) in
              let result = ((result with<| TLBRecord_addrdesc := tmp_550|>)) in
              let (tmp_560 : FullAddress) = (result.TLBRecord_addrdesc.AddressDescriptor_paddress) in
              let tmp_560 = ((tmp_560 with<| FullAddress_NS := ((vec_of_bits [B1]  :  1 words$word))|>)) in
              let (tmp_570 : AddressDescriptor) = (result.TLBRecord_addrdesc) in
              let tmp_570 = ((tmp_570 with<| AddressDescriptor_paddress := tmp_560|>)) in
              let result = ((result with<| TLBRecord_addrdesc := tmp_570|>)) in
              let (tmp_580 : FullAddress) = (result.TLBRecord_addrdesc.AddressDescriptor_paddress) in
              let tmp_580 = ((tmp_580 with<| FullAddress_physicaladdress := outputaddress|>)) in
              let (tmp_590 : AddressDescriptor) = (result.TLBRecord_addrdesc) in
              let tmp_590 = ((tmp_590 with<| AddressDescriptor_paddress := tmp_580|>)) in
              let result = ((result with<| TLBRecord_addrdesc := tmp_590|>)) in
              let (tmp_600 : AddressDescriptor) = (result.TLBRecord_addrdesc) in sail2_state_monad$bindS
              (sail2_state_monad$liftRS (AArch64_NoFault () )) (\ (w__53 : FaultRecord) . 
              let (tmp_600 : AddressDescriptor) = ((tmp_600 with<| AddressDescriptor_fault := w__53|>)) in
              let (result : TLBRecord) = ((result with<| TLBRecord_addrdesc := tmp_600|>)) in
              let (result : TLBRecord) =
                ((result with<|
                  TLBRecord_contiguous := (((contiguousbit = (vec_of_bits [B1]  :  1 words$word))))|>)) in
              let (result : TLBRecord) =
                (if ((HaveCommonNotPrivateTransExt () )) then
                  (result with<|
                    TLBRecord_CnP := ((vec_of_bits [access_vec_dec baseregister (( 0 : int):ii)]  :  1 words$word))|>)
                else result) in
              sail2_state_monad$returnS result))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))`;


val _ = Define `
 ((AArch64_SecondStageTranslate:AddressDescriptor ->(64)words$word -> AccType -> bool -> bool -> bool -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((AddressDescriptor),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) S1 vaddress acctype iswrite wasaligned s2fs1walk size1 hwupdatewalk=  (sail2_state_monad$bindS
   (HasS2Translation () ) (\ (w__0 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS w__0 "HasS2Translation()")
   (sail2_state$or_boolS
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__1 : 64 bits) . 
      sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__1 (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__2 : 64 bits) . 
      sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__2 (( 12 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))) (\ (s2_enabled : bool) . 
   let (secondstage : bool) = T in sail2_state_monad$bindS
   (undefined_AddressDescriptor () ) (\ (result : AddressDescriptor) .  sail2_state_monad$bindS
   (undefined_TLBRecord () ) (\ (S2 : TLBRecord) .  sail2_state_monad$bindS
   (undefined_bitvector (( 52 : int):ii)  : ( 52 words$word) M) (\ (ipaddress : 52 bits) . 
   if s2_enabled then
     let ipaddress =
       ((slice S1.AddressDescriptor_paddress.FullAddress_physicaladdress (( 0 : int):ii) (( 52 : int):ii)  :  52 words$word)) in sail2_state_monad$bindS
     (AArch64_TranslationTableWalk_SecondStage ipaddress vaddress acctype iswrite s2fs1walk size1) (\ (w__3 :
       TLBRecord) . 
     let S2 = w__3 in sail2_state_monad$bindS
     (if ((((((((((((((~ wasaligned)) /\ (((acctype <> AccType_IFETCH)))))) \/ (((acctype = AccType_DCZVA)))))) /\ (((S2.TLBRecord_addrdesc.AddressDescriptor_memattrs.MemoryAttributes_typ = MemType_Device)))))) /\ ((~ ((IsFault S2.TLBRecord_addrdesc))))))) then
        let (tmp_710 : AddressDescriptor) = (S2.TLBRecord_addrdesc) in sail2_state_monad$bindS
        (AArch64_AlignmentFault acctype iswrite secondstage) (\ (w__4 : FaultRecord) . 
        let (tmp_710 : AddressDescriptor) = ((tmp_710 with<| AddressDescriptor_fault := w__4|>)) in
        let (S2 : TLBRecord) = ((S2 with<| TLBRecord_addrdesc := tmp_710|>)) in
        sail2_state_monad$returnS S2)
      else sail2_state_monad$returnS S2) (\ (S2 : TLBRecord) .  sail2_state_monad$bindS
     (if ((~ ((IsFault S2.TLBRecord_addrdesc)))) then
        let (tmp_720 : AddressDescriptor) = (S2.TLBRecord_addrdesc) in sail2_state_monad$bindS
        (AArch64_CheckS2Permission S2.TLBRecord_perms vaddress ipaddress S2.TLBRecord_level acctype
          iswrite s2fs1walk hwupdatewalk) (\ (w__5 : FaultRecord) . 
        let (tmp_720 : AddressDescriptor) = ((tmp_720 with<| AddressDescriptor_fault := w__5|>)) in
        let (S2 : TLBRecord) = ((S2 with<| TLBRecord_addrdesc := tmp_720|>)) in
        sail2_state_monad$returnS S2)
      else sail2_state_monad$returnS S2) (\ (S2 : TLBRecord) .  sail2_state_monad$bindS
     (if (((((((((((~ s2fs1walk)) /\ ((~ ((IsFault S2.TLBRecord_addrdesc))))))) /\ (((S2.TLBRecord_addrdesc.AddressDescriptor_memattrs.MemoryAttributes_typ = MemType_Device)))))) /\ (((acctype = AccType_IFETCH)))))) then sail2_state_monad$bindS
        (AArch64_InstructionDevice S2.TLBRecord_addrdesc vaddress ipaddress S2.TLBRecord_level
          acctype iswrite secondstage s2fs1walk) (\ (w__6 : AddressDescriptor) . 
        let (S2 : TLBRecord) = ((S2 with<| TLBRecord_addrdesc := w__6|>)) in
        sail2_state_monad$returnS S2)
      else sail2_state_monad$returnS S2) (\ (S2 : TLBRecord) .  sail2_state_monad$bindS
     (sail2_state$and_boolS
       (sail2_state$and_boolS (sail2_state_monad$returnS (((s2fs1walk /\ ((~ ((IsFault S2.TLBRecord_addrdesc))))))))
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__7 : 64 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__7 (( 2 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
       (sail2_state_monad$returnS (((S2.TLBRecord_addrdesc.AddressDescriptor_memattrs.MemoryAttributes_typ = MemType_Device))))) (\ (w__9 : bool) .  sail2_state_monad$bindS
     (if w__9 then
        let (tmp_730 : AddressDescriptor) = (S2.TLBRecord_addrdesc) in sail2_state_monad$bindS
        (AArch64_PermissionFault ipaddress S2.TLBRecord_level acctype iswrite secondstage s2fs1walk) (\ (w__10 :
          FaultRecord) . 
        let (tmp_730 : AddressDescriptor) = ((tmp_730 with<| AddressDescriptor_fault := w__10|>)) in
        let (S2 : TLBRecord) = ((S2 with<| TLBRecord_addrdesc := tmp_730|>)) in
        sail2_state_monad$returnS S2)
      else sail2_state_monad$returnS S2) (\ (S2 : TLBRecord) . 
     let (tmp_740 : AddressDescriptor) = (S2.TLBRecord_addrdesc) in sail2_state_monad$bindS
     (AArch64_CheckAndUpdateDescriptor_SecondStage S2.TLBRecord_descupdate
       S2.TLBRecord_addrdesc.AddressDescriptor_fault vaddress acctype iswrite s2fs1walk hwupdatewalk) (\ (w__11 :
       FaultRecord) . 
     let tmp_740 = ((tmp_740 with<| AddressDescriptor_fault := w__11|>)) in
     let S2 = ((S2 with<| TLBRecord_addrdesc := tmp_740|>)) in
     CombineS1S2Desc S1 S2.TLBRecord_addrdesc)))))))
   else sail2_state_monad$returnS S1)))))))`;


val _ = Define `
 ((AArch64_SecondStageWalk:AddressDescriptor ->(64)words$word -> AccType -> bool -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((AddressDescriptor),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) S1 vaddress acctype iswrite size1 hwupdatewalk=  (sail2_state_monad$bindS
   (HasS2Translation () ) (\ (w__0 : bool) .  sail2_state_monad$seqS
   (sail2_state_monad$assert_expS w__0 "HasS2Translation()")
   (let (s2fs1walk : bool) = T in
   let (wasaligned : bool) = T in
   AArch64_SecondStageTranslate S1 vaddress acctype iswrite wasaligned s2fs1walk size1 hwupdatewalk))))`;


(*val DoubleLockStatus : unit -> M bool*)

val _ = Define `
 ((DoubleLockStatus:unit ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (ELUsingAArch32 EL1) (\ (w__0 : bool) . 
   if w__0 then
     sail2_state$and_boolS
       (sail2_state$and_boolS
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS DBGOSDLR_ref  : ( 32 words$word) M) (\ (w__1 : 32 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__1 (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS DBGPRCR_ref  : ( 32 words$word) M) (\ (w__2 : 32 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__2 (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))))))
       ( sail2_state_monad$bindS(Halted () ) (\ (w__4 : bool) .  sail2_state_monad$returnS ((~ w__4))))
   else
     sail2_state$and_boolS
       (sail2_state$and_boolS
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS OSDLR_EL1_ref  : ( 32 words$word) M) (\ (w__6 : 32 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__6 (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS DBGPRCR_EL1_ref  : ( 32 words$word) M) (\ (w__7 : 32 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__7 (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))))))
       ( sail2_state_monad$bindS(Halted () ) (\ (w__9 : bool) .  sail2_state_monad$returnS ((~ w__9)))))))`;


(*val HaltingAllowed : unit -> M bool*)

val _ = Define `
 ((HaltingAllowed:unit ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (sail2_state$or_boolS ((Halted () )) ((DoubleLockStatus () ))) (\ (w__2 : bool) . 
   if w__2 then sail2_state_monad$returnS F
   else sail2_state_monad$bindS
     (IsSecure () ) (\ (w__3 : bool) . 
     if w__3 then ExternalSecureInvasiveDebugEnabled () 
     else ExternalInvasiveDebugEnabled () ))))`;


(*val system_exceptions_debug_halt_decode : mword ty3 -> mword ty16 -> mword ty3 -> mword ty2 -> M unit*)

val _ = Define `
 ((system_exceptions_debug_halt_decode:(3)words$word ->(16)words$word ->(3)words$word ->(2)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) opc imm16 op2 LL=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (sail2_state$or_boolS
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS EDSCR_ref  : ( 32 words$word) M) (\ (w__0 : 32 bits) . 
      sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__0 (( 14 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))
     ( sail2_state_monad$bindS(HaltingAllowed () ) (\ (w__1 : bool) .  sail2_state_monad$returnS ((~ w__1)))))) (\ (w__2 : bool) .  sail2_state_monad$seqS
   (if w__2 then UndefinedFault ()  else sail2_state_monad$returnS () ) (aarch64_system_exceptions_debug_halt () ))))`;


(*val HaltOnBreakpointOrWatchpoint : unit -> M bool*)

val _ = Define `
 ((HaltOnBreakpointOrWatchpoint:unit ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$and_boolS
     (sail2_state$and_boolS ((HaltingAllowed () ))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS EDSCR_ref  : ( 32 words$word) M) (\ (w__1 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__1 (( 14 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS OSLSR_EL1_ref  : ( 32 words$word) M) (\ (w__3 : 32 bits) . 
      sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__3 (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))))`;


(*val DebugTargetFrom : bool -> M (mword ty2)*)

val _ = Define `
 ((DebugTargetFrom:bool ->(regstate)sail2_state_monad$sequential_state ->((((2)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) secure=  (sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (route_to_el2 : bool) .  sail2_state_monad$bindS
   (if (((((HaveEL EL2)) /\ ((~ secure))))) then sail2_state_monad$bindS
      (ELUsingAArch32 EL2) (\ (w__0 : bool) . 
      if w__0 then
        sail2_state$or_boolS
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS HDCR_ref  : ( 32 words$word) M) (\ (w__1 : 32 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__1 (( 8 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_ref  : ( 32 words$word) M) (\ (w__2 : 32 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__2 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))
      else
        sail2_state$or_boolS
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS MDCR_EL2_ref  : ( 32 words$word) M) (\ (w__4 : 32 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__4 (( 8 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__5 : 64 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__5 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
    else sail2_state_monad$returnS F) (\ (route_to_el2 : bool) .  sail2_state_monad$bindS
   (undefined_bitvector (( 2 : int):ii)  : ( 2 words$word) M) (\ (target : 2 bits) . 
   let (target : 2 bits) =
     (if route_to_el2 then EL2
     else if ((((((((HaveEL EL3)) /\ ((HighestELUsingAArch32 () ))))) /\ secure))) then EL3
     else EL1) in
   sail2_state_monad$returnS target)))))`;


(*val DebugTarget : unit -> M (mword ty2)*)

val _ = Define `
 ((DebugTarget:unit ->(regstate)sail2_state_monad$sequential_state ->((((2)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (IsSecure () ) (\ (secure : bool) .  (DebugTargetFrom secure  : ( 2 words$word) M))))`;


(*val SSAdvance : unit -> M unit*)

val _ = Define `
 ((SSAdvance:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (DebugTarget ()   : ( 2 words$word) M) (\ (target : 2 bits) .  sail2_state_monad$bindS
   (sail2_state$and_boolS ( sail2_state_monad$bindS(ELUsingAArch32 target) (\ (w__0 : bool) .  sail2_state_monad$returnS ((~ w__0))))
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS MDSCR_EL1_ref  : ( 32 words$word) M) (\ (w__1 : 32 bits) . 
      sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__1 (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (step_enabled : bool) .  sail2_state_monad$bindS
   (sail2_state$and_boolS (sail2_state_monad$returnS step_enabled)
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) . 
      sail2_state_monad$returnS (((w__2.ProcState_SS = (vec_of_bits [B1]  :  1 words$word))))))) (\ (active_not_pending :
     bool) . 
   if active_not_pending then sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__3 : ProcState) . 
     sail2_state_monad$write_regS PSTATE_ref (w__3 with<| ProcState_SS := ((vec_of_bits [B0]  :  1 words$word))|>))
   else sail2_state_monad$returnS () )))))`;


(*val ConditionHolds : mword ty4 -> M bool*)

val _ = Define `
 ((ConditionHolds:(4)words$word ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) cond=  (sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (result : bool) . 
   let b__0 = ((slice cond (( 1 : int):ii) (( 3 : int):ii)  :  3 words$word)) in sail2_state_monad$bindS
   (if (((b__0 = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) . 
      let (result : bool) = (w__0.ProcState_Z = (vec_of_bits [B1]  :  1 words$word)) in
      sail2_state_monad$returnS result)
    else if (((b__0 = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__1 : ProcState) . 
      let (result : bool) = (w__1.ProcState_C = (vec_of_bits [B1]  :  1 words$word)) in
      sail2_state_monad$returnS result)
    else if (((b__0 = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) . 
      let (result : bool) = (w__2.ProcState_N = (vec_of_bits [B1]  :  1 words$word)) in
      sail2_state_monad$returnS result)
    else if (((b__0 = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__3 : ProcState) . 
      let (result : bool) = (w__3.ProcState_V = (vec_of_bits [B1]  :  1 words$word)) in
      sail2_state_monad$returnS result)
    else if (((b__0 = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) then
      sail2_state$and_boolS
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__4 : ProcState) . 
         sail2_state_monad$returnS (((w__4.ProcState_C = (vec_of_bits [B1]  :  1 words$word))))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__5 : ProcState) . 
         sail2_state_monad$returnS (((w__5.ProcState_Z = (vec_of_bits [B0]  :  1 words$word))))))
    else if (((b__0 = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__7 : ProcState) .  sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__8 : ProcState) . 
      let (result : bool) = (w__7.ProcState_N = w__8.ProcState_V) in
      sail2_state_monad$returnS result))
    else if (((b__0 = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) then
      sail2_state$and_boolS
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__9 : ProcState) .  sail2_state_monad$bindS
         (sail2_state_monad$read_regS PSTATE_ref) (\ (w__10 : ProcState) . 
         sail2_state_monad$returnS (((w__9.ProcState_N = w__10.ProcState_V))))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__11 : ProcState) . 
         sail2_state_monad$returnS (((w__11.ProcState_Z = (vec_of_bits [B0]  :  1 words$word))))))
    else sail2_state_monad$returnS T) (\ (result : bool) . 
   let (result : bool) =
     (if (((((((vec_of_bits [access_vec_dec cond (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) /\ (((cond <> (vec_of_bits [B1;B1;B1;B1]  :  4 words$word))))))) then
       ~ result
     else result) in
   sail2_state_monad$returnS result))))`;


(*val aarch64_integer_conditional_select : mword ty4 -> ii -> ii -> bool -> bool -> ii -> ii -> M unit*)

val _ = Define `
 ((aarch64_integer_conditional_select:(4)words$word -> int -> int -> bool -> bool -> int -> int ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) condition d l__153 else_inc else_inv m n=
    (if (((l__153 = (( 8 : int):ii)))) then
     let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M)) (\ (result : 8 bits) .  sail2_state_monad$bindS
     (aget_X (( 8 : int):ii) n  : ( 8 words$word) M) (\ (operand1 : 8 bits) .  sail2_state_monad$bindS
     (aget_X (( 8 : int):ii) m  : ( 8 words$word) M) (\ (operand2 : 8 bits) .  sail2_state_monad$bindS
     (ConditionHolds condition) (\ (w__0 : bool) . 
     let (result : 8 bits) =
       (if w__0 then operand1
       else
         let (result : 8 bits) = operand2 in
         let (result : 8 bits) = (if else_inv then (not_vec result  :  8 words$word) else result) in
         if else_inc then (add_vec_int result (( 1 : int):ii)  :  8 words$word)
         else result) in
     aset_X d result))))
   else if (((l__153 = (( 16 : int):ii)))) then
     let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M)) (\ (result : 16 bits) .  sail2_state_monad$bindS
     (aget_X (( 16 : int):ii) n  : ( 16 words$word) M) (\ (operand1 : 16 bits) .  sail2_state_monad$bindS
     (aget_X (( 16 : int):ii) m  : ( 16 words$word) M) (\ (operand2 : 16 bits) .  sail2_state_monad$bindS
     (ConditionHolds condition) (\ (w__1 : bool) . 
     let (result : 16 bits) =
       (if w__1 then operand1
       else
         let (result : 16 bits) = operand2 in
         let (result : 16 bits) = (if else_inv then (not_vec result  :  16 words$word) else result) in
         if else_inc then (add_vec_int result (( 1 : int):ii)  :  16 words$word)
         else result) in
     aset_X d result))))
   else if (((l__153 = (( 32 : int):ii)))) then
     let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (result : 32 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) n  : ( 32 words$word) M) (\ (operand1 : 32 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) m  : ( 32 words$word) M) (\ (operand2 : 32 bits) .  sail2_state_monad$bindS
     (ConditionHolds condition) (\ (w__2 : bool) . 
     let (result : 32 bits) =
       (if w__2 then operand1
       else
         let (result : 32 bits) = operand2 in
         let (result : 32 bits) = (if else_inv then (not_vec result  :  32 words$word) else result) in
         if else_inc then (add_vec_int result (( 1 : int):ii)  :  32 words$word)
         else result) in
     aset_X d result))))
   else if (((l__153 = (( 64 : int):ii)))) then
     let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (result : 64 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) n  : ( 64 words$word) M) (\ (operand1 : 64 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) m  : ( 64 words$word) M) (\ (operand2 : 64 bits) .  sail2_state_monad$bindS
     (ConditionHolds condition) (\ (w__3 : bool) . 
     let (result : 64 bits) =
       (if w__3 then operand1
       else
         let (result : 64 bits) = operand2 in
         let (result : 64 bits) = (if else_inv then (not_vec result  :  64 words$word) else result) in
         if else_inc then (add_vec_int result (( 1 : int):ii)  :  64 words$word)
         else result) in
     aset_X d result))))
   else if (((l__153 = (( 128 : int):ii)))) then
     let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M)) (\ (result : 128 bits) .  sail2_state_monad$bindS
     (aget_X (( 128 : int):ii) n  : ( 128 words$word) M) (\ (operand1 : 128 bits) .  sail2_state_monad$bindS
     (aget_X (( 128 : int):ii) m  : ( 128 words$word) M) (\ (operand2 : 128 bits) .  sail2_state_monad$bindS
     (ConditionHolds condition) (\ (w__4 : bool) . 
     let (result : 128 bits) =
       (if w__4 then operand1
       else
         let (result : 128 bits) = operand2 in
         let (result : 128 bits) = (if else_inv then (not_vec result  :  128 words$word) else result) in
         if else_inc then (add_vec_int result (( 1 : int):ii)  :  128 words$word)
         else result) in
     aset_X d result))))
   else
     let dbytes = (ex_int ((l__153 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint"))`;


(*val integer_conditional_select_decode : mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty4 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_conditional_select_decode:(1)words$word ->(1)words$word ->(1)words$word ->(5)words$word ->(4)words$word ->(1)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) sf op S1 Rm cond o2 Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in
   let (m : ii) = (lem$w2ui Rm) in
   let (datasize : int) =
     (if (((sf = (vec_of_bits [B1]  :  1 words$word)))) then (( 64 : int):ii)
     else (( 32 : int):ii)) in
   let (condition : 4 bits) = cond in
   let (else_inv : bool) = (op = (vec_of_bits [B1]  :  1 words$word)) in
   let (else_inc : bool) = (o2 = (vec_of_bits [B1]  :  1 words$word)) in
   aarch64_integer_conditional_select condition d datasize else_inc else_inv m n)))`;


(*val aarch64_integer_conditional_compare_register : mword ty4 -> ii -> mword ty4 -> ii -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_integer_conditional_compare_register:(4)words$word -> int ->(4)words$word -> int -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) condition l__148 flags__arg m n sub_op=
    (if (((l__148 = (( 8 : int):ii)))) then
     let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let flags = flags__arg in sail2_state_monad$bindS
     (aget_X (( 8 : int):ii) n  : ( 8 words$word) M) (\ (operand1 : 8 bits) .  sail2_state_monad$bindS
     (aget_X (( 8 : int):ii) m  : ( 8 words$word) M) (\ (operand2 : 8 bits) . 
     let (carry_in : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in sail2_state_monad$bindS
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M) (\ (anon10 : 8 bits) .  sail2_state_monad$bindS
     (ConditionHolds condition) (\ (w__0 : bool) . 
     let (flags :  4 words$word) =
       (if w__0 then
         let ((carry_in : 1 bits), (operand2 : 8 bits)) =
           (if sub_op then
             let (operand2 : 8 bits) = ((not_vec operand2  :  8 words$word)) in
             let (carry_in : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
             (carry_in, operand2)
           else (carry_in, operand2)) in
         let (tup__0, tup__1) = ((AddWithCarry operand1 operand2 carry_in  : ( 8 words$word #  4 words$word))) in
         let (anon10 : 8 bits) = tup__0 in
         tup__1
       else flags) in
     let (tup__0, tup__1, tup__2, tup__3) =
       ((subrange_vec_dec flags (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
        (subrange_vec_dec flags (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
        (subrange_vec_dec flags (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
        (subrange_vec_dec flags (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__1 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__1 with<| ProcState_N := tup__0|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__2 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__2 with<| ProcState_Z := tup__1|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__3 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__3 with<| ProcState_C := tup__2|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__4 : ProcState) . 
     sail2_state_monad$write_regS PSTATE_ref (w__4 with<| ProcState_V := tup__3|>))))))))))
   else if (((l__148 = (( 16 : int):ii)))) then
     let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let flags = flags__arg in sail2_state_monad$bindS
     (aget_X (( 16 : int):ii) n  : ( 16 words$word) M) (\ (operand1 : 16 bits) .  sail2_state_monad$bindS
     (aget_X (( 16 : int):ii) m  : ( 16 words$word) M) (\ (operand2 : 16 bits) . 
     let (carry_in : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in sail2_state_monad$bindS
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M) (\ (anon10 : 16 bits) .  sail2_state_monad$bindS
     (ConditionHolds condition) (\ (w__5 : bool) . 
     let (flags :  4 words$word) =
       (if w__5 then
         let ((carry_in : 1 bits), (operand2 : 16 bits)) =
           (if sub_op then
             let (operand2 : 16 bits) = ((not_vec operand2  :  16 words$word)) in
             let (carry_in : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
             (carry_in, operand2)
           else (carry_in, operand2)) in
         let (tup__0, tup__1) =
           ((AddWithCarry operand1 operand2 carry_in  : ( 16 words$word #  4 words$word))) in
         let (anon10 : 16 bits) = tup__0 in
         tup__1
       else flags) in
     let (tup__0, tup__1, tup__2, tup__3) =
       ((subrange_vec_dec flags (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
        (subrange_vec_dec flags (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
        (subrange_vec_dec flags (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
        (subrange_vec_dec flags (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__6 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__6 with<| ProcState_N := tup__0|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__7 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__7 with<| ProcState_Z := tup__1|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__8 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__8 with<| ProcState_C := tup__2|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__9 : ProcState) . 
     sail2_state_monad$write_regS PSTATE_ref (w__9 with<| ProcState_V := tup__3|>))))))))))
   else if (((l__148 = (( 32 : int):ii)))) then
     let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let flags = flags__arg in sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) n  : ( 32 words$word) M) (\ (operand1 : 32 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) m  : ( 32 words$word) M) (\ (operand2 : 32 bits) . 
     let (carry_in : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (anon10 : 32 bits) .  sail2_state_monad$bindS
     (ConditionHolds condition) (\ (w__10 : bool) . 
     let (flags :  4 words$word) =
       (if w__10 then
         let ((carry_in : 1 bits), (operand2 : 32 bits)) =
           (if sub_op then
             let (operand2 : 32 bits) = ((not_vec operand2  :  32 words$word)) in
             let (carry_in : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
             (carry_in, operand2)
           else (carry_in, operand2)) in
         let (tup__0, tup__1) =
           ((AddWithCarry operand1 operand2 carry_in  : ( 32 words$word #  4 words$word))) in
         let (anon10 : 32 bits) = tup__0 in
         tup__1
       else flags) in
     let (tup__0, tup__1, tup__2, tup__3) =
       ((subrange_vec_dec flags (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
        (subrange_vec_dec flags (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
        (subrange_vec_dec flags (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
        (subrange_vec_dec flags (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__11 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__11 with<| ProcState_N := tup__0|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__12 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__12 with<| ProcState_Z := tup__1|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__13 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__13 with<| ProcState_C := tup__2|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__14 : ProcState) . 
     sail2_state_monad$write_regS PSTATE_ref (w__14 with<| ProcState_V := tup__3|>))))))))))
   else if (((l__148 = (( 64 : int):ii)))) then
     let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let flags = flags__arg in sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) n  : ( 64 words$word) M) (\ (operand1 : 64 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) m  : ( 64 words$word) M) (\ (operand2 : 64 bits) . 
     let (carry_in : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (anon10 : 64 bits) .  sail2_state_monad$bindS
     (ConditionHolds condition) (\ (w__15 : bool) . 
     let (flags :  4 words$word) =
       (if w__15 then
         let ((carry_in : 1 bits), (operand2 : 64 bits)) =
           (if sub_op then
             let (operand2 : 64 bits) = ((not_vec operand2  :  64 words$word)) in
             let (carry_in : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
             (carry_in, operand2)
           else (carry_in, operand2)) in
         let (tup__0, tup__1) =
           ((AddWithCarry operand1 operand2 carry_in  : ( 64 words$word #  4 words$word))) in
         let (anon10 : 64 bits) = tup__0 in
         tup__1
       else flags) in
     let (tup__0, tup__1, tup__2, tup__3) =
       ((subrange_vec_dec flags (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
        (subrange_vec_dec flags (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
        (subrange_vec_dec flags (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
        (subrange_vec_dec flags (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__16 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__16 with<| ProcState_N := tup__0|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__17 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__17 with<| ProcState_Z := tup__1|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__18 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__18 with<| ProcState_C := tup__2|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__19 : ProcState) . 
     sail2_state_monad$write_regS PSTATE_ref (w__19 with<| ProcState_V := tup__3|>))))))))))
   else if (((l__148 = (( 128 : int):ii)))) then
     let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let flags = flags__arg in sail2_state_monad$bindS
     (aget_X (( 128 : int):ii) n  : ( 128 words$word) M) (\ (operand1 : 128 bits) .  sail2_state_monad$bindS
     (aget_X (( 128 : int):ii) m  : ( 128 words$word) M) (\ (operand2 : 128 bits) . 
     let (carry_in : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in sail2_state_monad$bindS
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M) (\ (anon10 : 128 bits) .  sail2_state_monad$bindS
     (ConditionHolds condition) (\ (w__20 : bool) . 
     let (flags :  4 words$word) =
       (if w__20 then
         let ((carry_in : 1 bits), (operand2 : 128 bits)) =
           (if sub_op then
             let (operand2 : 128 bits) = ((not_vec operand2  :  128 words$word)) in
             let (carry_in : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
             (carry_in, operand2)
           else (carry_in, operand2)) in
         let (tup__0, tup__1) =
           ((AddWithCarry operand1 operand2 carry_in  : ( 128 words$word #  4 words$word))) in
         let (anon10 : 128 bits) = tup__0 in
         tup__1
       else flags) in
     let (tup__0, tup__1, tup__2, tup__3) =
       ((subrange_vec_dec flags (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
        (subrange_vec_dec flags (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
        (subrange_vec_dec flags (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
        (subrange_vec_dec flags (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__21 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__21 with<| ProcState_N := tup__0|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__22 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__22 with<| ProcState_Z := tup__1|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__23 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__23 with<| ProcState_C := tup__2|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__24 : ProcState) . 
     sail2_state_monad$write_regS PSTATE_ref (w__24 with<| ProcState_V := tup__3|>))))))))))
   else
     let dbytes = (ex_int ((l__148 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint"))`;


(*val integer_conditional_compare_register_decode : mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty4 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty4 -> M unit*)

val _ = Define `
 ((integer_conditional_compare_register_decode:(1)words$word ->(1)words$word ->(1)words$word ->(5)words$word ->(4)words$word ->(1)words$word ->(5)words$word ->(1)words$word ->(4)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) sf op S1 Rm cond o2 Rn o3 nzcv1=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (n : ii) = (lem$w2ui Rn) in
   let (m : ii) = (lem$w2ui Rm) in
   let (datasize : int) =
     (if (((sf = (vec_of_bits [B1]  :  1 words$word)))) then (( 64 : int):ii)
     else (( 32 : int):ii)) in
   let (sub_op : bool) = (op = (vec_of_bits [B1]  :  1 words$word)) in
   let (condition : 4 bits) = cond in
   let (flags : 4 bits) = nzcv1 in
   aarch64_integer_conditional_compare_register condition datasize flags m n sub_op)))`;


(*val aarch64_integer_conditional_compare_immediate : forall 'datasize. Size 'datasize => mword ty4 -> itself 'datasize -> mword ty4 -> mword 'datasize -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_integer_conditional_compare_immediate:(4)words$word -> 'datasize itself ->(4)words$word -> 'datasize words$word -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) condition datasize flags__arg imm n sub_op=
    (let datasize = (size_itself_int datasize) in
   let dbytes = (ex_int ((datasize / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS T "datasize constraint")
   (sail2_state_monad$assert_expS T "dbytes constraint"))
   (let flags = flags__arg in sail2_state_monad$bindS
   (aget_X datasize n  : ( 'datasize words$word) M) (\ (operand1 : 'datasize bits) . 
   let (operand2 : 'datasize bits) = imm in
   let (carry_in : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in sail2_state_monad$bindS
   (undefined_bitvector datasize  : ( 'datasize words$word) M) (\ (anon10 : 'datasize bits) .  sail2_state_monad$bindS
   (ConditionHolds condition) (\ (w__0 : bool) . 
   let (flags :  4 words$word) =
     (if w__0 then
       let ((carry_in : 1 bits), (operand2 : 'datasize bits)) =
         (if sub_op then
           let (operand2 : 'datasize bits) = ((not_vec operand2  :  'datasize words$word)) in
           let (carry_in : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
           (carry_in, operand2)
         else (carry_in, operand2)) in
       let (tup__0, tup__1) =
         ((AddWithCarry operand1 operand2 carry_in  : ( 'datasize words$word #  4 words$word))) in
       let (anon10 : 'datasize bits) = tup__0 in
       tup__1
     else flags) in
   let (tup__0, tup__1, tup__2, tup__3) =
     ((subrange_vec_dec flags (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
      (subrange_vec_dec flags (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
      (subrange_vec_dec flags (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
      (subrange_vec_dec flags (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__1 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__1 with<| ProcState_N := tup__0|>))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__2 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__2 with<| ProcState_Z := tup__1|>))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__3 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__3 with<| ProcState_C := tup__2|>))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__4 : ProcState) . 
   sail2_state_monad$write_regS PSTATE_ref (w__4 with<| ProcState_V := tup__3|>)))))))))))`;


(*val integer_conditional_compare_immediate_decode : mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty4 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty4 -> M unit*)

val _ = Define `
 ((integer_conditional_compare_immediate_decode:(1)words$word ->(1)words$word ->(1)words$word ->(5)words$word ->(4)words$word ->(1)words$word ->(5)words$word ->(1)words$word ->(4)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 op S1 imm5 cond o2 Rn o3 nzcv1=
    (if (((b__0 = (vec_of_bits [B0]  :  1 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (n : ii) = (lem$w2ui Rn) in
     let (sub_op : bool) = (op = (vec_of_bits [B1]  :  1 words$word)) in
     let (condition : 4 bits) = cond in
     let (flags : 4 bits) = nzcv1 in sail2_state_monad$bindS
     (ZeroExtend__0 imm5 ((make_the_value (( 32 : int):ii)  :  32 itself))  : ( 32 words$word) M) (\ (imm : 32
       bits) . 
     aarch64_integer_conditional_compare_immediate condition
       ((make_the_value (( 32 : int):ii)  :  32 itself)) flags imm n sub_op))
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (n : ii) = (lem$w2ui Rn) in
     let (sub_op : bool) = (op = (vec_of_bits [B1]  :  1 words$word)) in
     let (condition : 4 bits) = cond in
     let (flags : 4 bits) = nzcv1 in sail2_state_monad$bindS
     (ZeroExtend__0 imm5 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (imm : 64
       bits) . 
     aarch64_integer_conditional_compare_immediate condition
       ((make_the_value (( 64 : int):ii)  :  64 itself)) flags imm n sub_op))))`;


(*val ConditionSyndrome : unit -> M (mword ty5)*)

val _ = Define `
 ((ConditionSyndrome:unit ->(regstate)sail2_state_monad$sequential_state ->((((5)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (undefined_bitvector (( 5 : int):ii)  : ( 5 words$word) M) (\ (syndrome : 5 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (cond : 4 bits) .  sail2_state_monad$bindS
   (UsingAArch32 () ) (\ (w__0 : bool) . 
   if w__0 then sail2_state_monad$bindS
     (AArch32_CurrentCond ()   : ( 4 words$word) M) (\ (w__1 : 4 bits) . 
     let cond = w__1 in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) . 
     if (((w__2.ProcState_T = (vec_of_bits [B0]  :  1 words$word)))) then
       let syndrome =
         ((set_slice (( 5 : int):ii) (( 1 : int):ii) syndrome (( 4 : int):ii) (vec_of_bits [B1]  :  1 words$word)  :  5 words$word)) in sail2_state_monad$bindS
       (sail2_state$and_boolS ((ConditionHolds cond)) ((ConstrainUnpredictableBool Unpredictable_ESRCONDPASS))) (\ (w__5 :
         bool) . 
       let (syndrome : 5 bits) =
         (if w__5 then
           (set_slice (( 5 : int):ii) (( 4 : int):ii) syndrome (( 0 : int):ii) (vec_of_bits [B1;B1;B1;B0]  :  4 words$word)
             :  5 words$word)
         else (set_slice (( 5 : int):ii) (( 4 : int):ii) syndrome (( 0 : int):ii) cond  :  5 words$word)) in
       sail2_state_monad$returnS syndrome)
     else if ((IMPDEF_boolean "Condition valid for trapped T32")) then
       let (syndrome : 5 bits) =
         ((set_slice (( 5 : int):ii) (( 1 : int):ii) syndrome (( 4 : int):ii) (vec_of_bits [B1]  :  1 words$word)  :  5 words$word)) in
       let (syndrome : 5 bits) = ((set_slice (( 5 : int):ii) (( 4 : int):ii) syndrome (( 0 : int):ii) cond  :  5 words$word)) in
       sail2_state_monad$returnS syndrome
     else
       let syndrome =
         ((set_slice (( 5 : int):ii) (( 1 : int):ii) syndrome (( 4 : int):ii) (vec_of_bits [B0]  :  1 words$word)  :  5 words$word)) in sail2_state_monad$bindS
       (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (w__6 :  4 words$word) . 
       let (syndrome : 5 bits) = ((set_slice (( 5 : int):ii) (( 4 : int):ii) syndrome (( 0 : int):ii) w__6  :  5 words$word)) in
       sail2_state_monad$returnS syndrome)))
   else
     let (syndrome : 5 bits) =
       ((set_slice (( 5 : int):ii) (( 1 : int):ii) syndrome (( 4 : int):ii) (vec_of_bits [B1]  :  1 words$word)  :  5 words$word)) in
     let (syndrome : 5 bits) =
       ((set_slice (( 5 : int):ii) (( 4 : int):ii) syndrome (( 0 : int):ii) (vec_of_bits [B1;B1;B1;B0]  :  4 words$word)
         :  5 words$word)) in
     sail2_state_monad$returnS syndrome)))))`;


(*val BranchToAddr : forall 'N . Size 'N => mword 'N -> BranchType -> M unit*)

val _ = Define `
 ((BranchToAddr:'N words$word -> BranchType ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) target branch_type=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS BranchTaken_ref T)
   (let (_ : unit) = (Hint_Branch branch_type) in
   if (((((int_of_num (words$word_len target))) = (( 32 : int):ii)))) then sail2_state_monad$bindS
     (UsingAArch32 () ) (\ (w__0 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS w__0 "UsingAArch32()")
     (ZeroExtend__1 (( 64 : int):ii) target  : ( 64 words$word) M)) (\ (w__1 : 64 bits) . 
     sail2_state_monad$write_regS PC_ref w__1))
   else sail2_state_monad$bindS
     (sail2_state$and_boolS (sail2_state_monad$returnS (((((int_of_num (words$word_len target))) = (( 64 : int):ii)))))
       ( sail2_state_monad$bindS(UsingAArch32 () ) (\ (w__2 : bool) .  sail2_state_monad$returnS ((~ w__2))))) (\ (w__3 : bool) .  sail2_state_monad$seqS
     (sail2_state_monad$assert_expS w__3 "((N == 64) && !(UsingAArch32()))")
     (sail2_state_monad$write_regS PC_ref ((slice target (( 0 : int):ii) (( 64 : int):ii)  :  64 words$word)))))))`;


(*val BadMode : mword ty5 -> M bool*)

val _ = Define `
 ((BadMode:(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) mode=  (sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (valid_name : bool) . 
   let pat_0 = mode in
   let (valid_name : bool) =
     (if (((pat_0 = M32_Monitor))) then HaveAArch32EL EL3
     else if (((pat_0 = M32_Hyp))) then HaveAArch32EL EL2
     else if (((pat_0 = M32_FIQ))) then HaveAArch32EL EL1
     else if (((pat_0 = M32_IRQ))) then HaveAArch32EL EL1
     else if (((pat_0 = M32_Svc))) then HaveAArch32EL EL1
     else if (((pat_0 = M32_Abort))) then HaveAArch32EL EL1
     else if (((pat_0 = M32_Undef))) then HaveAArch32EL EL1
     else if (((pat_0 = M32_System))) then HaveAArch32EL EL1
     else if (((pat_0 = M32_User))) then HaveAArch32EL EL0
     else F) in
   sail2_state_monad$returnS ((~ valid_name)))))`;


(*val aset_Rmode : ii -> mword ty5 -> mword ty32 -> M unit*)

val _ = Define `
 ((aset_Rmode:int ->(5)words$word ->(32)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) n mode value_name=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS (((((n >= (( 0 : int):ii))) /\ ((n <= (( 14 : int):ii)))))) "((n >= 0) && (n <= 14))")
   (IsSecure () )) (\ (w__0 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (if ((~ w__0)) then sail2_state_monad$assert_expS (((mode <> M32_Monitor))) "(mode != M32_Monitor)"
    else sail2_state_monad$returnS () )
   (BadMode mode)) (\ (w__1 : bool) .  sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((~ w__1)) "!(BadMode(mode))")
   (if (((mode = M32_Monitor))) then
     if (((n = (( 13 : int):ii)))) then sail2_state_monad$write_regS SP_mon_ref value_name
     else if (((n = (( 14 : int):ii)))) then sail2_state_monad$write_regS LR_mon_ref value_name
     else sail2_state_monad$bindS
       (sail2_state_monad$read_regS R_ref) (\ (w__2 : ( 64 bits) list) . 
       let (tmp_10 : 64 bits) = ((access_list_dec w__2 n  :  64 words$word)) in
       let tmp_10 = ((update_subrange_vec_dec tmp_10 (( 31 : int):ii) (( 0 : int):ii) value_name  :  64 words$word)) in sail2_state_monad$bindS
       (sail2_state_monad$read_regS R_ref) (\ (w__3 : ( 64 words$word) list) . 
       sail2_state_monad$write_regS R_ref ((update_list_dec w__3 n tmp_10  : ( 64 words$word) list))))
   else sail2_state_monad$bindS
     (sail2_state$and_boolS (sail2_state_monad$returnS ((~ ((HighestELUsingAArch32 () )))))
       ((ConstrainUnpredictableBool Unpredictable_ZEROUPPER))) (\ (w__5 : bool) . 
     if w__5 then sail2_state_monad$bindS
       (sail2_state_monad$read_regS R_ref) (\ (w__6 : ( 64 words$word) list) .  sail2_state_monad$bindS
       (LookUpRIndex n mode) (\ (w__7 : ii) .  sail2_state_monad$bindS
       (ZeroExtend__0 value_name ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__8 :
          64 words$word) . 
       sail2_state_monad$write_regS R_ref ((update_list_dec w__6 w__7 w__8  : ( 64 words$word) list)))))
     else sail2_state_monad$bindS
       (sail2_state_monad$read_regS R_ref) (\ (w__9 : ( 64 bits) list) .  sail2_state_monad$bindS
       (LookUpRIndex n mode) (\ (w__10 : ii) . 
       let (tmp_20 : 64 bits) = ((access_list_dec w__9 w__10  :  64 words$word)) in
       let tmp_20 = ((update_subrange_vec_dec tmp_20 (( 31 : int):ii) (( 0 : int):ii) value_name  :  64 words$word)) in sail2_state_monad$bindS
       (sail2_state_monad$read_regS R_ref) (\ (w__11 : ( 64 words$word) list) .  sail2_state_monad$bindS
       (LookUpRIndex n mode) (\ (w__12 : ii) . 
       sail2_state_monad$write_regS R_ref ((update_list_dec w__11 w__12 tmp_20  : ( 64 words$word) list))))))))))))`;


(*val aset_R : ii -> mword ty32 -> M unit*)

val _ = Define `
 ((aset_R:int ->(32)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) n value_name=  (sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) .  aset_Rmode n w__0.ProcState_M value_name)))`;


(*val set_LR : mword ty32 -> M unit*)

val _ = Define `
 ((set_LR:(32)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) value_name=  (aset_R (( 14 : int):ii) value_name))`;


(*val ELFromM32 : mword ty5 -> M (bool * mword ty2)*)

val _ = Define `
 ((ELFromM32:(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((bool#(2)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) mode=  (sail2_state_monad$bindS
   (undefined_bitvector (( 2 : int):ii)  : ( 2 words$word) M) (\ (el : 2 bits) .  sail2_state_monad$bindS
   (BadMode mode) (\ (w__0 : bool) . 
   let (valid_name : bool) = (~ w__0) in
   let pat_0 = mode in sail2_state_monad$bindS
   (if (((pat_0 = M32_Monitor))) then
      let (el : 2 bits) = EL3 in
      sail2_state_monad$returnS (el, valid_name)
    else if (((pat_0 = M32_Hyp))) then
      let el = EL2 in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS valid_name)
        (sail2_state$or_boolS (sail2_state_monad$returnS ((~ ((HaveEL EL3)))))
           ( sail2_state_monad$bindS(aget_SCR_GEN ()   : ( 32 words$word) M) (\ (w__1 :  32 words$word) . 
            sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__1 (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))) (\ (w__3 : bool) . 
      let (valid_name : bool) = w__3 in
      sail2_state_monad$returnS (el, valid_name))
    else if (((pat_0 = M32_FIQ))) then sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveEL EL3)) /\ ((HighestELUsingAArch32 () ))))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_ref  : ( 32 words$word) M) (\ (w__4 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__4 (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__5 : bool) . 
      let (el : 2 bits) = (if w__5 then EL3 else EL1) in
      sail2_state_monad$returnS (el, valid_name))
    else if (((pat_0 = M32_IRQ))) then sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveEL EL3)) /\ ((HighestELUsingAArch32 () ))))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_ref  : ( 32 words$word) M) (\ (w__6 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__6 (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__7 : bool) . 
      let (el : 2 bits) = (if w__7 then EL3 else EL1) in
      sail2_state_monad$returnS (el, valid_name))
    else if (((pat_0 = M32_Svc))) then sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveEL EL3)) /\ ((HighestELUsingAArch32 () ))))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_ref  : ( 32 words$word) M) (\ (w__8 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__8 (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__9 : bool) . 
      let (el : 2 bits) = (if w__9 then EL3 else EL1) in
      sail2_state_monad$returnS (el, valid_name))
    else if (((pat_0 = M32_Abort))) then sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveEL EL3)) /\ ((HighestELUsingAArch32 () ))))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_ref  : ( 32 words$word) M) (\ (w__10 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__10 (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__11 : bool) . 
      let (el : 2 bits) = (if w__11 then EL3 else EL1) in
      sail2_state_monad$returnS (el, valid_name))
    else if (((pat_0 = M32_Undef))) then sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveEL EL3)) /\ ((HighestELUsingAArch32 () ))))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_ref  : ( 32 words$word) M) (\ (w__12 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__12 (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__13 : bool) . 
      let (el : 2 bits) = (if w__13 then EL3 else EL1) in
      sail2_state_monad$returnS (el, valid_name))
    else if (((pat_0 = M32_System))) then sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveEL EL3)) /\ ((HighestELUsingAArch32 () ))))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_ref  : ( 32 words$word) M) (\ (w__14 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__14 (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__15 : bool) . 
      let (el : 2 bits) = (if w__15 then EL3 else EL1) in
      sail2_state_monad$returnS (el, valid_name))
    else
      let ((el : 2 bits), (valid_name : bool)) =
        (if (((pat_0 = M32_User))) then
          let (el : 2 bits) = EL0 in
          (el, valid_name)
        else
          let (valid_name : bool) = F in
          (el, valid_name)) in
      sail2_state_monad$returnS (el, valid_name)) (\ varstup .  let ((el : 2 bits), (valid_name : bool)) = varstup in sail2_state_monad$bindS
   (if ((~ valid_name)) then (undefined_bitvector (( 2 : int):ii)  : ( 2 words$word) M)
    else sail2_state_monad$returnS el) (\ (el : 2 bits) . 
   sail2_state_monad$returnS (valid_name, el)))))))`;


(*val ELFromSPSR : mword ty32 -> M (bool * mword ty2)*)

val _ = Define `
 ((ELFromSPSR:(32)words$word ->(regstate)sail2_state_monad$sequential_state ->(((bool#(2)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) spsr=  (sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (valid_name : bool) .  sail2_state_monad$bindS
   (undefined_bitvector (( 2 : int):ii)  : ( 2 words$word) M) (\ (el : 2 bits) .  sail2_state_monad$bindS
   (if ((((vec_of_bits [access_vec_dec spsr (( 4 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))) then
      let el = ((slice spsr (( 2 : int):ii) (( 2 : int):ii)  :  2 words$word)) in sail2_state_monad$bindS
      (if ((HighestELUsingAArch32 () )) then sail2_state_monad$returnS F
       else if ((~ ((HaveEL el)))) then sail2_state_monad$returnS F
       else if ((((vec_of_bits [access_vec_dec spsr (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
         sail2_state_monad$returnS F
       else if ((((((el = EL0))) /\ ((((vec_of_bits [access_vec_dec spsr (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) then
         sail2_state_monad$returnS F
       else sail2_state_monad$bindS
         (sail2_state$and_boolS (sail2_state_monad$returnS ((((((el = EL2))) /\ ((HaveEL EL3))))))
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__0 : 32 bits) . 
            sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__0 (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__1 : bool) . 
         let (valid_name : bool) = (if w__1 then F else T) in
         sail2_state_monad$returnS valid_name)) (\ (valid_name : bool) . 
      sail2_state_monad$returnS (el, valid_name))
    else if ((~ ((HaveAnyAArch32 () )))) then
      let (valid_name : bool) = F in
      sail2_state_monad$returnS (el, valid_name)
    else sail2_state_monad$bindS
      (ELFromM32 ((slice spsr (( 0 : int):ii) (( 5 : int):ii)  :  5 words$word))  : ((bool #  2 words$word)) M) (\ varstup .  let (tup__0, tup__1) = varstup in
      let (valid_name : bool) = tup__0 in
      let (el : 2 bits) = tup__1 in
      sail2_state_monad$returnS (el, valid_name))) (\ varstup .  let ((el : 2 bits), (valid_name : bool)) = varstup in sail2_state_monad$bindS
   (if ((~ valid_name)) then (undefined_bitvector (( 2 : int):ii)  : ( 2 words$word) M)
    else sail2_state_monad$returnS el) (\ (el : 2 bits) . 
   sail2_state_monad$returnS (valid_name, el)))))))`;


(*val IllegalExceptionReturn : mword ty32 -> M bool*)

val _ = Define `
 ((IllegalExceptionReturn:(32)words$word ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) spsr=  (sail2_state_monad$bindS
   (undefined_bitvector (( 2 : int):ii)  : ( 2 words$word) M) (\ (target : 2 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (valid_name : bool) .  sail2_state_monad$bindS
   (ELFromSPSR spsr  : ((bool #  2 words$word)) M) (\ varstup .  let (tup__0, tup__1) = varstup in
   let valid_name = tup__0 in
   let target = tup__1 in
   if ((~ valid_name)) then sail2_state_monad$returnS T
   else sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) . 
     if ((((lem$w2ui target)) > ((lem$w2ui w__0.ProcState_EL)))) then sail2_state_monad$returnS T
     else
       let (spsr_mode_is_aarch32 : bool) =
         ((vec_of_bits [access_vec_dec spsr (( 4 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in sail2_state_monad$bindS
       (sail2_state_monad$undefined_boolS () ) (\ (target_el_is_aarch32 : bool) .  sail2_state_monad$bindS
       (sail2_state_monad$undefined_boolS () ) (\ (known : bool) .  sail2_state_monad$bindS
       (ELUsingAArch32K target) (\ varstup .  let (tup__0, tup__1) = varstup in
       let known = tup__0 in
       let target_el_is_aarch32 = tup__1 in sail2_state_monad$bindS
       (sail2_state$or_boolS (sail2_state_monad$returnS known)
         (sail2_state$and_boolS (sail2_state_monad$returnS (((target = EL0))))
            ( sail2_state_monad$bindS(ELUsingAArch32 EL1) (\ (w__1 : bool) .  sail2_state_monad$returnS ((~ w__1)))))) (\ (w__3 : bool) .  sail2_state_monad$seqS
       (sail2_state_monad$assert_expS w__3 "(known || ((target == EL0) && !(ELUsingAArch32(EL1))))")
       (if (((known /\ ((neq_bool spsr_mode_is_aarch32 target_el_is_aarch32))))) then sail2_state_monad$returnS T
       else sail2_state_monad$bindS
         (sail2_state$and_boolS ((UsingAArch32 () )) (sail2_state_monad$returnS ((~ spsr_mode_is_aarch32)))) (\ (w__5 : bool) . 
         if w__5 then sail2_state_monad$returnS T
         else sail2_state_monad$bindS
           (sail2_state$and_boolS
             (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveEL EL2)) /\ (((target = EL1)))))))
                ( sail2_state_monad$bindS(IsSecureBelowEL3 () ) (\ (w__6 : bool) .  sail2_state_monad$returnS ((~ w__6)))))
             ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__8 : 64 bits) . 
              sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__8 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__9 : bool) . 
           sail2_state_monad$returnS (if w__9 then T
                   else F))))))))))))))`;


(*val AArch32_WriteMode : mword ty5 -> M unit*)

val _ = Define `
 ((AArch32_WriteMode:(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) mode=  (sail2_state_monad$bindS
   (undefined_bitvector (( 2 : int):ii)  : ( 2 words$word) M) (\ (el : 2 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (valid_name : bool) .  sail2_state_monad$bindS
   (ELFromM32 mode  : ((bool #  2 words$word)) M) (\ varstup .  let (tup__0, tup__1) = varstup in
   let valid_name = tup__0 in
   let el = tup__1 in sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS valid_name "valid")
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__0 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__0 with<| ProcState_M := mode|>))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__1 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__1 with<| ProcState_EL := el|>))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__2 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__2 with<| ProcState_nRW := ((vec_of_bits [B1]  :  1 words$word))|>))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__3 : ProcState) . 
   sail2_state_monad$write_regS
     PSTATE_ref
     (w__3 with<|
       ProcState_SP :=
         (if ((((((mode = M32_User))) \/ (((mode = M32_System)))))) then
            (vec_of_bits [B0]  :  1 words$word)
          else (vec_of_bits [B1]  :  1 words$word))|>))))))))))`;


(*val AddrTop : mword ty64 -> bool -> mword ty2 -> M ii*)

val _ = Define `
 ((AddrTop:(64)words$word -> bool ->(2)words$word ->(regstate)sail2_state_monad$sequential_state ->(((int),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) address IsInstr el=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((HaveEL el)) "HaveEL(el)")
   (S1TranslationRegime__0 el  : ( 2 words$word) M)) (\ (regime : 2 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (tbid : 1 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (tbi : 1 bits) .  sail2_state_monad$bindS
   (ELUsingAArch32 regime) (\ (w__0 : bool) . 
   if w__0 then sail2_state_monad$returnS (( 31 : int):ii)
   else
     let pat_0 = regime in sail2_state_monad$bindS
     (if (((pat_0 = EL1))) then sail2_state_monad$bindS
        (if ((((vec_of_bits [access_vec_dec address (( 55 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then sail2_state_monad$bindS
           (sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M) (\ (w__1 : 64 bits) . 
           sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__1 (( 38 : int):ii)]  :  1 words$word))
         else sail2_state_monad$bindS
           (sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M) (\ (w__2 : 64 bits) . 
           sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__2 (( 37 : int):ii)]  :  1 words$word))) (\ (w__3 :
           1 words$word) . 
        let tbi = w__3 in sail2_state_monad$bindS
        (if ((HavePACExt () )) then
           if ((((vec_of_bits [access_vec_dec address (( 55 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then sail2_state_monad$bindS
             (sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M) (\ (w__4 : 64 bits) . 
             sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__4 (( 52 : int):ii)]  :  1 words$word))
           else sail2_state_monad$bindS
             (sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M) (\ (w__5 : 64 bits) . 
             sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__5 (( 51 : int):ii)]  :  1 words$word))
         else sail2_state_monad$returnS tbid) (\ (tbid : 1 bits) . 
        sail2_state_monad$returnS (tbi, tbid)))
      else if (((pat_0 = EL2))) then sail2_state_monad$bindS
        (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveVirtHostExt () ))) ((ELIsInHost el))) (\ (w__8 : bool) . 
        if w__8 then sail2_state_monad$bindS
          (if ((((vec_of_bits [access_vec_dec address (( 55 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then sail2_state_monad$bindS
             (sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M) (\ (w__9 : 64 bits) . 
             sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__9 (( 38 : int):ii)]  :  1 words$word))
           else sail2_state_monad$bindS
             (sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M) (\ (w__10 : 64 bits) . 
             sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__10 (( 37 : int):ii)]  :  1 words$word))) (\ (w__11 :
             1 words$word) . 
          let tbi = w__11 in sail2_state_monad$bindS
          (if ((HavePACExt () )) then
             if ((((vec_of_bits [access_vec_dec address (( 55 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then sail2_state_monad$bindS
               (sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M) (\ (w__12 : 64 bits) . 
               sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__12 (( 52 : int):ii)]  :  1 words$word))
             else sail2_state_monad$bindS
               (sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M) (\ (w__13 : 64 bits) . 
               sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__13 (( 51 : int):ii)]  :  1 words$word))
           else sail2_state_monad$returnS tbid) (\ (tbid : 1 bits) . 
          sail2_state_monad$returnS (tbi, tbid)))
        else sail2_state_monad$bindS
          (sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M) (\ (w__15 : 64 bits) . 
          let tbi = ((vec_of_bits [access_vec_dec w__15 (( 20 : int):ii)]  :  1 words$word)) in sail2_state_monad$bindS
          (if ((HavePACExt () )) then sail2_state_monad$bindS
             (sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M) (\ (w__16 : 64 bits) . 
             let (tbid : 1 bits) = ((vec_of_bits [access_vec_dec w__16 (( 29 : int):ii)]  :  1 words$word)) in
             sail2_state_monad$returnS tbid)
           else sail2_state_monad$returnS tbid) (\ (tbid : 1 bits) . 
          sail2_state_monad$returnS (tbi, tbid))))
      else sail2_state_monad$bindS
        (sail2_state_monad$read_regS TCR_EL3_ref  : ( 32 words$word) M) (\ (w__17 : 32 bits) . 
        let tbi = ((vec_of_bits [access_vec_dec w__17 (( 20 : int):ii)]  :  1 words$word)) in sail2_state_monad$bindS
        (if ((HavePACExt () )) then sail2_state_monad$bindS
           (sail2_state_monad$read_regS TCR_EL3_ref  : ( 32 words$word) M) (\ (w__18 : 32 bits) . 
           let (tbid : 1 bits) = ((vec_of_bits [access_vec_dec w__18 (( 29 : int):ii)]  :  1 words$word)) in
           sail2_state_monad$returnS tbid)
         else sail2_state_monad$returnS tbid) (\ (tbid : 1 bits) . 
        sail2_state_monad$returnS (tbi, tbid)))) (\ varstup .  let ((tbi : 1 bits), (tbid : 1 bits)) = varstup in
     sail2_state_monad$returnS (if ((((((tbi = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((((~ ((HavePACExt () )))) \/ (((tbid = (vec_of_bits [B0]  :  1 words$word))))))) \/ ((~ IsInstr))))))))
             then
               (( 55 : int):ii)
             else (( 63 : int):ii)))))))))`;


(*val AddPAC : mword ty64 -> mword ty64 -> mword ty128 -> bool -> M (mword ty64)*)

val _ = Define `
 ((AddPAC:(64)words$word ->(64)words$word ->(128)words$word -> bool ->(regstate)sail2_state_monad$sequential_state ->((((64)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) ptr modifier K1 data=  (sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (PAC : 64 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (result : 64 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (ext_ptr : 64 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (extfield : 64 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (selbit : 1 bits) .  sail2_state_monad$bindS
   (CalculateTBI ptr data) (\ (tbi : bool) . 
   let (top_bit : int) = (if tbi then (( 55 : int):ii) else (( 63 : int):ii)) in sail2_state_monad$bindS
   (PtrHasUpperAndLowerAddRanges () ) (\ (w__0 : bool) .  sail2_state_monad$bindS
   (if w__0 then sail2_state_monad$bindS
      (IsEL1TransRegimeRegs () ) (\ (w__1 : bool) . 
      if w__1 then
        if data then sail2_state_monad$bindS
          (sail2_state$or_boolS
            ( sail2_state_monad$bindS(sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M) (\ (w__2 : 64 bits) . 
             sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__2 (( 38 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))
            ( sail2_state_monad$bindS(sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M) (\ (w__3 : 64 bits) . 
             sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__3 (( 37 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__4 : bool) . 
          let (selbit : 1 bits) =
            (if w__4 then (vec_of_bits [access_vec_dec ptr (( 55 : int):ii)]  :  1 words$word)
            else (vec_of_bits [access_vec_dec ptr (( 63 : int):ii)]  :  1 words$word)) in
          sail2_state_monad$returnS selbit)
        else sail2_state_monad$bindS
          (sail2_state$or_boolS
            (sail2_state$and_boolS
               ( sail2_state_monad$bindS(sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M) (\ (w__5 : 64 bits) . 
                sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__5 (( 38 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))
               ( sail2_state_monad$bindS(sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M) (\ (w__6 : 64 bits) . 
                sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__6 (( 52 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))))))
            (sail2_state$and_boolS
               ( sail2_state_monad$bindS(sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M) (\ (w__8 : 64 bits) . 
                sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__8 (( 37 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))
               ( sail2_state_monad$bindS(sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M) (\ (w__9 : 64 bits) . 
                sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__9 (( 51 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))))))) (\ (w__11 : bool) . 
          let (selbit : 1 bits) =
            (if w__11 then (vec_of_bits [access_vec_dec ptr (( 55 : int):ii)]  :  1 words$word)
            else (vec_of_bits [access_vec_dec ptr (( 63 : int):ii)]  :  1 words$word)) in
          sail2_state_monad$returnS selbit)
      else if data then sail2_state_monad$bindS
        (sail2_state$or_boolS
          (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
             ( sail2_state_monad$bindS(sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M) (\ (w__12 : 64 bits) . 
              sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__12 (( 38 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
          (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
             ( sail2_state_monad$bindS(sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M) (\ (w__14 : 64 bits) . 
              sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__14 (( 37 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))) (\ (w__16 : bool) . 
        let (selbit : 1 bits) =
          (if w__16 then (vec_of_bits [access_vec_dec ptr (( 55 : int):ii)]  :  1 words$word)
          else (vec_of_bits [access_vec_dec ptr (( 63 : int):ii)]  :  1 words$word)) in
        sail2_state_monad$returnS selbit)
      else sail2_state_monad$bindS
        (sail2_state$or_boolS
          (sail2_state$and_boolS
             (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
                ( sail2_state_monad$bindS(sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M) (\ (w__17 : 64 bits) . 
                 sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__17 (( 38 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
             ( sail2_state_monad$bindS(sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M) (\ (w__19 : 64 bits) . 
              sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__19 (( 52 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))))))
          (sail2_state$and_boolS
             (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
                ( sail2_state_monad$bindS(sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M) (\ (w__21 : 64 bits) . 
                 sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__21 (( 37 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
             ( sail2_state_monad$bindS(sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M) (\ (w__23 : 64 bits) . 
              sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__23 (( 51 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))))))) (\ (w__25 : bool) . 
        let (selbit : 1 bits) =
          (if w__25 then (vec_of_bits [access_vec_dec ptr (( 55 : int):ii)]  :  1 words$word)
          else (vec_of_bits [access_vec_dec ptr (( 63 : int):ii)]  :  1 words$word)) in
        sail2_state_monad$returnS selbit))
    else
      let (selbit : 1 bits) =
        (if tbi then (vec_of_bits [access_vec_dec ptr (( 55 : int):ii)]  :  1 words$word)
        else (vec_of_bits [access_vec_dec ptr (( 63 : int):ii)]  :  1 words$word)) in
      sail2_state_monad$returnS selbit) (\ (selbit : 1 bits) .  sail2_state_monad$bindS
   (CalculateBottomPACBit ptr selbit) (\ (w__26 : ii) . 
   let (bottom_PAC_bit : int) = (ex_int w__26) in sail2_state_monad$seqS
   (sail2_state_monad$assert_expS T "")
   (let extfield = ((replicate_bits selbit (( 64 : int):ii)  :  64 words$word)) in
   let (ext_ptr : 64 bits) =
     (if tbi then
       (concat_vec ((subrange_vec_dec ptr (( 63 : int):ii) (( 56 : int):ii)  :  8 words$word))
          ((subrange_subrange_concat
              ((((((((((((~ bottom_PAC_bit)) + (( 56 : int):ii))) -
                              (( 1 : int):ii)))
                          - (((( 0 : int):ii) - (( 1 : int):ii)))))
                      +
                      ((bottom_PAC_bit - (( 1 : int):ii)))))
                  - (((( 0 : int):ii) - (( 1 : int):ii)))))
              extfield
              ((((((~ bottom_PAC_bit)) + (( 56 : int):ii))) - (( 1 : int):ii))) (( 0 : int):ii)
              ptr ((bottom_PAC_bit - (( 1 : int):ii))) (( 0 : int):ii)
             :  56 words$word))
         :  64 words$word)
     else
       (subrange_subrange_concat ((int_of_num (words$word_len PAC))) extfield
          ((((((~ bottom_PAC_bit)) + (( 64 : int):ii))) - (( 1 : int):ii))) (( 0 : int):ii) ptr
          ((bottom_PAC_bit - (( 1 : int):ii))) (( 0 : int):ii)
         :  64 words$word)) in sail2_state_monad$bindS
   (ComputePAC ext_ptr modifier ((subrange_vec_dec K1 (( 127 : int):ii) (( 64 : int):ii)  :  64 words$word))
      ((subrange_vec_dec K1 (( 63 : int):ii) (( 0 : int):ii)  :  64 words$word))
     : ( 64 words$word) M) (\ (w__27 : 64 bits) . 
   let (PAC : 64 bits) = w__27 in
   let (PAC : 64 bits) =
     (if (((((~ ((is_zero_subrange ptr
                    ((((((((top_bit - bottom_PAC_bit)) + (( 1 : int):ii))) -
                            (( 1 : int):ii)))
                        + bottom_PAC_bit)) bottom_PAC_bit)))) /\ ((~ ((is_ones_subrange ptr
                    ((((((((top_bit - bottom_PAC_bit)) + (( 1 : int):ii))) -
                            (( 1 : int):ii)))
                        + bottom_PAC_bit)) bottom_PAC_bit))))))) then
       (update_subrange_vec_dec PAC ((top_bit - (( 1 : int):ii))) ((top_bit - (( 1 : int):ii)))
          ((not_vec (vec_of_bits [access_vec_dec PAC ((top_bit - (( 1 : int):ii)))]  :  1 words$word)
             :  1 words$word))
         :  64 words$word)
     else PAC) in
   let (result : 64 bits) =
     (if tbi then
       (concat_vec
          ((concat_vec ((subrange_vec_dec ptr (( 63 : int):ii) (( 56 : int):ii)  :  8 words$word)) selbit  :  9 words$word))
          ((subrange_subrange_concat
              ((((((((((((((~ bottom_PAC_bit)) + (( 55 : int):ii))) -
                                  (( 1 : int):ii)))
                              + bottom_PAC_bit))
                          - ((bottom_PAC_bit - (( 1 : int):ii)))))
                      +
                      ((bottom_PAC_bit - (( 1 : int):ii)))))
                  - (((( 0 : int):ii) - (( 1 : int):ii))))) PAC
              ((((((((~ bottom_PAC_bit)) + (( 55 : int):ii))) - (( 1 : int):ii)))
                  +
                  bottom_PAC_bit)) bottom_PAC_bit ptr ((bottom_PAC_bit - (( 1 : int):ii))) (( 0 : int):ii)
             :  55 words$word))
         :  64 words$word)
     else
       (concat_vec
          ((concat_vec ((subrange_vec_dec PAC (( 63 : int):ii) (( 56 : int):ii)  :  8 words$word)) selbit  :  9 words$word))
          ((subrange_subrange_concat
              ((((((((((((((~ bottom_PAC_bit)) + (( 55 : int):ii))) -
                                  (( 1 : int):ii)))
                              + bottom_PAC_bit))
                          - ((bottom_PAC_bit - (( 1 : int):ii)))))
                      +
                      ((bottom_PAC_bit - (( 1 : int):ii)))))
                  - (((( 0 : int):ii) - (( 1 : int):ii))))) PAC
              ((((((((~ bottom_PAC_bit)) + (( 55 : int):ii))) - (( 1 : int):ii)))
                  +
                  bottom_PAC_bit)) bottom_PAC_bit ptr ((bottom_PAC_bit - (( 1 : int):ii))) (( 0 : int):ii)
             :  55 words$word))
         :  64 words$word)) in
   sail2_state_monad$returnS result)))))))))))))`;


(*val AArch64_vESBOperation : unit -> M unit*)

val _ = Define `
 ((AArch64_vESBOperation:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (sail2_state$and_boolS
     (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2))) ( sail2_state_monad$bindS(IsSecure () ) (\ (w__0 : bool) .  sail2_state_monad$returnS ((~ w__0)))))
     (sail2_state$or_boolS
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) .  sail2_state_monad$returnS (((w__2.ProcState_EL = EL0)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__3 : ProcState) .  sail2_state_monad$returnS (((w__3.ProcState_EL = EL1))))))) (\ (w__5 :
     bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS w__5 "((HaveEL(EL2) && !(IsSecure())) && (((PSTATE).EL == EL0) || ((PSTATE).EL == EL1)))")
   (sail2_state$and_boolS
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__6 : 64 bits) . 
      sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__6 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__7 : 64 bits) . 
      sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__7 (( 5 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))) (\ (vSEI_enabled : bool) .  sail2_state_monad$bindS
   (sail2_state$and_boolS (sail2_state_monad$returnS vSEI_enabled)
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__8 : 64 bits) . 
      sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__8 (( 8 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (vSEI_pending : bool) .  sail2_state_monad$bindS
   (sail2_state$or_boolS ((Halted () )) ((ExternalDebugInterruptsDisabled EL1))) (\ (vintdis : bool) .  sail2_state_monad$bindS
   (sail2_state$or_boolS (sail2_state_monad$returnS vintdis)
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__11 : ProcState) . 
      sail2_state_monad$returnS (((w__11.ProcState_A = (vec_of_bits [B1]  :  1 words$word))))))) (\ (vmasked : bool) .  sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (VDISR_EL2 : 64 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (VDISR : 32 bits) . 
   if (((vSEI_pending /\ vmasked))) then sail2_state_monad$bindS
     (ELUsingAArch32 EL1) (\ (w__12 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (if w__12 then sail2_state_monad$bindS
        (sail2_state_monad$read_regS VDFSR_ref  : ( 32 words$word) M) (\ (w__13 : 32 bits) .  sail2_state_monad$bindS
        (sail2_state_monad$read_regS VDFSR_ref  : ( 32 words$word) M) (\ (w__14 : 32 bits) .  sail2_state_monad$bindS
        (AArch32_ReportDeferredSError ((slice w__13 (( 14 : int):ii) (( 2 : int):ii)  :  2 words$word))
           (vec_of_bits [access_vec_dec w__14 (( 12 : int):ii)]  :  1 words$word)
          : ( 32 words$word) M) (\ (w__15 : 32 bits) . 
        let (VDISR : 32 bits) = w__15 in
        sail2_state_monad$returnS () )))
      else sail2_state_monad$bindS
        (sail2_state_monad$read_regS VSESR_EL2_ref  : ( 32 words$word) M) (\ (w__16 : 32 bits) .  sail2_state_monad$bindS
        (AArch64_ReportDeferredSError ((slice w__16 (( 0 : int):ii) (( 25 : int):ii)  :  25 words$word))  : ( 64 words$word) M) (\ (w__17 : 64
          bits) . 
        let (VDISR_EL2 : 64 bits) = w__17 in
        sail2_state_monad$returnS () )))
     (sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M)) (\ (w__18 :  64 words$word) . 
     sail2_state_monad$write_regS
       HCR_EL2_ref
       ((set_slice (( 64 : int):ii) (( 1 : int):ii) w__18 (( 8 : int):ii) (vec_of_bits [B0]  :  1 words$word)  :  64 words$word))))
   else sail2_state_monad$returnS () )))))))))`;


(*val AArch64_WatchpointByteMatch : ii -> mword ty64 -> M bool*)

val _ = Define `
 ((AArch64_WatchpointByteMatch:int ->(64)words$word ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) n vaddress=
    (sail2_state_monad$catch_early_returnS
     ( sail2_state_monad$bindS(sail2_state_monad$liftRS (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__0 : ProcState) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (AddrTop vaddress F w__0.ProcState_EL)) (\ (top : int) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (sail2_state_monad$read_regS DBGWVR_EL1_ref)) (\ (w__1 : ( 64 bits) list) . 
      let (bottom : ii) =
        (if ((((vec_of_bits [access_vec_dec ((access_list_dec w__1 n  :  64 words$word)) (( 2 : int):ii)]
                 :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
          (( 2 : int):ii)
        else (( 3 : int):ii)) in sail2_state_monad$bindS
      (sail2_state_monad$liftRS (sail2_state_monad$read_regS DBGWCR_EL1_ref)) (\ (w__2 : ( 32 bits) list) . 
      let (byte_select_match : bool) =
        ((vec_of_bits [access_vec_dec
                          ((subrange_vec_dec ((access_list_dec w__2 n  :  32 words$word)) (( 12 : int):ii) (( 5 : int):ii)
                             :  8 words$word))
                          ((unsigned_subrange vaddress ((((ex_int bottom)) - (( 1 : int):ii)))
                              (( 0 : int):ii)))]
            :  1 words$word) <> (vec_of_bits [B0]  :  1 words$word)) in sail2_state_monad$bindS
      (sail2_state_monad$liftRS (sail2_state_monad$read_regS DBGWCR_EL1_ref)) (\ (w__3 : ( 32 bits) list) . 
      let (mask : ii) =
        (lem$w2ui ((subrange_vec_dec ((access_list_dec w__3 n  :  32 words$word)) (( 28 : int):ii) (( 24 : int):ii)  :  5 words$word))) in sail2_state_monad$bindS
      (sail2_state_monad$liftRS ((undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M))) (\ (MSB : 8 bits) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS ((undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M))) (\ (LSB1 : 8 bits) .  sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((((ex_int mask)) > (( 0 : int):ii))))
        ( sail2_state_monad$bindS(sail2_state_monad$liftRS (sail2_state_monad$read_regS DBGWCR_EL1_ref)) (\ (w__4 : ( 32 bits) list) . 
         sail2_state_monad$returnS ((~ ((IsOnes
                        ((subrange_vec_dec ((access_list_dec w__4 n  :  32 words$word)) (( 12 : int):ii) (( 5 : int):ii)
                           :  8 words$word))))))))) (\ (w__5 : bool) .  sail2_state_monad$bindS
      (if w__5 then sail2_state_monad$bindS
         (sail2_state_monad$liftRS (ConstrainUnpredictableBool Unpredictable_WPMASKANDBAS)) (\ (w__6 : bool) . 
         let (byte_select_match : bool) = w__6 in
         sail2_state_monad$returnS (bottom, byte_select_match))
       else sail2_state_monad$bindS
         (sail2_state_monad$liftRS (sail2_state_monad$read_regS DBGWCR_EL1_ref)) (\ (w__7 : ( 32 bits) list) .  sail2_state_monad$bindS
         (sail2_state_monad$liftRS (sail2_state_monad$read_regS DBGWCR_EL1_ref)) (\ (w__8 : ( 32 bits) list) . 
         let LSB1 =
           ((and_vec
              ((subrange_vec_dec ((access_list_dec w__7 n  :  32 words$word)) (( 12 : int):ii) (( 5 : int):ii)
                 :  8 words$word))
              ((not_vec
                  ((sub_vec_int
                      ((subrange_vec_dec ((access_list_dec w__8 n  :  32 words$word)) (( 12 : int):ii) (( 5 : int):ii)
                         :  8 words$word)) (( 1 : int):ii)
                     :  8 words$word))
                 :  8 words$word))
             :  8 words$word)) in sail2_state_monad$bindS
         (sail2_state_monad$liftRS (sail2_state_monad$read_regS DBGWCR_EL1_ref)) (\ (w__9 : ( 32 bits) list) . 
         let MSB =
           ((add_vec
              ((subrange_vec_dec ((access_list_dec w__9 n  :  32 words$word)) (( 12 : int):ii) (( 5 : int):ii)
                 :  8 words$word)) LSB1
             :  8 words$word)) in
         if ((~ ((IsZero ((and_vec MSB ((sub_vec_int MSB (( 1 : int):ii)  :  8 words$word))  :  8 words$word))))))
         then sail2_state_monad$bindS
           (sail2_state_monad$liftRS (ConstrainUnpredictableBool Unpredictable_WPBASCONTIGUOUS)) (\ (w__10 : bool) . 
           let (byte_select_match : bool) = w__10 in
           let (bottom : ii) = ((( 3 : int):ii)) in
           sail2_state_monad$returnS (bottom, byte_select_match))
         else sail2_state_monad$returnS (bottom, byte_select_match))))) (\ varstup .  let ((bottom : ii), (byte_select_match :
        bool)) = varstup in sail2_state_monad$bindS
      (sail2_state_monad$liftRS (undefined_Constraint () )) (\ (c : Constraint) .  sail2_state_monad$bindS
      (if (((((((ex_int mask)) > (( 0 : int):ii))) /\ ((((ex_int mask)) <= (( 2 : int):ii)))))) then sail2_state_monad$bindS
         (sail2_state_monad$liftRS (ConstrainUnpredictableInteger (( 3 : int):ii) (( 31 : int):ii) Unpredictable_RESWPMASK)) (\ varstup .  let (tup__0, tup__1) = varstup in
         let c = tup__0 in
         let mask = tup__1 in sail2_state_monad$seqS
         (sail2_state_monad$liftRS (sail2_state_monad$assert_expS ((((((c = Constraint_DISABLED))) \/ ((((((c = Constraint_NONE))) \/ (((c = Constraint_UNKNOWN))))))))) "((c == Constraint_DISABLED) || ((c == Constraint_NONE) || (c == Constraint_UNKNOWN)))"))
         (case c of
           Constraint_DISABLED => sail2_state_monad$seqS (sail2_state_monad$early_returnS F : (unit, bool) MR) (sail2_state_monad$returnS mask)
         | Constraint_NONE => sail2_state_monad$returnS (( 0 : int):ii)
         ))
       else sail2_state_monad$returnS mask) (\ (mask : ii) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (WVR_match : bool) . 
      let (mask2 : int) = (ex_int mask) in
      let (bottom2 : int) = (ex_int bottom) in sail2_state_monad$bindS
      (if ((((ex_int mask)) > ((ex_int bottom)))) then sail2_state_monad$bindS (sail2_state_monad$seqS
         (sail2_state_monad$liftRS (sail2_state_monad$assert_expS T ""))
         (sail2_state_monad$liftRS (sail2_state_monad$read_regS DBGWVR_EL1_ref))) (\ (w__11 : ( 64 bits) list) . 
         let WVR_match =
           (subrange_subrange_eq vaddress
             ((((((((top - mask2)) + (( 1 : int):ii))) - (( 1 : int):ii))) +
                 mask2)) mask2 ((access_list_dec w__11 n  :  64 words$word))
             ((((((((top - mask2)) + (( 1 : int):ii))) - (( 1 : int):ii))) +
                 mask2)) mask2) in sail2_state_monad$bindS
         (sail2_state$and_boolS (sail2_state_monad$returnS WVR_match)
           ( sail2_state_monad$bindS(sail2_state_monad$liftRS (sail2_state_monad$read_regS DBGWVR_EL1_ref)) (\ (w__12 : ( 64 bits) list) . 
            sail2_state_monad$returnS ((~ ((is_zero_subrange ((access_list_dec w__12 n  :  64 words$word))
                           ((((((mask2 - bottom2)) - (( 1 : int):ii))) +
                               bottom2)) bottom2))))))) (\ (w__13 : bool) . 
         if w__13 then sail2_state_monad$liftRS (ConstrainUnpredictableBool Unpredictable_WPMASKEDBITS)
         else sail2_state_monad$returnS WVR_match))
       else sail2_state_monad$bindS
         (sail2_state_monad$liftRS (sail2_state_monad$read_regS DBGWVR_EL1_ref)) (\ (w__15 : ( 64 bits) list) . 
         let (WVR_match : bool) =
           (subrange_subrange_eq vaddress
             ((((((((top - bottom2)) + (( 1 : int):ii))) - (( 1 : int):ii))) +
                 bottom2)) bottom2 ((access_list_dec w__15 n  :  64 words$word))
             ((((((((top - bottom2)) + (( 1 : int):ii))) - (( 1 : int):ii))) +
                 bottom2)) bottom2) in
         sail2_state_monad$returnS WVR_match)) (\ (WVR_match : bool) . 
      sail2_state_monad$returnS (((WVR_match /\ byte_select_match)))))))))))))))))))`;


(*val IsOnes_slice : forall 'n . Size 'n => mword 'n -> ii -> ii -> M bool*)

val _ = Define `
 ((IsOnes_slice:'n words$word -> int -> int ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) xs i l=  (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS T "")
   (let (m : 'n bits) = ((slice_mask ((int_of_num (words$word_len xs))) i l  :  'n words$word)) in
   sail2_state_monad$returnS (((((and_vec xs m  :  'n words$word)) = m))))))`;


(*val AArch64_TranslationTableWalk : mword ty52 -> mword ty64 -> AccType -> bool -> bool -> bool -> ii -> M TLBRecord*)

val _ = Define `
 ((AArch64_TranslationTableWalk:(52)words$word ->(64)words$word -> AccType -> bool -> bool -> bool -> int ->(regstate)sail2_state_monad$sequential_state ->(((TLBRecord),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) ipaddress vaddress acctype iswrite secondstage s2fs1walk size1=
    (sail2_state_monad$catch_early_returnS
     ( sail2_state_monad$bindS (sail2_state_monad$seqS(if ((~ secondstage)) then sail2_state_monad$bindS
         (sail2_state_monad$liftRS ((S1TranslationRegime__1 ()   : ( 2 words$word) M))) (\ (w__0 :  2 words$word) .  sail2_state_monad$bindS
         (sail2_state_monad$liftRS (ELUsingAArch32 w__0)) (\ (w__1 : bool) .  sail2_state_monad$liftRS (sail2_state_monad$assert_expS ((~ w__1)) "")))
       else sail2_state_monad$bindS
         (sail2_state$and_boolS
           (sail2_state$and_boolS
              (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
                 ( sail2_state_monad$bindS(sail2_state_monad$liftRS (IsSecure () )) (\ (w__2 : bool) .  sail2_state_monad$returnS ((~ w__2)))))
              ( sail2_state_monad$bindS(sail2_state_monad$liftRS (ELUsingAArch32 EL2)) (\ (w__4 : bool) .  sail2_state_monad$returnS ((~ w__4)))))
           (sail2_state_monad$liftRS ((HasS2Translation () )))) (\ (w__7 : bool) . 
         sail2_state_monad$liftRS (sail2_state_monad$assert_expS w__7 "")))
      (sail2_state_monad$liftRS (undefined_TLBRecord () ))) (\ (result : TLBRecord) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (undefined_AddressDescriptor () )) (\ (descaddr : AddressDescriptor) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS ((undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M))) (\ (baseregister : 64 bits) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS ((undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M))) (\ (inputaddr : 64 bits) . 
      let (tmp_170 : FaultRecord) = (descaddr.AddressDescriptor_fault) in
      let tmp_170 = ((tmp_170 with<| FaultRecord_typ := Fault_None|>)) in
      let descaddr = ((descaddr with<| AddressDescriptor_fault := tmp_170|>)) in
      let (tmp_180 : MemoryAttributes) = (descaddr.AddressDescriptor_memattrs) in
      let tmp_180 = ((tmp_180 with<| MemoryAttributes_typ := MemType_Normal|>)) in
      let descaddr = ((descaddr with<| AddressDescriptor_memattrs := tmp_180|>)) in sail2_state_monad$bindS
      (sail2_state_monad$liftRS (undefined_int () )) (\ (startsizecheck : ii) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (undefined_int () )) (\ (inputsizecheck : ii) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (undefined_int () )) (\ (startlevel : ii) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (undefined_int () )) (\ (level : ii) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (undefined_int () )) (\ (stride : ii) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (undefined_int () )) (\ (firstblocklevel : ii) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (undefined_int () )) (\ (grainsize : ii) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (hierattrsdisabled : bool) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (update_AP : bool) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (update_AF : bool) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (singlepriv : bool) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (lookupsecure : bool) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (reversedescriptors : bool) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (disabled : bool) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (basefound : bool) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS ((undefined_bitvector (( 3 : int):ii)  : ( 3 words$word) M))) (\ (ps : 3 bits) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (undefined_int () )) (\ (inputsize_min : ii) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (undefined_Constraint () )) (\ (c : Constraint) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (undefined_int () )) (\ (inputsize_max : ii) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (undefined_int () )) (\ (inputsize : ii) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (midgrain : bool) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (largegrain : bool) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (undefined_int () )) (\ (top : ii) .  sail2_state_monad$bindS
      (if ((~ secondstage)) then sail2_state_monad$bindS
         (sail2_state_monad$liftRS ((ZeroExtend__1 (( 64 : int):ii) vaddress  : ( 64 words$word) M))) (\ (w__8 : 64 bits) . 
         let inputaddr = w__8 in sail2_state_monad$bindS
         (sail2_state_monad$liftRS (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__9 : ProcState) .  sail2_state_monad$bindS
         (sail2_state_monad$liftRS (AddrTop inputaddr (((acctype = AccType_IFETCH))) w__9.ProcState_EL)) (\ (w__10 :
           ii) . 
         let top = w__10 in sail2_state_monad$bindS
         (sail2_state_monad$liftRS (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__11 : ProcState) .  sail2_state_monad$bindS
         (if (((w__11.ProcState_EL = EL3))) then sail2_state_monad$bindS
            (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL3_ref  : ( 32 words$word) M))) (\ (w__12 : 32 bits) . 
            let largegrain =
              (((slice w__12 (( 14 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)) in sail2_state_monad$bindS
            (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL3_ref  : ( 32 words$word) M))) (\ (w__13 : 32 bits) . 
            let midgrain =
              (((slice w__13 (( 14 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word)) in sail2_state_monad$bindS
            (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL3_ref  : ( 32 words$word) M))) (\ (w__14 : 32 bits) . 
            let inputsize = ((( 64 : int):ii) - ((lem$w2ui ((slice w__14 (( 0 : int):ii) (( 6 : int):ii)  :  6 words$word))))) in
            let inputsize_max =
              (if (((((Have52BitVAExt () )) /\ largegrain))) then (( 52 : int):ii)
              else (( 48 : int):ii)) in sail2_state_monad$bindS
            (if ((((ex_int inputsize)) > ((ex_int inputsize_max)))) then
               let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in sail2_state_monad$seqS
               (sail2_state_monad$liftRS (sail2_state_monad$assert_expS ((((((c = Constraint_FORCE))) \/ (((c = Constraint_FAULT)))))) ""))
               (let (inputsize : ii) = (if (((c = Constraint_FORCE))) then inputsize_max else inputsize) in
               sail2_state_monad$returnS (c, inputsize))
             else sail2_state_monad$returnS (c, inputsize)) (\ varstup .  let ((c : Constraint), (inputsize : ii)) = varstup in
            let inputsize_min = ((( 64 : int):ii) - (( 39 : int):ii)) in sail2_state_monad$bindS
            (if ((((ex_int inputsize)) < ((ex_int inputsize_min)))) then
               let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in sail2_state_monad$seqS
               (sail2_state_monad$liftRS (sail2_state_monad$assert_expS ((((((c = Constraint_FORCE))) \/ (((c = Constraint_FAULT)))))) ""))
               (let (inputsize : ii) = (if (((c = Constraint_FORCE))) then inputsize_min else inputsize) in
               sail2_state_monad$returnS inputsize)
             else sail2_state_monad$returnS inputsize) (\ (inputsize : ii) .  sail2_state_monad$bindS
            (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL3_ref  : ( 32 words$word) M))) (\ (w__15 : 32 bits) . 
            let ps = ((slice w__15 (( 16 : int):ii) (( 3 : int):ii)  :  3 words$word)) in sail2_state_monad$bindS
            (sail2_state$and_boolS
              (sail2_state_monad$returnS (((((((ex_int inputsize)) >= ((ex_int inputsize_min)))) /\ ((((ex_int inputsize)) <= ((ex_int inputsize_max))))))))
              (sail2_state_monad$liftRS ((IsZero_slice inputaddr inputsize
                         ((((((ex_int top)) - ((ex_int inputsize)))) + (( 1 : int):ii))))))) (\ (w__17 :
              bool) . 
            let basefound = w__17 in
            let disabled = F in sail2_state_monad$bindS
            (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TTBR0_EL3_ref  : ( 64 words$word) M))) (\ (w__18 : 64 bits) . 
            let baseregister = w__18 in sail2_state_monad$bindS
            (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL3_ref  : ( 32 words$word) M))) (\ (w__19 : 32 bits) .  sail2_state_monad$bindS
            (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL3_ref  : ( 32 words$word) M))) (\ (w__20 : 32 bits) .  sail2_state_monad$bindS
            (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL3_ref  : ( 32 words$word) M))) (\ (w__21 : 32 bits) .  sail2_state_monad$bindS
            (sail2_state_monad$liftRS (WalkAttrDecode ((slice w__19 (( 12 : int):ii) (( 2 : int):ii)  :  2 words$word))
                     ((slice w__20 (( 10 : int):ii) (( 2 : int):ii)  :  2 words$word))
                     ((slice w__21 (( 8 : int):ii) (( 2 : int):ii)  :  2 words$word)) secondstage)) (\ (w__22 :
              MemoryAttributes) . 
            let descaddr = ((descaddr with<| AddressDescriptor_memattrs := w__22|>)) in sail2_state_monad$bindS
            (sail2_state_monad$liftRS ((sail2_state_monad$read_regS SCTLR_EL3_ref  : ( 32 words$word) M))) (\ (w__23 : 32 bits) . 
            let reversedescriptors =
              ((vec_of_bits [access_vec_dec w__23 (( 25 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
            let lookupsecure = T in
            let singlepriv = T in sail2_state_monad$bindS
            (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveAccessFlagUpdateExt () )))
              ( sail2_state_monad$bindS(sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL3_ref  : ( 32 words$word) M))) (\ (w__24 : 32 bits) . 
               sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__24 (( 21 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__25 : bool) . 
            let update_AF = w__25 in sail2_state_monad$bindS
            (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveDirtyBitModifierExt () )) /\ update_AF))))
              ( sail2_state_monad$bindS(sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL3_ref  : ( 32 words$word) M))) (\ (w__26 : 32 bits) . 
               sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__26 (( 22 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__27 : bool) . 
            let update_AP = w__27 in sail2_state_monad$bindS
            (sail2_state$and_boolS (sail2_state_monad$returnS ((AArch64_HaveHPDExt () )))
              ( sail2_state_monad$bindS(sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL3_ref  : ( 32 words$word) M))) (\ (w__28 : 32 bits) . 
               sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__28 (( 24 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__29 : bool) . 
            let (hierattrsdisabled : bool) = w__29 in
            sail2_state_monad$returnS (basefound,
                    baseregister,
                    descaddr,
                    disabled,
                    hierattrsdisabled,
                    inputsize,
                    largegrain,
                    lookupsecure,
                    midgrain,
                    ps,
                    reversedescriptors,
                    singlepriv,
                    update_AF,
                    update_AP)))))))))))))))))
          else sail2_state_monad$bindS
            (sail2_state_monad$liftRS (IsInHost () )) (\ (w__30 : bool) . 
            if w__30 then sail2_state_monad$bindS
              (if ((((vec_of_bits [access_vec_dec inputaddr top]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))) then sail2_state_monad$bindS
                 (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M))) (\ (w__31 : 64 bits) . 
                 let largegrain =
                   (((slice w__31 (( 14 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)) in sail2_state_monad$bindS
                 (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M))) (\ (w__32 : 64 bits) . 
                 let midgrain =
                   (((slice w__32 (( 14 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word)) in sail2_state_monad$bindS
                 (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M))) (\ (w__33 : 64 bits) . 
                 let inputsize =
                   ((( 64 : int):ii) - ((lem$w2ui ((slice w__33 (( 0 : int):ii) (( 6 : int):ii)  :  6 words$word))))) in
                 let inputsize_max =
                   (if (((((Have52BitVAExt () )) /\ largegrain))) then (( 52 : int):ii)
                   else (( 48 : int):ii)) in sail2_state_monad$bindS
                 (if ((((ex_int inputsize)) > ((ex_int inputsize_max)))) then
                    let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in sail2_state_monad$seqS
                    (sail2_state_monad$liftRS (sail2_state_monad$assert_expS ((((((c = Constraint_FORCE))) \/ (((c = Constraint_FAULT)))))) ""))
                    (let (inputsize : ii) =
                      (if (((c = Constraint_FORCE))) then inputsize_max
                      else inputsize) in
                    sail2_state_monad$returnS (c, inputsize))
                  else sail2_state_monad$returnS (c, inputsize)) (\ varstup .  let ((c : Constraint), (inputsize :
                   ii)) = varstup in
                 let inputsize_min = ((( 64 : int):ii) - (( 39 : int):ii)) in sail2_state_monad$bindS
                 (if ((((ex_int inputsize)) < ((ex_int inputsize_min)))) then
                    let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in sail2_state_monad$seqS
                    (sail2_state_monad$liftRS (sail2_state_monad$assert_expS ((((((c = Constraint_FORCE))) \/ (((c = Constraint_FAULT)))))) ""))
                    (let (inputsize : ii) =
                      (if (((c = Constraint_FORCE))) then inputsize_min
                      else inputsize) in
                    sail2_state_monad$returnS inputsize)
                  else sail2_state_monad$returnS inputsize) (\ (inputsize : ii) .  sail2_state_monad$bindS
                 (sail2_state$and_boolS
                   (sail2_state_monad$returnS (((((((ex_int inputsize)) >= ((ex_int inputsize_min)))) /\ ((((ex_int inputsize)) <= ((ex_int inputsize_max))))))))
                   (sail2_state_monad$liftRS ((IsZero_slice inputaddr inputsize
                              ((((((ex_int top)) - ((ex_int inputsize)))) +
                                  (( 1 : int):ii))))))) (\ (w__35 : bool) . 
                 let basefound = w__35 in sail2_state_monad$bindS
                 (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M))) (\ (w__36 : 64 bits) . 
                 let disabled =
                   ((vec_of_bits [access_vec_dec w__36 (( 7 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in sail2_state_monad$bindS
                 (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TTBR0_EL2_ref  : ( 64 words$word) M))) (\ (w__37 : 64 bits) . 
                 let baseregister = w__37 in sail2_state_monad$bindS
                 (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M))) (\ (w__38 : 64 bits) .  sail2_state_monad$bindS
                 (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M))) (\ (w__39 : 64 bits) .  sail2_state_monad$bindS
                 (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M))) (\ (w__40 : 64 bits) .  sail2_state_monad$bindS
                 (sail2_state_monad$liftRS (WalkAttrDecode ((slice w__38 (( 12 : int):ii) (( 2 : int):ii)  :  2 words$word))
                          ((slice w__39 (( 10 : int):ii) (( 2 : int):ii)  :  2 words$word))
                          ((slice w__40 (( 8 : int):ii) (( 2 : int):ii)  :  2 words$word)) secondstage)) (\ (w__41 :
                   MemoryAttributes) . 
                 let descaddr = ((descaddr with<| AddressDescriptor_memattrs := w__41|>)) in sail2_state_monad$bindS
                 (sail2_state$and_boolS (sail2_state_monad$returnS ((AArch64_HaveHPDExt () )))
                   ( sail2_state_monad$bindS(sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M))) (\ (w__42 : 64 bits) . 
                    sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__42 (( 41 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__43 : bool) . 
                 let (hierattrsdisabled : bool) = w__43 in
                 sail2_state_monad$returnS (basefound,
                         baseregister,
                         descaddr,
                         disabled,
                         hierattrsdisabled,
                         inputsize,
                         largegrain,
                         midgrain))))))))))))))
               else sail2_state_monad$bindS
                 (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M))) (\ (w__44 : 64 bits) . 
                 let inputsize =
                   ((( 64 : int):ii) - ((lem$w2ui ((slice w__44 (( 16 : int):ii) (( 6 : int):ii)  :  6 words$word))))) in sail2_state_monad$bindS
                 (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M))) (\ (w__45 : 64 bits) . 
                 let largegrain =
                   (((slice w__45 (( 30 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B1]  :  2 words$word)) in sail2_state_monad$bindS
                 (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M))) (\ (w__46 : 64 bits) . 
                 let midgrain =
                   (((slice w__46 (( 30 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)) in
                 let inputsize_max =
                   (if (((((Have52BitVAExt () )) /\ largegrain))) then (( 52 : int):ii)
                   else (( 48 : int):ii)) in sail2_state_monad$bindS
                 (if ((((ex_int inputsize)) > ((ex_int inputsize_max)))) then
                    let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in sail2_state_monad$seqS
                    (sail2_state_monad$liftRS (sail2_state_monad$assert_expS ((((((c = Constraint_FORCE))) \/ (((c = Constraint_FAULT)))))) ""))
                    (let (inputsize : ii) =
                      (if (((c = Constraint_FORCE))) then inputsize_max
                      else inputsize) in
                    sail2_state_monad$returnS (c, inputsize))
                  else sail2_state_monad$returnS (c, inputsize)) (\ varstup .  let ((c : Constraint), (inputsize :
                   ii)) = varstup in
                 let inputsize_min = ((( 64 : int):ii) - (( 39 : int):ii)) in sail2_state_monad$bindS
                 (if ((((ex_int inputsize)) < ((ex_int inputsize_min)))) then
                    let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in sail2_state_monad$seqS
                    (sail2_state_monad$liftRS (sail2_state_monad$assert_expS ((((((c = Constraint_FORCE))) \/ (((c = Constraint_FAULT)))))) ""))
                    (let (inputsize : ii) =
                      (if (((c = Constraint_FORCE))) then inputsize_min
                      else inputsize) in
                    sail2_state_monad$returnS inputsize)
                  else sail2_state_monad$returnS inputsize) (\ (inputsize : ii) .  sail2_state_monad$bindS
                 (sail2_state$and_boolS
                   (sail2_state_monad$returnS (((((((ex_int inputsize)) >= ((ex_int inputsize_min)))) /\ ((((ex_int inputsize)) <= ((ex_int inputsize_max))))))))
                   (sail2_state_monad$liftRS ((IsOnes_slice inputaddr inputsize
                              ((((((ex_int top)) - ((ex_int inputsize)))) +
                                  (( 1 : int):ii))))))) (\ (w__48 : bool) . 
                 let basefound = w__48 in sail2_state_monad$bindS
                 (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M))) (\ (w__49 : 64 bits) . 
                 let disabled =
                   ((vec_of_bits [access_vec_dec w__49 (( 23 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in sail2_state_monad$bindS
                 (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TTBR1_EL2_ref  : ( 64 words$word) M))) (\ (w__50 : 64 bits) . 
                 let baseregister = w__50 in sail2_state_monad$bindS
                 (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M))) (\ (w__51 : 64 bits) .  sail2_state_monad$bindS
                 (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M))) (\ (w__52 : 64 bits) .  sail2_state_monad$bindS
                 (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M))) (\ (w__53 : 64 bits) .  sail2_state_monad$bindS
                 (sail2_state_monad$liftRS (WalkAttrDecode ((slice w__51 (( 28 : int):ii) (( 2 : int):ii)  :  2 words$word))
                          ((slice w__52 (( 26 : int):ii) (( 2 : int):ii)  :  2 words$word))
                          ((slice w__53 (( 24 : int):ii) (( 2 : int):ii)  :  2 words$word)) secondstage)) (\ (w__54 :
                   MemoryAttributes) . 
                 let descaddr = ((descaddr with<| AddressDescriptor_memattrs := w__54|>)) in sail2_state_monad$bindS
                 (sail2_state$and_boolS (sail2_state_monad$returnS ((AArch64_HaveHPDExt () )))
                   ( sail2_state_monad$bindS(sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M))) (\ (w__55 : 64 bits) . 
                    sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__55 (( 42 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__56 : bool) . 
                 let (hierattrsdisabled : bool) = w__56 in
                 sail2_state_monad$returnS (basefound,
                         baseregister,
                         descaddr,
                         disabled,
                         hierattrsdisabled,
                         inputsize,
                         largegrain,
                         midgrain))))))))))))))) (\ varstup .  let ((basefound : bool), (baseregister : 64
                bits), (descaddr : AddressDescriptor), (disabled : bool), (hierattrsdisabled :
                bool), (inputsize : ii), (largegrain : bool), (midgrain : bool)) = varstup in sail2_state_monad$bindS
              (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M))) (\ (w__57 : 64 bits) . 
              let ps = ((slice w__57 (( 32 : int):ii) (( 3 : int):ii)  :  3 words$word)) in sail2_state_monad$bindS
              (sail2_state_monad$liftRS ((sail2_state_monad$read_regS SCTLR_EL2_ref  : ( 32 words$word) M))) (\ (w__58 : 32 bits) . 
              let reversedescriptors =
                ((vec_of_bits [access_vec_dec w__58 (( 25 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
              let lookupsecure = F in
              let singlepriv = F in sail2_state_monad$bindS
              (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveAccessFlagUpdateExt () )))
                ( sail2_state_monad$bindS(sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M))) (\ (w__59 : 64 bits) . 
                 sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__59 (( 39 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__60 : bool) . 
              let update_AF = w__60 in sail2_state_monad$bindS
              (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveDirtyBitModifierExt () )) /\ update_AF))))
                ( sail2_state_monad$bindS(sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M))) (\ (w__61 : 64 bits) . 
                 sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__61 (( 40 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__62 : bool) . 
              let (update_AP : bool) = w__62 in
              sail2_state_monad$returnS (basefound,
                      baseregister,
                      descaddr,
                      disabled,
                      hierattrsdisabled,
                      inputsize,
                      largegrain,
                      lookupsecure,
                      midgrain,
                      ps,
                      reversedescriptors,
                      singlepriv,
                      update_AF,
                      update_AP))))))
            else sail2_state_monad$bindS
              (sail2_state_monad$liftRS (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__63 : ProcState) . 
              if (((w__63.ProcState_EL = EL2))) then sail2_state_monad$bindS
                (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M))) (\ (w__64 : 64 bits) . 
                let inputsize =
                  ((( 64 : int):ii) - ((lem$w2ui ((slice w__64 (( 0 : int):ii) (( 6 : int):ii)  :  6 words$word))))) in sail2_state_monad$bindS
                (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M))) (\ (w__65 : 64 bits) . 
                let largegrain =
                  (((slice w__65 (( 14 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)) in sail2_state_monad$bindS
                (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M))) (\ (w__66 : 64 bits) . 
                let midgrain =
                  (((slice w__66 (( 14 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word)) in
                let inputsize_max =
                  (if (((((Have52BitVAExt () )) /\ largegrain))) then (( 52 : int):ii)
                  else (( 48 : int):ii)) in sail2_state_monad$bindS
                (if ((((ex_int inputsize)) > ((ex_int inputsize_max)))) then
                   let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in sail2_state_monad$seqS
                   (sail2_state_monad$liftRS (sail2_state_monad$assert_expS ((((((c = Constraint_FORCE))) \/ (((c = Constraint_FAULT)))))) ""))
                   (let (inputsize : ii) =
                     (if (((c = Constraint_FORCE))) then inputsize_max
                     else inputsize) in
                   sail2_state_monad$returnS (c, inputsize))
                 else sail2_state_monad$returnS (c, inputsize)) (\ varstup .  let ((c : Constraint), (inputsize :
                  ii)) = varstup in
                let inputsize_min = ((( 64 : int):ii) - (( 39 : int):ii)) in sail2_state_monad$bindS
                (if ((((ex_int inputsize)) < ((ex_int inputsize_min)))) then
                   let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in sail2_state_monad$seqS
                   (sail2_state_monad$liftRS (sail2_state_monad$assert_expS ((((((c = Constraint_FORCE))) \/ (((c = Constraint_FAULT)))))) ""))
                   (let (inputsize : ii) =
                     (if (((c = Constraint_FORCE))) then inputsize_min
                     else inputsize) in
                   sail2_state_monad$returnS inputsize)
                 else sail2_state_monad$returnS inputsize) (\ (inputsize : ii) .  sail2_state_monad$bindS
                (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M))) (\ (w__67 : 64 bits) . 
                let ps = ((slice w__67 (( 16 : int):ii) (( 3 : int):ii)  :  3 words$word)) in sail2_state_monad$bindS
                (sail2_state$and_boolS
                  (sail2_state_monad$returnS (((((((ex_int inputsize)) >= ((ex_int inputsize_min)))) /\ ((((ex_int inputsize)) <= ((ex_int inputsize_max))))))))
                  (sail2_state_monad$liftRS ((IsZero_slice inputaddr inputsize
                             ((((((ex_int top)) - ((ex_int inputsize)))) +
                                 (( 1 : int):ii))))))) (\ (w__69 : bool) . 
                let basefound = w__69 in
                let disabled = F in sail2_state_monad$bindS
                (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TTBR0_EL2_ref  : ( 64 words$word) M))) (\ (w__70 : 64 bits) . 
                let baseregister = w__70 in sail2_state_monad$bindS
                (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M))) (\ (w__71 : 64 bits) .  sail2_state_monad$bindS
                (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M))) (\ (w__72 : 64 bits) .  sail2_state_monad$bindS
                (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M))) (\ (w__73 : 64 bits) .  sail2_state_monad$bindS
                (sail2_state_monad$liftRS (WalkAttrDecode ((slice w__71 (( 12 : int):ii) (( 2 : int):ii)  :  2 words$word))
                         ((slice w__72 (( 10 : int):ii) (( 2 : int):ii)  :  2 words$word))
                         ((slice w__73 (( 8 : int):ii) (( 2 : int):ii)  :  2 words$word)) secondstage)) (\ (w__74 :
                  MemoryAttributes) . 
                let descaddr = ((descaddr with<| AddressDescriptor_memattrs := w__74|>)) in sail2_state_monad$bindS
                (sail2_state_monad$liftRS ((sail2_state_monad$read_regS SCTLR_EL2_ref  : ( 32 words$word) M))) (\ (w__75 : 32 bits) . 
                let reversedescriptors =
                  ((vec_of_bits [access_vec_dec w__75 (( 25 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
                let lookupsecure = F in
                let singlepriv = T in sail2_state_monad$bindS
                (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveAccessFlagUpdateExt () )))
                  ( sail2_state_monad$bindS(sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M))) (\ (w__76 : 64 bits) . 
                   sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__76 (( 39 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__77 : bool) . 
                let update_AF = w__77 in sail2_state_monad$bindS
                (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveDirtyBitModifierExt () )) /\ update_AF))))
                  ( sail2_state_monad$bindS(sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M))) (\ (w__78 : 64 bits) . 
                   sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__78 (( 40 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__79 : bool) . 
                let update_AP = w__79 in sail2_state_monad$bindS
                (sail2_state$and_boolS (sail2_state_monad$returnS ((AArch64_HaveHPDExt () )))
                  ( sail2_state_monad$bindS(sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL2_ref  : ( 64 words$word) M))) (\ (w__80 : 64 bits) . 
                   sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__80 (( 24 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__81 : bool) . 
                let (hierattrsdisabled : bool) = w__81 in
                sail2_state_monad$returnS (basefound,
                        baseregister,
                        descaddr,
                        disabled,
                        hierattrsdisabled,
                        inputsize,
                        largegrain,
                        lookupsecure,
                        midgrain,
                        ps,
                        reversedescriptors,
                        singlepriv,
                        update_AF,
                        update_AP)))))))))))))))))
              else sail2_state_monad$bindS
                (if ((((vec_of_bits [access_vec_dec inputaddr top]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))) then sail2_state_monad$bindS
                   (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M))) (\ (w__82 : 64 bits) . 
                   let inputsize =
                     ((( 64 : int):ii) - ((lem$w2ui ((slice w__82 (( 0 : int):ii) (( 6 : int):ii)  :  6 words$word))))) in sail2_state_monad$bindS
                   (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M))) (\ (w__83 : 64 bits) . 
                   let largegrain =
                     (((slice w__83 (( 14 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)) in sail2_state_monad$bindS
                   (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M))) (\ (w__84 : 64 bits) . 
                   let midgrain =
                     (((slice w__84 (( 14 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word)) in
                   let inputsize_max =
                     (if (((((Have52BitVAExt () )) /\ largegrain))) then (( 52 : int):ii)
                     else (( 48 : int):ii)) in sail2_state_monad$bindS
                   (if ((((ex_int inputsize)) > ((ex_int inputsize_max)))) then
                      let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in sail2_state_monad$seqS
                      (sail2_state_monad$liftRS (sail2_state_monad$assert_expS ((((((c = Constraint_FORCE))) \/ (((c = Constraint_FAULT)))))) ""))
                      (let (inputsize : ii) =
                        (if (((c = Constraint_FORCE))) then inputsize_max
                        else inputsize) in
                      sail2_state_monad$returnS (c, inputsize))
                    else sail2_state_monad$returnS (c, inputsize)) (\ varstup .  let ((c : Constraint), (inputsize :
                     ii)) = varstup in
                   let inputsize_min = ((( 64 : int):ii) - (( 39 : int):ii)) in sail2_state_monad$bindS
                   (if ((((ex_int inputsize)) < ((ex_int inputsize_min)))) then
                      let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in sail2_state_monad$seqS
                      (sail2_state_monad$liftRS (sail2_state_monad$assert_expS ((((((c = Constraint_FORCE))) \/ (((c = Constraint_FAULT)))))) ""))
                      (let (inputsize : ii) =
                        (if (((c = Constraint_FORCE))) then inputsize_min
                        else inputsize) in
                      sail2_state_monad$returnS inputsize)
                    else sail2_state_monad$returnS inputsize) (\ (inputsize : ii) .  sail2_state_monad$bindS
                   (sail2_state$and_boolS
                     (sail2_state_monad$returnS (((((((ex_int inputsize)) >= ((ex_int inputsize_min)))) /\ ((((ex_int inputsize)) <= ((ex_int inputsize_max))))))))
                     (sail2_state_monad$liftRS ((IsZero_slice inputaddr inputsize
                                ((((((ex_int top)) - ((ex_int inputsize)))) +
                                    (( 1 : int):ii))))))) (\ (w__86 : bool) . 
                   let basefound = w__86 in sail2_state_monad$bindS
                   (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M))) (\ (w__87 : 64 bits) . 
                   let disabled =
                     ((vec_of_bits [access_vec_dec w__87 (( 7 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in sail2_state_monad$bindS
                   (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TTBR0_EL1_ref  : ( 64 words$word) M))) (\ (w__88 : 64 bits) . 
                   let baseregister = w__88 in sail2_state_monad$bindS
                   (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M))) (\ (w__89 : 64 bits) .  sail2_state_monad$bindS
                   (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M))) (\ (w__90 : 64 bits) .  sail2_state_monad$bindS
                   (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M))) (\ (w__91 : 64 bits) .  sail2_state_monad$bindS
                   (sail2_state_monad$liftRS (WalkAttrDecode ((slice w__89 (( 12 : int):ii) (( 2 : int):ii)  :  2 words$word))
                            ((slice w__90 (( 10 : int):ii) (( 2 : int):ii)  :  2 words$word))
                            ((slice w__91 (( 8 : int):ii) (( 2 : int):ii)  :  2 words$word)) secondstage)) (\ (w__92 :
                     MemoryAttributes) . 
                   let descaddr = ((descaddr with<| AddressDescriptor_memattrs := w__92|>)) in sail2_state_monad$bindS
                   (sail2_state$and_boolS (sail2_state_monad$returnS ((AArch64_HaveHPDExt () )))
                     ( sail2_state_monad$bindS(sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M))) (\ (w__93 : 64 bits) . 
                      sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__93 (( 41 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__94 : bool) . 
                   let (hierattrsdisabled : bool) = w__94 in
                   sail2_state_monad$returnS (basefound,
                           baseregister,
                           descaddr,
                           disabled,
                           hierattrsdisabled,
                           inputsize,
                           largegrain,
                           midgrain))))))))))))))
                 else sail2_state_monad$bindS
                   (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M))) (\ (w__95 : 64 bits) . 
                   let inputsize =
                     ((( 64 : int):ii) - ((lem$w2ui ((slice w__95 (( 16 : int):ii) (( 6 : int):ii)  :  6 words$word))))) in sail2_state_monad$bindS
                   (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M))) (\ (w__96 : 64 bits) . 
                   let largegrain =
                     (((slice w__96 (( 30 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B1]  :  2 words$word)) in sail2_state_monad$bindS
                   (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M))) (\ (w__97 : 64 bits) . 
                   let midgrain =
                     (((slice w__97 (( 30 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)) in
                   let inputsize_max =
                     (if (((((Have52BitVAExt () )) /\ largegrain))) then (( 52 : int):ii)
                     else (( 48 : int):ii)) in sail2_state_monad$bindS
                   (if ((((ex_int inputsize)) > ((ex_int inputsize_max)))) then
                      let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in sail2_state_monad$seqS
                      (sail2_state_monad$liftRS (sail2_state_monad$assert_expS ((((((c = Constraint_FORCE))) \/ (((c = Constraint_FAULT)))))) ""))
                      (let (inputsize : ii) =
                        (if (((c = Constraint_FORCE))) then inputsize_max
                        else inputsize) in
                      sail2_state_monad$returnS (c, inputsize))
                    else sail2_state_monad$returnS (c, inputsize)) (\ varstup .  let ((c : Constraint), (inputsize :
                     ii)) = varstup in
                   let inputsize_min = ((( 64 : int):ii) - (( 39 : int):ii)) in sail2_state_monad$bindS
                   (if ((((ex_int inputsize)) < ((ex_int inputsize_min)))) then
                      let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in sail2_state_monad$seqS
                      (sail2_state_monad$liftRS (sail2_state_monad$assert_expS ((((((c = Constraint_FORCE))) \/ (((c = Constraint_FAULT)))))) ""))
                      (let (inputsize : ii) =
                        (if (((c = Constraint_FORCE))) then inputsize_min
                        else inputsize) in
                      sail2_state_monad$returnS inputsize)
                    else sail2_state_monad$returnS inputsize) (\ (inputsize : ii) .  sail2_state_monad$bindS
                   (sail2_state$and_boolS
                     (sail2_state_monad$returnS (((((((ex_int inputsize)) >= ((ex_int inputsize_min)))) /\ ((((ex_int inputsize)) <= ((ex_int inputsize_max))))))))
                     (sail2_state_monad$liftRS ((IsOnes_slice inputaddr inputsize
                                ((((((ex_int top)) - ((ex_int inputsize)))) +
                                    (( 1 : int):ii))))))) (\ (w__99 : bool) . 
                   let basefound = w__99 in sail2_state_monad$bindS
                   (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M))) (\ (w__100 : 64 bits) . 
                   let disabled =
                     ((vec_of_bits [access_vec_dec w__100 (( 23 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in sail2_state_monad$bindS
                   (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TTBR1_EL1_ref  : ( 64 words$word) M))) (\ (w__101 : 64 bits) . 
                   let baseregister = w__101 in sail2_state_monad$bindS
                   (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M))) (\ (w__102 : 64 bits) .  sail2_state_monad$bindS
                   (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M))) (\ (w__103 : 64 bits) .  sail2_state_monad$bindS
                   (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M))) (\ (w__104 : 64 bits) .  sail2_state_monad$bindS
                   (sail2_state_monad$liftRS (WalkAttrDecode ((slice w__102 (( 28 : int):ii) (( 2 : int):ii)  :  2 words$word))
                            ((slice w__103 (( 26 : int):ii) (( 2 : int):ii)  :  2 words$word))
                            ((slice w__104 (( 24 : int):ii) (( 2 : int):ii)  :  2 words$word)) secondstage)) (\ (w__105 :
                     MemoryAttributes) . 
                   let descaddr = ((descaddr with<| AddressDescriptor_memattrs := w__105|>)) in sail2_state_monad$bindS
                   (sail2_state$and_boolS (sail2_state_monad$returnS ((AArch64_HaveHPDExt () )))
                     ( sail2_state_monad$bindS(sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M))) (\ (w__106 : 64 bits) . 
                      sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__106 (( 42 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__107 : bool) . 
                   let (hierattrsdisabled : bool) = w__107 in
                   sail2_state_monad$returnS (basefound,
                           baseregister,
                           descaddr,
                           disabled,
                           hierattrsdisabled,
                           inputsize,
                           largegrain,
                           midgrain))))))))))))))) (\ varstup .  let ((basefound : bool), (baseregister : 64
                  bits), (descaddr : AddressDescriptor), (disabled : bool), (hierattrsdisabled :
                  bool), (inputsize : ii), (largegrain : bool), (midgrain : bool)) = varstup in sail2_state_monad$bindS
                (sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M))) (\ (w__108 : 64 bits) . 
                let ps = ((slice w__108 (( 32 : int):ii) (( 3 : int):ii)  :  3 words$word)) in sail2_state_monad$bindS
                (sail2_state_monad$liftRS ((sail2_state_monad$read_regS SCTLR_EL1_ref  : ( 32 words$word) M))) (\ (w__109 : 32 bits) . 
                let reversedescriptors =
                  ((vec_of_bits [access_vec_dec w__109 (( 25 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in sail2_state_monad$bindS
                (sail2_state_monad$liftRS (IsSecure () )) (\ (w__110 : bool) . 
                let lookupsecure = w__110 in
                let singlepriv = F in sail2_state_monad$bindS
                (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveAccessFlagUpdateExt () )))
                  ( sail2_state_monad$bindS(sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M))) (\ (w__111 : 64 bits) . 
                   sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__111 (( 39 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__112 : bool) . 
                let update_AF = w__112 in sail2_state_monad$bindS
                (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveDirtyBitModifierExt () )) /\ update_AF))))
                  ( sail2_state_monad$bindS(sail2_state_monad$liftRS ((sail2_state_monad$read_regS TCR_EL1_ref  : ( 64 words$word) M))) (\ (w__113 : 64 bits) . 
                   sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__113 (( 40 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__114 : bool) . 
                let (update_AP : bool) = w__114 in
                sail2_state_monad$returnS (basefound,
                        baseregister,
                        descaddr,
                        disabled,
                        hierattrsdisabled,
                        inputsize,
                        largegrain,
                        lookupsecure,
                        midgrain,
                        ps,
                        reversedescriptors,
                        singlepriv,
                        update_AF,
                        update_AP)))))))))) (\ varstup .  let ((basefound : bool), (baseregister : 64
           bits), (descaddr : AddressDescriptor), (disabled : bool), (hierattrsdisabled : bool), (inputsize :
           ii), (largegrain : bool), (lookupsecure : bool), (midgrain : bool), (ps : 3 bits), (reversedescriptors :
           bool), (singlepriv : bool), (update_AF : bool), (update_AP : bool)) = varstup in
         let ((firstblocklevel : ii), (grainsize : ii)) =
           (if largegrain then
             let (grainsize : ii) = ((( 16 : int):ii)) in
             let (firstblocklevel : ii) = (if ((Have52BitPAExt () )) then (( 1 : int):ii) else (( 2 : int):ii)) in
             (firstblocklevel, grainsize)
           else
             let ((firstblocklevel : ii), (grainsize : ii)) =
               (if midgrain then
                 let (grainsize : ii) = ((( 14 : int):ii)) in
                 let (firstblocklevel : ii) = ((( 2 : int):ii)) in
                 (firstblocklevel, grainsize)
               else
                 let (grainsize : ii) = ((( 12 : int):ii)) in
                 let (firstblocklevel : ii) = ((( 1 : int):ii)) in
                 (firstblocklevel, grainsize)) in
             (firstblocklevel, grainsize)) in
         let (stride : ii) = (((ex_int grainsize)) - (( 3 : int):ii)) in
         let (level : ii) =
           ((( 4 : int):ii) -
             ((ex_int
                 ((clg
                     (((((real_of_int ((((ex_int inputsize)) - ((ex_int grainsize)))))))
                         /
                         (((real_of_int stride)))))))))) in
         sail2_state_monad$returnS (basefound,
                 baseregister,
                 descaddr,
                 disabled,
                 firstblocklevel,
                 grainsize,
                 hierattrsdisabled,
                 inputaddr,
                 inputsize,
                 largegrain,
                 level,
                 lookupsecure,
                 midgrain,
                 ps,
                 reversedescriptors,
                 singlepriv,
                 stride,
                 update_AF,
                 update_AP))))))
       else sail2_state_monad$bindS
         (sail2_state_monad$liftRS ((ZeroExtend__1 (( 64 : int):ii) ipaddress  : ( 64 words$word) M))) (\ (w__115 : 64 bits) . 
         let inputaddr = w__115 in sail2_state_monad$bindS
         (sail2_state_monad$liftRS ((sail2_state_monad$read_regS VTCR_EL2_ref  : ( 32 words$word) M))) (\ (w__116 : 32 bits) . 
         let inputsize = ((( 64 : int):ii) - ((lem$w2ui ((slice w__116 (( 0 : int):ii) (( 6 : int):ii)  :  6 words$word))))) in sail2_state_monad$bindS
         (sail2_state_monad$liftRS ((sail2_state_monad$read_regS VTCR_EL2_ref  : ( 32 words$word) M))) (\ (w__117 : 32 bits) . 
         let largegrain =
           (((slice w__117 (( 14 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)) in sail2_state_monad$bindS
         (sail2_state_monad$liftRS ((sail2_state_monad$read_regS VTCR_EL2_ref  : ( 32 words$word) M))) (\ (w__118 : 32 bits) . 
         let midgrain =
           (((slice w__118 (( 14 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word)) in
         let inputsize_max =
           (if (((((Have52BitVAExt () )) /\ largegrain))) then (( 52 : int):ii)
           else (( 48 : int):ii)) in sail2_state_monad$bindS
         (if ((((ex_int inputsize)) > ((ex_int inputsize_max)))) then
            let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in sail2_state_monad$seqS
            (sail2_state_monad$liftRS (sail2_state_monad$assert_expS ((((((c = Constraint_FORCE))) \/ (((c = Constraint_FAULT)))))) ""))
            (let (inputsize : ii) = (if (((c = Constraint_FORCE))) then inputsize_max else inputsize) in
            sail2_state_monad$returnS (c, inputsize))
          else sail2_state_monad$returnS (c, inputsize)) (\ varstup .  let ((c : Constraint), (inputsize : ii)) = varstup in
         let inputsize_min = ((( 64 : int):ii) - (( 39 : int):ii)) in sail2_state_monad$bindS
         (if ((((ex_int inputsize)) < ((ex_int inputsize_min)))) then
            let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in sail2_state_monad$seqS
            (sail2_state_monad$liftRS (sail2_state_monad$assert_expS ((((((c = Constraint_FORCE))) \/ (((c = Constraint_FAULT)))))) ""))
            (let (inputsize : ii) = (if (((c = Constraint_FORCE))) then inputsize_min else inputsize) in
            sail2_state_monad$returnS inputsize)
          else sail2_state_monad$returnS inputsize) (\ (inputsize : ii) .  sail2_state_monad$bindS
         (sail2_state_monad$liftRS ((sail2_state_monad$read_regS VTCR_EL2_ref  : ( 32 words$word) M))) (\ (w__119 : 32 bits) . 
         let ps = ((slice w__119 (( 16 : int):ii) (( 3 : int):ii)  :  3 words$word)) in sail2_state_monad$bindS
         (sail2_state$and_boolS
           (sail2_state_monad$returnS (((((((ex_int inputsize)) >= ((ex_int inputsize_min)))) /\ ((((ex_int inputsize)) <= ((ex_int inputsize_max))))))))
           (sail2_state_monad$liftRS ((IsZero_slice inputaddr inputsize
                      ((((~ ((ex_int inputsize)))) + (( 64 : int):ii))))))) (\ (w__121 :
           bool) . 
         let basefound = w__121 in
         let disabled = F in sail2_state_monad$bindS
         (sail2_state_monad$liftRS ((sail2_state_monad$read_regS VTTBR_EL2_ref  : ( 64 words$word) M))) (\ (w__122 : 64 bits) . 
         let baseregister = w__122 in sail2_state_monad$bindS
         (sail2_state_monad$liftRS ((sail2_state_monad$read_regS VTCR_EL2_ref  : ( 32 words$word) M))) (\ (w__123 : 32 bits) .  sail2_state_monad$bindS
         (sail2_state_monad$liftRS ((sail2_state_monad$read_regS VTCR_EL2_ref  : ( 32 words$word) M))) (\ (w__124 : 32 bits) .  sail2_state_monad$bindS
         (sail2_state_monad$liftRS ((sail2_state_monad$read_regS VTCR_EL2_ref  : ( 32 words$word) M))) (\ (w__125 : 32 bits) .  sail2_state_monad$bindS
         (sail2_state_monad$liftRS (WalkAttrDecode ((slice w__123 (( 8 : int):ii) (( 2 : int):ii)  :  2 words$word))
                  ((slice w__124 (( 10 : int):ii) (( 2 : int):ii)  :  2 words$word))
                  ((slice w__125 (( 12 : int):ii) (( 2 : int):ii)  :  2 words$word)) secondstage)) (\ (w__126 :
           MemoryAttributes) . 
         let descaddr = ((descaddr with<| AddressDescriptor_memattrs := w__126|>)) in sail2_state_monad$bindS
         (sail2_state_monad$liftRS ((sail2_state_monad$read_regS SCTLR_EL2_ref  : ( 32 words$word) M))) (\ (w__127 : 32 bits) . 
         let reversedescriptors =
           ((vec_of_bits [access_vec_dec w__127 (( 25 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
         let lookupsecure = F in
         let singlepriv = T in sail2_state_monad$bindS
         (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveAccessFlagUpdateExt () )))
           ( sail2_state_monad$bindS(sail2_state_monad$liftRS ((sail2_state_monad$read_regS VTCR_EL2_ref  : ( 32 words$word) M))) (\ (w__128 : 32 bits) . 
            sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__128 (( 21 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__129 : bool) . 
         let update_AF = w__129 in sail2_state_monad$bindS
         (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveDirtyBitModifierExt () )) /\ update_AF))))
           ( sail2_state_monad$bindS(sail2_state_monad$liftRS ((sail2_state_monad$read_regS VTCR_EL2_ref  : ( 32 words$word) M))) (\ (w__130 : 32 bits) . 
            sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__130 (( 22 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__131 : bool) . 
         let update_AP = w__131 in sail2_state_monad$bindS
         (sail2_state_monad$liftRS ((sail2_state_monad$read_regS VTCR_EL2_ref  : ( 32 words$word) M))) (\ (w__132 : 32 bits) . 
         let startlevel = (lem$w2ui ((slice w__132 (( 6 : int):ii) (( 2 : int):ii)  :  2 words$word))) in
         let ((firstblocklevel : ii), (grainsize : ii), (level : ii)) =
           (if largegrain then
             let (grainsize : ii) = ((( 16 : int):ii)) in
             let (level : ii) = ((( 3 : int):ii) - ((ex_int startlevel))) in
             let (firstblocklevel : ii) = (if ((Have52BitPAExt () )) then (( 1 : int):ii) else (( 2 : int):ii)) in
             (firstblocklevel, grainsize, level)
           else
             let ((firstblocklevel : ii), (grainsize : ii), (level : ii)) =
               (if midgrain then
                 let (grainsize : ii) = ((( 14 : int):ii)) in
                 let (level : ii) = ((( 3 : int):ii) - ((ex_int startlevel))) in
                 let (firstblocklevel : ii) = ((( 2 : int):ii)) in
                 (firstblocklevel, grainsize, level)
               else
                 let (grainsize : ii) = ((( 12 : int):ii)) in
                 let (level : ii) = ((( 2 : int):ii) - ((ex_int startlevel))) in
                 let (firstblocklevel : ii) = ((( 1 : int):ii)) in
                 (firstblocklevel, grainsize, level)) in
             (firstblocklevel, grainsize, level)) in
         let stride = (((ex_int grainsize)) - (( 3 : int):ii)) in
         let (basefound : bool) =
           (if largegrain then
             if ((((((((ex_int level)) = (( 0 : int):ii)))) \/ ((((((((ex_int level)) = (( 1 : int):ii)))) /\ ((((ex_int ((PAMax () )))) <= (( 42 : int):ii))))))))) then
               F
             else basefound
           else if midgrain then
             if ((((((((ex_int level)) = (( 0 : int):ii)))) \/ ((((((((ex_int level)) = (( 1 : int):ii)))) /\ ((((ex_int ((PAMax () )))) <= (( 40 : int):ii))))))))) then
               F
             else basefound
           else if (((((((ex_int level)) < (( 0 : int):ii))) \/ ((((((((ex_int level)) = (( 0 : int):ii)))) /\ ((((ex_int ((PAMax () )))) <= (( 42 : int):ii))))))))) then
             F
           else basefound) in
         let inputsizecheck = inputsize in sail2_state_monad$bindS
         (sail2_state$and_boolS (sail2_state_monad$returnS ((((ex_int inputsize)) > ((ex_int ((PAMax () )))))))
           (sail2_state$or_boolS ( sail2_state_monad$bindS(sail2_state_monad$liftRS (ELUsingAArch32 EL1)) (\ (w__133 : bool) .  sail2_state_monad$returnS ((~ w__133))))
              (sail2_state_monad$returnS ((((ex_int inputsize)) > (( 40 : int):ii)))))) (\ (w__135 : bool) .  sail2_state_monad$bindS
         (if w__135 then
            (case ((ConstrainUnpredictable Unpredictable_LARGEIPA)) of
              Constraint_FORCE =>
               let (inputsize : ii) = (PAMax () ) in
               let (inputsizecheck : ii) = (PAMax () ) in
               sail2_state_monad$returnS (basefound, inputsize, inputsizecheck)
            | Constraint_FORCENOSLCHECK =>
               let (inputsize : ii) = (PAMax () ) in
               sail2_state_monad$returnS (basefound, inputsize, inputsizecheck)
            | Constraint_FAULT =>
               let (basefound : bool) = F in
               sail2_state_monad$returnS (basefound, inputsize, inputsizecheck)
            | _ => sail2_state_monad$seqS (sail2_state_monad$liftRS (Unreachable () )) (sail2_state_monad$returnS (basefound, inputsize, inputsizecheck))
            )
          else sail2_state_monad$returnS (basefound, inputsize, inputsizecheck)) (\ varstup .  let ((basefound :
           bool), (inputsize : ii), (inputsizecheck : ii)) = varstup in
         let (startsizecheck : ii) =
           (((ex_int inputsizecheck)) -
             (((((((( 3 : int):ii) - ((ex_int level)))) * ((ex_int stride)))) +
                 ((ex_int grainsize))))) in
         let (basefound : bool) =
           (if (((((((ex_int startsizecheck)) < (( 1 : int):ii))) \/ ((((ex_int startsizecheck)) > ((((ex_int stride)) + (( 4 : int):ii)))))))) then
             F
           else basefound) in
         sail2_state_monad$returnS (basefound,
                 baseregister,
                 descaddr,
                 disabled,
                 firstblocklevel,
                 grainsize,
                 hierattrsdisabled,
                 inputaddr,
                 inputsize,
                 largegrain,
                 level,
                 lookupsecure,
                 midgrain,
                 ps,
                 reversedescriptors,
                 singlepriv,
                 stride,
                 update_AF,
                 update_AP))))))))))))))))))))) (\ varstup .  let ((basefound : bool), (baseregister : 64 bits), (descaddr :
        AddressDescriptor), (disabled : bool), (firstblocklevel : ii), (grainsize : ii), (hierattrsdisabled :
        bool), (inputaddr : 64 bits), (inputsize : ii), (largegrain : bool), (level : ii), (lookupsecure :
        bool), (midgrain : bool), (ps : 3 bits), (reversedescriptors : bool), (singlepriv : bool), (stride :
        ii), (update_AF : bool), (update_AP : bool)) = varstup in
      if (((((~ basefound)) \/ disabled))) then
        let level = ((( 0 : int):ii)) in
        let (tmp_190 : AddressDescriptor) = (result.TLBRecord_addrdesc) in sail2_state_monad$bindS
        (sail2_state_monad$liftRS (AArch64_TranslationFault ipaddress level acctype iswrite secondstage s2fs1walk)) (\ (w__136 :
          FaultRecord) . 
        let (tmp_190 : AddressDescriptor) = ((tmp_190 with<| AddressDescriptor_fault := w__136|>)) in
        let (result : TLBRecord) = ((result with<| TLBRecord_addrdesc := tmp_190|>)) in
        sail2_state_monad$returnS result)
      else sail2_state_monad$bindS
        (sail2_state_monad$liftRS (undefined_int () )) (\ (outputsize : ii) . 
        let b__0 = ps in
        let (outputsize : ii) =
          (if (((b__0 = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) then (( 32 : int):ii)
          else if (((b__0 = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) then (( 36 : int):ii)
          else if (((b__0 = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) then (( 40 : int):ii)
          else if (((b__0 = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) then (( 42 : int):ii)
          else if (((b__0 = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) then (( 44 : int):ii)
          else if (((b__0 = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) then (( 48 : int):ii)
          else if (((b__0 = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) then
            if (((((Have52BitPAExt () )) /\ largegrain))) then (( 52 : int):ii)
            else (( 48 : int):ii)
          else (( 48 : int):ii)) in
        let (outputsize : ii) =
          (if ((((ex_int outputsize)) > ((ex_int ((PAMax () )))))) then PAMax () 
          else outputsize) in sail2_state_monad$bindS
        (sail2_state$and_boolS (sail2_state_monad$returnS ((((ex_int outputsize)) < (( 48 : int):ii))))
          ( sail2_state_monad$bindS(sail2_state_monad$liftRS (IsZero_slice baseregister outputsize
                    ((((~ ((ex_int outputsize)))) + (( 48 : int):ii))))) (\ (w__137 :
             bool) . 
           sail2_state_monad$returnS ((~ w__137))))) (\ (w__138 : bool) . 
        if w__138 then
          let level = ((( 0 : int):ii)) in
          let (tmp_200 : AddressDescriptor) = (result.TLBRecord_addrdesc) in sail2_state_monad$bindS
          (sail2_state_monad$liftRS (AArch64_AddressSizeFault ipaddress level acctype iswrite secondstage s2fs1walk)) (\ (w__139 :
            FaultRecord) . 
          let (tmp_200 : AddressDescriptor) = ((tmp_200 with<| AddressDescriptor_fault := w__139|>)) in
          let (result : TLBRecord) = ((result with<| TLBRecord_addrdesc := tmp_200|>)) in
          sail2_state_monad$returnS result)
        else
          let baselowerbound =
            ((((( 3 : int):ii) + ((ex_int inputsize)))) -
              (((((((( 3 : int):ii) - ((ex_int level)))) * ((ex_int stride))))
                  +
                  ((ex_int grainsize))))) in sail2_state_monad$bindS (sail2_state_monad$seqS
          (sail2_state_monad$liftRS (sail2_state_monad$assert_expS T ""))
          (sail2_state_monad$liftRS ((undefined_bitvector (( 52 : int):ii)  : ( 52 words$word) M)))) (\ (baseaddress : 52 bits) .  sail2_state_monad$bindS
          (if (((((ex_int outputsize)) = (( 52 : int):ii)))) then
             let z = (if ((baselowerbound < (( 6 : int):ii))) then (( 6 : int):ii) else baselowerbound) in sail2_state_monad$seqS
             (sail2_state_monad$liftRS (sail2_state_monad$assert_expS T ""))
             (let (baseaddress : 52 bits) =
               ((concat_vec ((slice baseregister (( 2 : int):ii) (( 4 : int):ii)  :  4 words$word))
                  ((slice_zeros_concat ((((((~ z)) + (( 48 : int):ii))) + z))
                      baseregister z ((((~ z)) + (( 48 : int):ii))) z
                     :  48 words$word))
                 :  52 words$word)) in
             sail2_state_monad$returnS baseaddress)
           else
             let (baseaddress : 52 bits) =
               ((place_slice (( 52 : int):ii) baseregister baselowerbound
                  ((((~ baselowerbound)) + (( 48 : int):ii))) baselowerbound
                 :  52 words$word)) in
             sail2_state_monad$returnS baseaddress) (\ (baseaddress : 52 bits) . 
          let (ns_table : 1 bits) =
            (if lookupsecure then (vec_of_bits [B0]  :  1 words$word)
            else (vec_of_bits [B1]  :  1 words$word)) in
          let (ap_table : 2 bits) = ((vec_of_bits [B0;B0]  :  2 words$word)) in
          let (xn_table : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in
          let (pxn_table : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in
          let (addrselecttop : ii) = (((ex_int inputsize)) - (( 1 : int):ii)) in sail2_state_monad$bindS
          (sail2_state$and_boolS
            (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveNVExt () )) /\ ((HaveEL EL2))))))
               ( sail2_state_monad$bindS(sail2_state_monad$liftRS ((sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M))) (\ (w__140 : 64 bits) . 
                sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__140 (( 42 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
            ( sail2_state_monad$bindS(sail2_state_monad$liftRS ((sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M))) (\ (w__142 : 64 bits) . 
             sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__142 (( 43 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (apply_nvnv1_effect : bool) .  sail2_state_monad$bindS
          (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (blocktranslate : bool) .  sail2_state_monad$bindS
          (sail2_state_monad$liftRS ((undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M))) (\ (desc : 64 bits) .  sail2_state_monad$bindS
          (sail2_state_monad$liftRS (undefined_AccessDescriptor () )) (\ (accdesc : AccessDescriptor) .  sail2_state_monad$bindS
          (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (hwupdatewalk : bool) .  sail2_state_monad$bindS
          (sail2_state_monad$liftRS (undefined_AddressDescriptor () )) (\ (descaddr2 : AddressDescriptor) .  sail2_state_monad$bindS
          (sail2_state_monad$liftRS (undefined_int () )) (\ (addrselectbottom : ii) .  sail2_state_monad$bindS
          (sail2_state$untilS (accdesc,
                   addrselectbottom,
                   addrselecttop,
                   ap_table,
                   baseaddress,
                   blocktranslate,
                   desc,
                   descaddr,
                   descaddr2,
                   hwupdatewalk,
                   level,
                   ns_table,
                   pxn_table,
                   result,
                   xn_table)
            (\ varstup . 
            let (accdesc,
                 addrselectbottom,
                 addrselecttop,
                 ap_table,
                 baseaddress,
                 blocktranslate,
                 desc,
                 descaddr,
                 descaddr2,
                 hwupdatewalk,
                 level,
                 ns_table,
                 pxn_table,
                 result,
                 xn_table) = varstup in
              sail2_state_monad$returnS blocktranslate)
            (\ varstup . 
            let (accdesc,
                 addrselectbottom,
                 addrselecttop,
                 ap_table,
                 baseaddress,
                 blocktranslate,
                 desc,
                 descaddr,
                 descaddr2,
                 hwupdatewalk,
                 level,
                 ns_table,
                 pxn_table,
                 result,
                 xn_table) = varstup in
              let addrselectbottom =
                ((((((( 3 : int):ii) - ((ex_int level)))) * ((ex_int stride))))
                  +
                  ((ex_int grainsize))) in sail2_state_monad$bindS
              (sail2_state_monad$liftRS ((ZeroExtend_slice_append (( 52 : int):ii) inputaddr addrselectbottom
                        ((((((ex_int addrselecttop)) - ((ex_int addrselectbottom))))
                            +
                            (( 1 : int):ii))) (vec_of_bits [B0;B0;B0]  :  3 words$word)
                       : ( 52 words$word) M))) (\ (index : 52 bits) . 
              let (tmp_210 : FullAddress) = (descaddr.AddressDescriptor_paddress) in
              let tmp_210 =
                ((tmp_210 with<|
                  FullAddress_physicaladdress := ((or_vec baseaddress index  :  52 words$word))|>)) in
              let descaddr = ((descaddr with<| AddressDescriptor_paddress := tmp_210|>)) in
              let (tmp_220 : FullAddress) = (descaddr.AddressDescriptor_paddress) in
              let tmp_220 = ((tmp_220 with<| FullAddress_NS := ns_table|>)) in
              let descaddr = ((descaddr with<| AddressDescriptor_paddress := tmp_220|>)) in sail2_state_monad$bindS
              (sail2_state$or_boolS (sail2_state_monad$returnS secondstage)
                ( sail2_state_monad$bindS(sail2_state_monad$liftRS (HasS2Translation () )) (\ (w__143 : bool) .  sail2_state_monad$returnS ((~ w__143))))) (\ (w__144 :
                bool) .  sail2_state_monad$bindS
              (if w__144 then
                 let (descaddr2 : AddressDescriptor) = descaddr in
                 sail2_state_monad$returnS (descaddr2, hwupdatewalk, result)
               else
                 let hwupdatewalk = F in sail2_state_monad$bindS
                 (sail2_state_monad$liftRS (AArch64_SecondStageWalk descaddr vaddress acctype iswrite (( 8 : int):ii)
                          hwupdatewalk)) (\ (w__145 : AddressDescriptor) . 
                 let descaddr2 = w__145 in sail2_state_monad$bindS
                 (if ((IsFault descaddr2)) then
                    let (tmp_230 : AddressDescriptor) = (result.TLBRecord_addrdesc) in
                    let tmp_230 =
                      ((tmp_230 with<| AddressDescriptor_fault := (descaddr2.AddressDescriptor_fault)|>)) in
                    let result = ((result with<| TLBRecord_addrdesc := tmp_230|>)) in sail2_state_monad$seqS
                    (sail2_state_monad$early_returnS result : (unit, TLBRecord) MR) (sail2_state_monad$returnS result)
                  else sail2_state_monad$returnS result) (\ (result : TLBRecord) . 
                 sail2_state_monad$returnS (descaddr2, hwupdatewalk, result)))) (\ varstup .  let ((descaddr2 :
                AddressDescriptor), (hwupdatewalk : bool), (result : TLBRecord)) = varstup in sail2_state_monad$bindS
              (sail2_state_monad$liftRS ((ZeroExtend__1 (( 64 : int):ii) vaddress  : ( 64 words$word) M))) (\ (w__146 : 64 bits) . 
              let descaddr2 = ((descaddr2 with<| AddressDescriptor_vaddress := w__146|>)) in sail2_state_monad$bindS
              (sail2_state_monad$liftRS (CreateAccessDescriptorPTW acctype secondstage s2fs1walk level)) (\ (w__147 :
                AccessDescriptor) . 
              let accdesc = w__147 in sail2_state_monad$bindS
              (sail2_state_monad$liftRS ((aget__Mem descaddr2 (( 8 : int):ii) accdesc  : ( 64 words$word) M))) (\ (w__148 : 64
                bits) . 
              let desc = w__148 in sail2_state_monad$bindS
              (if reversedescriptors then sail2_state_monad$liftRS ((BigEndianReverse desc  : ( 64 words$word) M))
               else sail2_state_monad$returnS desc) (\ (desc : 64 bits) .  sail2_state_monad$bindS
              (if (((((((vec_of_bits [access_vec_dec desc (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))) \/ ((((((((slice desc (( 0 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((((ex_int level)) = (( 3 : int):ii))))))))))
               then
                 let (tmp_240 : AddressDescriptor) = (result.TLBRecord_addrdesc) in sail2_state_monad$bindS
                 (sail2_state_monad$liftRS (AArch64_TranslationFault ipaddress level acctype iswrite secondstage
                          s2fs1walk)) (\ (w__150 : FaultRecord) . 
                 let tmp_240 = ((tmp_240 with<| AddressDescriptor_fault := w__150|>)) in
                 let result = ((result with<| TLBRecord_addrdesc := tmp_240|>)) in sail2_state_monad$seqS
                 (sail2_state_monad$early_returnS result : (unit, TLBRecord) MR)
                 (sail2_state_monad$returnS (addrselecttop,
                         ap_table,
                         baseaddress,
                         blocktranslate,
                         level,
                         ns_table,
                         pxn_table,
                         result,
                         xn_table)))
               else if ((((((((slice desc (( 0 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))) \/ (((((ex_int level)) = (( 3 : int):ii)))))))
               then
                 let (blocktranslate : bool) = T in
                 sail2_state_monad$returnS (addrselecttop,
                         ap_table,
                         baseaddress,
                         blocktranslate,
                         level,
                         ns_table,
                         pxn_table,
                         result,
                         xn_table)
               else sail2_state_monad$bindS
                 (sail2_state$or_boolS
                   (sail2_state_monad$returnS ((((((((((ex_int outputsize)) < (( 52 : int):ii))) /\ largegrain))) /\ ((~ ((IsZero ((slice desc (( 12 : int):ii) (( 4 : int):ii)  :  4 words$word))))))))))
                   (sail2_state$and_boolS (sail2_state_monad$returnS ((((ex_int outputsize)) < (( 48 : int):ii))))
                      ( sail2_state_monad$bindS(sail2_state_monad$liftRS (IsZero_slice desc outputsize
                                ((((~ ((ex_int outputsize)))) + (( 48 : int):ii))))) (\ (w__151 :
                         bool) . 
                       sail2_state_monad$returnS ((~ w__151)))))) (\ (w__153 : bool) . 
                 if w__153 then
                   let (tmp_250 : AddressDescriptor) = (result.TLBRecord_addrdesc) in sail2_state_monad$bindS
                   (sail2_state_monad$liftRS (AArch64_AddressSizeFault ipaddress level acctype iswrite secondstage
                            s2fs1walk)) (\ (w__154 : FaultRecord) . 
                   let tmp_250 = ((tmp_250 with<| AddressDescriptor_fault := w__154|>)) in
                   let result = ((result with<| TLBRecord_addrdesc := tmp_250|>)) in sail2_state_monad$seqS
                   (sail2_state_monad$early_returnS result : (unit, TLBRecord) MR)
                   (sail2_state_monad$returnS (addrselecttop,
                           ap_table,
                           baseaddress,
                           blocktranslate,
                           level,
                           ns_table,
                           pxn_table,
                           result,
                           xn_table)))
                 else
                   let gsz = grainsize in sail2_state_monad$seqS
                   (sail2_state_monad$liftRS (sail2_state_monad$assert_expS T ""))
                   (let (baseaddress : 52 bits) =
                     (if (((((ex_int outputsize)) = (( 52 : int):ii)))) then
                       (concat_vec ((slice desc (( 12 : int):ii) (( 4 : int):ii)  :  4 words$word))
                          ((slice_zeros_concat
                              ((((((~ gsz)) + (( 48 : int):ii))) + gsz)) desc
                              gsz ((((~ gsz)) + (( 48 : int):ii))) gsz
                             :  48 words$word))
                         :  52 words$word)
                     else
                       (place_slice (( 52 : int):ii) desc gsz ((((~ gsz)) + (( 48 : int):ii)))
                          gsz
                         :  52 words$word)) in
                   let (ns_table : 1 bits) =
                     (if ((~ secondstage)) then
                       (or_vec ns_table (vec_of_bits [access_vec_dec desc (( 63 : int):ii)]  :  1 words$word)
                         :  1 words$word)
                     else ns_table) in
                   let ((ap_table : 2 bits), (pxn_table : 1 bits), (xn_table : 1 bits)) =
                     (if (((((~ secondstage)) /\ ((~ hierattrsdisabled))))) then
                       let (ap_table : 2 bits) =
                         ((set_slice (( 2 : int):ii) (( 1 : int):ii) ap_table (( 1 : int):ii)
                            ((or_vec (vec_of_bits [access_vec_dec ap_table (( 1 : int):ii)]  :  1 words$word)
                                (vec_of_bits [access_vec_dec desc (( 62 : int):ii)]  :  1 words$word)
                               :  1 words$word))
                           :  2 words$word)) in
                       let ((pxn_table : 1 bits), (xn_table : 1 bits)) =
                         (if apply_nvnv1_effect then
                           let (pxn_table : 1 bits) =
                             ((or_vec pxn_table
                                (vec_of_bits [access_vec_dec desc (( 60 : int):ii)]  :  1 words$word)
                               :  1 words$word)) in
                           (pxn_table, xn_table)
                         else
                           let (xn_table : 1 bits) =
                             ((or_vec xn_table
                                (vec_of_bits [access_vec_dec desc (( 60 : int):ii)]  :  1 words$word)
                               :  1 words$word)) in
                           (pxn_table, xn_table)) in
                       let ((ap_table : 2 bits), (pxn_table : 1 bits)) =
                         (if ((~ singlepriv)) then
                           let ((ap_table : 2 bits), (pxn_table : 1 bits)) =
                             (if ((~ apply_nvnv1_effect)) then
                               let (pxn_table : 1 bits) =
                                 ((or_vec pxn_table
                                    (vec_of_bits [access_vec_dec desc (( 59 : int):ii)]  :  1 words$word)
                                   :  1 words$word)) in
                               let (ap_table : 2 bits) =
                                 ((set_slice (( 2 : int):ii) (( 1 : int):ii) ap_table (( 0 : int):ii)
                                    ((or_vec
                                        (vec_of_bits [access_vec_dec ap_table (( 0 : int):ii)]  :  1 words$word)
                                        (vec_of_bits [access_vec_dec desc (( 61 : int):ii)]  :  1 words$word)
                                       :  1 words$word))
                                   :  2 words$word)) in
                               (ap_table, pxn_table)
                             else (ap_table, pxn_table)) in
                           (ap_table, pxn_table)
                         else (ap_table, pxn_table)) in
                       (ap_table, pxn_table, xn_table)
                     else (ap_table, pxn_table, xn_table)) in
                   let (level : ii) = (((ex_int level)) + (( 1 : int):ii)) in
                   let (addrselecttop : ii) = (((ex_int addrselectbottom)) - (( 1 : int):ii)) in
                   let (blocktranslate : bool) = F in
                   sail2_state_monad$returnS (addrselecttop,
                           ap_table,
                           baseaddress,
                           blocktranslate,
                           level,
                           ns_table,
                           pxn_table,
                           result,
                           xn_table)))) (\ varstup .  let ((addrselecttop : ii), (ap_table : 2
                bits), (baseaddress : 52 bits), (blocktranslate : bool), (level : ii), (ns_table : 1
                bits), (pxn_table : 1 bits), (result : TLBRecord), (xn_table : 1 bits)) = varstup in
              sail2_state_monad$returnS (accdesc,
                      addrselectbottom,
                      addrselecttop,
                      ap_table,
                      baseaddress,
                      blocktranslate,
                      desc,
                      descaddr,
                      descaddr2,
                      hwupdatewalk,
                      level,
                      ns_table,
                      pxn_table,
                      result,
                      xn_table))))))))))) (\ varstup .  let ((accdesc : AccessDescriptor), (addrselectbottom :
            ii), (addrselecttop : ii), (ap_table : 2 bits), (baseaddress : 52 bits), (blocktranslate :
            bool), (desc : 64 bits), (descaddr : AddressDescriptor), (descaddr2 :
            AddressDescriptor), (hwupdatewalk : bool), (level : ii), (ns_table : 1 bits), (pxn_table : 1
            bits), (result : TLBRecord), (xn_table : 1 bits)) = varstup in
          if ((((ex_int level)) < ((ex_int firstblocklevel)))) then
            let (tmp_260 : AddressDescriptor) = (result.TLBRecord_addrdesc) in sail2_state_monad$bindS
            (sail2_state_monad$liftRS (AArch64_TranslationFault ipaddress level acctype iswrite secondstage s2fs1walk)) (\ (w__155 :
              FaultRecord) . 
            let (tmp_260 : AddressDescriptor) = ((tmp_260 with<| AddressDescriptor_fault := w__155|>)) in
            let (result : TLBRecord) = ((result with<| TLBRecord_addrdesc := tmp_260|>)) in
            sail2_state_monad$returnS result)
          else sail2_state_monad$bindS
            (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (contiguousbitcheck : bool) . 
            let (contiguousbitcheck : bool) =
              (if largegrain then
                ((((((ex_int level)) = (( 2 : int):ii)))) /\ ((((ex_int inputsize)) < (( 34 : int):ii))))
              else if midgrain then
                ((((((ex_int level)) = (( 2 : int):ii)))) /\ ((((ex_int inputsize)) < (( 30 : int):ii))))
              else ((((((ex_int level)) = (( 1 : int):ii)))) /\ ((((ex_int inputsize)) < (( 34 : int):ii))))) in sail2_state_monad$bindS
            (if (((contiguousbitcheck /\ ((((vec_of_bits [access_vec_dec desc (( 52 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) then sail2_state_monad$bindS
               (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (w__156 : bool) . 
               if w__156 then
                 let (tmp_270 : AddressDescriptor) = (result.TLBRecord_addrdesc) in sail2_state_monad$bindS
                 (sail2_state_monad$liftRS (AArch64_TranslationFault ipaddress level acctype iswrite secondstage
                          s2fs1walk)) (\ (w__157 : FaultRecord) . 
                 let tmp_270 = ((tmp_270 with<| AddressDescriptor_fault := w__157|>)) in
                 let result = ((result with<| TLBRecord_addrdesc := tmp_270|>)) in sail2_state_monad$seqS
                 (sail2_state_monad$early_returnS result : (unit, TLBRecord) MR) (sail2_state_monad$returnS result))
               else sail2_state_monad$returnS result)
             else sail2_state_monad$returnS result) (\ (result : TLBRecord) .  sail2_state_monad$bindS
            (sail2_state$or_boolS
              (sail2_state_monad$returnS ((((((((((ex_int outputsize)) < (( 52 : int):ii))) /\ largegrain))) /\ ((~ ((IsZero ((slice desc (( 12 : int):ii) (( 4 : int):ii)  :  4 words$word))))))))))
              (sail2_state$and_boolS (sail2_state_monad$returnS ((((ex_int outputsize)) < (( 48 : int):ii))))
                 ( sail2_state_monad$bindS(sail2_state_monad$liftRS (IsZero_slice desc outputsize
                           ((((~ ((ex_int outputsize)))) + (( 48 : int):ii))))) (\ (w__158 :
                    bool) . 
                  sail2_state_monad$returnS ((~ w__158)))))) (\ (w__160 : bool) . 
            if w__160 then
              let (tmp_280 : AddressDescriptor) = (result.TLBRecord_addrdesc) in sail2_state_monad$bindS
              (sail2_state_monad$liftRS (AArch64_AddressSizeFault ipaddress level acctype iswrite secondstage s2fs1walk)) (\ (w__161 :
                FaultRecord) . 
              let (tmp_280 : AddressDescriptor) =
                ((tmp_280 with<| AddressDescriptor_fault := w__161|>)) in
              let (result : TLBRecord) = ((result with<| TLBRecord_addrdesc := tmp_280|>)) in
              sail2_state_monad$returnS result)
            else sail2_state_monad$bindS
              (sail2_state_monad$liftRS ((undefined_bitvector (( 52 : int):ii)  : ( 52 words$word) M))) (\ (outputaddress : 52
                bits) . 
              let asb = addrselectbottom in sail2_state_monad$seqS
              (sail2_state_monad$liftRS (sail2_state_monad$assert_expS T ""))
              (let (outputaddress : 52 bits) =
                (if (((((ex_int outputsize)) = (( 52 : int):ii)))) then
                  (concat_vec ((slice desc (( 12 : int):ii) (( 4 : int):ii)  :  4 words$word))
                     ((slice_slice_concat (( 48 : int):ii) desc asb
                         ((((~ asb)) + (( 48 : int):ii))) inputaddr (( 0 : int):ii) asb
                        :  48 words$word))
                    :  52 words$word)
                else
                  (slice_slice_concat (( 52 : int):ii) desc asb ((((~ asb)) + (( 48 : int):ii)))
                     inputaddr (( 0 : int):ii) asb
                    :  52 words$word)) in
              let (tmp_330 : DescriptorUpdate) = (result.TLBRecord_descupdate) in
              let tmp_330 = ((tmp_330 with<| DescriptorUpdate_AF := F|>)) in
              let tmp_330 = ((tmp_330 with<| DescriptorUpdate_AP := F|>)) in
              let tmp_330 = ((tmp_330 with<| DescriptorUpdate_descaddr := descaddr|>)) in
              let result = ((result with<| TLBRecord_descupdate := tmp_330|>)) in sail2_state_monad$bindS
              (if ((((vec_of_bits [access_vec_dec desc (( 10 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))) then
                 if ((~ update_AF)) then
                   let (tmp_290 : AddressDescriptor) = (result.TLBRecord_addrdesc) in sail2_state_monad$bindS
                   (sail2_state_monad$liftRS (AArch64_AccessFlagFault ipaddress level acctype iswrite secondstage
                            s2fs1walk)) (\ (w__162 : FaultRecord) . 
                   let tmp_290 = ((tmp_290 with<| AddressDescriptor_fault := w__162|>)) in
                   let result = ((result with<| TLBRecord_addrdesc := tmp_290|>)) in sail2_state_monad$seqS
                   (sail2_state_monad$early_returnS result : (unit, TLBRecord) MR) (sail2_state_monad$returnS result))
                 else
                   let (tmp_300 : DescriptorUpdate) = (result.TLBRecord_descupdate) in
                   let (tmp_300 : DescriptorUpdate) = ((tmp_300 with<| DescriptorUpdate_AF := T|>)) in
                   let (result : TLBRecord) = ((result with<| TLBRecord_descupdate := tmp_300|>)) in
                   sail2_state_monad$returnS result
               else sail2_state_monad$returnS result) (\ (result : TLBRecord) . 
              let ((desc : 64 bits), (result : TLBRecord)) =
                (if (((update_AP /\ ((((vec_of_bits [access_vec_dec desc (( 51 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) then
                  let ((desc : 64 bits), (result : TLBRecord)) =
                    (if (((((~ secondstage)) /\ ((((vec_of_bits [access_vec_dec desc (( 7 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) then
                      let (desc : 64 bits) =
                        ((set_slice (( 64 : int):ii) (( 1 : int):ii) desc (( 7 : int):ii) (vec_of_bits [B0]  :  1 words$word)
                          :  64 words$word)) in
                      let (tmp_310 : DescriptorUpdate) = (result.TLBRecord_descupdate) in
                      let (tmp_310 : DescriptorUpdate) =
                        ((tmp_310 with<| DescriptorUpdate_AP := T|>)) in
                      let (result : TLBRecord) = ((result with<| TLBRecord_descupdate := tmp_310|>)) in
                      (desc, result)
                    else
                      let ((desc : 64 bits), (result : TLBRecord)) =
                        (if (((secondstage /\ ((((vec_of_bits [access_vec_dec desc (( 7 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) then
                          let (desc : 64 bits) =
                            ((set_slice (( 64 : int):ii) (( 1 : int):ii) desc (( 7 : int):ii) (vec_of_bits [B1]  :  1 words$word)
                              :  64 words$word)) in
                          let (tmp_320 : DescriptorUpdate) = (result.TLBRecord_descupdate) in
                          let (tmp_320 : DescriptorUpdate) =
                            ((tmp_320 with<| DescriptorUpdate_AP := T|>)) in
                          let (result : TLBRecord) = ((result with<| TLBRecord_descupdate := tmp_320|>)) in
                          (desc, result)
                        else (desc, result)) in
                      (desc, result)) in
                  (desc, result)
                else (desc, result)) in sail2_state_monad$bindS
              (sail2_state_monad$liftRS ((undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M))) (\ (xn : 1 bits) .  sail2_state_monad$bindS
              (sail2_state_monad$liftRS ((undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M))) (\ (pxn : 1 bits) . 
              let ((pxn : 1 bits), (xn : 1 bits)) =
                (if apply_nvnv1_effect then
                  let (pxn : 1 bits) = ((vec_of_bits [access_vec_dec desc (( 54 : int):ii)]  :  1 words$word)) in
                  let (xn : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in
                  (pxn, xn)
                else
                  let (xn : 1 bits) = ((vec_of_bits [access_vec_dec desc (( 54 : int):ii)]  :  1 words$word)) in
                  let (pxn : 1 bits) = ((vec_of_bits [access_vec_dec desc (( 53 : int):ii)]  :  1 words$word)) in
                  (pxn, xn)) in
              let (contiguousbit : 1 bits) =
                ((vec_of_bits [access_vec_dec desc (( 52 : int):ii)]  :  1 words$word)) in
              let (nG : 1 bits) = ((vec_of_bits [access_vec_dec desc (( 11 : int):ii)]  :  1 words$word)) in
              let (sh : 2 bits) = ((slice desc (( 8 : int):ii) (( 2 : int):ii)  :  2 words$word)) in sail2_state_monad$bindS
              (sail2_state_monad$liftRS ((undefined_bitvector (( 3 : int):ii)  : ( 3 words$word) M))) (\ (ap : 3 bits) . 
              let (ap : 3 bits) =
                (if apply_nvnv1_effect then
                  (concat_vec (vec_of_bits [access_vec_dec desc (( 7 : int):ii)]  :  1 words$word)
                     (vec_of_bits [B0;B1]  :  2 words$word)
                    :  3 words$word)
                else
                  (concat_vec ((slice desc (( 6 : int):ii) (( 2 : int):ii)  :  2 words$word))
                     (vec_of_bits [B1]  :  1 words$word)
                    :  3 words$word)) in
              let (memattr : 4 bits) = ((slice desc (( 2 : int):ii) (( 4 : int):ii)  :  4 words$word)) in sail2_state_monad$bindS
              (sail2_state_monad$liftRS ((undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M))) (\ (w__163 : 4 bits) . 
              let result = ((result with<| TLBRecord_domain := w__163|>)) in
              let result = ((result with<| TLBRecord_level := level|>)) in
              let result =
                ((result with<|
                  TLBRecord_blocksize :=
                    ((pow2
                        (((((((( 3 : int):ii) - ((ex_int level)))) * ((ex_int stride))))
                            +
                            ((ex_int grainsize))))))|>)) in sail2_state_monad$bindS
              (if ((~ secondstage)) then
                 let (tmp_340 : Permissions) = (result.TLBRecord_perms) in
                 let tmp_340 =
                   ((tmp_340 with<| Permissions_xn := ((or_vec xn xn_table  :  1 words$word))|>)) in
                 let result = ((result with<| TLBRecord_perms := tmp_340|>)) in
                 let (tmp_350 : 3 bits) = (result.TLBRecord_perms.Permissions_ap) in
                 let tmp_350 =
                   ((set_slice (( 3 : int):ii) (( 1 : int):ii) tmp_350 (( 2 : int):ii)
                      ((or_vec (vec_of_bits [access_vec_dec ap (( 2 : int):ii)]  :  1 words$word)
                          (vec_of_bits [access_vec_dec ap_table (( 1 : int):ii)]  :  1 words$word)
                         :  1 words$word))
                     :  3 words$word)) in
                 let (tmp_360 : Permissions) = (result.TLBRecord_perms) in
                 let tmp_360 = ((tmp_360 with<| Permissions_ap := tmp_350|>)) in
                 let result = ((result with<| TLBRecord_perms := tmp_360|>)) in sail2_state_monad$bindS
                 (if ((~ singlepriv)) then
                    let (tmp_370 : 3 bits) = (result.TLBRecord_perms.Permissions_ap) in
                    let tmp_370 =
                      ((set_slice (( 3 : int):ii) (( 1 : int):ii) tmp_370 (( 1 : int):ii)
                         ((and_vec (vec_of_bits [access_vec_dec ap (( 1 : int):ii)]  :  1 words$word)
                             ((not_vec (vec_of_bits [access_vec_dec ap_table (( 0 : int):ii)]  :  1 words$word)
                                :  1 words$word))
                            :  1 words$word))
                        :  3 words$word)) in
                    let (tmp_380 : Permissions) = (result.TLBRecord_perms) in
                    let tmp_380 = ((tmp_380 with<| Permissions_ap := tmp_370|>)) in
                    let result = ((result with<| TLBRecord_perms := tmp_380|>)) in
                    let (tmp_390 : Permissions) = (result.TLBRecord_perms) in
                    let tmp_390 =
                      ((tmp_390 with<| Permissions_pxn := ((or_vec pxn pxn_table  :  1 words$word))|>)) in
                    let result = ((result with<| TLBRecord_perms := tmp_390|>)) in sail2_state_monad$bindS
                    (sail2_state_monad$liftRS (IsSecure () )) (\ (w__164 : bool) . 
                    let (result : TLBRecord) =
                      (if w__164 then
                        (result with<| TLBRecord_nG := ((or_vec nG ns_table  :  1 words$word))|>)
                      else (result with<| TLBRecord_nG := nG|>)) in
                    sail2_state_monad$returnS result)
                  else
                    let (tmp_400 : 3 bits) = (result.TLBRecord_perms.Permissions_ap) in
                    let (tmp_400 : 3 bits) =
                      ((set_slice (( 3 : int):ii) (( 1 : int):ii) tmp_400 (( 1 : int):ii) (vec_of_bits [B1]  :  1 words$word)
                        :  3 words$word)) in
                    let (tmp_410 : Permissions) = (result.TLBRecord_perms) in
                    let (tmp_410 : Permissions) = ((tmp_410 with<| Permissions_ap := tmp_400|>)) in
                    let (result : TLBRecord) = ((result with<| TLBRecord_perms := tmp_410|>)) in
                    let (tmp_420 : Permissions) = (result.TLBRecord_perms) in
                    let (tmp_420 : Permissions) =
                      ((tmp_420 with<| Permissions_pxn := ((vec_of_bits [B0]  :  1 words$word))|>)) in
                    let (result : TLBRecord) = ((result with<| TLBRecord_perms := tmp_420|>)) in
                    let (result : TLBRecord) =
                      ((result with<| TLBRecord_nG := ((vec_of_bits [B0]  :  1 words$word))|>)) in
                    sail2_state_monad$returnS result) (\ (result : TLBRecord) . 
                 let (tmp_430 : 3 bits) = (result.TLBRecord_perms.Permissions_ap) in
                 let tmp_430 =
                   ((set_slice (( 3 : int):ii) (( 1 : int):ii) tmp_430 (( 0 : int):ii) (vec_of_bits [B1]  :  1 words$word)
                     :  3 words$word)) in
                 let (tmp_440 : Permissions) = (result.TLBRecord_perms) in
                 let tmp_440 = ((tmp_440 with<| Permissions_ap := tmp_430|>)) in
                 let result = ((result with<| TLBRecord_perms := tmp_440|>)) in
                 let (tmp_450 : AddressDescriptor) = (result.TLBRecord_addrdesc) in sail2_state_monad$bindS
                 (sail2_state_monad$liftRS (AArch64_S1AttrDecode sh ((slice memattr (( 0 : int):ii) (( 3 : int):ii)  :  3 words$word)) acctype)) (\ (w__165 :
                   MemoryAttributes) . 
                 let (tmp_450 : AddressDescriptor) =
                   ((tmp_450 with<| AddressDescriptor_memattrs := w__165|>)) in
                 let (result : TLBRecord) = ((result with<| TLBRecord_addrdesc := tmp_450|>)) in
                 let (tmp_460 : FullAddress) = (result.TLBRecord_addrdesc.AddressDescriptor_paddress) in
                 let (tmp_460 : FullAddress) =
                   ((tmp_460 with<|
                     FullAddress_NS :=
                       ((or_vec (vec_of_bits [access_vec_dec memattr (( 3 : int):ii)]  :  1 words$word) ns_table
                          :  1 words$word))|>)) in
                 let (tmp_470 : AddressDescriptor) = (result.TLBRecord_addrdesc) in
                 let (tmp_470 : AddressDescriptor) =
                   ((tmp_470 with<| AddressDescriptor_paddress := tmp_460|>)) in
                 let (result : TLBRecord) = ((result with<| TLBRecord_addrdesc := tmp_470|>)) in
                 sail2_state_monad$returnS result))
               else
                 let (tmp_480 : 3 bits) = (result.TLBRecord_perms.Permissions_ap) in
                 let tmp_480 =
                   ((set_slice (( 3 : int):ii) (( 2 : int):ii) tmp_480 (( 1 : int):ii) ((slice ap (( 1 : int):ii) (( 2 : int):ii)  :  2 words$word))
                     :  3 words$word)) in
                 let (tmp_490 : Permissions) = (result.TLBRecord_perms) in
                 let tmp_490 = ((tmp_490 with<| Permissions_ap := tmp_480|>)) in
                 let result = ((result with<| TLBRecord_perms := tmp_490|>)) in
                 let (tmp_500 : 3 bits) = (result.TLBRecord_perms.Permissions_ap) in
                 let tmp_500 =
                   ((set_slice (( 3 : int):ii) (( 1 : int):ii) tmp_500 (( 0 : int):ii) (vec_of_bits [B1]  :  1 words$word)
                     :  3 words$word)) in
                 let (tmp_510 : Permissions) = (result.TLBRecord_perms) in
                 let tmp_510 = ((tmp_510 with<| Permissions_ap := tmp_500|>)) in
                 let result = ((result with<| TLBRecord_perms := tmp_510|>)) in
                 let (tmp_520 : Permissions) = (result.TLBRecord_perms) in
                 let tmp_520 = ((tmp_520 with<| Permissions_xn := xn|>)) in
                 let result = ((result with<| TLBRecord_perms := tmp_520|>)) in
                 let (result : TLBRecord) =
                   (if ((HaveExtendedExecuteNeverExt () )) then
                     let (tmp_530 : Permissions) = (result.TLBRecord_perms) in
                     let (tmp_530 : Permissions) =
                       ((tmp_530 with<|
                         Permissions_xxn := ((vec_of_bits [access_vec_dec desc (( 53 : int):ii)]  :  1 words$word))|>)) in
                     (result with<| TLBRecord_perms := tmp_530|>)
                   else result) in
                 let (tmp_540 : Permissions) = (result.TLBRecord_perms) in
                 let tmp_540 = ((tmp_540 with<| Permissions_pxn := ((vec_of_bits [B0]  :  1 words$word))|>)) in
                 let result = ((result with<| TLBRecord_perms := tmp_540|>)) in
                 let result = ((result with<| TLBRecord_nG := ((vec_of_bits [B0]  :  1 words$word))|>)) in
                 let (tmp_550 : AddressDescriptor) = (result.TLBRecord_addrdesc) in sail2_state_monad$bindS
                 (sail2_state_monad$liftRS (S2AttrDecode sh memattr acctype)) (\ (w__166 : MemoryAttributes) . 
                 let (tmp_550 : AddressDescriptor) =
                   ((tmp_550 with<| AddressDescriptor_memattrs := w__166|>)) in
                 let (result : TLBRecord) = ((result with<| TLBRecord_addrdesc := tmp_550|>)) in
                 let (tmp_560 : FullAddress) = (result.TLBRecord_addrdesc.AddressDescriptor_paddress) in
                 let (tmp_560 : FullAddress) =
                   ((tmp_560 with<| FullAddress_NS := ((vec_of_bits [B1]  :  1 words$word))|>)) in
                 let (tmp_570 : AddressDescriptor) = (result.TLBRecord_addrdesc) in
                 let (tmp_570 : AddressDescriptor) =
                   ((tmp_570 with<| AddressDescriptor_paddress := tmp_560|>)) in
                 let (result : TLBRecord) = ((result with<| TLBRecord_addrdesc := tmp_570|>)) in
                 sail2_state_monad$returnS result)) (\ (result : TLBRecord) . 
              let (tmp_580 : FullAddress) = (result.TLBRecord_addrdesc.AddressDescriptor_paddress) in
              let tmp_580 = ((tmp_580 with<| FullAddress_physicaladdress := outputaddress|>)) in
              let (tmp_590 : AddressDescriptor) = (result.TLBRecord_addrdesc) in
              let tmp_590 = ((tmp_590 with<| AddressDescriptor_paddress := tmp_580|>)) in
              let result = ((result with<| TLBRecord_addrdesc := tmp_590|>)) in
              let (tmp_600 : AddressDescriptor) = (result.TLBRecord_addrdesc) in sail2_state_monad$bindS
              (sail2_state_monad$liftRS (AArch64_NoFault () )) (\ (w__167 : FaultRecord) . 
              let (tmp_600 : AddressDescriptor) =
                ((tmp_600 with<| AddressDescriptor_fault := w__167|>)) in
              let (result : TLBRecord) = ((result with<| TLBRecord_addrdesc := tmp_600|>)) in
              let (result : TLBRecord) =
                ((result with<|
                  TLBRecord_contiguous := (((contiguousbit = (vec_of_bits [B1]  :  1 words$word))))|>)) in
              let (result : TLBRecord) =
                (if ((HaveCommonNotPrivateTransExt () )) then
                  (result with<|
                    TLBRecord_CnP := ((vec_of_bits [access_vec_dec baseregister (( 0 : int):ii)]  :  1 words$word))|>)
                else result) in
              sail2_state_monad$returnS result)))))))))))))))))))))))))))))))))))))))))))))))))))))))`;


(*val IsZero_slice2 : forall 'n . Size 'n => mword 'n -> ii -> ii -> M bool*)

val _ = Define `
 ((IsZero_slice2:'n words$word -> int -> int ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) xs i l=  (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS T "")
   (sail2_state_monad$returnS ((IsZero ((and_vec xs ((slice_mask ((int_of_num (words$word_len xs))) i l  :  'n words$word))  :  'n words$word)))))))`;


(*val AArch64_TranslateAddressS1Off : mword ty64 -> AccType -> bool -> M TLBRecord*)

val _ = Define `
 ((AArch64_TranslateAddressS1Off:(64)words$word -> AccType -> bool ->(regstate)sail2_state_monad$sequential_state ->(((TLBRecord),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) vaddress acctype iswrite=  (sail2_state_monad$bindS
   (S1TranslationRegime__1 ()   : ( 2 words$word) M) (\ (w__0 :  2 words$word) .  sail2_state_monad$bindS
   (ELUsingAArch32 w__0) (\ (w__1 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((~ w__1)) "")
   (undefined_TLBRecord () )) (\ (result : TLBRecord) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) .  sail2_state_monad$bindS
   (AddrTop vaddress F w__2.ProcState_EL) (\ (Top : ii) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (s2fs1walk : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (secondstage : bool) .  sail2_state_monad$bindS
   (undefined_bitvector (( 52 : int):ii)  : ( 52 words$word) M) (\ (ipaddress : 52 bits) .  sail2_state_monad$bindS
   (undefined_int () ) (\ (level : ii) .  sail2_state_monad$bindS
   (IsZero_slice2 vaddress ((PAMax () ))
     ((((((ex_int Top)) + (( 1 : int):ii))) - ((ex_int ((PAMax () ))))))) (\ (w__3 :
     bool) . 
   if ((~ w__3)) then
     let level = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (undefined_bitvector (( 52 : int):ii)  : ( 52 words$word) M) (\ (w__4 : 52 bits) . 
     let ipaddress = w__4 in
     let secondstage = F in
     let s2fs1walk = F in
     let (tmp_1980 : AddressDescriptor) = (result.TLBRecord_addrdesc) in sail2_state_monad$bindS
     (AArch64_AddressSizeFault ipaddress level acctype iswrite secondstage s2fs1walk) (\ (w__5 :
       FaultRecord) . 
     let (tmp_1980 : AddressDescriptor) = ((tmp_1980 with<| AddressDescriptor_fault := w__5|>)) in
     let (result : TLBRecord) = ((result with<| TLBRecord_addrdesc := tmp_1980|>)) in
     sail2_state_monad$returnS result))
   else sail2_state_monad$bindS
     (sail2_state$and_boolS ((HasS2Translation () ))
       ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__7 : 64 bits) . 
        sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__7 (( 12 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (default_cacheable : bool) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (cacheable : bool) .  sail2_state_monad$bindS
     (if default_cacheable then
        let (tmp_1990 : MemoryAttributes) = (result.TLBRecord_addrdesc.AddressDescriptor_memattrs) in
        let (tmp_1990 : MemoryAttributes) =
          ((tmp_1990 with<| MemoryAttributes_typ := MemType_Normal|>)) in
        let (tmp_2000 : AddressDescriptor) = (result.TLBRecord_addrdesc) in
        let (tmp_2000 : AddressDescriptor) =
          ((tmp_2000 with<| AddressDescriptor_memattrs := tmp_1990|>)) in
        let (result : TLBRecord) = ((result with<| TLBRecord_addrdesc := tmp_2000|>)) in
        let (tmp_2010 : MemAttrHints) =
          (result.TLBRecord_addrdesc.AddressDescriptor_memattrs.MemoryAttributes_inner) in
        let (tmp_2010 : MemAttrHints) = ((tmp_2010 with<| MemAttrHints_attrs := MemAttr_WB|>)) in
        let (tmp_2020 : MemoryAttributes) = (result.TLBRecord_addrdesc.AddressDescriptor_memattrs) in
        let (tmp_2020 : MemoryAttributes) = ((tmp_2020 with<| MemoryAttributes_inner := tmp_2010|>)) in
        let (tmp_2030 : AddressDescriptor) = (result.TLBRecord_addrdesc) in
        let (tmp_2030 : AddressDescriptor) =
          ((tmp_2030 with<| AddressDescriptor_memattrs := tmp_2020|>)) in
        let (result : TLBRecord) = ((result with<| TLBRecord_addrdesc := tmp_2030|>)) in
        let (tmp_2040 : MemAttrHints) =
          (result.TLBRecord_addrdesc.AddressDescriptor_memattrs.MemoryAttributes_inner) in
        let (tmp_2040 : MemAttrHints) = ((tmp_2040 with<| MemAttrHints_hints := MemHint_RWA|>)) in
        let (tmp_2050 : MemoryAttributes) = (result.TLBRecord_addrdesc.AddressDescriptor_memattrs) in
        let (tmp_2050 : MemoryAttributes) = ((tmp_2050 with<| MemoryAttributes_inner := tmp_2040|>)) in
        let (tmp_2060 : AddressDescriptor) = (result.TLBRecord_addrdesc) in
        let (tmp_2060 : AddressDescriptor) =
          ((tmp_2060 with<| AddressDescriptor_memattrs := tmp_2050|>)) in
        let (result : TLBRecord) = ((result with<| TLBRecord_addrdesc := tmp_2060|>)) in
        let (tmp_2070 : MemoryAttributes) = (result.TLBRecord_addrdesc.AddressDescriptor_memattrs) in
        let (tmp_2070 : MemoryAttributes) = ((tmp_2070 with<| MemoryAttributes_shareable := F|>)) in
        let (tmp_2080 : AddressDescriptor) = (result.TLBRecord_addrdesc) in
        let (tmp_2080 : AddressDescriptor) =
          ((tmp_2080 with<| AddressDescriptor_memattrs := tmp_2070|>)) in
        let (result : TLBRecord) = ((result with<| TLBRecord_addrdesc := tmp_2080|>)) in
        let (tmp_2090 : MemoryAttributes) = (result.TLBRecord_addrdesc.AddressDescriptor_memattrs) in
        let (tmp_2090 : MemoryAttributes) =
          ((tmp_2090 with<| MemoryAttributes_outershareable := F|>)) in
        let (tmp_2100 : AddressDescriptor) = (result.TLBRecord_addrdesc) in
        let (tmp_2100 : AddressDescriptor) =
          ((tmp_2100 with<| AddressDescriptor_memattrs := tmp_2090|>)) in
        let (result : TLBRecord) = ((result with<| TLBRecord_addrdesc := tmp_2100|>)) in
        sail2_state_monad$returnS result
      else if (((acctype <> AccType_IFETCH))) then
        let (tmp_2110 : MemoryAttributes) = (result.TLBRecord_addrdesc.AddressDescriptor_memattrs) in
        let tmp_2110 = ((tmp_2110 with<| MemoryAttributes_typ := MemType_Device|>)) in
        let (tmp_2120 : AddressDescriptor) = (result.TLBRecord_addrdesc) in
        let tmp_2120 = ((tmp_2120 with<| AddressDescriptor_memattrs := tmp_2110|>)) in
        let result = ((result with<| TLBRecord_addrdesc := tmp_2120|>)) in
        let (tmp_2130 : MemoryAttributes) = (result.TLBRecord_addrdesc.AddressDescriptor_memattrs) in
        let tmp_2130 = ((tmp_2130 with<| MemoryAttributes_device := DeviceType_nGnRnE|>)) in
        let (tmp_2140 : AddressDescriptor) = (result.TLBRecord_addrdesc) in
        let tmp_2140 = ((tmp_2140 with<| AddressDescriptor_memattrs := tmp_2130|>)) in
        let result = ((result with<| TLBRecord_addrdesc := tmp_2140|>)) in
        let (tmp_2150 : MemoryAttributes) = (result.TLBRecord_addrdesc.AddressDescriptor_memattrs) in sail2_state_monad$bindS
        (undefined_MemAttrHints () ) (\ (w__8 : MemAttrHints) . 
        let (tmp_2150 : MemoryAttributes) = ((tmp_2150 with<| MemoryAttributes_inner := w__8|>)) in
        let (tmp_2160 : AddressDescriptor) = (result.TLBRecord_addrdesc) in
        let (tmp_2160 : AddressDescriptor) =
          ((tmp_2160 with<| AddressDescriptor_memattrs := tmp_2150|>)) in
        let (result : TLBRecord) = ((result with<| TLBRecord_addrdesc := tmp_2160|>)) in
        sail2_state_monad$returnS result)
      else sail2_state_monad$bindS
        (aget_SCTLR__1 ()   : ( 32 words$word) M) (\ (w__9 :  32 words$word) . 
        let (cacheable : bool) =
          ((vec_of_bits [access_vec_dec w__9 (( 12 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
        let (tmp_2170 : MemoryAttributes) = (result.TLBRecord_addrdesc.AddressDescriptor_memattrs) in
        let (tmp_2170 : MemoryAttributes) =
          ((tmp_2170 with<| MemoryAttributes_typ := MemType_Normal|>)) in
        let (tmp_2180 : AddressDescriptor) = (result.TLBRecord_addrdesc) in
        let (tmp_2180 : AddressDescriptor) =
          ((tmp_2180 with<| AddressDescriptor_memattrs := tmp_2170|>)) in
        let (result : TLBRecord) = ((result with<| TLBRecord_addrdesc := tmp_2180|>)) in
        let (result : TLBRecord) =
          (if cacheable then
            let (tmp_2190 : MemAttrHints) =
              (result.TLBRecord_addrdesc.AddressDescriptor_memattrs.MemoryAttributes_inner) in
            let (tmp_2190 : MemAttrHints) = ((tmp_2190 with<| MemAttrHints_attrs := MemAttr_WT|>)) in
            let (tmp_2200 : MemoryAttributes) =
              (result.TLBRecord_addrdesc.AddressDescriptor_memattrs) in
            let (tmp_2200 : MemoryAttributes) =
              ((tmp_2200 with<| MemoryAttributes_inner := tmp_2190|>)) in
            let (tmp_2210 : AddressDescriptor) = (result.TLBRecord_addrdesc) in
            let (tmp_2210 : AddressDescriptor) =
              ((tmp_2210 with<| AddressDescriptor_memattrs := tmp_2200|>)) in
            let (result : TLBRecord) = ((result with<| TLBRecord_addrdesc := tmp_2210|>)) in
            let (tmp_2220 : MemAttrHints) =
              (result.TLBRecord_addrdesc.AddressDescriptor_memattrs.MemoryAttributes_inner) in
            let (tmp_2220 : MemAttrHints) = ((tmp_2220 with<| MemAttrHints_hints := MemHint_RA|>)) in
            let (tmp_2230 : MemoryAttributes) =
              (result.TLBRecord_addrdesc.AddressDescriptor_memattrs) in
            let (tmp_2230 : MemoryAttributes) =
              ((tmp_2230 with<| MemoryAttributes_inner := tmp_2220|>)) in
            let (tmp_2240 : AddressDescriptor) = (result.TLBRecord_addrdesc) in
            let (tmp_2240 : AddressDescriptor) =
              ((tmp_2240 with<| AddressDescriptor_memattrs := tmp_2230|>)) in
            (result with<| TLBRecord_addrdesc := tmp_2240|>)
          else
            let (tmp_2250 : MemAttrHints) =
              (result.TLBRecord_addrdesc.AddressDescriptor_memattrs.MemoryAttributes_inner) in
            let (tmp_2250 : MemAttrHints) = ((tmp_2250 with<| MemAttrHints_attrs := MemAttr_NC|>)) in
            let (tmp_2260 : MemoryAttributes) =
              (result.TLBRecord_addrdesc.AddressDescriptor_memattrs) in
            let (tmp_2260 : MemoryAttributes) =
              ((tmp_2260 with<| MemoryAttributes_inner := tmp_2250|>)) in
            let (tmp_2270 : AddressDescriptor) = (result.TLBRecord_addrdesc) in
            let (tmp_2270 : AddressDescriptor) =
              ((tmp_2270 with<| AddressDescriptor_memattrs := tmp_2260|>)) in
            let (result : TLBRecord) = ((result with<| TLBRecord_addrdesc := tmp_2270|>)) in
            let (tmp_2280 : MemAttrHints) =
              (result.TLBRecord_addrdesc.AddressDescriptor_memattrs.MemoryAttributes_inner) in
            let (tmp_2280 : MemAttrHints) = ((tmp_2280 with<| MemAttrHints_hints := MemHint_No|>)) in
            let (tmp_2290 : MemoryAttributes) =
              (result.TLBRecord_addrdesc.AddressDescriptor_memattrs) in
            let (tmp_2290 : MemoryAttributes) =
              ((tmp_2290 with<| MemoryAttributes_inner := tmp_2280|>)) in
            let (tmp_2300 : AddressDescriptor) = (result.TLBRecord_addrdesc) in
            let (tmp_2300 : AddressDescriptor) =
              ((tmp_2300 with<| AddressDescriptor_memattrs := tmp_2290|>)) in
            (result with<| TLBRecord_addrdesc := tmp_2300|>)) in
        let (tmp_2310 : MemoryAttributes) = (result.TLBRecord_addrdesc.AddressDescriptor_memattrs) in
        let (tmp_2310 : MemoryAttributes) = ((tmp_2310 with<| MemoryAttributes_shareable := T|>)) in
        let (tmp_2320 : AddressDescriptor) = (result.TLBRecord_addrdesc) in
        let (tmp_2320 : AddressDescriptor) =
          ((tmp_2320 with<| AddressDescriptor_memattrs := tmp_2310|>)) in
        let (result : TLBRecord) = ((result with<| TLBRecord_addrdesc := tmp_2320|>)) in
        let (tmp_2330 : MemoryAttributes) = (result.TLBRecord_addrdesc.AddressDescriptor_memattrs) in
        let (tmp_2330 : MemoryAttributes) =
          ((tmp_2330 with<| MemoryAttributes_outershareable := T|>)) in
        let (tmp_2340 : AddressDescriptor) = (result.TLBRecord_addrdesc) in
        let (tmp_2340 : AddressDescriptor) =
          ((tmp_2340 with<| AddressDescriptor_memattrs := tmp_2330|>)) in
        let (result : TLBRecord) = ((result with<| TLBRecord_addrdesc := tmp_2340|>)) in
        sail2_state_monad$returnS result)) (\ (result : TLBRecord) . 
     let (tmp_2350 : MemoryAttributes) = (result.TLBRecord_addrdesc.AddressDescriptor_memattrs) in
     let tmp_2350 =
       ((tmp_2350 with<|
         MemoryAttributes_outer :=
           (result.TLBRecord_addrdesc.AddressDescriptor_memattrs.MemoryAttributes_inner)|>)) in
     let (tmp_2360 : AddressDescriptor) = (result.TLBRecord_addrdesc) in
     let tmp_2360 = ((tmp_2360 with<| AddressDescriptor_memattrs := tmp_2350|>)) in
     let result = ((result with<| TLBRecord_addrdesc := tmp_2360|>)) in
     let (tmp_2370 : AddressDescriptor) = (result.TLBRecord_addrdesc) in sail2_state_monad$bindS
     (MemAttrDefaults result.TLBRecord_addrdesc.AddressDescriptor_memattrs) (\ (w__10 :
       MemoryAttributes) . 
     let tmp_2370 = ((tmp_2370 with<| AddressDescriptor_memattrs := w__10|>)) in
     let result = ((result with<| TLBRecord_addrdesc := tmp_2370|>)) in
     let (tmp_2380 : Permissions) = (result.TLBRecord_perms) in sail2_state_monad$bindS
     (undefined_bitvector (( 3 : int):ii)  : ( 3 words$word) M) (\ (w__11 : 3 bits) . 
     let tmp_2380 = ((tmp_2380 with<| Permissions_ap := w__11|>)) in
     let result = ((result with<| TLBRecord_perms := tmp_2380|>)) in
     let (tmp_2390 : Permissions) = (result.TLBRecord_perms) in
     let tmp_2390 = ((tmp_2390 with<| Permissions_xn := ((vec_of_bits [B0]  :  1 words$word))|>)) in
     let result = ((result with<| TLBRecord_perms := tmp_2390|>)) in
     let (tmp_2400 : Permissions) = (result.TLBRecord_perms) in
     let tmp_2400 = ((tmp_2400 with<| Permissions_pxn := ((vec_of_bits [B0]  :  1 words$word))|>)) in
     let result = ((result with<| TLBRecord_perms := tmp_2400|>)) in sail2_state_monad$bindS
     (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__12 : 1 bits) . 
     let result = ((result with<| TLBRecord_nG := w__12|>)) in sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (w__13 : bool) . 
     let result = ((result with<| TLBRecord_contiguous := w__13|>)) in sail2_state_monad$bindS
     (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (w__14 : 4 bits) . 
     let result = ((result with<| TLBRecord_domain := w__14|>)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__15 : ii) . 
     let result = ((result with<| TLBRecord_level := w__15|>)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__16 : ii) . 
     let result = ((result with<| TLBRecord_blocksize := w__16|>)) in
     let (tmp_2410 : FullAddress) = (result.TLBRecord_addrdesc.AddressDescriptor_paddress) in
     let tmp_2410 =
       ((tmp_2410 with<|
         FullAddress_physicaladdress := ((slice vaddress (( 0 : int):ii) (( 52 : int):ii)  :  52 words$word))|>)) in
     let (tmp_2420 : AddressDescriptor) = (result.TLBRecord_addrdesc) in
     let tmp_2420 = ((tmp_2420 with<| AddressDescriptor_paddress := tmp_2410|>)) in
     let result = ((result with<| TLBRecord_addrdesc := tmp_2420|>)) in
     let (tmp_2430 : FullAddress) = (result.TLBRecord_addrdesc.AddressDescriptor_paddress) in sail2_state_monad$bindS
     (IsSecure () ) (\ (w__17 : bool) . 
     let tmp_2430 =
       ((tmp_2430 with<|
         FullAddress_NS :=
           (if w__17 then (vec_of_bits [B0]  :  1 words$word)
            else (vec_of_bits [B1]  :  1 words$word))|>)) in
     let (tmp_2440 : AddressDescriptor) = (result.TLBRecord_addrdesc) in
     let tmp_2440 = ((tmp_2440 with<| AddressDescriptor_paddress := tmp_2430|>)) in
     let result = ((result with<| TLBRecord_addrdesc := tmp_2440|>)) in
     let (tmp_2450 : AddressDescriptor) = (result.TLBRecord_addrdesc) in sail2_state_monad$bindS
     (AArch64_NoFault () ) (\ (w__18 : FaultRecord) . 
     let (tmp_2450 : AddressDescriptor) = ((tmp_2450 with<| AddressDescriptor_fault := w__18|>)) in
     let (result : TLBRecord) = ((result with<| TLBRecord_addrdesc := tmp_2450|>)) in
     sail2_state_monad$returnS result))))))))))))))))))))))))`;


(*val AArch64_MaybeZeroRegisterUppers : unit -> M unit*)

val _ = Define `
 ((AArch64_MaybeZeroRegisterUppers:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (UsingAArch32 () ) (\ (w__0 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS w__0 "UsingAArch32()")
   (sail2_state_monad$undefined_boolS () )) (\ (include_R15_name : bool) .  sail2_state_monad$bindS
   (undefined_int () ) (\ (last : ii) .  sail2_state_monad$bindS
   (undefined_int () ) (\ (first : ii) .  sail2_state_monad$bindS
   (sail2_state$and_boolS
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__1 : ProcState) .  sail2_state_monad$returnS (((w__1.ProcState_EL = EL0)))))
     ( sail2_state_monad$bindS(ELUsingAArch32 EL1) (\ (w__2 : bool) .  sail2_state_monad$returnS ((~ w__2))))) (\ (w__3 : bool) .  sail2_state_monad$bindS
   (if w__3 then
      let (first : ii) = ((( 0 : int):ii)) in
      let (last : ii) = ((( 14 : int):ii)) in
      let (include_R15_name : bool) = F in
      sail2_state_monad$returnS (first, include_R15_name, last)
    else sail2_state_monad$bindS
      (sail2_state$and_boolS
        (sail2_state$and_boolS
           (sail2_state$and_boolS
              (sail2_state$or_boolS
                 ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__4 : ProcState) . 
                  sail2_state_monad$returnS (((w__4.ProcState_EL = EL0)))))
                 ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__5 : ProcState) . 
                  sail2_state_monad$returnS (((w__5.ProcState_EL = EL1)))))) (sail2_state_monad$returnS ((HaveEL EL2))))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__8 : bool) .  sail2_state_monad$returnS ((~ w__8)))))
        ( sail2_state_monad$bindS(ELUsingAArch32 EL2) (\ (w__10 : bool) .  sail2_state_monad$returnS ((~ w__10))))) (\ (w__11 : bool) . 
      let ((first : ii), (include_R15_name : bool), (last : ii)) =
        (if w__11 then
          let (first : ii) = ((( 0 : int):ii)) in
          let (last : ii) = ((( 30 : int):ii)) in
          let (include_R15_name : bool) = F in
          (first, include_R15_name, last)
        else
          let (first : ii) = ((( 0 : int):ii)) in
          let (last : ii) = ((( 30 : int):ii)) in
          let (include_R15_name : bool) = T in
          (first, include_R15_name, last)) in
      sail2_state_monad$returnS (first, include_R15_name, last))) (\ varstup .  let ((first : ii), (include_R15_name :
     bool), (last : ii)) = varstup in
   (sail2_state$foreachS (index_list first last (( 1 : int):ii)) () 
     (\ n unit_var .  sail2_state_monad$bindS
       (sail2_state$and_boolS (sail2_state_monad$returnS ((((((n <> (( 15 : int):ii)))) \/ include_R15_name))))
         ((ConstrainUnpredictableBool Unpredictable_ZEROUPPER))) (\ (w__13 : bool) . 
       if w__13 then sail2_state_monad$bindS
         (sail2_state_monad$read_regS R_ref) (\ (w__14 : ( 64 bits) list) . 
         let (tmp_30 : 64 bits) = ((access_list_dec w__14 n  :  64 words$word)) in
         let tmp_30 =
           ((set_slice (( 64 : int):ii) (( 32 : int):ii) tmp_30 (( 32 : int):ii) ((Zeros__1 (( 32 : int):ii) ()   :  32 words$word))
             :  64 words$word)) in sail2_state_monad$bindS
         (sail2_state_monad$read_regS R_ref) (\ (w__15 : ( 64 words$word) list) . 
         sail2_state_monad$write_regS R_ref ((update_list_dec w__15 n tmp_30  : ( 64 words$word) list))))
       else sail2_state_monad$returnS () )))))))))))`;


(*val DCPSInstruction : mword ty2 -> M unit*)

val _ = Define `
 ((DCPSInstruction:(2)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) target_el=
    (let (_ : unit) = (SynchronizeContext () ) in sail2_state_monad$bindS
   (undefined_bitvector (( 2 : int):ii)  : ( 2 words$word) M) (\ (handle_el : 2 bits) . 
   let pat_0 = target_el in sail2_state_monad$bindS
   (if (((pat_0 = EL1))) then sail2_state_monad$bindS
      (sail2_state$or_boolS
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) .  sail2_state_monad$returnS (((w__0.ProcState_EL = EL2)))))
        (sail2_state$and_boolS
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__1 : ProcState) . 
            sail2_state_monad$returnS (((w__1.ProcState_EL = EL3)))))
           ( sail2_state_monad$bindS(UsingAArch32 () ) (\ (w__2 : bool) .  sail2_state_monad$returnS ((~ w__2)))))) (\ (w__4 : bool) . 
      if w__4 then sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__5 : ProcState) . 
        let (handle_el : 2 bits) = (w__5.ProcState_EL) in
        sail2_state_monad$returnS handle_el)
      else sail2_state_monad$bindS
        (sail2_state$and_boolS
          (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
             ( sail2_state_monad$bindS(IsSecure () ) (\ (w__6 : bool) .  sail2_state_monad$returnS ((~ w__6)))))
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__8 : 64 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__8 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__9 : bool) . 
        if w__9 then sail2_state_monad$seqS (UndefinedFault () ) (sail2_state_monad$returnS handle_el)
        else sail2_state_monad$returnS EL1))
    else if (((pat_0 = EL2))) then
      if ((~ ((HaveEL EL2)))) then sail2_state_monad$seqS (UndefinedFault () ) (sail2_state_monad$returnS handle_el)
      else sail2_state_monad$bindS
        (sail2_state$and_boolS
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__10 : ProcState) . 
           sail2_state_monad$returnS (((w__10.ProcState_EL = EL3)))))
          ( sail2_state_monad$bindS(UsingAArch32 () ) (\ (w__11 : bool) .  sail2_state_monad$returnS ((~ w__11))))) (\ (w__12 : bool) . 
        if w__12 then sail2_state_monad$returnS EL3
        else sail2_state_monad$bindS
          (IsSecure () ) (\ (w__13 : bool) . 
          if w__13 then sail2_state_monad$seqS (UndefinedFault () ) (sail2_state_monad$returnS handle_el)
          else sail2_state_monad$returnS EL2))
    else if (((pat_0 = EL3))) then sail2_state_monad$bindS
      (sail2_state$or_boolS
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS EDSCR_ref  : ( 32 words$word) M) (\ (w__14 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__14 (( 16 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))) (sail2_state_monad$returnS ((~ ((HaveEL EL3)))))) (\ (w__15 :
        bool) .  sail2_state_monad$seqS
      (if w__15 then UndefinedFault ()  else sail2_state_monad$returnS () ) (sail2_state_monad$returnS EL3))
    else sail2_state_monad$seqS (Unreachable () ) (sail2_state_monad$returnS handle_el)) (\ (handle_el : 2 bits) .  sail2_state_monad$bindS
   (IsSecure () ) (\ (from_secure : bool) .  sail2_state_monad$bindS
   (ELUsingAArch32 handle_el) (\ (w__16 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (if w__16 then sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__17 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (if (((w__17.ProcState_M = M32_Monitor))) then sail2_state_monad$bindS
         (sail2_state_monad$read_regS SCR_ref  : ( 32 words$word) M) (\ (w__18 :  32 words$word) . 
         sail2_state_monad$write_regS
           SCR_ref
           ((set_slice (( 32 : int):ii) (( 1 : int):ii) w__18 (( 0 : int):ii) (vec_of_bits [B0]  :  1 words$word)  :  32 words$word)))
       else sail2_state_monad$returnS () )
      (UsingAArch32 () )) (\ (w__19 : bool) .  sail2_state_monad$seqS
      (sail2_state_monad$assert_expS w__19 "UsingAArch32()")
      (let pat_0 = handle_el in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
      (if (((pat_0 = EL1))) then sail2_state_monad$bindS (sail2_state_monad$seqS
         (AArch32_WriteMode M32_Svc)
         (sail2_state$and_boolS (sail2_state_monad$returnS ((HavePANExt () )))
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCTLR_ref  : ( 32 words$word) M) (\ (w__20 : 32 bits) . 
            sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__20 (( 23 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))))))) (\ (w__21 : bool) . 
         if w__21 then sail2_state_monad$bindS
           (sail2_state_monad$read_regS PSTATE_ref) (\ (w__22 : ProcState) . 
           sail2_state_monad$write_regS PSTATE_ref (w__22 with<| ProcState_PAN := ((vec_of_bits [B1]  :  1 words$word))|>))
         else sail2_state_monad$returnS () )
       else if (((pat_0 = EL2))) then AArch32_WriteMode M32_Hyp
       else sail2_state_monad$seqS
         (AArch32_WriteMode M32_Monitor)
         (if ((HavePANExt () )) then
           if ((~ from_secure)) then sail2_state_monad$bindS
             (sail2_state_monad$read_regS PSTATE_ref) (\ (w__23 : ProcState) . 
             sail2_state_monad$write_regS PSTATE_ref (w__23 with<| ProcState_PAN := ((vec_of_bits [B0]  :  1 words$word))|>))
           else sail2_state_monad$bindS
             (sail2_state_monad$read_regS SCTLR_ref  : ( 32 words$word) M) (\ (w__24 : 32 bits) . 
             if ((((vec_of_bits [access_vec_dec w__24 (( 23 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))) then sail2_state_monad$bindS
               (sail2_state_monad$read_regS PSTATE_ref) (\ (w__25 : ProcState) . 
               sail2_state_monad$write_regS PSTATE_ref (w__25 with<| ProcState_PAN := ((vec_of_bits [B1]  :  1 words$word))|>))
             else sail2_state_monad$returnS () )
         else sail2_state_monad$returnS () ))
      (if (((handle_el = EL2))) then sail2_state_monad$bindS
         (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (w__26 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
         (sail2_state_monad$write_regS ELR_hyp_ref w__26)
         (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__27 : 32 bits) . 
         sail2_state_monad$write_regS HSR_ref w__27))
       else sail2_state_monad$bindS
         (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (w__28 :  32 words$word) . 
         set_LR w__28)))
      (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__29 :  32 words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (aset_SPSR w__29)
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__30 : ProcState) .  sail2_state_monad$bindS
      (aget_SCTLR__1 ()   : ( 32 words$word) M) (\ (w__31 :  32 words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS
        PSTATE_ref
        (w__30 with<| ProcState_E := ((vec_of_bits [access_vec_dec w__31 (( 25 : int):ii)]  :  1 words$word))|>))
      (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__32 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS DLR_ref w__32)
      (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__33 : 32 bits) . 
      sail2_state_monad$write_regS DSPSR_ref w__33))))))))
    else sail2_state_monad$bindS
      (UsingAArch32 () ) (\ (w__34 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (if w__34 then AArch64_MaybeZeroRegisterUppers () 
       else sail2_state_monad$returnS () )
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__35 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__35 with<| ProcState_nRW := ((vec_of_bits [B0]  :  1 words$word))|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__36 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__36 with<| ProcState_SP := ((vec_of_bits [B1]  :  1 words$word))|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__37 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__37 with<| ProcState_EL := handle_el|>))
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HavePANExt () )))
        (sail2_state$or_boolS
           (sail2_state$and_boolS (sail2_state_monad$returnS (((handle_el = EL1))))
              ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCTLR_EL1_ref  : ( 32 words$word) M) (\ (w__38 : 32 bits) . 
               sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__38 (( 23 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))))))
           (sail2_state$and_boolS
              (sail2_state$and_boolS
                 (sail2_state$and_boolS (sail2_state_monad$returnS (((handle_el = EL2))))
                    ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__40 : 64 bits) . 
                     sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__40 (( 34 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
                 ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__42 : 64 bits) . 
                  sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__42 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
              ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCTLR_EL2_ref  : ( 32 words$word) M) (\ (w__44 : 32 bits) . 
               sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__44 (( 23 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))))))))) (\ (w__47 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (if w__47 then sail2_state_monad$bindS
         (sail2_state_monad$read_regS PSTATE_ref) (\ (w__48 : ProcState) . 
         sail2_state_monad$write_regS PSTATE_ref (w__48 with<| ProcState_PAN := ((vec_of_bits [B1]  :  1 words$word))|>))
       else sail2_state_monad$returnS () )
      (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__49 :  64 words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (aset_ELR__1 w__49)
      (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__50 :  32 words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (aset_SPSR w__50)
      (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__51 :  32 words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (aset_ESR__1 w__51)
      (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__52 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS DLR_EL0_ref w__52)
      (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__53 : 32 bits) .  sail2_state_monad$seqS
      (sail2_state_monad$write_regS DSPSR_EL0_ref w__53)
      (if ((HaveUAOExt () )) then sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__54 : ProcState) . 
        sail2_state_monad$write_regS PSTATE_ref (w__54 with<| ProcState_UAO := ((vec_of_bits [B0]  :  1 words$word))|>))
      else sail2_state_monad$returnS () ))))))))))))
   (UpdateEDSCRFields () ))
   (sail2_state$and_boolS
     (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveRASExt () )))
        ( sail2_state_monad$bindS(aget_SCTLR__1 ()   : ( 32 words$word) M) (\ (w__55 :  32 words$word) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__55 (( 21 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
     ((ConstrainUnpredictableBool Unpredictable_IESBinDebug)))) (\ (w__58 : bool) . 
   let (_ : unit) =
     (if w__58 then ErrorSynchronizationBarrier MBReqDomain_FullSystem MBReqTypes_All
     else () ) in
   sail2_state_monad$returnS () )))))))`;


(*val aarch64_system_exceptions_debug_exception : mword ty2 -> M unit*)

val _ = Define `
 ((aarch64_system_exceptions_debug_exception:(2)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) target_level=  (DCPSInstruction target_level))`;


(*val AArch64_GenerateDebugExceptionsFrom : mword ty2 -> bool -> mword ty1 -> M bool*)

val _ = Define `
 ((AArch64_GenerateDebugExceptionsFrom:(2)words$word -> bool ->(1)words$word ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) from secure mask=  (sail2_state_monad$bindS
   (sail2_state$or_boolS
     (sail2_state$or_boolS
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS OSLSR_EL1_ref  : ( 32 words$word) M) (\ (w__0 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__0 (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))) ((DoubleLockStatus () ))) ((Halted () ))) (\ (w__4 :
     bool) . 
   if w__4 then sail2_state_monad$returnS F
   else sail2_state_monad$bindS
     (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveEL EL2)) /\ ((~ secure))))))
       (sail2_state$or_boolS
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__5 : 64 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__5 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS MDCR_EL2_ref  : ( 32 words$word) M) (\ (w__6 : 32 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__6 (( 8 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))) (\ (route_to_el2 : bool) . 
     let (target : 2 bits) = (if route_to_el2 then EL2 else EL1) in sail2_state_monad$bindS
     (sail2_state$or_boolS (sail2_state_monad$returnS (((((~ ((HaveEL EL3)))) \/ ((~ secure))))))
       ( sail2_state_monad$bindS(sail2_state_monad$read_regS MDCR_EL3_ref  : ( 32 words$word) M) (\ (w__8 : 32 bits) . 
        sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__8 (( 16 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (enabled : bool) . 
     if (((from = target))) then
       sail2_state$and_boolS
         (sail2_state$and_boolS (sail2_state_monad$returnS enabled)
            ( sail2_state_monad$bindS(sail2_state_monad$read_regS MDSCR_EL1_ref  : ( 32 words$word) M) (\ (w__9 : 32 bits) . 
             sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__9 (( 13 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
         (sail2_state_monad$returnS (((mask = (vec_of_bits [B0]  :  1 words$word)))))
     else
       let (enabled : bool) = (enabled /\ ((((lem$w2ui target)) > ((lem$w2ui from))))) in
       sail2_state_monad$returnS enabled)))))`;


(*val AArch64_GenerateDebugExceptions : unit -> M bool*)

val _ = Define `
 ((AArch64_GenerateDebugExceptions:unit ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) .  sail2_state_monad$bindS
   (IsSecure () ) (\ (w__1 : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) . 
   AArch64_GenerateDebugExceptionsFrom w__0.ProcState_EL w__1 w__2.ProcState_D)))))`;


(*val AArch64_FaultSyndrome : bool -> FaultRecord -> M (mword ty25)*)

val _ = Define `
 ((AArch64_FaultSyndrome:bool -> FaultRecord ->(regstate)sail2_state_monad$sequential_state ->((((25)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d_side fault=  (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS (((fault.FaultRecord_typ <> Fault_None))) "((fault).type != Fault_None)")
   (let (iss : 25 bits) = ((Zeros__1 (( 25 : int):ii) ()   :  25 words$word)) in sail2_state_monad$bindS
   (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveRASExt () ))) ((IsExternalSyncAbort__1 fault))) (\ (w__1 : bool) . 
   let (iss : 25 bits) =
     (if w__1 then (set_slice (( 25 : int):ii) (( 2 : int):ii) iss (( 11 : int):ii) fault.FaultRecord_errortype  :  25 words$word)
     else iss) in sail2_state_monad$bindS
   (if d_side then sail2_state_monad$bindS
      (sail2_state$and_boolS ((IsSecondStage fault)) (sail2_state_monad$returnS ((~ fault.FaultRecord_s2fs1walk)))) (\ (w__3 :
        bool) .  sail2_state_monad$bindS
      (if w__3 then sail2_state_monad$bindS
         (LSInstructionSyndrome ()   : ( 11 words$word) M) (\ (w__4 :  11 words$word) . 
         let (iss : 25 bits) = ((set_slice (( 25 : int):ii) (( 11 : int):ii) iss (( 14 : int):ii) w__4  :  25 words$word)) in
         sail2_state_monad$returnS iss)
       else sail2_state_monad$returnS iss) (\ (iss : 25 bits) . 
      let (iss : 25 bits) =
        (if ((((((fault.FaultRecord_acctype = AccType_DC))) \/ ((((((fault.FaultRecord_acctype = AccType_IC))) \/ (((fault.FaultRecord_acctype = AccType_AT))))))))) then
          let (iss : 25 bits) =
            ((set_slice (( 25 : int):ii) (( 1 : int):ii) iss (( 8 : int):ii) (vec_of_bits [B1]  :  1 words$word)  :  25 words$word)) in
          (set_slice (( 25 : int):ii) (( 1 : int):ii) iss (( 6 : int):ii) (vec_of_bits [B1]  :  1 words$word)  :  25 words$word)
        else
          (set_slice (( 25 : int):ii) (( 1 : int):ii) iss (( 6 : int):ii)
             (if fault.FaultRecord_write then (vec_of_bits [B1]  :  1 words$word)
              else (vec_of_bits [B0]  :  1 words$word))
            :  25 words$word)) in
      sail2_state_monad$returnS iss))
    else sail2_state_monad$returnS iss) (\ (iss : 25 bits) .  sail2_state_monad$bindS
   (IsExternalAbort__1 fault) (\ (w__5 : bool) . 
   let (iss : 25 bits) =
     (if w__5 then (set_slice (( 25 : int):ii) (( 1 : int):ii) iss (( 9 : int):ii) fault.FaultRecord_extflag  :  25 words$word)
     else iss) in
   let iss =
     ((set_slice (( 25 : int):ii) (( 1 : int):ii) iss (( 7 : int):ii)
        (if fault.FaultRecord_s2fs1walk then (vec_of_bits [B1]  :  1 words$word)
         else (vec_of_bits [B0]  :  1 words$word))
       :  25 words$word)) in sail2_state_monad$bindS
   (EncodeLDFSC fault.FaultRecord_typ fault.FaultRecord_level  : ( 6 words$word) M) (\ (w__6 :
      6 words$word) . 
   let (iss : 25 bits) = ((set_slice (( 25 : int):ii) (( 6 : int):ii) iss (( 0 : int):ii) w__6  :  25 words$word)) in
   sail2_state_monad$returnS iss)))))))`;


(*val AArch64_AbortSyndrome : Exception -> FaultRecord -> mword ty64 -> M ExceptionRecord*)

val _ = Define `
 ((AArch64_AbortSyndrome:Exception -> FaultRecord ->(64)words$word ->(regstate)sail2_state_monad$sequential_state ->(((ExceptionRecord),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) typ fault vaddress=  (sail2_state_monad$bindS
   (ExceptionSyndrome typ) (\ (exception : ExceptionRecord) . 
   let (d_side : bool) = ((((typ = Exception_DataAbort))) \/ (((typ = Exception_Watchpoint)))) in sail2_state_monad$bindS
   (AArch64_FaultSyndrome d_side fault  : ( 25 words$word) M) (\ (w__0 : 25 bits) . 
   let exception = ((exception with<| ExceptionRecord_syndrome := w__0|>)) in sail2_state_monad$bindS
   (ZeroExtend__1 (( 64 : int):ii) vaddress  : ( 64 words$word) M) (\ (w__1 : 64 bits) . 
   let exception = ((exception with<| ExceptionRecord_vaddress := w__1|>)) in sail2_state_monad$bindS
   (IPAValid fault) (\ (w__2 : bool) . 
   let (exception : ExceptionRecord) =
     (if w__2 then
       let (exception : ExceptionRecord) = ((exception with<| ExceptionRecord_ipavalid := T|>)) in
       (exception with<| ExceptionRecord_ipaddress := (fault.FaultRecord_ipaddress)|>)
     else (exception with<| ExceptionRecord_ipavalid := F|>)) in
   sail2_state_monad$returnS exception))))))`;


(*val AArch64_ExecutingATS1xPInstr : unit -> M bool*)

val _ = Define `
 ((AArch64_ExecutingATS1xPInstr:unit ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (if ((~ ((HavePrivATExt () )))) then sail2_state_monad$returnS F
   else sail2_state_monad$bindS
     (ThisInstr0 ()   : ( 32 words$word) M) (\ (instr : 32 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 3 : int):ii)  : ( 3 words$word) M) (\ (op2 : 3 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (CRm : 4 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M) (\ (CRn : 4 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 3 : int):ii)  : ( 3 words$word) M) (\ (op1 : 3 bits) . 
     let (w__0 : bool) =
       (if (((((slice instr (( 22 : int):ii) (( 10 : int):ii)  :  10 words$word)) = (vec_of_bits [B1;B1;B0;B1;B0;B1;B0;B1;B0;B0]  :  10 words$word)))) then
         let (op1 : 3 bits) = ((slice instr (( 16 : int):ii) (( 3 : int):ii)  :  3 words$word)) in
         let (CRn : 4 bits) = ((slice instr (( 12 : int):ii) (( 4 : int):ii)  :  4 words$word)) in
         let (CRm : 4 bits) = ((slice instr (( 8 : int):ii) (( 4 : int):ii)  :  4 words$word)) in
         let (op2 : 3 bits) = ((slice instr (( 5 : int):ii) (( 3 : int):ii)  :  3 words$word)) in
         ((((((((((op1 = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((CRn = (vec_of_bits [B0;B1;B1;B1]  :  4 words$word))))))) /\ (((CRm = (vec_of_bits [B1;B0;B0;B1]  :  4 words$word))))))) /\ ((((((op2 = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) \/ (((op2 = (vec_of_bits [B0;B0;B1]  :  3 words$word))))))))
       else F) in
     sail2_state_monad$returnS w__0)))))))`;


(*val AArch64_ExceptionClass : Exception -> mword ty2 -> M (ii * mword ty1)*)

val _ = Define `
 ((AArch64_ExceptionClass:Exception ->(2)words$word ->(regstate)sail2_state_monad$sequential_state ->(((int#(1)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) typ target_el=  (sail2_state_monad$bindS
   (ThisInstrLength () ) (\ (w__0 : ii) . 
   let (il : 1 bits) =
     (if (((((ex_int w__0)) = (( 32 : int):ii)))) then (vec_of_bits [B1]  :  1 words$word)
     else (vec_of_bits [B0]  :  1 words$word)) in sail2_state_monad$bindS
   (UsingAArch32 () ) (\ (from_32 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS (((from_32 \/ (((il = (vec_of_bits [B1]  :  1 words$word))))))) "(from_32 || (il == '1'))")
   (undefined_int () )) (\ (ec : ii) .  sail2_state_monad$bindS
   (case typ of
     Exception_Uncategorized =>
      let (ec : ii) = ((( 0 : int):ii)) in
      let (il : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_WFxTrap =>
      let (ec : ii) = ((( 1 : int):ii)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_CP15RTTrap =>
      let ec = ((( 3 : int):ii)) in sail2_state_monad$seqS
      (sail2_state_monad$assert_expS from_32 "from_32") (sail2_state_monad$returnS (ec, il))
   | Exception_CP15RRTTrap =>
      let ec = ((( 4 : int):ii)) in sail2_state_monad$seqS
      (sail2_state_monad$assert_expS from_32 "from_32") (sail2_state_monad$returnS (ec, il))
   | Exception_CP14RTTrap =>
      let ec = ((( 5 : int):ii)) in sail2_state_monad$seqS
      (sail2_state_monad$assert_expS from_32 "from_32") (sail2_state_monad$returnS (ec, il))
   | Exception_CP14DTTrap =>
      let ec = ((( 6 : int):ii)) in sail2_state_monad$seqS
      (sail2_state_monad$assert_expS from_32 "from_32") (sail2_state_monad$returnS (ec, il))
   | Exception_AdvSIMDFPAccessTrap =>
      let (ec : ii) = ((( 7 : int):ii)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_FPIDTrap =>
      let (ec : ii) = ((( 8 : int):ii)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_CP14RRTTrap =>
      let ec = ((( 12 : int):ii)) in sail2_state_monad$seqS
      (sail2_state_monad$assert_expS from_32 "from_32") (sail2_state_monad$returnS (ec, il))
   | Exception_IllegalState =>
      let (ec : ii) = ((( 14 : int):ii)) in
      let (il : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_SupervisorCall =>
      let (ec : ii) = ((( 17 : int):ii)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_HypervisorCall =>
      let (ec : ii) = ((( 18 : int):ii)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_MonitorCall =>
      let (ec : ii) = ((( 19 : int):ii)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_SystemRegisterTrap =>
      let ec = ((( 24 : int):ii)) in sail2_state_monad$seqS
      (sail2_state_monad$assert_expS ((~ from_32)) "!(from_32)") (sail2_state_monad$returnS (ec, il))
   | Exception_InstructionAbort =>
      let (ec : ii) = ((( 32 : int):ii)) in
      let (il : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_PCAlignment =>
      let (ec : ii) = ((( 34 : int):ii)) in
      let (il : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_DataAbort =>
      let (ec : ii) = ((( 36 : int):ii)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_SPAlignment =>
      let ec = ((( 38 : int):ii)) in
      let il = ((vec_of_bits [B1]  :  1 words$word)) in sail2_state_monad$seqS
      (sail2_state_monad$assert_expS ((~ from_32)) "!(from_32)") (sail2_state_monad$returnS (ec, il))
   | Exception_FPTrappedException =>
      let (ec : ii) = ((( 40 : int):ii)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_SError =>
      let (ec : ii) = ((( 47 : int):ii)) in
      let (il : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_Breakpoint =>
      let (ec : ii) = ((( 48 : int):ii)) in
      let (il : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_SoftwareStep =>
      let (ec : ii) = ((( 50 : int):ii)) in
      let (il : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_Watchpoint =>
      let (ec : ii) = ((( 52 : int):ii)) in
      let (il : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_SoftwareBreakpoint =>
      let (ec : ii) = ((( 56 : int):ii)) in
      sail2_state_monad$returnS (ec, il)
   | Exception_VectorCatch =>
      let ec = ((( 58 : int):ii)) in
      let il = ((vec_of_bits [B1]  :  1 words$word)) in sail2_state_monad$seqS
      (sail2_state_monad$assert_expS from_32 "from_32") (sail2_state_monad$returnS (ec, il))
   | _ => sail2_state_monad$seqS (Unreachable () ) (sail2_state_monad$returnS (ec, il))
   ) (\ varstup .  let ((ec : ii), (il : 1 bits)) = varstup in sail2_state_monad$bindS
   (sail2_state$and_boolS
     (sail2_state_monad$returnS ((((((((ex_int ec)) = (( 32 : int):ii)))) \/ ((((((((ex_int ec)) = (( 36 : int):ii)))) \/ ((((((((ex_int ec)) = (( 48 : int):ii)))) \/ ((((((((ex_int ec)) = (( 50 : int):ii)))) \/ (((((ex_int ec)) = (( 52 : int):ii)))))))))))))))))
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__1 : ProcState) . 
      sail2_state_monad$returnS (((target_el = w__1.ProcState_EL)))))) (\ (w__2 : bool) . 
   let (ec : ii) = (if w__2 then ((ex_int ec)) + (( 1 : int):ii) else ec) in
   let (ec : ii) =
     (if (((((((((((ex_int ec)) = (( 17 : int):ii)))) \/ ((((((((ex_int ec)) = (( 18 : int):ii)))) \/ ((((((((ex_int ec)) = (( 19 : int):ii)))) \/ ((((((((ex_int ec)) = (( 40 : int):ii)))) \/ (((((ex_int ec)) = (( 56 : int):ii)))))))))))))))) /\ ((~ from_32))))) then
       ((ex_int ec)) + (( 4 : int):ii)
     else ec) in
   sail2_state_monad$returnS (ec, il))))))))`;


(*val AArch64_ReportException : ExceptionRecord -> mword ty2 -> M unit*)

val _ = Define `
 ((AArch64_ReportException:ExceptionRecord ->(2)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) exception target_el=
    (let (typ : Exception) = (exception.ExceptionRecord_typ) in sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (il : 1 bits) .  sail2_state_monad$bindS
   (undefined_int () ) (\ (ec : ii) .  sail2_state_monad$bindS
   (AArch64_ExceptionClass typ target_el  : ((ii #  1 words$word)) M) (\ varstup .  let (tup__0, tup__1) = varstup in
   let ec = tup__0 in
   let il = tup__1 in
   let (iss : 25 bits) = (exception.ExceptionRecord_syndrome) in
   let (il : 1 bits) =
     (if (((((((((((ex_int ec)) = (( 36 : int):ii)))) \/ (((((ex_int ec)) = (( 37 : int):ii))))))) /\ ((((vec_of_bits [access_vec_dec iss (( 24 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) then
       (vec_of_bits [B1]  :  1 words$word)
     else il) in sail2_state_monad$seqS (sail2_state_monad$seqS
   (aset_ESR__0 target_el
     ((concat_vec
         ((concat_vec
             ((GetSlice_int ((make_the_value (( 6 : int):ii)  :  6 itself)) ec (( 0 : int):ii)  :  6 words$word)) il
            :  7 words$word)) iss
        :  32 words$word)))
   (if ((((((typ = Exception_InstructionAbort))) \/ ((((((typ = Exception_PCAlignment))) \/ ((((((typ = Exception_DataAbort))) \/ (((typ = Exception_Watchpoint)))))))))))) then
      aset_FAR__0 target_el exception.ExceptionRecord_vaddress
    else sail2_state_monad$bindS
      (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (w__0 :  64 words$word) . 
      aset_FAR__0 target_el w__0)))
   (if (((target_el = EL2))) then
     if exception.ExceptionRecord_ipavalid then sail2_state_monad$bindS
       (sail2_state_monad$read_regS HPFAR_EL2_ref  : ( 64 words$word) M) (\ (w__1 :  64 words$word) . 
       sail2_state_monad$write_regS
         HPFAR_EL2_ref
         ((set_slice (( 64 : int):ii) (( 40 : int):ii) w__1 (( 4 : int):ii)
             ((slice exception.ExceptionRecord_ipaddress (( 12 : int):ii) (( 40 : int):ii)  :  40 words$word))
            :  64 words$word)))
     else sail2_state_monad$bindS
       (sail2_state_monad$read_regS HPFAR_EL2_ref  : ( 64 words$word) M) (\ (w__2 :  64 words$word) .  sail2_state_monad$bindS
       (undefined_bitvector (( 40 : int):ii)  : ( 40 words$word) M) (\ (w__3 :  40 words$word) . 
       sail2_state_monad$write_regS HPFAR_EL2_ref ((set_slice (( 64 : int):ii) (( 40 : int):ii) w__2 (( 4 : int):ii) w__3  :  64 words$word))))
   else sail2_state_monad$returnS () ))))))`;


(*val AArch64_ESBOperation : unit -> M unit*)

val _ = Define `
 ((AArch64_ESBOperation:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__0 : 32 bits) . 
      sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__0 (( 3 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (route_to_el3 : bool) .  sail2_state_monad$bindS
   (sail2_state$and_boolS
     (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2))) ( sail2_state_monad$bindS(IsSecure () ) (\ (w__1 : bool) .  sail2_state_monad$returnS ((~ w__1)))))
     (sail2_state$or_boolS
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__3 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__3 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__4 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__4 (( 5 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))) (\ (route_to_el2 : bool) . 
   let (target : 2 bits) = (if route_to_el3 then EL3 else if route_to_el2 then EL2 else EL1) in sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (mask_active : bool) .  sail2_state_monad$bindS
   (if (((target = EL1))) then
      sail2_state$or_boolS
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__6 : ProcState) .  sail2_state_monad$returnS (((w__6.ProcState_EL = EL0)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__7 : ProcState) .  sail2_state_monad$returnS (((w__7.ProcState_EL = EL1)))))
    else sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveVirtHostExt () )) /\ (((target = EL2)))))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__9 : 64 bits) .  sail2_state_monad$bindS
         (sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__10 : 64 bits) . 
         sail2_state_monad$returnS ((((access_vec_dec w__9 (( 34 : int):ii), access_vec_dec w__10 (( 27 : int):ii)) = (B1, B1)))))))) (\ (w__11 :
        bool) . 
      if w__11 then
        sail2_state$or_boolS
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__12 : ProcState) . 
           sail2_state_monad$returnS (((w__12.ProcState_EL = EL0)))))
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__13 : ProcState) . 
           sail2_state_monad$returnS (((w__13.ProcState_EL = EL2)))))
      else sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__15 : ProcState) . 
        let (mask_active : bool) = (w__15.ProcState_EL = target) in
        sail2_state_monad$returnS mask_active))) (\ (mask_active : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__16 : ProcState) . 
   let (mask_set : bool) = (w__16.ProcState_A = (vec_of_bits [B1]  :  1 words$word)) in sail2_state_monad$bindS
   (sail2_state$or_boolS ((Halted () )) ((ExternalDebugInterruptsDisabled target))) (\ (intdis : bool) .  sail2_state_monad$bindS
   (sail2_state$or_boolS
     (sail2_state$or_boolS
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__19 : ProcState) . 
         sail2_state_monad$returnS ((((lem$w2ui target)) < ((lem$w2ui w__19.ProcState_EL)))))) (sail2_state_monad$returnS intdis))
     (sail2_state_monad$returnS (((mask_active /\ mask_set))))) (\ (masked : bool) .  sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (DISR_EL1 : 64 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 25 : int):ii)  : ( 25 words$word) M) (\ (syndrome64 : 25 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (implicit_esb : bool) .  sail2_state_monad$bindS
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (DISR : 32 bits) .  sail2_state_monad$bindS
   (undefined_AArch32_SErrorSyndrome () ) (\ (syndrome32 : AArch32_SErrorSyndrome) .  sail2_state_monad$bindS
   (sail2_state$and_boolS ((SErrorPending () )) (sail2_state_monad$returnS masked)) (\ (w__22 : bool) . 
   if w__22 then sail2_state_monad$bindS
     (S1TranslationRegime__1 ()   : ( 2 words$word) M) (\ (w__23 :  2 words$word) .  sail2_state_monad$bindS
     (ELUsingAArch32 w__23) (\ (w__24 : bool) .  sail2_state_monad$seqS
     (if w__24 then sail2_state_monad$bindS
        (AArch32_PhysicalSErrorSyndrome () ) (\ (w__25 : AArch32_SErrorSyndrome) . 
        let syndrome32 = w__25 in sail2_state_monad$bindS
        (AArch32_ReportDeferredSError syndrome32.AArch32_SErrorSyndrome_AET
           syndrome32.AArch32_SErrorSyndrome_ExT
          : ( 32 words$word) M) (\ (w__26 : 32 bits) . 
        let (DISR : 32 bits) = w__26 in
        sail2_state_monad$returnS () ))
      else
        let implicit_esb = F in sail2_state_monad$bindS
        (AArch64_PhysicalSErrorSyndrome implicit_esb  : ( 25 words$word) M) (\ (w__27 : 25 bits) . 
        let syndrome64 = w__27 in sail2_state_monad$bindS
        (AArch64_ReportDeferredSError syndrome64  : ( 64 words$word) M) (\ (w__28 : 64 bits) . 
        let (DISR_EL1 : 64 bits) = w__28 in
        sail2_state_monad$returnS () )))
     (ClearPendingPhysicalSError () )))
   else sail2_state_monad$returnS () )))))))))))))))`;


val _ = Define `
 ((AArch64_CheckAndUpdateDescriptor:DescriptorUpdate -> FaultRecord -> bool ->(64)words$word -> AccType -> bool -> bool -> bool ->(regstate)sail2_state_monad$sequential_state ->(((FaultRecord),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) result fault secondstage vaddress acctype iswrite s2fs1walk hwupdatewalk__arg=
    (sail2_state_monad$catch_early_returnS
     ( sail2_state_monad$bindS(sail2_state_monad$liftRS ((aget_SCTLR__1 ()   : ( 32 words$word) M))) (\ (w__0 :  32 words$word) . 
      let reversedescriptors = (((access_vec_dec w__0 (( 25 : int):ii))) = B1) in
      let hwupdatewalk = hwupdatewalk__arg in sail2_state_monad$bindS
      (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (hw_update_AF : bool) . 
      let (hw_update_AF : bool) =
        (if result.DescriptorUpdate_AF then
          if (((fault.FaultRecord_typ = Fault_None))) then T
          else if (((((ConstrainUnpredictable Unpredictable_AFUPDATE)) = Constraint_TRUE))) then T
          else F
        else F) in sail2_state_monad$bindS
      (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (hw_update_AP : bool) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (write_perm_req : bool) . 
      let (hw_update_AP : bool) =
        (if (((result.DescriptorUpdate_AP /\ (((fault.FaultRecord_typ = Fault_None)))))) then
          let (write_perm_req : bool) =
            ((((iswrite \/ ((((((acctype = AccType_ATOMICRW))) \/ (((acctype = AccType_ORDEREDRW))))))))) /\ ((~ s2fs1walk))) in
          ((((write_perm_req /\ ((~ ((((((acctype = AccType_AT))) \/ (((acctype = AccType_DC))))))))))) \/ hwupdatewalk)
        else F) in sail2_state_monad$bindS
      (sail2_state_monad$liftRS ((undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M))) (\ (desc : 64 bits) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (undefined_AccessDescriptor () )) (\ (accdesc : AccessDescriptor) .  sail2_state_monad$bindS
      (sail2_state_monad$liftRS (undefined_AddressDescriptor () )) (\ (descaddr2 : AddressDescriptor) .  sail2_state_monad$seqS
      (if (((hw_update_AF \/ hw_update_AP))) then sail2_state_monad$bindS
         (sail2_state$or_boolS (sail2_state_monad$returnS secondstage)
           ( sail2_state_monad$bindS(sail2_state_monad$liftRS (HasS2Translation () )) (\ (w__1 : bool) .  sail2_state_monad$returnS ((~ w__1))))) (\ (w__2 :
           bool) .  sail2_state_monad$bindS
         (if w__2 then
            let (descaddr2 : AddressDescriptor) = (result.DescriptorUpdate_descaddr) in
            sail2_state_monad$returnS descaddr2
          else
            let hwupdatewalk = T in sail2_state_monad$bindS
            (sail2_state_monad$liftRS (AArch64_SecondStageWalk result.DescriptorUpdate_descaddr vaddress acctype iswrite
                     (( 8 : int):ii) hwupdatewalk)) (\ (w__3 : AddressDescriptor) . 
            let descaddr2 = w__3 in sail2_state_monad$seqS
            (if ((IsFault descaddr2)) then
               (sail2_state_monad$early_returnS descaddr2.AddressDescriptor_fault : (unit, FaultRecord) MR)
             else sail2_state_monad$returnS () )
            (sail2_state_monad$returnS descaddr2))) (\ (descaddr2 : AddressDescriptor) .  sail2_state_monad$bindS
         (sail2_state_monad$liftRS (CreateAccessDescriptor AccType_ATOMICRW)) (\ (w__4 : AccessDescriptor) . 
         let accdesc = w__4 in sail2_state_monad$bindS
         (sail2_state_monad$liftRS ((aget__Mem descaddr2 (( 8 : int):ii) accdesc  : ( 64 words$word) M))) (\ (w__5 : 64 bits) . 
         let desc = w__5 in sail2_state_monad$bindS
         (if reversedescriptors then sail2_state_monad$liftRS ((BigEndianReverse desc  : ( 64 words$word) M))
          else sail2_state_monad$returnS desc) (\ (desc : 64 bits) . 
         let (desc : 64 bits) =
           (if hw_update_AF then
             (set_slice (( 64 : int):ii) (( 1 : int):ii) desc (( 10 : int):ii) (vec_of_bits [B1]  :  1 words$word)  :  64 words$word)
           else desc) in
         let (desc : 64 bits) =
           (if hw_update_AP then
             (set_slice (( 64 : int):ii) (( 1 : int):ii) desc (( 7 : int):ii)
                (if secondstage then (vec_of_bits [B1]  :  1 words$word)
                 else (vec_of_bits [B0]  :  1 words$word))
               :  64 words$word)
           else desc) in sail2_state_monad$bindS
         (if reversedescriptors then sail2_state_monad$liftRS ((BigEndianReverse desc  : ( 64 words$word) M))
          else sail2_state_monad$returnS desc) (\ (desc : 64 bits) . 
         sail2_state_monad$liftRS (aset__Mem descaddr2 (( 8 : int):ii) accdesc desc)))))))
       else sail2_state_monad$returnS () )
      (sail2_state_monad$returnS fault)))))))))))`;


(*val AArch64_BreakpointValueMatch : ii -> mword ty64 -> bool -> bool*)

val _ = Define `
 ((AArch64_BreakpointValueMatch:int ->(64)words$word -> bool -> bool) n__arg vaddress linked_to=  F)`;


(*val AArch64_StateMatch : mword ty2 -> mword ty1 -> mword ty2 -> bool -> mword ty4 -> bool -> bool -> M bool*)

val _ = Define `
 ((AArch64_StateMatch:(2)words$word ->(1)words$word ->(2)words$word -> bool ->(4)words$word -> bool -> bool ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) SSC__arg HMC__arg PxC__arg linked__arg LBN isbreakpnt ispriv=
    (sail2_state_monad$catch_early_returnS
     (let HMC = HMC__arg in
     let PxC = PxC__arg in
     let SSC = SSC__arg in
     let linked = linked__arg in sail2_state_monad$bindS
     (sail2_state_monad$liftRS (undefined_Constraint () )) (\ (c : Constraint) .  sail2_state_monad$bindS
     (if ((((((((((((((((((((and_vec
                                     ((concat_vec ((concat_vec HMC SSC  :  3 words$word)) PxC
                                        :  5 words$word)) (vec_of_bits [B1;B1;B1;B0;B0]  :  5 words$word)
                                    :  5 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0]  :  5 words$word)))) \/ ((((((((and_vec
                                         ((concat_vec ((concat_vec HMC SSC  :  3 words$word)) PxC
                                            :  5 words$word))
                                         (vec_of_bits [B1;B1;B1;B0;B1]  :  5 words$word)
                                        :  5 words$word)) = (vec_of_bits [B1;B0;B0;B0;B0]  :  5 words$word)))) \/ ((((((((and_vec
                                             ((concat_vec ((concat_vec HMC SSC  :  3 words$word)) PxC
                                                :  5 words$word))
                                             (vec_of_bits [B1;B1;B1;B0;B1]  :  5 words$word)
                                            :  5 words$word)) = (vec_of_bits [B1;B0;B1;B0;B0]  :  5 words$word)))) \/ ((((((((concat_vec ((concat_vec HMC SSC  :  3 words$word)) PxC
                                                :  5 words$word)) = (vec_of_bits [B1;B1;B0;B1;B0]  :  5 words$word)))) \/ ((((((((concat_vec ((concat_vec HMC SSC  :  3 words$word))
                                                     PxC
                                                    :  5 words$word)) = (vec_of_bits [B1;B1;B1;B0;B1]  :  5 words$word)))) \/ (((((and_vec
                                                     ((concat_vec
                                                         ((concat_vec HMC SSC  :  3 words$word)) PxC
                                                        :  5 words$word))
                                                     (vec_of_bits [B1;B1;B1;B1;B0]  :  5 words$word)
                                                    :  5 words$word)) = (vec_of_bits [B1;B1;B1;B1;B0]  :  5 words$word))))))))))))))))))) \/ (((((((((HMC = (vec_of_bits [B0]  :  1 words$word)))) /\ (((PxC = (vec_of_bits [B0;B0]  :  2 words$word))))))) /\ (((((~ isbreakpnt)) \/ ((~ ((HaveAArch32EL EL1))))))))))))) \/ (((((((((SSC = (vec_of_bits [B0;B1]  :  2 words$word)))) \/ (((SSC = (vec_of_bits [B1;B0]  :  2 words$word))))))) /\ ((~ ((HaveEL EL3)))))))))) \/ ((((((((((((((concat_vec HMC SSC  :  3 words$word)) <> (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((((concat_vec HMC SSC  :  3 words$word)) <> (vec_of_bits [B1;B1;B1]  :  3 words$word))))))) /\ ((~ ((HaveEL EL3))))))) /\ ((~ ((HaveEL EL2)))))))))) \/ ((((((((concat_vec ((concat_vec HMC SSC  :  3 words$word)) PxC  :  5 words$word)) = (vec_of_bits [B1;B1;B1;B0;B0]  :  5 words$word)))) /\ ((~ ((HaveEL EL2)))))))))) then sail2_state_monad$bindS
        (sail2_state_monad$liftRS ((undefined_bitvector (( 5 : int):ii)  : ( 5 words$word) M))) (\ (tmp_50 : 5 bits) .  sail2_state_monad$bindS
        (sail2_state_monad$liftRS ((ConstrainUnpredictableBits (( 5 : int):ii) Unpredictable_RESBPWPCTRL
                 : ((Constraint #  5 words$word)) M))) (\ (w__0 : (Constraint # 5 bits)) . 
        let (tup__0, tup__1) = w__0 in
        let c = tup__0 in
        let tmp_50 = tup__1 in
        let (tmp_60 : 5 bits) = tmp_50 in
        let HMC = ((vec_of_bits [access_vec_dec tmp_60 (( 4 : int):ii)]  :  1 words$word)) in
        let (tmp_70 : 4 bits) = ((slice tmp_60 (( 0 : int):ii) (( 4 : int):ii)  :  4 words$word)) in
        let SSC = ((slice tmp_70 (( 2 : int):ii) (( 2 : int):ii)  :  2 words$word)) in
        let PxC = ((slice tmp_70 (( 0 : int):ii) (( 2 : int):ii)  :  2 words$word)) in sail2_state_monad$seqS (sail2_state_monad$seqS
        (sail2_state_monad$liftRS (sail2_state_monad$assert_expS ((((((c = Constraint_DISABLED))) \/ (((c = Constraint_UNKNOWN)))))) "((c == Constraint_DISABLED) || (c == Constraint_UNKNOWN))"))
        (if (((c = Constraint_DISABLED))) then (sail2_state_monad$early_returnS F : (unit, bool) MR)
         else sail2_state_monad$returnS () ))
        (sail2_state_monad$returnS (HMC, PxC, SSC, c))))
      else sail2_state_monad$returnS (HMC, PxC, SSC, c)) (\ varstup .  let ((HMC :  1 words$word), (PxC :  2 words$word), (SSC :
        2 words$word), (c : Constraint)) = varstup in
     let (EL3_match : bool) =
       ((((((HaveEL EL3)) /\ (((HMC = (vec_of_bits [B1]  :  1 words$word))))))) /\ ((((vec_of_bits [access_vec_dec SSC (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))) in
     let (EL2_match : bool) = (((HaveEL EL2)) /\ (((HMC = (vec_of_bits [B1]  :  1 words$word))))) in
     let (EL1_match : bool) =
       ((vec_of_bits [access_vec_dec PxC (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
     let (EL0_match : bool) =
       ((vec_of_bits [access_vec_dec PxC (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (priv_match : bool) .  sail2_state_monad$bindS
     (if (((((~ ispriv)) /\ ((~ isbreakpnt))))) then sail2_state_monad$returnS EL0_match
      else sail2_state_monad$bindS
        (sail2_state_monad$liftRS (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__1 : ProcState) . 
        let p__294 = (w__1.ProcState_EL) in
        let pat_0 = p__294 in
        let (priv_match : bool) =
          (if (((pat_0 = EL3))) then EL3_match
          else if (((pat_0 = EL2))) then EL2_match
          else if (((pat_0 = EL1))) then EL1_match
          else EL0_match) in
        sail2_state_monad$returnS priv_match)) (\ (priv_match : bool) .  sail2_state_monad$bindS
     (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (security_state_match : bool) . 
     let b__0 = SSC in sail2_state_monad$bindS
     (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$returnS T
      else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$bindS
        (sail2_state_monad$liftRS (IsSecure () )) (\ (w__2 : bool) . 
        let (security_state_match : bool) = (~ w__2) in
        sail2_state_monad$returnS security_state_match)
      else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$liftRS (IsSecure () )
      else sail2_state_monad$returnS T) (\ (security_state_match : bool) .  sail2_state_monad$bindS
     (sail2_state_monad$liftRS (undefined_int () )) (\ (last_ctx_cmp : ii) .  sail2_state_monad$bindS
     (sail2_state_monad$liftRS (undefined_int () )) (\ (first_ctx_cmp : ii) .  sail2_state_monad$bindS
     (sail2_state_monad$liftRS (undefined_int () )) (\ (lbn : ii) .  sail2_state_monad$bindS
     (if linked then
        let lbn = (lem$w2ui LBN) in sail2_state_monad$bindS
        (sail2_state_monad$liftRS ((sail2_state_monad$read_regS ID_AA64DFR0_EL1_ref  : ( 64 words$word) M))) (\ (w__4 : 64 bits) .  sail2_state_monad$bindS
        (sail2_state_monad$liftRS ((sail2_state_monad$read_regS ID_AA64DFR0_EL1_ref  : ( 64 words$word) M))) (\ (w__5 : 64 bits) . 
        let first_ctx_cmp =
          (((lem$w2ui ((slice w__4 (( 12 : int):ii) (( 4 : int):ii)  :  4 words$word)))) -
            ((lem$w2ui ((slice w__5 (( 28 : int):ii) (( 4 : int):ii)  :  4 words$word))))) in sail2_state_monad$bindS
        (sail2_state_monad$liftRS ((sail2_state_monad$read_regS ID_AA64DFR0_EL1_ref  : ( 64 words$word) M))) (\ (w__6 : 64 bits) . 
        let last_ctx_cmp = (lem$w2ui ((slice w__6 (( 12 : int):ii) (( 4 : int):ii)  :  4 words$word))) in
        if (((((((ex_int lbn)) < ((ex_int first_ctx_cmp)))) \/ ((((ex_int lbn)) > ((ex_int last_ctx_cmp))))))) then sail2_state_monad$bindS
          (sail2_state_monad$liftRS (ConstrainUnpredictableInteger first_ctx_cmp last_ctx_cmp Unpredictable_BPNOTCTXCMP)) (\ varstup .  let (tup__0, tup__1) = varstup in
          let c = tup__0 in
          let lbn = tup__1 in sail2_state_monad$bindS (sail2_state_monad$seqS
          (sail2_state_monad$liftRS (sail2_state_monad$assert_expS ((((((c = Constraint_DISABLED))) \/ ((((((c = Constraint_NONE))) \/ (((c = Constraint_UNKNOWN))))))))) "((c == Constraint_DISABLED) || ((c == Constraint_NONE) || (c == Constraint_UNKNOWN)))"))
          (case c of
            Constraint_DISABLED => sail2_state_monad$seqS (sail2_state_monad$early_returnS F : (unit, bool) MR) (sail2_state_monad$returnS linked)
          | Constraint_NONE => sail2_state_monad$returnS F
          )) (\ (linked : bool) . 
          sail2_state_monad$returnS (lbn, linked)))
        else sail2_state_monad$returnS (lbn, linked))))
      else sail2_state_monad$returnS (lbn, linked)) (\ varstup .  let ((lbn : ii), (linked : bool)) = varstup in sail2_state_monad$bindS
     (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (linked_match : bool) .  sail2_state_monad$bindS
     (sail2_state_monad$liftRS (sail2_state_monad$undefined_boolS () )) (\ (linked_to : bool) .  sail2_state_monad$bindS
     (sail2_state_monad$liftRS ((undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M))) (\ (vaddress : 64 bits) .  sail2_state_monad$bindS
     (if linked then sail2_state_monad$bindS
        (sail2_state_monad$liftRS ((undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M))) (\ (w__7 : 64 bits) . 
        let (vaddress : 64 bits) = w__7 in
        let (linked_to : bool) = T in
        let (linked_match : bool) = (AArch64_BreakpointValueMatch lbn vaddress linked_to) in
        sail2_state_monad$returnS linked_match)
      else sail2_state_monad$returnS linked_match) (\ (linked_match : bool) . 
     sail2_state_monad$returnS ((((((priv_match /\ security_state_match))) /\ (((((~ linked)) \/ linked_match)))))))))))))))))))))))`;


(*val AArch64_WatchpointMatch : ii -> mword ty64 -> ii -> bool -> bool -> M bool*)

val _ = Define `
 ((AArch64_WatchpointMatch:int ->(64)words$word -> int -> bool -> bool ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) n vaddress size1 ispriv iswrite=  (sail2_state_monad$bindS
   (S1TranslationRegime__1 ()   : ( 2 words$word) M) (\ (w__0 :  2 words$word) .  sail2_state_monad$bindS
   (ELUsingAArch32 w__0) (\ (w__1 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((~ w__1)) "!(ELUsingAArch32(S1TranslationRegime()))")
   (sail2_state_monad$read_regS ID_AA64DFR0_EL1_ref  : ( 64 words$word) M)) (\ (w__2 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((n <= ((lem$w2ui ((slice w__2 (( 20 : int):ii) (( 4 : int):ii)  :  4 words$word)))))) "(n <= UInt((ID_AA64DFR0_EL1).WRPs))")
   (sail2_state_monad$read_regS DBGWCR_EL1_ref)) (\ (w__3 : ( 32 bits) list) . 
   let (enabled : bool) =
     ((vec_of_bits [access_vec_dec ((access_list_dec w__3 n  :  32 words$word)) (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in sail2_state_monad$bindS
   (sail2_state_monad$read_regS DBGWCR_EL1_ref) (\ (w__4 : ( 32 bits) list) . 
   let (linked : bool) =
     ((vec_of_bits [access_vec_dec ((access_list_dec w__4 n  :  32 words$word)) (( 20 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
   let (isbreakpnt : bool) = F in sail2_state_monad$bindS
   (sail2_state_monad$read_regS DBGWCR_EL1_ref) (\ (w__5 : ( 32 bits) list) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS DBGWCR_EL1_ref) (\ (w__6 : ( 32 bits) list) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS DBGWCR_EL1_ref) (\ (w__7 : ( 32 bits) list) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS DBGWCR_EL1_ref) (\ (w__8 : ( 32 bits) list) .  sail2_state_monad$bindS
   (AArch64_StateMatch ((slice ((access_list_dec w__5 n  :  32 words$word)) (( 14 : int):ii) (( 2 : int):ii)  :  2 words$word))
     (vec_of_bits [access_vec_dec ((access_list_dec w__6 n  :  32 words$word)) (( 13 : int):ii)]  :  1 words$word)
     ((slice ((access_list_dec w__7 n  :  32 words$word)) (( 1 : int):ii) (( 2 : int):ii)  :  2 words$word)) linked
     ((slice ((access_list_dec w__8 n  :  32 words$word)) (( 16 : int):ii) (( 4 : int):ii)  :  4 words$word)) isbreakpnt
     ispriv) (\ (state_match : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS DBGWCR_EL1_ref) (\ (w__9 : ( 32 bits) list) . 
   let (ls_match : bool) =
     ((vec_of_bits [access_vec_dec
                       ((slice ((access_list_dec w__9 n  :  32 words$word)) (( 3 : int):ii) (( 2 : int):ii)  :  2 words$word))
                       (if iswrite then (( 1 : int):ii)
                        else (( 0 : int):ii))]
         :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
   let (value_match_name : bool) = F in sail2_state_monad$bindS
   (sail2_state$foreachS (index_list (( 0 : int):ii) ((size1 - (( 1 : int):ii))) (( 1 : int):ii)) value_match_name
     (\ byte value_match_name . 
       sail2_state$or_boolS (sail2_state_monad$returnS value_match_name)
         ((AArch64_WatchpointByteMatch n ((add_vec_int vaddress byte  :  64 words$word)))))) (\ (value_match_name :
     bool) . 
   sail2_state_monad$returnS (((((((((value_match_name /\ state_match))) /\ ls_match))) /\ enabled)))))))))))))))))`;


(*val AArch64_BreakpointMatch : ii -> mword ty64 -> ii -> M bool*)

val _ = Define `
 ((AArch64_BreakpointMatch:int ->(64)words$word -> int ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) n vaddress size1=  (sail2_state_monad$bindS
   (S1TranslationRegime__1 ()   : ( 2 words$word) M) (\ (w__0 :  2 words$word) .  sail2_state_monad$bindS
   (ELUsingAArch32 w__0) (\ (w__1 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((~ w__1)) "!(ELUsingAArch32(S1TranslationRegime()))")
   (sail2_state_monad$read_regS ID_AA64DFR0_EL1_ref  : ( 64 words$word) M)) (\ (w__2 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((n <= ((lem$w2ui ((slice w__2 (( 12 : int):ii) (( 4 : int):ii)  :  4 words$word)))))) "(n <= UInt((ID_AA64DFR0_EL1).BRPs))")
   (sail2_state_monad$read_regS DBGBCR_EL1_ref)) (\ (w__3 : ( 32 bits) list) . 
   let (enabled : bool) =
     ((vec_of_bits [access_vec_dec ((access_list_dec w__3 n  :  32 words$word)) (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__4 : ProcState) . 
   let (ispriv : bool) = (w__4.ProcState_EL <> EL0) in sail2_state_monad$bindS
   (sail2_state_monad$read_regS DBGBCR_EL1_ref) (\ (w__5 : ( 32 bits) list) . 
   let (linked : bool) =
     (((and_vec ((slice ((access_list_dec w__5 n  :  32 words$word)) (( 20 : int):ii) (( 4 : int):ii)  :  4 words$word))
           (vec_of_bits [B1;B0;B1;B1]  :  4 words$word)
          :  4 words$word)) = (vec_of_bits [B0;B0;B0;B1]  :  4 words$word)) in
   let (isbreakpnt : bool) = T in
   let (linked_to : bool) = F in sail2_state_monad$bindS
   (sail2_state_monad$read_regS DBGBCR_EL1_ref) (\ (w__6 : ( 32 bits) list) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS DBGBCR_EL1_ref) (\ (w__7 : ( 32 bits) list) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS DBGBCR_EL1_ref) (\ (w__8 : ( 32 bits) list) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS DBGBCR_EL1_ref) (\ (w__9 : ( 32 bits) list) .  sail2_state_monad$bindS
   (AArch64_StateMatch ((slice ((access_list_dec w__6 n  :  32 words$word)) (( 14 : int):ii) (( 2 : int):ii)  :  2 words$word))
     (vec_of_bits [access_vec_dec ((access_list_dec w__7 n  :  32 words$word)) (( 13 : int):ii)]  :  1 words$word)
     ((slice ((access_list_dec w__8 n  :  32 words$word)) (( 1 : int):ii) (( 2 : int):ii)  :  2 words$word)) linked
     ((slice ((access_list_dec w__9 n  :  32 words$word)) (( 16 : int):ii) (( 4 : int):ii)  :  4 words$word)) isbreakpnt
     ispriv) (\ (state_match : bool) . 
   let (value_match_name : bool) = (AArch64_BreakpointValueMatch n vaddress linked_to) in sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (match_i : bool) .  sail2_state_monad$bindS
   (if (((((HaveAnyAArch32 () )) /\ (((size1 = (( 4 : int):ii))))))) then
      let match_i =
        (AArch64_BreakpointValueMatch n ((add_vec_int vaddress (( 2 : int):ii)  :  64 words$word)) linked_to) in
      if (((((~ value_match_name)) /\ match_i))) then
        ConstrainUnpredictableBool Unpredictable_BPMATCHHALF
      else sail2_state_monad$returnS value_match_name
    else sail2_state_monad$returnS value_match_name) (\ (value_match_name : bool) .  sail2_state_monad$bindS
   (sail2_state$and_boolS
     (sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec vaddress (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS DBGBCR_EL1_ref) (\ (w__11 : ( 32 bits) list) . 
      sail2_state_monad$returnS (((((slice ((access_list_dec w__11 n  :  32 words$word)) (( 5 : int):ii) (( 4 : int):ii)  :  4 words$word)) = (vec_of_bits [B1;B1;B1;B1]  :  4 words$word))))))) (\ (w__12 : bool) .  sail2_state_monad$bindS
   (if w__12 then
      if value_match_name then ConstrainUnpredictableBool Unpredictable_BPMATCHHALF
      else sail2_state_monad$returnS value_match_name
    else sail2_state_monad$returnS value_match_name) (\ (value_match_name : bool) . 
   let (val_match : bool) = ((((value_match_name /\ state_match))) /\ enabled) in
   sail2_state_monad$returnS val_match)))))))))))))))))`;


(*val AArch64_CheckBreakpoint : mword ty64 -> ii -> M FaultRecord*)

val _ = Define `
 ((AArch64_CheckBreakpoint:(64)words$word -> int ->(regstate)sail2_state_monad$sequential_state ->(((FaultRecord),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) vaddress size1=  (sail2_state_monad$bindS
   (S1TranslationRegime__1 ()   : ( 2 words$word) M) (\ (w__0 :  2 words$word) .  sail2_state_monad$bindS
   (ELUsingAArch32 w__0) (\ (w__1 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((~ w__1)) "!(ELUsingAArch32(S1TranslationRegime()))")
   (sail2_state$or_boolS
     (sail2_state$and_boolS ((UsingAArch32 () )) (sail2_state_monad$returnS ((((((size1 = (( 2 : int):ii)))) \/ (((size1 = (( 4 : int):ii)))))))))
     (sail2_state_monad$returnS (((size1 = (( 4 : int):ii))))))) (\ (w__4 : bool) .  sail2_state_monad$seqS
   (sail2_state_monad$assert_expS w__4 "((UsingAArch32() && ((size == 2) || (size == 4))) || (size == 4))")
   (let (val_match : bool) = F in sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (match_i : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS ID_AA64DFR0_EL1_ref  : ( 64 words$word) M) (\ (w__5 : 64 bits) .  sail2_state_monad$bindS
   (sail2_state$foreachS (index_list (( 0 : int):ii) ((lem$w2ui ((slice w__5 (( 12 : int):ii) (( 4 : int):ii)  :  4 words$word)))) (( 1 : int):ii)) (match_i,
                                                                                             val_match)
     (\ i varstup .  let (match_i, val_match) = varstup in sail2_state_monad$bindS
       (AArch64_BreakpointMatch i vaddress size1) (\ (w__6 : bool) . 
       let (match_i : bool) = w__6 in
       let (val_match : bool) = (val_match \/ match_i) in
       sail2_state_monad$returnS (match_i, val_match)))) (\ varstup .  let ((match_i : bool), (val_match : bool)) = varstup in sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (iswrite : bool) .  sail2_state_monad$bindS
   (undefined_AccType () ) (\ (acctype : AccType) .  sail2_state_monad$bindS
   (undefined_bitvector (( 6 : int):ii)  : ( 6 words$word) M) (\ (reason : 6 bits) .  sail2_state_monad$bindS
   (sail2_state$and_boolS (sail2_state_monad$returnS val_match) ((HaltOnBreakpointOrWatchpoint () ))) (\ (w__8 : bool) . 
   if w__8 then
     let reason = DebugHalt_Breakpoint in sail2_state_monad$bindS (sail2_state_monad$seqS
     (Halt reason) (undefined_FaultRecord () )) (\ (w__9 : FaultRecord) .  sail2_state_monad$returnS w__9)
   else sail2_state_monad$bindS
     (sail2_state$and_boolS
       (sail2_state$and_boolS (sail2_state_monad$returnS val_match)
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS MDSCR_EL1_ref  : ( 32 words$word) M) (\ (w__10 : 32 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__10 (( 15 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) ((AArch64_GenerateDebugExceptions () ))) (\ (w__13 :
       bool) . 
     if w__13 then
       let acctype = AccType_IFETCH in
       let iswrite = F in
       AArch64_DebugFault acctype iswrite
     else AArch64_NoFault () ))))))))))))))`;


(*val AArch64_BranchAddr : mword ty64 -> M (mword ty64)*)

val _ = Define `
 ((AArch64_BranchAddr:(64)words$word ->(regstate)sail2_state_monad$sequential_state ->((((64)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) vaddress=  (sail2_state_monad$bindS
   (UsingAArch32 () ) (\ (w__0 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((~ w__0)) "!(UsingAArch32())")
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__1 : ProcState) .  sail2_state_monad$bindS
   (AddrTop vaddress T w__1.ProcState_EL) (\ (w__2 : ii) .  sail2_state_monad$bindS
   (coerce_int_nat w__2) (\ (msbit : ii) . 
   if (((((ex_nat msbit)) = (( 63 : int):ii)))) then sail2_state_monad$returnS vaddress
   else sail2_state_monad$bindS
     (sail2_state$and_boolS
       (sail2_state$or_boolS
          (sail2_state$or_boolS
             ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__3 : ProcState) . 
              sail2_state_monad$returnS (((w__3.ProcState_EL = EL0)))))
             ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__4 : ProcState) . 
              sail2_state_monad$returnS (((w__4.ProcState_EL = EL1)))))) ((IsInHost () )))
       (sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec vaddress msbit]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))) (\ (w__8 : bool) . 
     sail2_state_monad$returnS (if w__8 then
               (sext_slice (( 64 : int):ii) vaddress (( 0 : int):ii) ((((ex_nat msbit)) + (( 1 : int):ii)))
                 :  64 words$word)
             else
               (zext_slice (( 64 : int):ii) vaddress (( 0 : int):ii) ((((ex_nat msbit)) + (( 1 : int):ii)))
                 :  64 words$word)))))))))`;


(*val BranchTo : forall 'N . Size 'N => mword 'N -> BranchType -> M unit*)

val _ = Define `
 ((BranchTo:'N words$word -> BranchType ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) target branch_type=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS BranchTaken_ref T)
   (let (_ : unit) = (Hint_Branch branch_type) in
   if (((((int_of_num (words$word_len target))) = (( 32 : int):ii)))) then sail2_state_monad$bindS
     (UsingAArch32 () ) (\ (w__0 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS w__0 "UsingAArch32()")
     (ZeroExtend__1 (( 64 : int):ii) target  : ( 64 words$word) M)) (\ (w__1 : 64 bits) . 
     sail2_state_monad$write_regS PC_ref w__1))
   else sail2_state_monad$bindS
     (sail2_state$and_boolS (sail2_state_monad$returnS (((((int_of_num (words$word_len target))) = (( 64 : int):ii)))))
       ( sail2_state_monad$bindS(UsingAArch32 () ) (\ (w__2 : bool) .  sail2_state_monad$returnS ((~ w__2))))) (\ (w__3 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS w__3 "((N == 64) && !(UsingAArch32()))")
     (AArch64_BranchAddr ((slice target (( 0 : int):ii) (( 64 : int):ii)  :  64 words$word))  : ( 64 words$word) M)) (\ (w__4 : 64
       bits) . 
     sail2_state_monad$write_regS PC_ref w__4)))))`;


(*val aarch64_branch_unconditional_immediate : BranchType -> mword ty64 -> M unit*)

val _ = Define `
 ((aarch64_branch_unconditional_immediate:BranchType ->(64)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) branch_type offset=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (if (((branch_type = BranchType_CALL))) then sail2_state_monad$bindS
      (aget_PC ()   : ( 64 words$word) M) (\ (w__0 :  64 words$word) . 
      aset_X (( 30 : int):ii) ((add_vec_int w__0 (( 4 : int):ii)  :  64 words$word)))
    else sail2_state_monad$returnS () )
   (aget_PC ()   : ( 64 words$word) M)) (\ (w__1 :  64 words$word) . 
   BranchTo ((add_vec w__1 offset  :  64 words$word)) branch_type)))`;


(*val branch_unconditional_immediate_decode : mword ty1 -> mword ty26 -> M unit*)

val _ = Define `
 ((branch_unconditional_immediate_decode:(1)words$word ->(26)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) op imm26=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (branch_type : BranchType) =
     (if (((op = (vec_of_bits [B1]  :  1 words$word)))) then BranchType_CALL
     else BranchType_JMP) in sail2_state_monad$bindS
   (SignExtend__0 ((concat_vec imm26 (vec_of_bits [B0;B0]  :  2 words$word)  :  28 words$word))
      ((make_the_value (( 64 : int):ii)  :  64 itself))
     : ( 64 words$word) M) (\ (offset : 64 bits) . 
   aarch64_branch_unconditional_immediate branch_type offset))))`;


(*val aarch64_branch_conditional_test : ii -> mword ty1 -> ii -> mword ty64 -> ii -> M unit*)

val _ = Define `
 ((aarch64_branch_conditional_test:int ->(1)words$word -> int ->(64)words$word -> int ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) bit_pos bit_val l__143 offset t=
    (if (((l__143 = (( 8 : int):ii)))) then
     let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 8 : int):ii) t  : ( 8 words$word) M)) (\ (operand : 8 bits) . 
     if ((((vec_of_bits [access_vec_dec operand bit_pos]  :  1 words$word) = bit_val))) then sail2_state_monad$bindS
       (aget_PC ()   : ( 64 words$word) M) (\ (w__0 :  64 words$word) . 
       BranchTo ((add_vec w__0 offset  :  64 words$word)) BranchType_JMP)
     else sail2_state_monad$returnS () )
   else if (((l__143 = (( 16 : int):ii)))) then
     let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 16 : int):ii) t  : ( 16 words$word) M)) (\ (operand : 16 bits) . 
     if ((((vec_of_bits [access_vec_dec operand bit_pos]  :  1 words$word) = bit_val))) then sail2_state_monad$bindS
       (aget_PC ()   : ( 64 words$word) M) (\ (w__1 :  64 words$word) . 
       BranchTo ((add_vec w__1 offset  :  64 words$word)) BranchType_JMP)
     else sail2_state_monad$returnS () )
   else if (((l__143 = (( 32 : int):ii)))) then
     let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 32 : int):ii) t  : ( 32 words$word) M)) (\ (operand : 32 bits) . 
     if ((((vec_of_bits [access_vec_dec operand bit_pos]  :  1 words$word) = bit_val))) then sail2_state_monad$bindS
       (aget_PC ()   : ( 64 words$word) M) (\ (w__2 :  64 words$word) . 
       BranchTo ((add_vec w__2 offset  :  64 words$word)) BranchType_JMP)
     else sail2_state_monad$returnS () )
   else if (((l__143 = (( 64 : int):ii)))) then
     let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 64 : int):ii) t  : ( 64 words$word) M)) (\ (operand : 64 bits) . 
     if ((((vec_of_bits [access_vec_dec operand bit_pos]  :  1 words$word) = bit_val))) then sail2_state_monad$bindS
       (aget_PC ()   : ( 64 words$word) M) (\ (w__3 :  64 words$word) . 
       BranchTo ((add_vec w__3 offset  :  64 words$word)) BranchType_JMP)
     else sail2_state_monad$returnS () )
   else if (((l__143 = (( 128 : int):ii)))) then
     let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 128 : int):ii) t  : ( 128 words$word) M)) (\ (operand : 128 bits) . 
     if ((((vec_of_bits [access_vec_dec operand bit_pos]  :  1 words$word) = bit_val))) then sail2_state_monad$bindS
       (aget_PC ()   : ( 64 words$word) M) (\ (w__4 :  64 words$word) . 
       BranchTo ((add_vec w__4 offset  :  64 words$word)) BranchType_JMP)
     else sail2_state_monad$returnS () )
   else
     let dbytes = (ex_int ((l__143 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint"))`;


(*val branch_conditional_test_decode : mword ty1 -> mword ty1 -> mword ty5 -> mword ty14 -> mword ty5 -> M unit*)

val _ = Define `
 ((branch_conditional_test_decode:(1)words$word ->(1)words$word ->(5)words$word ->(14)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b5 op b40 imm14 Rt=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (t : ii) = (lem$w2ui Rt) in
   let (datasize : int) =
     (if (((b5 = (vec_of_bits [B1]  :  1 words$word)))) then (( 64 : int):ii)
     else (( 32 : int):ii)) in
   let (bit_pos : ii) = (lem$w2ui ((concat_vec b5 b40  :  6 words$word))) in
   let (bit_val : 1 bits) = op in sail2_state_monad$bindS
   (SignExtend__0 ((concat_vec imm14 (vec_of_bits [B0;B0]  :  2 words$word)  :  16 words$word))
      ((make_the_value (( 64 : int):ii)  :  64 itself))
     : ( 64 words$word) M) (\ (offset : 64 bits) . 
   aarch64_branch_conditional_test bit_pos bit_val datasize offset t))))`;


(*val aarch64_branch_conditional_cond : mword ty4 -> mword ty64 -> M unit*)

val _ = Define `
 ((aarch64_branch_conditional_cond:(4)words$word ->(64)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) condition offset=  (sail2_state_monad$bindS
   (ConditionHolds condition) (\ (w__0 : bool) . 
   if w__0 then sail2_state_monad$bindS
     (aget_PC ()   : ( 64 words$word) M) (\ (w__1 :  64 words$word) . 
     BranchTo ((add_vec w__1 offset  :  64 words$word)) BranchType_JMP)
   else sail2_state_monad$returnS () )))`;


(*val branch_conditional_cond_decode : mword ty1 -> mword ty19 -> mword ty1 -> mword ty4 -> M unit*)

val _ = Define `
 ((branch_conditional_cond_decode:(1)words$word ->(19)words$word ->(1)words$word ->(4)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) o1 imm19 o0 cond=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (SignExtend__0 ((concat_vec imm19 (vec_of_bits [B0;B0]  :  2 words$word)  :  21 words$word))
      ((make_the_value (( 64 : int):ii)  :  64 itself))
     : ( 64 words$word) M)) (\ (offset : 64 bits) . 
   let (condition : 4 bits) = cond in
   aarch64_branch_conditional_cond condition offset)))`;


(*val aarch64_branch_conditional_compare : ii -> bool -> mword ty64 -> ii -> M unit*)

val _ = Define `
 ((aarch64_branch_conditional_compare:int -> bool ->(64)words$word -> int ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) l__138 iszero offset t=
    (if (((l__138 = (( 8 : int):ii)))) then
     let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 8 : int):ii) t  : ( 8 words$word) M)) (\ (operand1 : 8 bits) . 
     if (((((IsZero operand1)) = iszero))) then sail2_state_monad$bindS
       (aget_PC ()   : ( 64 words$word) M) (\ (w__0 :  64 words$word) . 
       BranchTo ((add_vec w__0 offset  :  64 words$word)) BranchType_JMP)
     else sail2_state_monad$returnS () )
   else if (((l__138 = (( 16 : int):ii)))) then
     let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 16 : int):ii) t  : ( 16 words$word) M)) (\ (operand1 : 16 bits) . 
     if (((((IsZero operand1)) = iszero))) then sail2_state_monad$bindS
       (aget_PC ()   : ( 64 words$word) M) (\ (w__1 :  64 words$word) . 
       BranchTo ((add_vec w__1 offset  :  64 words$word)) BranchType_JMP)
     else sail2_state_monad$returnS () )
   else if (((l__138 = (( 32 : int):ii)))) then
     let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 32 : int):ii) t  : ( 32 words$word) M)) (\ (operand1 : 32 bits) . 
     if (((((IsZero operand1)) = iszero))) then sail2_state_monad$bindS
       (aget_PC ()   : ( 64 words$word) M) (\ (w__2 :  64 words$word) . 
       BranchTo ((add_vec w__2 offset  :  64 words$word)) BranchType_JMP)
     else sail2_state_monad$returnS () )
   else if (((l__138 = (( 64 : int):ii)))) then
     let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 64 : int):ii) t  : ( 64 words$word) M)) (\ (operand1 : 64 bits) . 
     if (((((IsZero operand1)) = iszero))) then sail2_state_monad$bindS
       (aget_PC ()   : ( 64 words$word) M) (\ (w__3 :  64 words$word) . 
       BranchTo ((add_vec w__3 offset  :  64 words$word)) BranchType_JMP)
     else sail2_state_monad$returnS () )
   else if (((l__138 = (( 128 : int):ii)))) then
     let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (aget_X (( 128 : int):ii) t  : ( 128 words$word) M)) (\ (operand1 : 128 bits) . 
     if (((((IsZero operand1)) = iszero))) then sail2_state_monad$bindS
       (aget_PC ()   : ( 64 words$word) M) (\ (w__4 :  64 words$word) . 
       BranchTo ((add_vec w__4 offset  :  64 words$word)) BranchType_JMP)
     else sail2_state_monad$returnS () )
   else
     let dbytes = (ex_int ((l__138 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint"))`;


(*val branch_conditional_compare_decode : mword ty1 -> mword ty1 -> mword ty19 -> mword ty5 -> M unit*)

val _ = Define `
 ((branch_conditional_compare_decode:(1)words$word ->(1)words$word ->(19)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) sf op imm19 Rt=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (t : ii) = (lem$w2ui Rt) in
   let (datasize : int) =
     (if (((sf = (vec_of_bits [B1]  :  1 words$word)))) then (( 64 : int):ii)
     else (( 32 : int):ii)) in
   let (iszero : bool) = (op = (vec_of_bits [B0]  :  1 words$word)) in sail2_state_monad$bindS
   (SignExtend__0 ((concat_vec imm19 (vec_of_bits [B0;B0]  :  2 words$word)  :  21 words$word))
      ((make_the_value (( 64 : int):ii)  :  64 itself))
     : ( 64 words$word) M) (\ (offset : 64 bits) . 
   aarch64_branch_conditional_compare datasize iszero offset t))))`;


(*val AArch64_TakeReset : bool -> M unit*)

val _ = Define `
 ((AArch64_TakeReset:bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) cold_reset=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((~ ((HighestELUsingAArch32 () )))) "!(HighestELUsingAArch32())")
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__0 : ProcState) .  sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__0 with<| ProcState_nRW := ((vec_of_bits [B0]  :  1 words$word))|>))
   (if ((HaveEL EL3)) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__1 : ProcState) . 
      sail2_state_monad$write_regS PSTATE_ref (w__1 with<| ProcState_EL := EL3|>))
    else if ((HaveEL EL2)) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) . 
      sail2_state_monad$write_regS PSTATE_ref (w__2 with<| ProcState_EL := EL2|>))
    else sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__3 : ProcState) . 
      sail2_state_monad$write_regS PSTATE_ref (w__3 with<| ProcState_EL := EL1|>))))
   (let (_ : unit) = (AArch64_ResetControlRegisters cold_reset) in sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__4 : ProcState) .  sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__4 with<| ProcState_SP := ((vec_of_bits [B1]  :  1 words$word))|>))
   (let split_vec = ((vec_of_bits [B1;B1;B1;B1]  :  4 words$word)) in
   let (tup__0, tup__1, tup__2, tup__3) =
     ((subrange_vec_dec split_vec (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
      (subrange_vec_dec split_vec (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
      (subrange_vec_dec split_vec (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
      (subrange_vec_dec split_vec (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__5 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__5 with<| ProcState_D := tup__0|>))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__6 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__6 with<| ProcState_A := tup__1|>))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__7 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__7 with<| ProcState_I := tup__2|>))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__8 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__8 with<| ProcState_F := tup__3|>))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__9 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__9 with<| ProcState_SS := ((vec_of_bits [B0]  :  1 words$word))|>))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__10 : ProcState) .  sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__10 with<| ProcState_IL := ((vec_of_bits [B0]  :  1 words$word))|>))
   (AArch64_ResetGeneralRegisters () ))
   (AArch64_ResetSIMDFPRegisters () ))
   (AArch64_ResetSpecialRegisters () ))
   (let (_ : unit) = (ResetExternalDebugRegisters cold_reset) in sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (rv : 64 bits) .  sail2_state_monad$bindS
   (if ((HaveEL EL3)) then (sail2_state_monad$read_regS RVBAR_EL3_ref  : ( 64 words$word) M)
    else if ((HaveEL EL2)) then (sail2_state_monad$read_regS RVBAR_EL2_ref  : ( 64 words$word) M)
    else (sail2_state_monad$read_regS RVBAR_EL1_ref  : ( 64 words$word) M)) (\ (rv : 64 bits) .  sail2_state_monad$bindS
   (sail2_state$and_boolS ((IsZero_slice rv ((PAMax () )) (((( 64 : int):ii) - ((ex_int ((PAMax () ))))))))
     ((IsZero_slice rv (( 0 : int):ii) (( 2 : int):ii)))) (\ (w__16 : bool) .  sail2_state_monad$seqS
   (sail2_state_monad$assert_expS w__16 "(IsZero((rv)<PAMax()+:((63 - PAMax()) + 1)>) && IsZero((rv)<0+:((1 - 0) + 1)>))")
   (BranchTo rv BranchType_UNKNOWN)))))))))))))))))`;


(*val __TakeColdReset : unit -> M unit*)

val _ = Define `
 ((TakeColdReset:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__0 with<| ProcState_nRW := ((vec_of_bits [B0]  :  1 words$word))|>))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__1 : ProcState) .  sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__1 with<| ProcState_SS := ((vec_of_bits [B0]  :  1 words$word))|>))
   (ResetInterruptState () ))
   (ResetMemoryState () )) (ResetExecuteState () )) (AArch64_TakeReset T)))))`;


(*val AArch64_TakeException : mword ty2 -> ExceptionRecord -> mword ty64 -> ii -> M unit*)

val _ = Define `
 ((AArch64_TakeException:(2)words$word -> ExceptionRecord ->(64)words$word -> int ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) target_el exception preferred_exception_return vect_offset__arg=
    (let (vect_offset : ii) = vect_offset__arg in
   let (_ : unit) = (SynchronizeContext () ) in sail2_state_monad$bindS
   (sail2_state$and_boolS
     (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL target_el)))
        ( sail2_state_monad$bindS(ELUsingAArch32 target_el) (\ (w__0 : bool) .  sail2_state_monad$returnS ((~ w__0)))))
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) . 
      sail2_state_monad$returnS ((((lem$w2ui target_el)) >= ((lem$w2ui w__2.ProcState_EL))))))) (\ (w__3 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS w__3 "((HaveEL(target_el) && !(ELUsingAArch32(target_el))) && (UInt(target_el) >= UInt((PSTATE).EL)))")
   (UsingAArch32 () )) (\ (from_32 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (if from_32 then AArch64_MaybeZeroRegisterUppers () 
    else sail2_state_monad$returnS () )
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__4 : ProcState) .  sail2_state_monad$bindS
   (if ((((lem$w2ui target_el)) > ((lem$w2ui w__4.ProcState_EL)))) then sail2_state_monad$bindS
      (sail2_state_monad$undefined_boolS () ) (\ (lower_32 : bool) .  sail2_state_monad$bindS
      (if (((target_el = EL3))) then sail2_state_monad$bindS
         (sail2_state$and_boolS ( sail2_state_monad$bindS(IsSecure () ) (\ (w__5 : bool) .  sail2_state_monad$returnS ((~ w__5))))
           (sail2_state_monad$returnS ((HaveEL EL2)))) (\ (w__6 : bool) . 
         if w__6 then ELUsingAArch32 EL2
         else ELUsingAArch32 EL1)
       else sail2_state_monad$bindS
         (sail2_state$and_boolS
           (sail2_state$and_boolS ((IsInHost () ))
              ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__10 : ProcState) . 
               sail2_state_monad$returnS (((w__10.ProcState_EL = EL0)))))) (sail2_state_monad$returnS (((target_el = EL2))))) (\ (w__12 :
           bool) . 
         if w__12 then ELUsingAArch32 EL0
         else ELUsingAArch32 ((sub_vec_int target_el (( 1 : int):ii)  :  2 words$word)))) (\ (lower_32 : bool) . 
      let (vect_offset : ii) = (vect_offset + (if lower_32 then (( 1536 : int):ii) else (( 1024 : int):ii))) in
      sail2_state_monad$returnS vect_offset))
    else sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__15 : ProcState) . 
      let (vect_offset : ii) =
        (if (((w__15.ProcState_SP = (vec_of_bits [B1]  :  1 words$word)))) then
          ((ex_int vect_offset)) + (( 512 : int):ii)
        else vect_offset) in
      sail2_state_monad$returnS vect_offset)) (\ (vect_offset : ii) .  sail2_state_monad$bindS
   (GetPSRFromPSTATE ()   : ( 32 words$word) M) (\ (spsr : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (if ((HaveUAOExt () )) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__16 : ProcState) . 
      sail2_state_monad$write_regS PSTATE_ref (w__16 with<| ProcState_UAO := ((vec_of_bits [B0]  :  1 words$word))|>))
    else sail2_state_monad$returnS () )
   (if ((~ ((((((exception.ExceptionRecord_typ = Exception_IRQ))) \/ (((exception.ExceptionRecord_typ = Exception_FIQ)))))))) then
      AArch64_ReportException exception target_el
    else sail2_state_monad$returnS () ))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__17 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__17 with<| ProcState_EL := target_el|>))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__18 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__18 with<| ProcState_nRW := ((vec_of_bits [B0]  :  1 words$word))|>))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__19 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__19 with<| ProcState_SP := ((vec_of_bits [B1]  :  1 words$word))|>))
   (aset_SPSR spsr))
   (aset_ELR__1 preferred_exception_return))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__20 : ProcState) .  sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__20 with<| ProcState_SS := ((vec_of_bits [B0]  :  1 words$word))|>))
   (let split_vec = ((vec_of_bits [B1;B1;B1;B1]  :  4 words$word)) in
   let (tup__0, tup__1, tup__2, tup__3) =
     ((subrange_vec_dec split_vec (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
      (subrange_vec_dec split_vec (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
      (subrange_vec_dec split_vec (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
      (subrange_vec_dec split_vec (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__21 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__21 with<| ProcState_D := tup__0|>))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__22 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__22 with<| ProcState_A := tup__1|>))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__23 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__23 with<| ProcState_I := tup__2|>))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__24 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__24 with<| ProcState_F := tup__3|>))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__25 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__25 with<| ProcState_IL := ((vec_of_bits [B0]  :  1 words$word))|>))
   (if from_32 then sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__26 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS
        PSTATE_ref
        (w__26 with<| ProcState_IT := ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0]  :  8 words$word))|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__27 : ProcState) . 
      sail2_state_monad$write_regS PSTATE_ref (w__27 with<| ProcState_T := ((vec_of_bits [B0]  :  1 words$word))|>)))
    else sail2_state_monad$returnS () ))
   (sail2_state$and_boolS
     (sail2_state$and_boolS (sail2_state_monad$returnS ((HavePANExt () )))
        (sail2_state$or_boolS
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__28 : ProcState) . 
            sail2_state_monad$returnS (((w__28.ProcState_EL = EL1)))))
           (sail2_state$and_boolS
              ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__29 : ProcState) . 
               sail2_state_monad$returnS (((w__29.ProcState_EL = EL2))))) ((ELIsInHost EL0)))))
     ( sail2_state_monad$bindS(aget_SCTLR__1 ()   : ( 32 words$word) M) (\ (w__34 :  32 words$word) . 
      sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__34 (( 23 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))))))) (\ (w__35 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (if w__35 then sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__36 : ProcState) . 
      sail2_state_monad$write_regS PSTATE_ref (w__36 with<| ProcState_PAN := ((vec_of_bits [B1]  :  1 words$word))|>))
    else sail2_state_monad$returnS () )
   (aget_VBAR__1 ()   : ( 64 words$word) M)) (\ (w__37 :  64 words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (BranchTo
     ((concat_vec ((slice w__37 (( 11 : int):ii) (( 53 : int):ii)  :  53 words$word))
         ((GetSlice_int ((make_the_value (( 11 : int):ii)  :  11 itself)) vect_offset (( 0 : int):ii)  :  11 words$word))
        :  64 words$word)) BranchType_EXCEPTION)
   (sail2_state_monad$undefined_boolS () )) (\ (iesb_req : bool) .  sail2_state_monad$bindS
   (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveRASExt () )))
     ( sail2_state_monad$bindS(aget_SCTLR__1 ()   : ( 32 words$word) M) (\ (w__38 :  32 words$word) . 
      sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__38 (( 21 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__39 : bool) .  sail2_state_monad$seqS
   (if w__39 then
      let (_ : unit) = (ErrorSynchronizationBarrier MBReqDomain_FullSystem MBReqTypes_All) in
      let iesb_req = T in
      TakeUnmaskedPhysicalSErrorInterrupts iesb_req
    else sail2_state_monad$returnS () )
   (EndOfInstruction () ))))))))))))))))))))))`;


(*val TrapPACUse : mword ty2 -> M unit*)

val _ = Define `
 ((TrapPACUse:(2)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) target_el=  (sail2_state_monad$bindS
   (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveEL target_el)) /\ (((target_el <> EL0)))))))
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) . 
      sail2_state_monad$returnS ((((lem$w2ui target_el)) >= ((lem$w2ui w__0.ProcState_EL))))))) (\ (w__1 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS w__1 "((HaveEL(target_el) && (target_el != EL0)) && (UInt(target_el) >= UInt((PSTATE).EL)))")
   (ThisInstrAddr (( 64 : int):ii) ()   : ( 64 words$word) M)) (\ (preferred_exception_return : 64 bits) .  sail2_state_monad$bindS
   (undefined_ExceptionRecord () ) (\ (exception : ExceptionRecord) . 
   let (vect_offset : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
   (ExceptionSyndrome Exception_PACTrap) (\ (w__2 : ExceptionRecord) . 
   let exception = w__2 in
   AArch64_TakeException target_el exception preferred_exception_return vect_offset))))))`;


(*val Strip : mword ty64 -> bool -> M (mword ty64)*)

val _ = Define `
 ((Strip:(64)words$word -> bool ->(regstate)sail2_state_monad$sequential_state ->((((64)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) A data=  (sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (TrapEL2 : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (TrapEL3 : bool) .  sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (original_ptr : 64 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (extfield : 64 bits) .  sail2_state_monad$bindS
   (CalculateTBI A data) (\ (tbi : bool) .  sail2_state_monad$bindS
   (CalculateBottomPACBit A (vec_of_bits [access_vec_dec A (( 55 : int):ii)]  :  1 words$word)) (\ (w__0 : ii) . 
   let bottom_PAC_bit = (ex_int w__0) in sail2_state_monad$seqS
   (sail2_state_monad$assert_expS T "")
   (let extfield =
     ((replicate_bits (vec_of_bits [access_vec_dec A (( 55 : int):ii)]  :  1 words$word) (( 64 : int):ii)  :  64 words$word)) in
   let (original_ptr : 64 bits) =
     (if tbi then
       (concat_vec ((slice A (( 56 : int):ii) (( 8 : int):ii)  :  8 words$word))
          ((slice_slice_concat (( 56 : int):ii) extfield (( 0 : int):ii)
              ((((~ bottom_PAC_bit)) + (( 56 : int):ii))) A (( 0 : int):ii) bottom_PAC_bit
             :  56 words$word))
         :  64 words$word)
     else
       (slice_slice_concat (( 64 : int):ii) extfield (( 0 : int):ii)
          ((((~ bottom_PAC_bit)) + (( 64 : int):ii))) A (( 0 : int):ii) bottom_PAC_bit
         :  64 words$word)) in sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__1 : ProcState) . 
   let p__293 = (w__1.ProcState_EL) in
   let pat_0 = p__293 in sail2_state_monad$bindS
   (if (((pat_0 = EL0))) then sail2_state_monad$bindS
      (sail2_state$or_boolS
        (sail2_state$or_boolS (sail2_state_monad$returnS ((~ ((HaveEL EL2)))))
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__2 : 64 bits) . 
            sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__2 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__4 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__4 (( 34 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (IsEL1Regime : bool) .  sail2_state_monad$bindS
      (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveEL EL2)) /\ IsEL1Regime))))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__5 : bool) .  sail2_state_monad$returnS ((~ w__5)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__7 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__7 (( 41 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__8 : bool) . 
      let TrapEL2 = w__8 in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__9 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__9 (( 17 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__10 : bool) . 
      let (TrapEL3 : bool) = w__10 in
      sail2_state_monad$returnS (TrapEL2, TrapEL3))))
    else if (((pat_0 = EL1))) then sail2_state_monad$bindS
      (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__11 : bool) .  sail2_state_monad$returnS ((~ w__11)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__13 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__13 (( 41 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__14 : bool) . 
      let TrapEL2 = w__14 in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__15 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__15 (( 17 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__16 : bool) . 
      let (TrapEL3 : bool) = w__16 in
      sail2_state_monad$returnS (TrapEL2, TrapEL3)))
    else if (((pat_0 = EL2))) then
      let TrapEL2 = F in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__17 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__17 (( 17 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__18 : bool) . 
      let (TrapEL3 : bool) = w__18 in
      sail2_state_monad$returnS (TrapEL2, TrapEL3))
    else
      let (TrapEL2 : bool) = F in
      let (TrapEL3 : bool) = F in
      sail2_state_monad$returnS (TrapEL2, TrapEL3)) (\ varstup .  let ((TrapEL2 : bool), (TrapEL3 : bool)) = varstup in
   if TrapEL2 then sail2_state_monad$seqS (TrapPACUse EL2) (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
   else if TrapEL3 then sail2_state_monad$seqS (TrapPACUse EL3) (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
   else sail2_state_monad$returnS original_ptr)))))))))))`;


(*val aarch64_integer_pac_strip_dp_1src : ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_integer_pac_strip_dp_1src:int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d data=
    (if ((HavePACExt () )) then sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) d  : ( 64 words$word) M) (\ (w__0 :  64 words$word) .  sail2_state_monad$bindS
     (Strip w__0 data  : ( 64 words$word) M) (\ (w__1 :  64 words$word) .  aset_X d w__1))
   else sail2_state_monad$returnS () ))`;


(*val integer_pac_strip_hint_decode : mword ty1 -> mword ty2 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty3 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_pac_strip_hint_decode:(1)words$word ->(2)words$word ->(3)words$word ->(4)words$word ->(4)words$word ->(3)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) L op0 op1 CRn CRm op2 Rt=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (d : ii) = ((( 30 : int):ii)) in
   let (data : bool) = F in
   aarch64_integer_pac_strip_dp_1src d data)))`;


(*val AuthIB : mword ty64 -> mword ty64 -> M (mword ty64)*)

val _ = Define `
 ((AuthIB:(64)words$word ->(64)words$word ->(regstate)sail2_state_monad$sequential_state ->((((64)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) X Y=  (sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (TrapEL2 : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (TrapEL3 : bool) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (Enable : 1 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS APIBKeyHi_EL1_ref  : ( 64 words$word) M) (\ (w__0 : 64 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS APIBKeyLo_EL1_ref  : ( 64 words$word) M) (\ (w__1 : 64 bits) . 
   let (APIBKey_EL1 : 128 bits) =
     ((concat_vec ((slice w__0 (( 0 : int):ii) (( 64 : int):ii)  :  64 words$word))
        ((slice w__1 (( 0 : int):ii) (( 64 : int):ii)  :  64 words$word))
       :  128 words$word)) in sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) . 
   let p__292 = (w__2.ProcState_EL) in
   let pat_0 = p__292 in sail2_state_monad$bindS
   (if (((pat_0 = EL0))) then sail2_state_monad$bindS
      (sail2_state$or_boolS
        (sail2_state$or_boolS (sail2_state_monad$returnS ((~ ((HaveEL EL2)))))
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__3 : 64 bits) . 
            sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__3 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__5 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__5 (( 34 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (IsEL1Regime : bool) .  sail2_state_monad$bindS
      (if IsEL1Regime then sail2_state_monad$bindS
         (sail2_state_monad$read_regS SCTLR_EL1_ref  : ( 32 words$word) M) (\ (w__6 : 32 bits) . 
         sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__6 (( 30 : int):ii)]  :  1 words$word))
       else sail2_state_monad$bindS
         (sail2_state_monad$read_regS SCTLR_EL2_ref  : ( 32 words$word) M) (\ (w__7 : 32 bits) . 
         sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__7 (( 30 : int):ii)]  :  1 words$word))) (\ (w__8 :  1 words$word) . 
      let Enable = w__8 in sail2_state_monad$bindS
      (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveEL EL2)) /\ IsEL1Regime))))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__9 : bool) .  sail2_state_monad$returnS ((~ w__9)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__11 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__11 (( 41 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__12 : bool) . 
      let TrapEL2 = w__12 in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__13 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__13 (( 17 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__14 : bool) . 
      let (TrapEL3 : bool) = w__14 in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3)))))
    else if (((pat_0 = EL1))) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS SCTLR_EL1_ref  : ( 32 words$word) M) (\ (w__15 : 32 bits) . 
      let Enable = ((vec_of_bits [access_vec_dec w__15 (( 30 : int):ii)]  :  1 words$word)) in sail2_state_monad$bindS
      (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__16 : bool) .  sail2_state_monad$returnS ((~ w__16)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__18 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__18 (( 41 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__19 : bool) . 
      let TrapEL2 = w__19 in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__20 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__20 (( 17 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__21 : bool) . 
      let (TrapEL3 : bool) = w__21 in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3))))
    else if (((pat_0 = EL2))) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS SCTLR_EL2_ref  : ( 32 words$word) M) (\ (w__22 : 32 bits) . 
      let Enable = ((vec_of_bits [access_vec_dec w__22 (( 30 : int):ii)]  :  1 words$word)) in
      let TrapEL2 = F in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__23 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__23 (( 17 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__24 : bool) . 
      let (TrapEL3 : bool) = w__24 in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3)))
    else sail2_state_monad$bindS
      (sail2_state_monad$read_regS SCTLR_EL3_ref  : ( 32 words$word) M) (\ (w__25 : 32 bits) . 
      let (Enable : 1 bits) = ((vec_of_bits [access_vec_dec w__25 (( 30 : int):ii)]  :  1 words$word)) in
      let (TrapEL2 : bool) = F in
      let (TrapEL3 : bool) = F in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3))) (\ varstup .  let ((Enable : 1 bits), (TrapEL2 :
     bool), (TrapEL3 : bool)) = varstup in
   if (((Enable = (vec_of_bits [B0]  :  1 words$word)))) then sail2_state_monad$returnS X
   else if TrapEL2 then sail2_state_monad$seqS (TrapPACUse EL2) (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
   else if TrapEL3 then sail2_state_monad$seqS (TrapPACUse EL3) (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
   else (Auth X Y APIBKey_EL1 F (vec_of_bits [B1]  :  1 words$word)  : ( 64 words$word) M))))))))))`;


(*val aarch64_integer_pac_autib_dp_1src : ii -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_integer_pac_autib_dp_1src:int -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d n source_is_sp=
    (if ((HavePACExt () )) then
     if source_is_sp then sail2_state_monad$bindS
       (aget_X (( 64 : int):ii) d  : ( 64 words$word) M) (\ (w__0 :  64 words$word) .  sail2_state_monad$bindS
       (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M) (\ (w__1 :  64 words$word) .  sail2_state_monad$bindS
       (AuthIB w__0 w__1  : ( 64 words$word) M) (\ (w__2 :  64 words$word) .  aset_X d w__2)))
     else sail2_state_monad$bindS
       (aget_X (( 64 : int):ii) d  : ( 64 words$word) M) (\ (w__3 :  64 words$word) .  sail2_state_monad$bindS
       (aget_X (( 64 : int):ii) n  : ( 64 words$word) M) (\ (w__4 :  64 words$word) .  sail2_state_monad$bindS
       (AuthIB w__3 w__4  : ( 64 words$word) M) (\ (w__5 :  64 words$word) .  aset_X d w__5)))
   else sail2_state_monad$returnS () ))`;


(*val integer_pac_autib_hint_decode : mword ty1 -> mword ty2 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty3 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_pac_autib_hint_decode:(1)words$word ->(2)words$word ->(3)words$word ->(4)words$word ->(4)words$word ->(3)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) L op0 op1 CRn CRm op2 Rt=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (undefined_int () )) (\ (d : ii) .  sail2_state_monad$bindS
   (undefined_int () ) (\ (n : ii) . 
   let (source_is_sp : bool) = F in
   let b__0 = ((concat_vec CRm op2  :  7 words$word)) in sail2_state_monad$bindS
   (if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B1;B1;B0]  :  7 words$word)))) then
      let (d : ii) = ((( 30 : int):ii)) in
      let (n : ii) = ((( 31 : int):ii)) in
      sail2_state_monad$returnS (d, n, source_is_sp)
    else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B1;B1;B1]  :  7 words$word)))) then
      let (d : ii) = ((( 30 : int):ii)) in
      let (source_is_sp : bool) = T in
      sail2_state_monad$returnS (d, n, source_is_sp)
    else sail2_state_monad$bindS
      (if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B1;B1;B0]  :  7 words$word)))) then
         let (d : ii) = ((( 17 : int):ii)) in
         let (n : ii) = ((( 16 : int):ii)) in
         sail2_state_monad$returnS (d, n)
       else sail2_state_monad$seqS
         (if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0]  :  7 words$word)))) then
            sail2_state_monad$throwS (Error_See "PACIA")
          else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0]  :  7 words$word)))) then
            sail2_state_monad$throwS (Error_See "PACIB")
          else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B1;B0;B0]  :  7 words$word)))) then
            sail2_state_monad$throwS (Error_See "AUTIA")
          else if (((((subrange_vec_dec b__0 (( 6 : int):ii) (( 1 : int):ii)  :  6 words$word)) = (vec_of_bits [B0;B0;B1;B1;B0;B0]  :  6 words$word)))) then
            sail2_state_monad$throwS (Error_See "PACIA")
          else if (((((subrange_vec_dec b__0 (( 6 : int):ii) (( 1 : int):ii)  :  6 words$word)) = (vec_of_bits [B0;B0;B1;B1;B0;B1]  :  6 words$word)))) then
            sail2_state_monad$throwS (Error_See "PACIB")
          else if (((((subrange_vec_dec b__0 (( 6 : int):ii) (( 1 : int):ii)  :  6 words$word)) = (vec_of_bits [B0;B0;B1;B1;B1;B0]  :  6 words$word)))) then
            sail2_state_monad$throwS (Error_See "AUTIA")
          else sail2_state_monad$throwS (Error_See "XPACLRI"))
         (sail2_state_monad$returnS (d, n))) (\ varstup .  let ((d : ii), (n : ii)) = varstup in
      sail2_state_monad$returnS (d, n, source_is_sp))) (\ varstup .  let ((d : ii), (n : ii), (source_is_sp : bool)) = varstup in
   aarch64_integer_pac_autib_dp_1src d n source_is_sp)))))`;


(*val AuthIA : mword ty64 -> mword ty64 -> M (mword ty64)*)

val _ = Define `
 ((AuthIA:(64)words$word ->(64)words$word ->(regstate)sail2_state_monad$sequential_state ->((((64)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) X Y=  (sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (TrapEL2 : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (TrapEL3 : bool) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (Enable : 1 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS APIAKeyHi_EL1_ref  : ( 64 words$word) M) (\ (w__0 : 64 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS APIAKeyLo_EL1_ref  : ( 64 words$word) M) (\ (w__1 : 64 bits) . 
   let (APIAKey_EL1 : 128 bits) =
     ((concat_vec ((slice w__0 (( 0 : int):ii) (( 64 : int):ii)  :  64 words$word))
        ((slice w__1 (( 0 : int):ii) (( 64 : int):ii)  :  64 words$word))
       :  128 words$word)) in sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) . 
   let p__291 = (w__2.ProcState_EL) in
   let pat_0 = p__291 in sail2_state_monad$bindS
   (if (((pat_0 = EL0))) then sail2_state_monad$bindS
      (sail2_state$or_boolS
        (sail2_state$or_boolS (sail2_state_monad$returnS ((~ ((HaveEL EL2)))))
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__3 : 64 bits) . 
            sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__3 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__5 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__5 (( 34 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (IsEL1Regime : bool) .  sail2_state_monad$bindS
      (if IsEL1Regime then sail2_state_monad$bindS
         (sail2_state_monad$read_regS SCTLR_EL1_ref  : ( 32 words$word) M) (\ (w__6 : 32 bits) . 
         sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__6 (( 31 : int):ii)]  :  1 words$word))
       else sail2_state_monad$bindS
         (sail2_state_monad$read_regS SCTLR_EL2_ref  : ( 32 words$word) M) (\ (w__7 : 32 bits) . 
         sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__7 (( 31 : int):ii)]  :  1 words$word))) (\ (w__8 :  1 words$word) . 
      let Enable = w__8 in sail2_state_monad$bindS
      (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveEL EL2)) /\ IsEL1Regime))))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__9 : bool) .  sail2_state_monad$returnS ((~ w__9)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__11 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__11 (( 41 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__12 : bool) . 
      let TrapEL2 = w__12 in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__13 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__13 (( 17 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__14 : bool) . 
      let (TrapEL3 : bool) = w__14 in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3)))))
    else if (((pat_0 = EL1))) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS SCTLR_EL1_ref  : ( 32 words$word) M) (\ (w__15 : 32 bits) . 
      let Enable = ((vec_of_bits [access_vec_dec w__15 (( 31 : int):ii)]  :  1 words$word)) in sail2_state_monad$bindS
      (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__16 : bool) .  sail2_state_monad$returnS ((~ w__16)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__18 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__18 (( 41 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__19 : bool) . 
      let TrapEL2 = w__19 in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__20 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__20 (( 17 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__21 : bool) . 
      let (TrapEL3 : bool) = w__21 in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3))))
    else if (((pat_0 = EL2))) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS SCTLR_EL2_ref  : ( 32 words$word) M) (\ (w__22 : 32 bits) . 
      let Enable = ((vec_of_bits [access_vec_dec w__22 (( 31 : int):ii)]  :  1 words$word)) in
      let TrapEL2 = F in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__23 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__23 (( 17 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__24 : bool) . 
      let (TrapEL3 : bool) = w__24 in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3)))
    else sail2_state_monad$bindS
      (sail2_state_monad$read_regS SCTLR_EL3_ref  : ( 32 words$word) M) (\ (w__25 : 32 bits) . 
      let (Enable : 1 bits) = ((vec_of_bits [access_vec_dec w__25 (( 31 : int):ii)]  :  1 words$word)) in
      let (TrapEL2 : bool) = F in
      let (TrapEL3 : bool) = F in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3))) (\ varstup .  let ((Enable : 1 bits), (TrapEL2 :
     bool), (TrapEL3 : bool)) = varstup in
   if (((Enable = (vec_of_bits [B0]  :  1 words$word)))) then sail2_state_monad$returnS X
   else if TrapEL2 then sail2_state_monad$seqS (TrapPACUse EL2) (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
   else if TrapEL3 then sail2_state_monad$seqS (TrapPACUse EL3) (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
   else (Auth X Y APIAKey_EL1 F (vec_of_bits [B0]  :  1 words$word)  : ( 64 words$word) M))))))))))`;


(*val aarch64_integer_pac_autia_dp_1src : ii -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_integer_pac_autia_dp_1src:int -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d n source_is_sp=
    (if ((HavePACExt () )) then
     if source_is_sp then sail2_state_monad$bindS
       (aget_X (( 64 : int):ii) d  : ( 64 words$word) M) (\ (w__0 :  64 words$word) .  sail2_state_monad$bindS
       (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M) (\ (w__1 :  64 words$word) .  sail2_state_monad$bindS
       (AuthIA w__0 w__1  : ( 64 words$word) M) (\ (w__2 :  64 words$word) .  aset_X d w__2)))
     else sail2_state_monad$bindS
       (aget_X (( 64 : int):ii) d  : ( 64 words$word) M) (\ (w__3 :  64 words$word) .  sail2_state_monad$bindS
       (aget_X (( 64 : int):ii) n  : ( 64 words$word) M) (\ (w__4 :  64 words$word) .  sail2_state_monad$bindS
       (AuthIA w__3 w__4  : ( 64 words$word) M) (\ (w__5 :  64 words$word) .  aset_X d w__5)))
   else sail2_state_monad$returnS () ))`;


(*val integer_pac_autia_hint_decode : mword ty1 -> mword ty2 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty3 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_pac_autia_hint_decode:(1)words$word ->(2)words$word ->(3)words$word ->(4)words$word ->(4)words$word ->(3)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) L op0 op1 CRn CRm op2 Rt=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (undefined_int () )) (\ (d : ii) .  sail2_state_monad$bindS
   (undefined_int () ) (\ (n : ii) . 
   let (source_is_sp : bool) = F in
   let b__0 = ((concat_vec CRm op2  :  7 words$word)) in sail2_state_monad$bindS
   (if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B1;B0;B0]  :  7 words$word)))) then
      let (d : ii) = ((( 30 : int):ii)) in
      let (n : ii) = ((( 31 : int):ii)) in
      sail2_state_monad$returnS (d, n, source_is_sp)
    else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B1;B0;B1]  :  7 words$word)))) then
      let (d : ii) = ((( 30 : int):ii)) in
      let (source_is_sp : bool) = T in
      sail2_state_monad$returnS (d, n, source_is_sp)
    else sail2_state_monad$bindS
      (if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B1;B0;B0]  :  7 words$word)))) then
         let (d : ii) = ((( 17 : int):ii)) in
         let (n : ii) = ((( 16 : int):ii)) in
         sail2_state_monad$returnS (d, n)
       else sail2_state_monad$seqS
         (if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0]  :  7 words$word)))) then
            sail2_state_monad$throwS (Error_See "PACIA")
          else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0]  :  7 words$word)))) then
            sail2_state_monad$throwS (Error_See "PACIB")
          else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B1;B1;B0]  :  7 words$word)))) then
            sail2_state_monad$throwS (Error_See "AUTIB")
          else if (((((subrange_vec_dec b__0 (( 6 : int):ii) (( 1 : int):ii)  :  6 words$word)) = (vec_of_bits [B0;B0;B1;B1;B0;B0]  :  6 words$word)))) then
            sail2_state_monad$throwS (Error_See "PACIA")
          else if (((((subrange_vec_dec b__0 (( 6 : int):ii) (( 1 : int):ii)  :  6 words$word)) = (vec_of_bits [B0;B0;B1;B1;B0;B1]  :  6 words$word)))) then
            sail2_state_monad$throwS (Error_See "PACIB")
          else if (((((subrange_vec_dec b__0 (( 6 : int):ii) (( 1 : int):ii)  :  6 words$word)) = (vec_of_bits [B0;B0;B1;B1;B1;B1]  :  6 words$word)))) then
            sail2_state_monad$throwS (Error_See "AUTIB")
          else if (((b__0 = (vec_of_bits [B0;B0;B0;B0;B1;B1;B1]  :  7 words$word)))) then
            sail2_state_monad$throwS (Error_See "XPACLRI")
          else sail2_state_monad$throwS (Error_See "HINT"))
         (sail2_state_monad$returnS (d, n))) (\ varstup .  let ((d : ii), (n : ii)) = varstup in
      sail2_state_monad$returnS (d, n, source_is_sp))) (\ varstup .  let ((d : ii), (n : ii), (source_is_sp : bool)) = varstup in
   aarch64_integer_pac_autia_dp_1src d n source_is_sp)))))`;


(*val aarch64_branch_unconditional_register : BranchType -> ii -> ii -> bool -> bool -> bool -> M unit*)

val _ = Define `
 ((aarch64_branch_unconditional_register:BranchType -> int -> int -> bool -> bool -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) branch_type m n pac source_is_sp use_key_a=  (sail2_state_monad$bindS
   (aget_X (( 64 : int):ii) n  : ( 64 words$word) M) (\ (target : 64 bits) .  sail2_state_monad$bindS
   (if pac then sail2_state_monad$bindS
      (if source_is_sp then (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
       else (aget_X (( 64 : int):ii) m  : ( 64 words$word) M)) (\ (modifier : 64 bits) . 
      if use_key_a then (AuthIA target modifier  : ( 64 words$word) M)
      else (AuthIB target modifier  : ( 64 words$word) M))
    else sail2_state_monad$returnS target) (\ (target : 64 bits) .  sail2_state_monad$seqS
   (if (((branch_type = BranchType_CALL))) then sail2_state_monad$bindS
      (aget_PC ()   : ( 64 words$word) M) (\ (w__4 :  64 words$word) . 
      aset_X (( 30 : int):ii) ((add_vec_int w__4 (( 4 : int):ii)  :  64 words$word)))
    else sail2_state_monad$returnS () )
   (BranchTo target branch_type)))))`;


(*val AuthDB : mword ty64 -> mword ty64 -> M (mword ty64)*)

val _ = Define `
 ((AuthDB:(64)words$word ->(64)words$word ->(regstate)sail2_state_monad$sequential_state ->((((64)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) X Y=  (sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (TrapEL2 : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (TrapEL3 : bool) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (Enable : 1 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS APDBKeyHi_EL1_ref  : ( 64 words$word) M) (\ (w__0 : 64 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS APDBKeyLo_EL1_ref  : ( 64 words$word) M) (\ (w__1 : 64 bits) . 
   let (APDBKey_EL1 : 128 bits) =
     ((concat_vec ((slice w__0 (( 0 : int):ii) (( 64 : int):ii)  :  64 words$word))
        ((slice w__1 (( 0 : int):ii) (( 64 : int):ii)  :  64 words$word))
       :  128 words$word)) in sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) . 
   let p__290 = (w__2.ProcState_EL) in
   let pat_0 = p__290 in sail2_state_monad$bindS
   (if (((pat_0 = EL0))) then sail2_state_monad$bindS
      (sail2_state$or_boolS
        (sail2_state$or_boolS (sail2_state_monad$returnS ((~ ((HaveEL EL2)))))
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__3 : 64 bits) . 
            sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__3 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__5 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__5 (( 34 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (IsEL1Regime : bool) .  sail2_state_monad$bindS
      (if IsEL1Regime then sail2_state_monad$bindS
         (sail2_state_monad$read_regS SCTLR_EL1_ref  : ( 32 words$word) M) (\ (w__6 : 32 bits) . 
         sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__6 (( 13 : int):ii)]  :  1 words$word))
       else sail2_state_monad$bindS
         (sail2_state_monad$read_regS SCTLR_EL2_ref  : ( 32 words$word) M) (\ (w__7 : 32 bits) . 
         sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__7 (( 13 : int):ii)]  :  1 words$word))) (\ (w__8 :  1 words$word) . 
      let Enable = w__8 in sail2_state_monad$bindS
      (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveEL EL2)) /\ IsEL1Regime))))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__9 : bool) .  sail2_state_monad$returnS ((~ w__9)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__11 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__11 (( 41 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__12 : bool) . 
      let TrapEL2 = w__12 in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__13 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__13 (( 17 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__14 : bool) . 
      let (TrapEL3 : bool) = w__14 in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3)))))
    else if (((pat_0 = EL1))) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS SCTLR_EL1_ref  : ( 32 words$word) M) (\ (w__15 : 32 bits) . 
      let Enable = ((vec_of_bits [access_vec_dec w__15 (( 13 : int):ii)]  :  1 words$word)) in sail2_state_monad$bindS
      (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__16 : bool) .  sail2_state_monad$returnS ((~ w__16)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__18 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__18 (( 41 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__19 : bool) . 
      let TrapEL2 = w__19 in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__20 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__20 (( 17 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__21 : bool) . 
      let (TrapEL3 : bool) = w__21 in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3))))
    else if (((pat_0 = EL2))) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS SCTLR_EL2_ref  : ( 32 words$word) M) (\ (w__22 : 32 bits) . 
      let Enable = ((vec_of_bits [access_vec_dec w__22 (( 13 : int):ii)]  :  1 words$word)) in
      let TrapEL2 = F in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__23 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__23 (( 17 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__24 : bool) . 
      let (TrapEL3 : bool) = w__24 in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3)))
    else sail2_state_monad$bindS
      (sail2_state_monad$read_regS SCTLR_EL3_ref  : ( 32 words$word) M) (\ (w__25 : 32 bits) . 
      let (Enable : 1 bits) = ((vec_of_bits [access_vec_dec w__25 (( 13 : int):ii)]  :  1 words$word)) in
      let (TrapEL2 : bool) = F in
      let (TrapEL3 : bool) = F in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3))) (\ varstup .  let ((Enable : 1 bits), (TrapEL2 :
     bool), (TrapEL3 : bool)) = varstup in
   if (((Enable = (vec_of_bits [B0]  :  1 words$word)))) then sail2_state_monad$returnS X
   else if TrapEL2 then sail2_state_monad$seqS (TrapPACUse EL2) (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
   else if TrapEL3 then sail2_state_monad$seqS (TrapPACUse EL3) (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
   else (Auth X Y APDBKey_EL1 T (vec_of_bits [B1]  :  1 words$word)  : ( 64 words$word) M))))))))))`;


(*val aarch64_integer_pac_autdb_dp_1src : ii -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_integer_pac_autdb_dp_1src:int -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d n source_is_sp=
    (if source_is_sp then sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) d  : ( 64 words$word) M) (\ (w__0 :  64 words$word) .  sail2_state_monad$bindS
     (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M) (\ (w__1 :  64 words$word) .  sail2_state_monad$bindS
     (AuthDB w__0 w__1  : ( 64 words$word) M) (\ (w__2 :  64 words$word) .  aset_X d w__2)))
   else sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) d  : ( 64 words$word) M) (\ (w__3 :  64 words$word) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) n  : ( 64 words$word) M) (\ (w__4 :  64 words$word) .  sail2_state_monad$bindS
     (AuthDB w__3 w__4  : ( 64 words$word) M) (\ (w__5 :  64 words$word) .  aset_X d w__5)))))`;


(*val AuthDA : mword ty64 -> mword ty64 -> M (mword ty64)*)

val _ = Define `
 ((AuthDA:(64)words$word ->(64)words$word ->(regstate)sail2_state_monad$sequential_state ->((((64)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) X Y=  (sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (TrapEL2 : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (TrapEL3 : bool) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (Enable : 1 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS APDAKeyHi_EL1_ref  : ( 64 words$word) M) (\ (w__0 : 64 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS APDAKeyLo_EL1_ref  : ( 64 words$word) M) (\ (w__1 : 64 bits) . 
   let (APDAKey_EL1 : 128 bits) =
     ((concat_vec ((slice w__0 (( 0 : int):ii) (( 64 : int):ii)  :  64 words$word))
        ((slice w__1 (( 0 : int):ii) (( 64 : int):ii)  :  64 words$word))
       :  128 words$word)) in sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) . 
   let p__289 = (w__2.ProcState_EL) in
   let pat_0 = p__289 in sail2_state_monad$bindS
   (if (((pat_0 = EL0))) then sail2_state_monad$bindS
      (sail2_state$or_boolS
        (sail2_state$or_boolS (sail2_state_monad$returnS ((~ ((HaveEL EL2)))))
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__3 : 64 bits) . 
            sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__3 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__5 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__5 (( 34 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (IsEL1Regime : bool) .  sail2_state_monad$bindS
      (if IsEL1Regime then sail2_state_monad$bindS
         (sail2_state_monad$read_regS SCTLR_EL1_ref  : ( 32 words$word) M) (\ (w__6 : 32 bits) . 
         sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__6 (( 27 : int):ii)]  :  1 words$word))
       else sail2_state_monad$bindS
         (sail2_state_monad$read_regS SCTLR_EL2_ref  : ( 32 words$word) M) (\ (w__7 : 32 bits) . 
         sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__7 (( 27 : int):ii)]  :  1 words$word))) (\ (w__8 :  1 words$word) . 
      let Enable = w__8 in sail2_state_monad$bindS
      (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveEL EL2)) /\ IsEL1Regime))))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__9 : bool) .  sail2_state_monad$returnS ((~ w__9)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__11 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__11 (( 41 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__12 : bool) . 
      let TrapEL2 = w__12 in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__13 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__13 (( 17 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__14 : bool) . 
      let (TrapEL3 : bool) = w__14 in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3)))))
    else if (((pat_0 = EL1))) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS SCTLR_EL1_ref  : ( 32 words$word) M) (\ (w__15 : 32 bits) . 
      let Enable = ((vec_of_bits [access_vec_dec w__15 (( 27 : int):ii)]  :  1 words$word)) in sail2_state_monad$bindS
      (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__16 : bool) .  sail2_state_monad$returnS ((~ w__16)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__18 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__18 (( 41 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__19 : bool) . 
      let TrapEL2 = w__19 in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__20 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__20 (( 17 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__21 : bool) . 
      let (TrapEL3 : bool) = w__21 in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3))))
    else if (((pat_0 = EL2))) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS SCTLR_EL2_ref  : ( 32 words$word) M) (\ (w__22 : 32 bits) . 
      let Enable = ((vec_of_bits [access_vec_dec w__22 (( 27 : int):ii)]  :  1 words$word)) in
      let TrapEL2 = F in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__23 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__23 (( 17 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__24 : bool) . 
      let (TrapEL3 : bool) = w__24 in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3)))
    else sail2_state_monad$bindS
      (sail2_state_monad$read_regS SCTLR_EL3_ref  : ( 32 words$word) M) (\ (w__25 : 32 bits) . 
      let (Enable : 1 bits) = ((vec_of_bits [access_vec_dec w__25 (( 27 : int):ii)]  :  1 words$word)) in
      let (TrapEL2 : bool) = F in
      let (TrapEL3 : bool) = F in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3))) (\ varstup .  let ((Enable : 1 bits), (TrapEL2 :
     bool), (TrapEL3 : bool)) = varstup in
   if (((Enable = (vec_of_bits [B0]  :  1 words$word)))) then sail2_state_monad$returnS X
   else if TrapEL2 then sail2_state_monad$seqS (TrapPACUse EL2) (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
   else if TrapEL3 then sail2_state_monad$seqS (TrapPACUse EL3) (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
   else (Auth X Y APDAKey_EL1 T (vec_of_bits [B0]  :  1 words$word)  : ( 64 words$word) M))))))))))`;


(*val aarch64_integer_pac_autda_dp_1src : ii -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_integer_pac_autda_dp_1src:int -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d n source_is_sp=
    (if source_is_sp then sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) d  : ( 64 words$word) M) (\ (w__0 :  64 words$word) .  sail2_state_monad$bindS
     (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M) (\ (w__1 :  64 words$word) .  sail2_state_monad$bindS
     (AuthDA w__0 w__1  : ( 64 words$word) M) (\ (w__2 :  64 words$word) .  aset_X d w__2)))
   else sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) d  : ( 64 words$word) M) (\ (w__3 :  64 words$word) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) n  : ( 64 words$word) M) (\ (w__4 :  64 words$word) .  sail2_state_monad$bindS
     (AuthDA w__3 w__4  : ( 64 words$word) M) (\ (w__5 :  64 words$word) .  aset_X d w__5)))))`;


(*val AddPACIB : mword ty64 -> mword ty64 -> M (mword ty64)*)

val _ = Define `
 ((AddPACIB:(64)words$word ->(64)words$word ->(regstate)sail2_state_monad$sequential_state ->((((64)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) X Y=  (sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (TrapEL2 : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (TrapEL3 : bool) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (Enable : 1 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS APIBKeyHi_EL1_ref  : ( 64 words$word) M) (\ (w__0 : 64 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS APIBKeyLo_EL1_ref  : ( 64 words$word) M) (\ (w__1 : 64 bits) . 
   let (APIBKey_EL1 : 128 bits) =
     ((concat_vec ((slice w__0 (( 0 : int):ii) (( 64 : int):ii)  :  64 words$word))
        ((slice w__1 (( 0 : int):ii) (( 64 : int):ii)  :  64 words$word))
       :  128 words$word)) in sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) . 
   let p__288 = (w__2.ProcState_EL) in
   let pat_0 = p__288 in sail2_state_monad$bindS
   (if (((pat_0 = EL0))) then sail2_state_monad$bindS
      (sail2_state$or_boolS
        (sail2_state$or_boolS (sail2_state_monad$returnS ((~ ((HaveEL EL2)))))
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__3 : 64 bits) . 
            sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__3 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__5 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__5 (( 34 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (IsEL1Regime : bool) .  sail2_state_monad$bindS
      (if IsEL1Regime then sail2_state_monad$bindS
         (sail2_state_monad$read_regS SCTLR_EL1_ref  : ( 32 words$word) M) (\ (w__6 : 32 bits) . 
         sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__6 (( 30 : int):ii)]  :  1 words$word))
       else sail2_state_monad$bindS
         (sail2_state_monad$read_regS SCTLR_EL2_ref  : ( 32 words$word) M) (\ (w__7 : 32 bits) . 
         sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__7 (( 30 : int):ii)]  :  1 words$word))) (\ (w__8 :  1 words$word) . 
      let Enable = w__8 in sail2_state_monad$bindS
      (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveEL EL2)) /\ IsEL1Regime))))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__9 : bool) .  sail2_state_monad$returnS ((~ w__9)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__11 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__11 (( 41 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__12 : bool) . 
      let TrapEL2 = w__12 in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__13 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__13 (( 17 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__14 : bool) . 
      let (TrapEL3 : bool) = w__14 in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3)))))
    else if (((pat_0 = EL1))) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS SCTLR_EL1_ref  : ( 32 words$word) M) (\ (w__15 : 32 bits) . 
      let Enable = ((vec_of_bits [access_vec_dec w__15 (( 30 : int):ii)]  :  1 words$word)) in sail2_state_monad$bindS
      (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__16 : bool) .  sail2_state_monad$returnS ((~ w__16)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__18 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__18 (( 41 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__19 : bool) . 
      let TrapEL2 = w__19 in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__20 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__20 (( 17 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__21 : bool) . 
      let (TrapEL3 : bool) = w__21 in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3))))
    else if (((pat_0 = EL2))) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS SCTLR_EL2_ref  : ( 32 words$word) M) (\ (w__22 : 32 bits) . 
      let Enable = ((vec_of_bits [access_vec_dec w__22 (( 30 : int):ii)]  :  1 words$word)) in
      let TrapEL2 = F in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__23 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__23 (( 17 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__24 : bool) . 
      let (TrapEL3 : bool) = w__24 in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3)))
    else sail2_state_monad$bindS
      (sail2_state_monad$read_regS SCTLR_EL3_ref  : ( 32 words$word) M) (\ (w__25 : 32 bits) . 
      let (Enable : 1 bits) = ((vec_of_bits [access_vec_dec w__25 (( 30 : int):ii)]  :  1 words$word)) in
      let (TrapEL2 : bool) = F in
      let (TrapEL3 : bool) = F in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3))) (\ varstup .  let ((Enable : 1 bits), (TrapEL2 :
     bool), (TrapEL3 : bool)) = varstup in
   if (((Enable = (vec_of_bits [B0]  :  1 words$word)))) then sail2_state_monad$returnS X
   else if TrapEL2 then sail2_state_monad$seqS (TrapPACUse EL2) (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
   else if TrapEL3 then sail2_state_monad$seqS (TrapPACUse EL3) (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
   else (AddPAC X Y APIBKey_EL1 F  : ( 64 words$word) M))))))))))`;


(*val aarch64_integer_pac_pacib_dp_1src : ii -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_integer_pac_pacib_dp_1src:int -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d n source_is_sp=
    (if ((HavePACExt () )) then
     if source_is_sp then sail2_state_monad$bindS
       (aget_X (( 64 : int):ii) d  : ( 64 words$word) M) (\ (w__0 :  64 words$word) .  sail2_state_monad$bindS
       (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M) (\ (w__1 :  64 words$word) .  sail2_state_monad$bindS
       (AddPACIB w__0 w__1  : ( 64 words$word) M) (\ (w__2 :  64 words$word) .  aset_X d w__2)))
     else sail2_state_monad$bindS
       (aget_X (( 64 : int):ii) d  : ( 64 words$word) M) (\ (w__3 :  64 words$word) .  sail2_state_monad$bindS
       (aget_X (( 64 : int):ii) n  : ( 64 words$word) M) (\ (w__4 :  64 words$word) .  sail2_state_monad$bindS
       (AddPACIB w__3 w__4  : ( 64 words$word) M) (\ (w__5 :  64 words$word) .  aset_X d w__5)))
   else sail2_state_monad$returnS () ))`;


(*val integer_pac_pacib_hint_decode : mword ty1 -> mword ty2 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty3 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_pac_pacib_hint_decode:(1)words$word ->(2)words$word ->(3)words$word ->(4)words$word ->(4)words$word ->(3)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) L op0 op1 CRn CRm op2 Rt=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (undefined_int () )) (\ (d : ii) .  sail2_state_monad$bindS
   (undefined_int () ) (\ (n : ii) . 
   let (source_is_sp : bool) = F in
   let b__0 = ((concat_vec CRm op2  :  7 words$word)) in sail2_state_monad$bindS
   (if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0]  :  7 words$word)))) then
      let (d : ii) = ((( 30 : int):ii)) in
      let (n : ii) = ((( 31 : int):ii)) in
      sail2_state_monad$returnS (d, n, source_is_sp)
    else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  :  7 words$word)))) then
      let (d : ii) = ((( 30 : int):ii)) in
      let (source_is_sp : bool) = T in
      sail2_state_monad$returnS (d, n, source_is_sp)
    else sail2_state_monad$bindS
      (if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0]  :  7 words$word)))) then
         let (d : ii) = ((( 17 : int):ii)) in
         let (n : ii) = ((( 16 : int):ii)) in
         sail2_state_monad$returnS (d, n)
       else sail2_state_monad$seqS
         (if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0]  :  7 words$word)))) then
            sail2_state_monad$throwS (Error_See "PACIA")
          else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B1;B0;B0]  :  7 words$word)))) then
            sail2_state_monad$throwS (Error_See "AUTIA")
          else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B1;B1;B0]  :  7 words$word)))) then
            sail2_state_monad$throwS (Error_See "AUTIB")
          else if (((((subrange_vec_dec b__0 (( 6 : int):ii) (( 1 : int):ii)  :  6 words$word)) = (vec_of_bits [B0;B0;B1;B1;B0;B0]  :  6 words$word)))) then
            sail2_state_monad$throwS (Error_See "PACIA")
          else if (((((subrange_vec_dec b__0 (( 6 : int):ii) (( 1 : int):ii)  :  6 words$word)) = (vec_of_bits [B0;B0;B1;B1;B1;B0]  :  6 words$word)))) then
            sail2_state_monad$throwS (Error_See "AUTIA")
          else if (((((subrange_vec_dec b__0 (( 6 : int):ii) (( 1 : int):ii)  :  6 words$word)) = (vec_of_bits [B0;B0;B1;B1;B1;B1]  :  6 words$word)))) then
            sail2_state_monad$throwS (Error_See "AUTIB")
          else sail2_state_monad$throwS (Error_See "XPACLRI"))
         (sail2_state_monad$returnS (d, n))) (\ varstup .  let ((d : ii), (n : ii)) = varstup in
      sail2_state_monad$returnS (d, n, source_is_sp))) (\ varstup .  let ((d : ii), (n : ii), (source_is_sp : bool)) = varstup in
   aarch64_integer_pac_pacib_dp_1src d n source_is_sp)))))`;


(*val AddPACIA : mword ty64 -> mword ty64 -> M (mword ty64)*)

val _ = Define `
 ((AddPACIA:(64)words$word ->(64)words$word ->(regstate)sail2_state_monad$sequential_state ->((((64)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) X Y=  (sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (TrapEL2 : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (TrapEL3 : bool) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (Enable : 1 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS APIAKeyHi_EL1_ref  : ( 64 words$word) M) (\ (w__0 : 64 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS APIAKeyLo_EL1_ref  : ( 64 words$word) M) (\ (w__1 : 64 bits) . 
   let (APIAKey_EL1 : 128 bits) =
     ((concat_vec ((slice w__0 (( 0 : int):ii) (( 64 : int):ii)  :  64 words$word))
        ((slice w__1 (( 0 : int):ii) (( 64 : int):ii)  :  64 words$word))
       :  128 words$word)) in sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) . 
   let p__287 = (w__2.ProcState_EL) in
   let pat_0 = p__287 in sail2_state_monad$bindS
   (if (((pat_0 = EL0))) then sail2_state_monad$bindS
      (sail2_state$or_boolS
        (sail2_state$or_boolS (sail2_state_monad$returnS ((~ ((HaveEL EL2)))))
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__3 : 64 bits) . 
            sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__3 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__5 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__5 (( 34 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (IsEL1Regime : bool) .  sail2_state_monad$bindS
      (if IsEL1Regime then sail2_state_monad$bindS
         (sail2_state_monad$read_regS SCTLR_EL1_ref  : ( 32 words$word) M) (\ (w__6 : 32 bits) . 
         sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__6 (( 31 : int):ii)]  :  1 words$word))
       else sail2_state_monad$bindS
         (sail2_state_monad$read_regS SCTLR_EL2_ref  : ( 32 words$word) M) (\ (w__7 : 32 bits) . 
         sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__7 (( 31 : int):ii)]  :  1 words$word))) (\ (w__8 :  1 words$word) . 
      let Enable = w__8 in sail2_state_monad$bindS
      (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveEL EL2)) /\ IsEL1Regime))))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__9 : bool) .  sail2_state_monad$returnS ((~ w__9)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__11 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__11 (( 41 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__12 : bool) . 
      let TrapEL2 = w__12 in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__13 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__13 (( 17 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__14 : bool) . 
      let (TrapEL3 : bool) = w__14 in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3)))))
    else if (((pat_0 = EL1))) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS SCTLR_EL1_ref  : ( 32 words$word) M) (\ (w__15 : 32 bits) . 
      let Enable = ((vec_of_bits [access_vec_dec w__15 (( 31 : int):ii)]  :  1 words$word)) in sail2_state_monad$bindS
      (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__16 : bool) .  sail2_state_monad$returnS ((~ w__16)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__18 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__18 (( 41 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__19 : bool) . 
      let TrapEL2 = w__19 in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__20 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__20 (( 17 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__21 : bool) . 
      let (TrapEL3 : bool) = w__21 in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3))))
    else if (((pat_0 = EL2))) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS SCTLR_EL2_ref  : ( 32 words$word) M) (\ (w__22 : 32 bits) . 
      let Enable = ((vec_of_bits [access_vec_dec w__22 (( 31 : int):ii)]  :  1 words$word)) in
      let TrapEL2 = F in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__23 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__23 (( 17 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__24 : bool) . 
      let (TrapEL3 : bool) = w__24 in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3)))
    else sail2_state_monad$bindS
      (sail2_state_monad$read_regS SCTLR_EL3_ref  : ( 32 words$word) M) (\ (w__25 : 32 bits) . 
      let (Enable : 1 bits) = ((vec_of_bits [access_vec_dec w__25 (( 31 : int):ii)]  :  1 words$word)) in
      let (TrapEL2 : bool) = F in
      let (TrapEL3 : bool) = F in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3))) (\ varstup .  let ((Enable : 1 bits), (TrapEL2 :
     bool), (TrapEL3 : bool)) = varstup in
   if (((Enable = (vec_of_bits [B0]  :  1 words$word)))) then sail2_state_monad$returnS X
   else if TrapEL2 then sail2_state_monad$seqS (TrapPACUse EL2) (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
   else if TrapEL3 then sail2_state_monad$seqS (TrapPACUse EL3) (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
   else (AddPAC X Y APIAKey_EL1 F  : ( 64 words$word) M))))))))))`;


(*val aarch64_integer_pac_pacia_dp_1src : ii -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_integer_pac_pacia_dp_1src:int -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d n source_is_sp=
    (if ((HavePACExt () )) then
     if source_is_sp then sail2_state_monad$bindS
       (aget_X (( 64 : int):ii) d  : ( 64 words$word) M) (\ (w__0 :  64 words$word) .  sail2_state_monad$bindS
       (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M) (\ (w__1 :  64 words$word) .  sail2_state_monad$bindS
       (AddPACIA w__0 w__1  : ( 64 words$word) M) (\ (w__2 :  64 words$word) .  aset_X d w__2)))
     else sail2_state_monad$bindS
       (aget_X (( 64 : int):ii) d  : ( 64 words$word) M) (\ (w__3 :  64 words$word) .  sail2_state_monad$bindS
       (aget_X (( 64 : int):ii) n  : ( 64 words$word) M) (\ (w__4 :  64 words$word) .  sail2_state_monad$bindS
       (AddPACIA w__3 w__4  : ( 64 words$word) M) (\ (w__5 :  64 words$word) .  aset_X d w__5)))
   else sail2_state_monad$returnS () ))`;


(*val integer_pac_pacia_hint_decode : mword ty1 -> mword ty2 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty3 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_pac_pacia_hint_decode:(1)words$word ->(2)words$word ->(3)words$word ->(4)words$word ->(4)words$word ->(3)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) L op0 op1 CRn CRm op2 Rt=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (undefined_int () )) (\ (d : ii) .  sail2_state_monad$bindS
   (undefined_int () ) (\ (n : ii) . 
   let (source_is_sp : bool) = F in
   let b__0 = ((concat_vec CRm op2  :  7 words$word)) in sail2_state_monad$bindS
   (if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0]  :  7 words$word)))) then
      let (d : ii) = ((( 30 : int):ii)) in
      let (n : ii) = ((( 31 : int):ii)) in
      sail2_state_monad$returnS (d, n, source_is_sp)
    else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B1]  :  7 words$word)))) then
      let (d : ii) = ((( 30 : int):ii)) in
      let (source_is_sp : bool) = T in
      sail2_state_monad$returnS (d, n, source_is_sp)
    else sail2_state_monad$bindS
      (if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0]  :  7 words$word)))) then
         let (d : ii) = ((( 17 : int):ii)) in
         let (n : ii) = ((( 16 : int):ii)) in
         sail2_state_monad$returnS (d, n)
       else sail2_state_monad$seqS
         (if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0]  :  7 words$word)))) then
            sail2_state_monad$throwS (Error_See "PACIB")
          else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B1;B0;B0]  :  7 words$word)))) then
            sail2_state_monad$throwS (Error_See "AUTIA")
          else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B1;B1;B0]  :  7 words$word)))) then
            sail2_state_monad$throwS (Error_See "AUTIB")
          else if (((((subrange_vec_dec b__0 (( 6 : int):ii) (( 1 : int):ii)  :  6 words$word)) = (vec_of_bits [B0;B0;B1;B1;B0;B1]  :  6 words$word)))) then
            sail2_state_monad$throwS (Error_See "PACIB")
          else if (((((subrange_vec_dec b__0 (( 6 : int):ii) (( 1 : int):ii)  :  6 words$word)) = (vec_of_bits [B0;B0;B1;B1;B1;B0]  :  6 words$word)))) then
            sail2_state_monad$throwS (Error_See "AUTIA")
          else if (((((subrange_vec_dec b__0 (( 6 : int):ii) (( 1 : int):ii)  :  6 words$word)) = (vec_of_bits [B0;B0;B1;B1;B1;B1]  :  6 words$word)))) then
            sail2_state_monad$throwS (Error_See "AUTIB")
          else sail2_state_monad$throwS (Error_See "XPACLRI"))
         (sail2_state_monad$returnS (d, n))) (\ varstup .  let ((d : ii), (n : ii)) = varstup in
      sail2_state_monad$returnS (d, n, source_is_sp))) (\ varstup .  let ((d : ii), (n : ii), (source_is_sp : bool)) = varstup in
   aarch64_integer_pac_pacia_dp_1src d n source_is_sp)))))`;


(*val AddPACGA : mword ty64 -> mword ty64 -> M (mword ty64)*)

val _ = Define `
 ((AddPACGA:(64)words$word ->(64)words$word ->(regstate)sail2_state_monad$sequential_state ->((((64)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) X Y=  (sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (TrapEL2 : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (TrapEL3 : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS APGAKeyHi_EL1_ref  : ( 64 words$word) M) (\ (w__0 : 64 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS APGAKeyLo_EL1_ref  : ( 64 words$word) M) (\ (w__1 : 64 bits) . 
   let (APGAKey_EL1 : 128 bits) =
     ((concat_vec ((slice w__0 (( 0 : int):ii) (( 64 : int):ii)  :  64 words$word))
        ((slice w__1 (( 0 : int):ii) (( 64 : int):ii)  :  64 words$word))
       :  128 words$word)) in sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) . 
   let p__286 = (w__2.ProcState_EL) in
   let pat_0 = p__286 in sail2_state_monad$bindS
   (if (((pat_0 = EL0))) then sail2_state_monad$bindS
      (sail2_state$or_boolS
        (sail2_state$or_boolS (sail2_state_monad$returnS ((~ ((HaveEL EL2)))))
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__3 : 64 bits) . 
            sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__3 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__5 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__5 (( 34 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (IsEL1Regime : bool) .  sail2_state_monad$bindS
      (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveEL EL2)) /\ IsEL1Regime))))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__6 : bool) .  sail2_state_monad$returnS ((~ w__6)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__8 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__8 (( 41 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__9 : bool) . 
      let TrapEL2 = w__9 in sail2_state_monad$bindS
      (sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__10 : 32 bits) . 
      let (TrapEL3 : bool) =
        ((vec_of_bits [access_vec_dec w__10 (( 17 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)) in
      sail2_state_monad$returnS (TrapEL2, TrapEL3))))
    else if (((pat_0 = EL1))) then sail2_state_monad$bindS
      (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__11 : bool) .  sail2_state_monad$returnS ((~ w__11)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__13 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__13 (( 41 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__14 : bool) . 
      let TrapEL2 = w__14 in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__15 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__15 (( 17 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__16 : bool) . 
      let (TrapEL3 : bool) = w__16 in
      sail2_state_monad$returnS (TrapEL2, TrapEL3)))
    else if (((pat_0 = EL2))) then
      let TrapEL2 = F in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__17 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__17 (( 17 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__18 : bool) . 
      let (TrapEL3 : bool) = w__18 in
      sail2_state_monad$returnS (TrapEL2, TrapEL3))
    else
      let (TrapEL2 : bool) = F in
      let (TrapEL3 : bool) = F in
      sail2_state_monad$returnS (TrapEL2, TrapEL3)) (\ varstup .  let ((TrapEL2 : bool), (TrapEL3 : bool)) = varstup in
   if TrapEL2 then sail2_state_monad$seqS (TrapPACUse EL2) (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
   else if TrapEL3 then sail2_state_monad$seqS (TrapPACUse EL3) (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
   else sail2_state_monad$bindS
     (ComputePAC X Y ((slice APGAKey_EL1 (( 64 : int):ii) (( 64 : int):ii)  :  64 words$word))
        ((slice APGAKey_EL1 (( 0 : int):ii) (( 64 : int):ii)  :  64 words$word))
       : ( 64 words$word) M) (\ (w__21 :  64 words$word) . 
     sail2_state_monad$returnS ((concat_vec ((slice w__21 (( 32 : int):ii) (( 32 : int):ii)  :  32 words$word))
                ((Zeros__0 ((make_the_value (( 32 : int):ii)  :  32 itself))  :  32 words$word))
               :  64 words$word)))))))))))`;


(*val aarch64_integer_pac_pacga_dp_2src : ii -> ii -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_integer_pac_pacga_dp_2src:int -> int -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d m n source_is_sp=
    (if source_is_sp then sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) n  : ( 64 words$word) M) (\ (w__0 :  64 words$word) .  sail2_state_monad$bindS
     (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M) (\ (w__1 :  64 words$word) .  sail2_state_monad$bindS
     (AddPACGA w__0 w__1  : ( 64 words$word) M) (\ (w__2 :  64 words$word) .  aset_X d w__2)))
   else sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) n  : ( 64 words$word) M) (\ (w__3 :  64 words$word) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) m  : ( 64 words$word) M) (\ (w__4 :  64 words$word) .  sail2_state_monad$bindS
     (AddPACGA w__3 w__4  : ( 64 words$word) M) (\ (w__5 :  64 words$word) .  aset_X d w__5)))))`;


(*val AddPACDB : mword ty64 -> mword ty64 -> M (mword ty64)*)

val _ = Define `
 ((AddPACDB:(64)words$word ->(64)words$word ->(regstate)sail2_state_monad$sequential_state ->((((64)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) X Y=  (sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (TrapEL2 : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (TrapEL3 : bool) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (Enable : 1 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS APDBKeyHi_EL1_ref  : ( 64 words$word) M) (\ (w__0 : 64 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS APDBKeyLo_EL1_ref  : ( 64 words$word) M) (\ (w__1 : 64 bits) . 
   let (APDBKey_EL1 : 128 bits) =
     ((concat_vec ((slice w__0 (( 0 : int):ii) (( 64 : int):ii)  :  64 words$word))
        ((slice w__1 (( 0 : int):ii) (( 64 : int):ii)  :  64 words$word))
       :  128 words$word)) in sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) . 
   let p__285 = (w__2.ProcState_EL) in
   let pat_0 = p__285 in sail2_state_monad$bindS
   (if (((pat_0 = EL0))) then sail2_state_monad$bindS
      (sail2_state$or_boolS
        (sail2_state$or_boolS (sail2_state_monad$returnS ((~ ((HaveEL EL2)))))
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__3 : 64 bits) . 
            sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__3 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__5 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__5 (( 34 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (IsEL1Regime : bool) .  sail2_state_monad$bindS
      (if IsEL1Regime then sail2_state_monad$bindS
         (sail2_state_monad$read_regS SCTLR_EL1_ref  : ( 32 words$word) M) (\ (w__6 : 32 bits) . 
         sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__6 (( 13 : int):ii)]  :  1 words$word))
       else sail2_state_monad$bindS
         (sail2_state_monad$read_regS SCTLR_EL2_ref  : ( 32 words$word) M) (\ (w__7 : 32 bits) . 
         sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__7 (( 13 : int):ii)]  :  1 words$word))) (\ (w__8 :  1 words$word) . 
      let Enable = w__8 in sail2_state_monad$bindS
      (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveEL EL2)) /\ IsEL1Regime))))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__9 : bool) .  sail2_state_monad$returnS ((~ w__9)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__11 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__11 (( 41 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__12 : bool) . 
      let TrapEL2 = w__12 in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__13 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__13 (( 17 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__14 : bool) . 
      let (TrapEL3 : bool) = w__14 in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3)))))
    else if (((pat_0 = EL1))) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS SCTLR_EL1_ref  : ( 32 words$word) M) (\ (w__15 : 32 bits) . 
      let Enable = ((vec_of_bits [access_vec_dec w__15 (( 13 : int):ii)]  :  1 words$word)) in sail2_state_monad$bindS
      (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__16 : bool) .  sail2_state_monad$returnS ((~ w__16)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__18 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__18 (( 41 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__19 : bool) . 
      let TrapEL2 = w__19 in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__20 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__20 (( 17 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__21 : bool) . 
      let (TrapEL3 : bool) = w__21 in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3))))
    else if (((pat_0 = EL2))) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS SCTLR_EL2_ref  : ( 32 words$word) M) (\ (w__22 : 32 bits) . 
      let Enable = ((vec_of_bits [access_vec_dec w__22 (( 13 : int):ii)]  :  1 words$word)) in
      let TrapEL2 = F in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__23 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__23 (( 17 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__24 : bool) . 
      let (TrapEL3 : bool) = w__24 in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3)))
    else sail2_state_monad$bindS
      (sail2_state_monad$read_regS SCTLR_EL3_ref  : ( 32 words$word) M) (\ (w__25 : 32 bits) . 
      let (Enable : 1 bits) = ((vec_of_bits [access_vec_dec w__25 (( 13 : int):ii)]  :  1 words$word)) in
      let (TrapEL2 : bool) = F in
      let (TrapEL3 : bool) = F in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3))) (\ varstup .  let ((Enable : 1 bits), (TrapEL2 :
     bool), (TrapEL3 : bool)) = varstup in
   if (((Enable = (vec_of_bits [B0]  :  1 words$word)))) then sail2_state_monad$returnS X
   else if TrapEL2 then sail2_state_monad$seqS (TrapPACUse EL2) (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
   else if TrapEL3 then sail2_state_monad$seqS (TrapPACUse EL3) (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
   else (AddPAC X Y APDBKey_EL1 T  : ( 64 words$word) M))))))))))`;


(*val aarch64_integer_pac_pacdb_dp_1src : ii -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_integer_pac_pacdb_dp_1src:int -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d n source_is_sp=
    (if source_is_sp then sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) d  : ( 64 words$word) M) (\ (w__0 :  64 words$word) .  sail2_state_monad$bindS
     (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M) (\ (w__1 :  64 words$word) .  sail2_state_monad$bindS
     (AddPACDB w__0 w__1  : ( 64 words$word) M) (\ (w__2 :  64 words$word) .  aset_X d w__2)))
   else sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) d  : ( 64 words$word) M) (\ (w__3 :  64 words$word) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) n  : ( 64 words$word) M) (\ (w__4 :  64 words$word) .  sail2_state_monad$bindS
     (AddPACDB w__3 w__4  : ( 64 words$word) M) (\ (w__5 :  64 words$word) .  aset_X d w__5)))))`;


(*val AddPACDA : mword ty64 -> mword ty64 -> M (mword ty64)*)

val _ = Define `
 ((AddPACDA:(64)words$word ->(64)words$word ->(regstate)sail2_state_monad$sequential_state ->((((64)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) X Y=  (sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (TrapEL2 : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (TrapEL3 : bool) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (Enable : 1 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS APDAKeyHi_EL1_ref  : ( 64 words$word) M) (\ (w__0 : 64 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS APDAKeyLo_EL1_ref  : ( 64 words$word) M) (\ (w__1 : 64 bits) . 
   let (APDAKey_EL1 : 128 bits) =
     ((concat_vec ((slice w__0 (( 0 : int):ii) (( 64 : int):ii)  :  64 words$word))
        ((slice w__1 (( 0 : int):ii) (( 64 : int):ii)  :  64 words$word))
       :  128 words$word)) in sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) . 
   let p__284 = (w__2.ProcState_EL) in
   let pat_0 = p__284 in sail2_state_monad$bindS
   (if (((pat_0 = EL0))) then sail2_state_monad$bindS
      (sail2_state$or_boolS
        (sail2_state$or_boolS (sail2_state_monad$returnS ((~ ((HaveEL EL2)))))
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__3 : 64 bits) . 
            sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__3 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__5 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__5 (( 34 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (IsEL1Regime : bool) .  sail2_state_monad$bindS
      (if IsEL1Regime then sail2_state_monad$bindS
         (sail2_state_monad$read_regS SCTLR_EL1_ref  : ( 32 words$word) M) (\ (w__6 : 32 bits) . 
         sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__6 (( 27 : int):ii)]  :  1 words$word))
       else sail2_state_monad$bindS
         (sail2_state_monad$read_regS SCTLR_EL2_ref  : ( 32 words$word) M) (\ (w__7 : 32 bits) . 
         sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__7 (( 27 : int):ii)]  :  1 words$word))) (\ (w__8 :  1 words$word) . 
      let Enable = w__8 in sail2_state_monad$bindS
      (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveEL EL2)) /\ IsEL1Regime))))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__9 : bool) .  sail2_state_monad$returnS ((~ w__9)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__11 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__11 (( 41 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__12 : bool) . 
      let TrapEL2 = w__12 in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__13 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__13 (( 17 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__14 : bool) . 
      let (TrapEL3 : bool) = w__14 in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3)))))
    else if (((pat_0 = EL1))) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS SCTLR_EL1_ref  : ( 32 words$word) M) (\ (w__15 : 32 bits) . 
      let Enable = ((vec_of_bits [access_vec_dec w__15 (( 27 : int):ii)]  :  1 words$word)) in sail2_state_monad$bindS
      (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__16 : bool) .  sail2_state_monad$returnS ((~ w__16)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__18 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__18 (( 41 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__19 : bool) . 
      let TrapEL2 = w__19 in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__20 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__20 (( 17 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__21 : bool) . 
      let (TrapEL3 : bool) = w__21 in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3))))
    else if (((pat_0 = EL2))) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS SCTLR_EL2_ref  : ( 32 words$word) M) (\ (w__22 : 32 bits) . 
      let Enable = ((vec_of_bits [access_vec_dec w__22 (( 27 : int):ii)]  :  1 words$word)) in
      let TrapEL2 = F in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__23 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__23 (( 17 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) (\ (w__24 : bool) . 
      let (TrapEL3 : bool) = w__24 in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3)))
    else sail2_state_monad$bindS
      (sail2_state_monad$read_regS SCTLR_EL3_ref  : ( 32 words$word) M) (\ (w__25 : 32 bits) . 
      let (Enable : 1 bits) = ((vec_of_bits [access_vec_dec w__25 (( 27 : int):ii)]  :  1 words$word)) in
      let (TrapEL2 : bool) = F in
      let (TrapEL3 : bool) = F in
      sail2_state_monad$returnS (Enable, TrapEL2, TrapEL3))) (\ varstup .  let ((Enable : 1 bits), (TrapEL2 :
     bool), (TrapEL3 : bool)) = varstup in
   if (((Enable = (vec_of_bits [B0]  :  1 words$word)))) then sail2_state_monad$returnS X
   else if TrapEL2 then sail2_state_monad$seqS (TrapPACUse EL2) (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
   else if TrapEL3 then sail2_state_monad$seqS (TrapPACUse EL3) (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
   else (AddPAC X Y APDAKey_EL1 T  : ( 64 words$word) M))))))))))`;


(*val aarch64_integer_pac_pacda_dp_1src : ii -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_integer_pac_pacda_dp_1src:int -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d n source_is_sp=
    (if source_is_sp then sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) d  : ( 64 words$word) M) (\ (w__0 :  64 words$word) .  sail2_state_monad$bindS
     (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M) (\ (w__1 :  64 words$word) .  sail2_state_monad$bindS
     (AddPACDA w__0 w__1  : ( 64 words$word) M) (\ (w__2 :  64 words$word) .  aset_X d w__2)))
   else sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) d  : ( 64 words$word) M) (\ (w__3 :  64 words$word) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) n  : ( 64 words$word) M) (\ (w__4 :  64 words$word) .  sail2_state_monad$bindS
     (AddPACDA w__3 w__4  : ( 64 words$word) M) (\ (w__5 :  64 words$word) .  aset_X d w__5)))))`;


(*val AArch64_WatchpointException : mword ty64 -> FaultRecord -> M unit*)

val _ = Define `
 ((AArch64_WatchpointException:(64)words$word -> FaultRecord ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) vaddress fault=  (sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS (((w__0.ProcState_EL <> EL3))) "((PSTATE).EL != EL3)")
   (sail2_state$and_boolS
     (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__1 : bool) .  sail2_state_monad$returnS ((~ w__1)))))
        (sail2_state$or_boolS
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__3 : ProcState) . 
            sail2_state_monad$returnS (((w__3.ProcState_EL = EL0)))))
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__4 : ProcState) . 
            sail2_state_monad$returnS (((w__4.ProcState_EL = EL1)))))))
     (sail2_state$or_boolS
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__7 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__7 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS MDCR_EL2_ref  : ( 32 words$word) M) (\ (w__8 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__8 (( 8 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))))) (\ (route_to_el2 : bool) .  sail2_state_monad$bindS
   (ThisInstrAddr (( 64 : int):ii) ()   : ( 64 words$word) M) (\ (preferred_exception_return : 64 bits) . 
   let (vect_offset : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
   (AArch64_AbortSyndrome Exception_Watchpoint fault vaddress) (\ (exception : ExceptionRecord) .  sail2_state_monad$bindS
   (sail2_state$or_boolS
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__10 : ProcState) .  sail2_state_monad$returnS (((w__10.ProcState_EL = EL2)))))
     (sail2_state_monad$returnS route_to_el2)) (\ (w__11 : bool) . 
   if w__11 then AArch64_TakeException EL2 exception preferred_exception_return vect_offset
   else AArch64_TakeException EL1 exception preferred_exception_return vect_offset)))))))`;


(*val AArch64_WFxTrap : mword ty2 -> bool -> M unit*)

val _ = Define `
 ((AArch64_WFxTrap:(2)words$word -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) target_el is_wfe=  (sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((lem$w2ui target_el)) > ((lem$w2ui w__0.ProcState_EL)))) "(UInt(target_el) > UInt((PSTATE).EL))")
   (ThisInstrAddr (( 64 : int):ii) ()   : ( 64 words$word) M)) (\ (preferred_exception_return : 64 bits) . 
   let (vect_offset : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
   (ExceptionSyndrome Exception_WFxTrap) (\ (exception : ExceptionRecord) . 
   let (tmp_2720 : 25 bits) = (exception.ExceptionRecord_syndrome) in sail2_state_monad$bindS
   (ConditionSyndrome ()   : ( 5 words$word) M) (\ (w__1 :  5 words$word) . 
   let tmp_2720 = ((set_slice (( 25 : int):ii) (( 5 : int):ii) tmp_2720 (( 20 : int):ii) w__1  :  25 words$word)) in
   let exception = ((exception with<| ExceptionRecord_syndrome := tmp_2720|>)) in
   let (tmp_2730 : 25 bits) = (exception.ExceptionRecord_syndrome) in
   let tmp_2730 =
     ((set_slice (( 25 : int):ii) (( 1 : int):ii) tmp_2730 (( 0 : int):ii)
        (if is_wfe then (vec_of_bits [B1]  :  1 words$word)
         else (vec_of_bits [B0]  :  1 words$word))
       :  25 words$word)) in
   let exception = ((exception with<| ExceptionRecord_syndrome := tmp_2730|>)) in sail2_state_monad$bindS
   (sail2_state$and_boolS
     (sail2_state$and_boolS (sail2_state_monad$returnS ((((((target_el = EL1))) /\ ((HaveEL EL2))))))
        ( sail2_state_monad$bindS(IsSecure () ) (\ (w__2 : bool) .  sail2_state_monad$returnS ((~ w__2)))))
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__4 : 64 bits) . 
      sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__4 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__5 : bool) . 
   if w__5 then AArch64_TakeException EL2 exception preferred_exception_return vect_offset
   else AArch64_TakeException target_el exception preferred_exception_return vect_offset)))))))`;


(*val AArch64_CheckForWFxTrap : mword ty2 -> bool -> M unit*)

val _ = Define `
 ((AArch64_CheckForWFxTrap:(2)words$word -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) target_el is_wfe=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((HaveEL target_el)) "HaveEL(target_el)")
   (sail2_state_monad$undefined_boolS () )) (\ (trap : bool) . 
   let pat_0 = target_el in sail2_state_monad$bindS
   (if (((pat_0 = EL1))) then sail2_state_monad$bindS
      (if is_wfe then sail2_state_monad$bindS
         (aget_SCTLR__1 ()   : ( 32 words$word) M) (\ (w__0 :  32 words$word) . 
         sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__0 (( 18 : int):ii)]  :  1 words$word))
       else sail2_state_monad$bindS
         (aget_SCTLR__1 ()   : ( 32 words$word) M) (\ (w__1 :  32 words$word) . 
         sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__1 (( 16 : int):ii)]  :  1 words$word))) (\ (w__2 :  1 words$word) . 
      let (trap : bool) = (w__2 = (vec_of_bits [B0]  :  1 words$word)) in
      sail2_state_monad$returnS trap)
    else if (((pat_0 = EL2))) then sail2_state_monad$bindS
      (if is_wfe then sail2_state_monad$bindS
         (sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__3 : 64 bits) . 
         sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__3 (( 14 : int):ii)]  :  1 words$word))
       else sail2_state_monad$bindS
         (sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__4 : 64 bits) . 
         sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__4 (( 13 : int):ii)]  :  1 words$word))) (\ (w__5 :  1 words$word) . 
      let (trap : bool) = (w__5 = (vec_of_bits [B1]  :  1 words$word)) in
      sail2_state_monad$returnS trap)
    else sail2_state_monad$bindS
      (if is_wfe then sail2_state_monad$bindS
         (sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__6 : 32 bits) . 
         sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__6 (( 13 : int):ii)]  :  1 words$word))
       else sail2_state_monad$bindS
         (sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__7 : 32 bits) . 
         sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__7 (( 12 : int):ii)]  :  1 words$word))) (\ (w__8 :  1 words$word) . 
      let (trap : bool) = (w__8 = (vec_of_bits [B1]  :  1 words$word)) in
      sail2_state_monad$returnS trap)) (\ (trap : bool) . 
   if trap then AArch64_WFxTrap target_el is_wfe
   else sail2_state_monad$returnS () ))))`;


(*val aarch64_system_hints : SystemHintOp -> M unit*)

val _ = Define `
 ((aarch64_system_hints:SystemHintOp ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) op=
    ((case op of
     SystemHintOp_YIELD => sail2_state_monad$returnS ((Hint_Yield () ))
   | SystemHintOp_WFE => sail2_state_monad$bindS
      (IsEventRegisterSet () ) (\ (w__0 : bool) . 
      if w__0 then ClearEventRegister () 
      else sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__1 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (if (((w__1.ProcState_EL = EL0))) then AArch64_CheckForWFxTrap EL1 T
         else sail2_state_monad$returnS () )
        (sail2_state$and_boolS
          (sail2_state$and_boolS
             (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
                ( sail2_state_monad$bindS(IsSecure () ) (\ (w__2 : bool) .  sail2_state_monad$returnS ((~ w__2)))))
             (sail2_state$or_boolS
                ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__4 : ProcState) . 
                 sail2_state_monad$returnS (((w__4.ProcState_EL = EL0)))))
                ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__5 : ProcState) . 
                 sail2_state_monad$returnS (((w__5.ProcState_EL = EL1)))))))
          ( sail2_state_monad$bindS(IsInHost () ) (\ (w__8 : bool) .  sail2_state_monad$returnS ((~ w__8)))))) (\ (w__9 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (if w__9 then AArch64_CheckForWFxTrap EL2 T
         else sail2_state_monad$returnS () )
        (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__10 : ProcState) . 
           sail2_state_monad$returnS (((w__10.ProcState_EL <> EL3))))))) (\ (w__11 : bool) .  sail2_state_monad$seqS
        (if w__11 then AArch64_CheckForWFxTrap EL3 T else sail2_state_monad$returnS () ) (WaitForEvent () )))))
   | SystemHintOp_WFI => sail2_state_monad$bindS
      (InterruptPending () ) (\ (w__12 : bool) . 
      if ((~ w__12)) then sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__13 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (if (((w__13.ProcState_EL = EL0))) then AArch64_CheckForWFxTrap EL1 F
         else sail2_state_monad$returnS () )
        (sail2_state$and_boolS
          (sail2_state$and_boolS
             (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
                ( sail2_state_monad$bindS(IsSecure () ) (\ (w__14 : bool) .  sail2_state_monad$returnS ((~ w__14)))))
             (sail2_state$or_boolS
                ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__16 : ProcState) . 
                 sail2_state_monad$returnS (((w__16.ProcState_EL = EL0)))))
                ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__17 : ProcState) . 
                 sail2_state_monad$returnS (((w__17.ProcState_EL = EL1)))))))
          ( sail2_state_monad$bindS(IsInHost () ) (\ (w__20 : bool) .  sail2_state_monad$returnS ((~ w__20)))))) (\ (w__21 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (if w__21 then AArch64_CheckForWFxTrap EL2 F
         else sail2_state_monad$returnS () )
        (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__22 : ProcState) . 
           sail2_state_monad$returnS (((w__22.ProcState_EL <> EL3))))))) (\ (w__23 : bool) .  sail2_state_monad$seqS
        (if w__23 then AArch64_CheckForWFxTrap EL3 F else sail2_state_monad$returnS () ) (WaitForInterrupt () ))))
      else sail2_state_monad$returnS () )
   | SystemHintOp_SEV => SendEvent () 
   | SystemHintOp_SEVL => SendEventLocal () 
   | SystemHintOp_ESB =>
      let (_ : unit) = (ErrorSynchronizationBarrier MBReqDomain_FullSystem MBReqTypes_All) in sail2_state_monad$bindS (sail2_state_monad$seqS
      (AArch64_ESBOperation () )
      (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__24 : bool) .  sail2_state_monad$returnS ((~ w__24)))))
        (sail2_state$or_boolS
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__26 : ProcState) . 
            sail2_state_monad$returnS (((w__26.ProcState_EL = EL0)))))
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__27 : ProcState) . 
            sail2_state_monad$returnS (((w__27.ProcState_EL = EL1)))))))) (\ (w__29 : bool) .  sail2_state_monad$seqS
      (if w__29 then AArch64_vESBOperation ()  else sail2_state_monad$returnS () ) (TakeUnmaskedSErrorInterrupts () ))
   | SystemHintOp_PSB => sail2_state_monad$returnS ((ProfilingSynchronizationBarrier () ))
   | _ => sail2_state_monad$returnS () 
   )))`;


(*val system_hints_decode : mword ty1 -> mword ty2 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty3 -> mword ty5 -> M unit*)

val _ = Define `
 ((system_hints_decode:(1)words$word ->(2)words$word ->(3)words$word ->(4)words$word ->(4)words$word ->(3)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) L op0 op1 CRn CRm op2 Rt=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (undefined_SystemHintOp () )) (\ (op : SystemHintOp) . 
   let b__0 = ((concat_vec CRm op2  :  7 words$word)) in sail2_state_monad$bindS
   (if (((b__0 = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  :  7 words$word)))) then
      sail2_state_monad$returnS SystemHintOp_NOP
    else if (((b__0 = (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  :  7 words$word)))) then
      sail2_state_monad$returnS SystemHintOp_YIELD
    else if (((b__0 = (vec_of_bits [B0;B0;B0;B0;B0;B1;B0]  :  7 words$word)))) then
      sail2_state_monad$returnS SystemHintOp_WFE
    else if (((b__0 = (vec_of_bits [B0;B0;B0;B0;B0;B1;B1]  :  7 words$word)))) then
      sail2_state_monad$returnS SystemHintOp_WFI
    else if (((b__0 = (vec_of_bits [B0;B0;B0;B0;B1;B0;B0]  :  7 words$word)))) then
      sail2_state_monad$returnS SystemHintOp_SEV
    else if (((b__0 = (vec_of_bits [B0;B0;B0;B0;B1;B0;B1]  :  7 words$word)))) then
      sail2_state_monad$returnS SystemHintOp_SEVL
    else if (((b__0 = (vec_of_bits [B0;B0;B0;B0;B1;B1;B1]  :  7 words$word)))) then sail2_state_monad$seqS
      (sail2_state_monad$throwS (Error_See "XPACLRI")) (sail2_state_monad$returnS op)
    else if (((((subrange_vec_dec b__0 (( 6 : int):ii) (( 3 : int):ii)  :  4 words$word)) = (vec_of_bits [B0;B0;B0;B1]  :  4 words$word)))) then sail2_state_monad$seqS
      (sail2_state_monad$throwS (Error_See "PACIA1716, PACIB1716, AUTIA1716, AUTIB1716")) (sail2_state_monad$returnS op)
    else if (((b__0 = (vec_of_bits [B0;B0;B1;B0;B0;B0;B0]  :  7 words$word)))) then sail2_state_monad$seqS
      (if ((~ ((HaveRASExt () )))) then EndOfInstruction () 
       else sail2_state_monad$returnS () )
      (sail2_state_monad$returnS SystemHintOp_ESB)
    else if (((b__0 = (vec_of_bits [B0;B0;B1;B0;B0;B0;B1]  :  7 words$word)))) then sail2_state_monad$seqS
      (if ((~ ((HaveStatisticalProfiling () )))) then EndOfInstruction () 
       else sail2_state_monad$returnS () )
      (sail2_state_monad$returnS SystemHintOp_PSB)
    else sail2_state_monad$seqS
      (if (((((subrange_vec_dec b__0 (( 6 : int):ii) (( 3 : int):ii)  :  4 words$word)) = (vec_of_bits [B0;B0;B1;B1]  :  4 words$word)))) then
         sail2_state_monad$throwS (Error_See "PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP")
       else EndOfInstruction () )
      (sail2_state_monad$returnS op)) (\ (op : SystemHintOp) . 
   aarch64_system_hints op))))`;


(*val AArch64_VectorCatchException : FaultRecord -> M unit*)

val _ = Define `
 ((AArch64_VectorCatchException:FaultRecord ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) fault=  (sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS (((w__0.ProcState_EL <> EL2))) "((PSTATE).EL != EL2)")
   (sail2_state$and_boolS
     (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2))) ( sail2_state_monad$bindS(IsSecure () ) (\ (w__1 : bool) .  sail2_state_monad$returnS ((~ w__1)))))
     (sail2_state$or_boolS
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__3 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__3 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS MDCR_EL2_ref  : ( 32 words$word) M) (\ (w__4 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__4 (( 8 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))))) (\ (w__6 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS w__6 "((HaveEL(EL2) && !(IsSecure())) && (((HCR_EL2).TGE == '1') || ((MDCR_EL2).TDE == '1')))")
   (ThisInstrAddr (( 64 : int):ii) ()   : ( 64 words$word) M)) (\ (preferred_exception_return : 64 bits) . 
   let (vect_offset : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (vaddress : 64 bits) .  sail2_state_monad$bindS
   (AArch64_AbortSyndrome Exception_VectorCatch fault vaddress) (\ (exception : ExceptionRecord) . 
   AArch64_TakeException EL2 exception preferred_exception_return vect_offset)))))))`;


(*val AArch64_UndefinedFault : unit -> M unit*)

val _ = Define `
 ((AArch64_UndefinedFault:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (sail2_state$and_boolS
     (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__0 : bool) .  sail2_state_monad$returnS ((~ w__0)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) .  sail2_state_monad$returnS (((w__2.ProcState_EL = EL0))))))
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__4 : 64 bits) . 
      sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__4 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (route_to_el2 : bool) .  sail2_state_monad$bindS
   (ThisInstrAddr (( 64 : int):ii) ()   : ( 64 words$word) M) (\ (preferred_exception_return : 64 bits) . 
   let (vect_offset : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
   (ExceptionSyndrome Exception_Uncategorized) (\ (exception : ExceptionRecord) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__5 : ProcState) . 
   if ((((lem$w2ui w__5.ProcState_EL)) > ((lem$w2ui EL1)))) then sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__6 : ProcState) . 
     AArch64_TakeException w__6.ProcState_EL exception preferred_exception_return vect_offset)
   else if route_to_el2 then
     AArch64_TakeException EL2 exception preferred_exception_return vect_offset
   else AArch64_TakeException EL1 exception preferred_exception_return vect_offset))))))`;


(*val AArch64_SystemRegisterTrap : mword ty2 -> mword ty2 -> mword ty3 -> mword ty3 -> mword ty4 -> mword ty5 -> mword ty4 -> mword ty1 -> M unit*)

val _ = Define `
 ((AArch64_SystemRegisterTrap:(2)words$word ->(2)words$word ->(3)words$word ->(3)words$word ->(4)words$word ->(5)words$word ->(4)words$word ->(1)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) target_el op0 op2 op1 crn rt crm dir=  (sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((lem$w2ui target_el)) >= ((lem$w2ui w__0.ProcState_EL)))) "(UInt(target_el) >= UInt((PSTATE).EL))")
   (ThisInstrAddr (( 64 : int):ii) ()   : ( 64 words$word) M)) (\ (preferred_exception_return : 64 bits) . 
   let (vect_offset : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
   (ExceptionSyndrome Exception_SystemRegisterTrap) (\ (exception : ExceptionRecord) . 
   let (tmp_2800 : 25 bits) = (exception.ExceptionRecord_syndrome) in
   let tmp_2800 = ((set_slice (( 25 : int):ii) (( 2 : int):ii) tmp_2800 (( 20 : int):ii) op0  :  25 words$word)) in
   let exception = ((exception with<| ExceptionRecord_syndrome := tmp_2800|>)) in
   let (tmp_2810 : 25 bits) = (exception.ExceptionRecord_syndrome) in
   let tmp_2810 = ((set_slice (( 25 : int):ii) (( 3 : int):ii) tmp_2810 (( 17 : int):ii) op2  :  25 words$word)) in
   let exception = ((exception with<| ExceptionRecord_syndrome := tmp_2810|>)) in
   let (tmp_2820 : 25 bits) = (exception.ExceptionRecord_syndrome) in
   let tmp_2820 = ((set_slice (( 25 : int):ii) (( 3 : int):ii) tmp_2820 (( 14 : int):ii) op1  :  25 words$word)) in
   let exception = ((exception with<| ExceptionRecord_syndrome := tmp_2820|>)) in
   let (tmp_2830 : 25 bits) = (exception.ExceptionRecord_syndrome) in
   let tmp_2830 = ((set_slice (( 25 : int):ii) (( 4 : int):ii) tmp_2830 (( 10 : int):ii) crn  :  25 words$word)) in
   let exception = ((exception with<| ExceptionRecord_syndrome := tmp_2830|>)) in
   let (tmp_2840 : 25 bits) = (exception.ExceptionRecord_syndrome) in
   let tmp_2840 = ((set_slice (( 25 : int):ii) (( 5 : int):ii) tmp_2840 (( 5 : int):ii) rt  :  25 words$word)) in
   let exception = ((exception with<| ExceptionRecord_syndrome := tmp_2840|>)) in
   let (tmp_2850 : 25 bits) = (exception.ExceptionRecord_syndrome) in
   let tmp_2850 = ((set_slice (( 25 : int):ii) (( 4 : int):ii) tmp_2850 (( 1 : int):ii) crm  :  25 words$word)) in
   let exception = ((exception with<| ExceptionRecord_syndrome := tmp_2850|>)) in
   let (tmp_2860 : 25 bits) = (exception.ExceptionRecord_syndrome) in
   let tmp_2860 = ((set_slice (( 25 : int):ii) (( 1 : int):ii) tmp_2860 (( 0 : int):ii) dir  :  25 words$word)) in
   let exception = ((exception with<| ExceptionRecord_syndrome := tmp_2860|>)) in sail2_state_monad$bindS
   (sail2_state$and_boolS
     (sail2_state$and_boolS (sail2_state_monad$returnS ((((((target_el = EL1))) /\ ((HaveEL EL2))))))
        ( sail2_state_monad$bindS(IsSecure () ) (\ (w__1 : bool) .  sail2_state_monad$returnS ((~ w__1)))))
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__3 : 64 bits) . 
      sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__3 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__4 : bool) . 
   if w__4 then AArch64_TakeException EL2 exception preferred_exception_return vect_offset
   else AArch64_TakeException target_el exception preferred_exception_return vect_offset))))))`;


(*val AArch64_SoftwareBreakpoint : mword ty16 -> M unit*)

val _ = Define `
 ((AArch64_SoftwareBreakpoint:(16)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) immediate=  (sail2_state_monad$bindS
   (sail2_state$and_boolS
     (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__0 : bool) .  sail2_state_monad$returnS ((~ w__0)))))
        (sail2_state$or_boolS
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) . 
            sail2_state_monad$returnS (((w__2.ProcState_EL = EL0)))))
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__3 : ProcState) . 
            sail2_state_monad$returnS (((w__3.ProcState_EL = EL1)))))))
     (sail2_state$or_boolS
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__6 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__6 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS MDCR_EL2_ref  : ( 32 words$word) M) (\ (w__7 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__7 (( 8 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))) (\ (route_to_el2 : bool) .  sail2_state_monad$bindS
   (ThisInstrAddr (( 64 : int):ii) ()   : ( 64 words$word) M) (\ (preferred_exception_return : 64 bits) . 
   let (vect_offset : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
   (ExceptionSyndrome Exception_SoftwareBreakpoint) (\ (exception : ExceptionRecord) . 
   let (tmp_2710 : 25 bits) = (exception.ExceptionRecord_syndrome) in
   let tmp_2710 = ((set_slice (( 25 : int):ii) (( 16 : int):ii) tmp_2710 (( 0 : int):ii) immediate  :  25 words$word)) in
   let exception = ((exception with<| ExceptionRecord_syndrome := tmp_2710|>)) in sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__9 : ProcState) . 
   if ((((lem$w2ui w__9.ProcState_EL)) > ((lem$w2ui EL1)))) then sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__10 : ProcState) . 
     AArch64_TakeException w__10.ProcState_EL exception preferred_exception_return vect_offset)
   else if route_to_el2 then
     AArch64_TakeException EL2 exception preferred_exception_return vect_offset
   else AArch64_TakeException EL1 exception preferred_exception_return vect_offset))))))`;


(*val aarch64_system_exceptions_debug_breakpoint : mword ty16 -> M unit*)

val _ = Define `
 ((aarch64_system_exceptions_debug_breakpoint:(16)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) comment=  (AArch64_SoftwareBreakpoint comment))`;


(*val system_exceptions_debug_breakpoint_decode : mword ty3 -> mword ty16 -> mword ty3 -> mword ty2 -> M unit*)

val _ = Define `
 ((system_exceptions_debug_breakpoint_decode:(3)words$word ->(16)words$word ->(3)words$word ->(2)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) opc imm16 op2 LL=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (comment : 16 bits) = imm16 in
   aarch64_system_exceptions_debug_breakpoint comment)))`;


(*val AArch64_SPAlignmentFault : unit -> M unit*)

val _ = Define `
 ((AArch64_SPAlignmentFault:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (ThisInstrAddr (( 64 : int):ii) ()   : ( 64 words$word) M) (\ (preferred_exception_return : 64 bits) . 
   let (vect_offset : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
   (ExceptionSyndrome Exception_SPAlignment) (\ (exception : ExceptionRecord) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) . 
   if ((((lem$w2ui w__0.ProcState_EL)) > ((lem$w2ui EL1)))) then sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__1 : ProcState) . 
     AArch64_TakeException w__1.ProcState_EL exception preferred_exception_return vect_offset)
   else sail2_state_monad$bindS
     (sail2_state$and_boolS
       (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2))) ( sail2_state_monad$bindS(IsSecure () ) (\ (w__2 : bool) .  sail2_state_monad$returnS ((~ w__2)))))
       ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__4 : 64 bits) . 
        sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__4 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__5 : bool) . 
     if w__5 then AArch64_TakeException EL2 exception preferred_exception_return vect_offset
     else AArch64_TakeException EL1 exception preferred_exception_return vect_offset))))))`;


(*val CheckSPAlignment : unit -> M unit*)

val _ = Define `
 ((CheckSPAlignment:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M) (\ (sp : 64 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (stack_align_check : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) .  sail2_state_monad$bindS
   (if (((w__0.ProcState_EL = EL0))) then sail2_state_monad$bindS
      (aget_SCTLR__1 ()   : ( 32 words$word) M) (\ (w__1 :  32 words$word) . 
      let (stack_align_check : bool) =
        ((vec_of_bits [access_vec_dec w__1 (( 4 : int):ii)]  :  1 words$word) <> (vec_of_bits [B0]  :  1 words$word)) in
      sail2_state_monad$returnS stack_align_check)
    else sail2_state_monad$bindS
      (aget_SCTLR__1 ()   : ( 32 words$word) M) (\ (w__2 :  32 words$word) . 
      let (stack_align_check : bool) =
        ((vec_of_bits [access_vec_dec w__2 (( 3 : int):ii)]  :  1 words$word) <> (vec_of_bits [B0]  :  1 words$word)) in
      sail2_state_monad$returnS stack_align_check)) (\ (stack_align_check : bool) . 
   if (((stack_align_check /\ (((sp <> ((Align__1 sp (( 16 : int):ii)  :  64 words$word)))))))) then
     AArch64_SPAlignmentFault () 
   else sail2_state_monad$returnS () ))))))`;


(*val AArch64_InstructionAbort : mword ty64 -> FaultRecord -> M unit*)

val _ = Define `
 ((AArch64_InstructionAbort:(64)words$word -> FaultRecord ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) vaddress fault=  (sail2_state_monad$bindS
   (sail2_state$and_boolS
     (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__0 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__0 (( 3 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) ((IsExternalAbort__1 fault))) (\ (route_to_el3 :
     bool) .  sail2_state_monad$bindS
   (sail2_state$and_boolS
     (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__3 : bool) .  sail2_state_monad$returnS ((~ w__3)))))
        (sail2_state$or_boolS
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__5 : ProcState) . 
            sail2_state_monad$returnS (((w__5.ProcState_EL = EL0)))))
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__6 : ProcState) . 
            sail2_state_monad$returnS (((w__6.ProcState_EL = EL1)))))))
     (sail2_state$or_boolS
        (sail2_state$or_boolS
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__9 : 64 bits) . 
            sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__9 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))) ((IsSecondStage fault)))
        (sail2_state$and_boolS
           (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveRASExt () )))
              ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__12 : 64 bits) . 
               sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__12 (( 37 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) ((IsExternalAbort__1 fault))))) (\ (route_to_el2 :
     bool) .  sail2_state_monad$bindS
   (ThisInstrAddr (( 64 : int):ii) ()   : ( 64 words$word) M) (\ (preferred_exception_return : 64 bits) . 
   let (vect_offset : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
   (AArch64_AbortSyndrome Exception_InstructionAbort fault vaddress) (\ (exception :
     ExceptionRecord) .  sail2_state_monad$bindS
   (sail2_state$or_boolS
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__17 : ProcState) .  sail2_state_monad$returnS (((w__17.ProcState_EL = EL3)))))
     (sail2_state_monad$returnS route_to_el3)) (\ (w__18 : bool) . 
   if w__18 then AArch64_TakeException EL3 exception preferred_exception_return vect_offset
   else sail2_state_monad$bindS
     (sail2_state$or_boolS
       ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__19 : ProcState) .  sail2_state_monad$returnS (((w__19.ProcState_EL = EL2)))))
       (sail2_state_monad$returnS route_to_el2)) (\ (w__20 : bool) . 
     if w__20 then AArch64_TakeException EL2 exception preferred_exception_return vect_offset
     else AArch64_TakeException EL1 exception preferred_exception_return vect_offset))))))))`;


(*val AArch64_DataAbort : mword ty64 -> FaultRecord -> M unit*)

val _ = Define `
 ((AArch64_DataAbort:(64)words$word -> FaultRecord ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) vaddress fault=  (sail2_state_monad$bindS
   (sail2_state$and_boolS
     (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__0 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__0 (( 3 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) ((IsExternalAbort__1 fault))) (\ (route_to_el3 :
     bool) .  sail2_state_monad$bindS
   (sail2_state$and_boolS
     (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__3 : bool) .  sail2_state_monad$returnS ((~ w__3)))))
        (sail2_state$or_boolS
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__5 : ProcState) . 
            sail2_state_monad$returnS (((w__5.ProcState_EL = EL0)))))
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__6 : ProcState) . 
            sail2_state_monad$returnS (((w__6.ProcState_EL = EL1)))))))
     (sail2_state$or_boolS
        (sail2_state$or_boolS
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__9 : 64 bits) . 
            sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__9 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))) ((IsSecondStage fault)))
        (sail2_state$and_boolS
           (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveRASExt () )))
              ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__12 : 64 bits) . 
               sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__12 (( 37 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) ((IsExternalAbort__1 fault))))) (\ (route_to_el2 :
     bool) .  sail2_state_monad$bindS
   (ThisInstrAddr (( 64 : int):ii) ()   : ( 64 words$word) M) (\ (preferred_exception_return : 64 bits) . 
   let (vect_offset : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
   (AArch64_AbortSyndrome Exception_DataAbort fault vaddress) (\ (exception : ExceptionRecord) .  sail2_state_monad$bindS
   (sail2_state$or_boolS
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__17 : ProcState) .  sail2_state_monad$returnS (((w__17.ProcState_EL = EL3)))))
     (sail2_state_monad$returnS route_to_el3)) (\ (w__18 : bool) . 
   if w__18 then AArch64_TakeException EL3 exception preferred_exception_return vect_offset
   else sail2_state_monad$bindS
     (sail2_state$or_boolS
       ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__19 : ProcState) .  sail2_state_monad$returnS (((w__19.ProcState_EL = EL2)))))
       (sail2_state_monad$returnS route_to_el2)) (\ (w__20 : bool) . 
     if w__20 then AArch64_TakeException EL2 exception preferred_exception_return vect_offset
     else AArch64_TakeException EL1 exception preferred_exception_return vect_offset))))))))`;


(*val AArch64_CheckForERetTrap : bool -> bool -> M unit*)

val _ = Define `
 ((AArch64_CheckForERetTrap:bool -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) eret_with_pac pac_uses_key_a=  (sail2_state_monad$bindS
   (sail2_state$and_boolS
     (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveNVExt () )) /\ ((HaveEL EL2))))))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__0 : bool) .  sail2_state_monad$returnS ((~ w__0)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) .  sail2_state_monad$returnS (((w__2.ProcState_EL = EL1))))))
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__4 : 64 bits) . 
      sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__4 (( 42 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (route_to_el2 : bool) .  sail2_state_monad$bindS
   (undefined_int () ) (\ (vect_offset : ii) . 
   if route_to_el2 then sail2_state_monad$bindS
     (undefined_ExceptionRecord () ) (\ (exception : ExceptionRecord) .  sail2_state_monad$bindS
     (ThisInstrAddr (( 64 : int):ii) ()   : ( 64 words$word) M) (\ (preferred_exception_return : 64 bits) . 
     let vect_offset = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (ExceptionSyndrome Exception_ERetTrap) (\ (w__5 : ExceptionRecord) . 
     let exception = w__5 in
     let (tmp_2550 : 25 bits) = (exception.ExceptionRecord_syndrome) in sail2_state_monad$bindS
     (ZeroExtend__0 (vec_of_bits [B0]  :  1 words$word) ((make_the_value (( 23 : int):ii)  :  23 itself))
       : ( 23 words$word) M) (\ (w__6 :  23 words$word) . 
     let tmp_2550 = ((set_slice (( 25 : int):ii) (( 23 : int):ii) tmp_2550 (( 2 : int):ii) w__6  :  25 words$word)) in
     let exception = ((exception with<| ExceptionRecord_syndrome := tmp_2550|>)) in
     let (exception : ExceptionRecord) =
       (if ((~ eret_with_pac)) then
         let (tmp_2560 : 25 bits) = (exception.ExceptionRecord_syndrome) in
         let (tmp_2560 : 25 bits) =
           ((set_slice (( 25 : int):ii) (( 1 : int):ii) tmp_2560 (( 1 : int):ii) (vec_of_bits [B0]  :  1 words$word)  :  25 words$word)) in
         let (exception : ExceptionRecord) = ((exception with<| ExceptionRecord_syndrome := tmp_2560|>)) in
         let (tmp_2570 : 25 bits) = (exception.ExceptionRecord_syndrome) in
         let (tmp_2570 : 25 bits) =
           ((set_slice (( 25 : int):ii) (( 1 : int):ii) tmp_2570 (( 0 : int):ii) (vec_of_bits [B0]  :  1 words$word)  :  25 words$word)) in
         (exception with<| ExceptionRecord_syndrome := tmp_2570|>)
       else
         let (tmp_2580 : 25 bits) = (exception.ExceptionRecord_syndrome) in
         let (tmp_2580 : 25 bits) =
           ((set_slice (( 25 : int):ii) (( 1 : int):ii) tmp_2580 (( 1 : int):ii) (vec_of_bits [B1]  :  1 words$word)  :  25 words$word)) in
         let (exception : ExceptionRecord) = ((exception with<| ExceptionRecord_syndrome := tmp_2580|>)) in
         if pac_uses_key_a then
           let (tmp_2590 : 25 bits) = (exception.ExceptionRecord_syndrome) in
           let (tmp_2590 : 25 bits) =
             ((set_slice (( 25 : int):ii) (( 1 : int):ii) tmp_2590 (( 0 : int):ii) (vec_of_bits [B0]  :  1 words$word)
               :  25 words$word)) in
           (exception with<| ExceptionRecord_syndrome := tmp_2590|>)
         else
           let (tmp_2600 : 25 bits) = (exception.ExceptionRecord_syndrome) in
           let (tmp_2600 : 25 bits) =
             ((set_slice (( 25 : int):ii) (( 1 : int):ii) tmp_2600 (( 0 : int):ii) (vec_of_bits [B1]  :  1 words$word)
               :  25 words$word)) in
           (exception with<| ExceptionRecord_syndrome := tmp_2600|>)) in
     AArch64_TakeException EL2 exception preferred_exception_return vect_offset))))
   else sail2_state_monad$returnS () ))))`;


(*val AArch64_CallSupervisor : mword ty16 -> M unit*)

val _ = Define `
 ((AArch64_CallSupervisor:(16)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) immediate=  (sail2_state_monad$bindS
   (UsingAArch32 () ) (\ (w__0 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (if w__0 then AArch32_ITAdvance () 
    else sail2_state_monad$returnS () )
   (SSAdvance () ))
   (sail2_state$and_boolS
     (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__1 : bool) .  sail2_state_monad$returnS ((~ w__1)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__3 : ProcState) .  sail2_state_monad$returnS (((w__3.ProcState_EL = EL0))))))
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__5 : 64 bits) . 
      sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__5 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))) (\ (route_to_el2 : bool) .  sail2_state_monad$bindS
   (NextInstrAddr (( 64 : int):ii) ()   : ( 64 words$word) M) (\ (preferred_exception_return : 64 bits) . 
   let (vect_offset : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
   (ExceptionSyndrome Exception_SupervisorCall) (\ (exception : ExceptionRecord) . 
   let (tmp_2770 : 25 bits) = (exception.ExceptionRecord_syndrome) in
   let tmp_2770 = ((set_slice (( 25 : int):ii) (( 16 : int):ii) tmp_2770 (( 0 : int):ii) immediate  :  25 words$word)) in
   let exception = ((exception with<| ExceptionRecord_syndrome := tmp_2770|>)) in sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__6 : ProcState) . 
   if ((((lem$w2ui w__6.ProcState_EL)) > ((lem$w2ui EL1)))) then sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__7 : ProcState) . 
     AArch64_TakeException w__7.ProcState_EL exception preferred_exception_return vect_offset)
   else if route_to_el2 then
     AArch64_TakeException EL2 exception preferred_exception_return vect_offset
   else AArch64_TakeException EL1 exception preferred_exception_return vect_offset)))))))`;


(*val aarch64_system_exceptions_runtime_svc : mword ty16 -> M unit*)

val _ = Define `
 ((aarch64_system_exceptions_runtime_svc:(16)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) imm=  (AArch64_CallSupervisor imm))`;


(*val system_exceptions_runtime_svc_decode : mword ty3 -> mword ty16 -> mword ty3 -> mword ty2 -> M unit*)

val _ = Define `
 ((system_exceptions_runtime_svc_decode:(3)words$word ->(16)words$word ->(3)words$word ->(2)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) opc imm16 op2 LL=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (imm : 16 bits) = imm16 in
   aarch64_system_exceptions_runtime_svc imm)))`;


(*val AArch64_CallSecureMonitor : mword ty16 -> M unit*)

val _ = Define `
 ((AArch64_CallSecureMonitor:(16)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) immediate=  (sail2_state_monad$bindS
   (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3)))
     ( sail2_state_monad$bindS(ELUsingAArch32 EL3) (\ (w__0 : bool) .  sail2_state_monad$returnS ((~ w__0))))) (\ (w__1 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS w__1 "(HaveEL(EL3) && !(ELUsingAArch32(EL3)))")
   (UsingAArch32 () )) (\ (w__2 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (if w__2 then AArch32_ITAdvance () 
    else sail2_state_monad$returnS () )
   (SSAdvance () ))
   (NextInstrAddr (( 64 : int):ii) ()   : ( 64 words$word) M)) (\ (preferred_exception_return : 64 bits) . 
   let (vect_offset : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
   (ExceptionSyndrome Exception_MonitorCall) (\ (exception : ExceptionRecord) . 
   let (tmp_2930 : 25 bits) = (exception.ExceptionRecord_syndrome) in
   let tmp_2930 = ((set_slice (( 25 : int):ii) (( 16 : int):ii) tmp_2930 (( 0 : int):ii) immediate  :  25 words$word)) in
   let exception = ((exception with<| ExceptionRecord_syndrome := tmp_2930|>)) in
   AArch64_TakeException EL3 exception preferred_exception_return vect_offset))))))`;


(*val AArch64_CallHypervisor : mword ty16 -> M unit*)

val _ = Define `
 ((AArch64_CallHypervisor:(16)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) immediate=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((HaveEL EL2)) "HaveEL(EL2)")
   (UsingAArch32 () )) (\ (w__0 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (if w__0 then AArch32_ITAdvance () 
    else sail2_state_monad$returnS () )
   (SSAdvance () ))
   (NextInstrAddr (( 64 : int):ii) ()   : ( 64 words$word) M)) (\ (preferred_exception_return : 64 bits) . 
   let (vect_offset : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
   (ExceptionSyndrome Exception_HypervisorCall) (\ (exception : ExceptionRecord) . 
   let (tmp_2890 : 25 bits) = (exception.ExceptionRecord_syndrome) in
   let tmp_2890 = ((set_slice (( 25 : int):ii) (( 16 : int):ii) tmp_2890 (( 0 : int):ii) immediate  :  25 words$word)) in
   let exception = ((exception with<| ExceptionRecord_syndrome := tmp_2890|>)) in sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__1 : ProcState) . 
   if (((w__1.ProcState_EL = EL3))) then
     AArch64_TakeException EL3 exception preferred_exception_return vect_offset
   else AArch64_TakeException EL2 exception preferred_exception_return vect_offset))))))`;


(*val AArch64_BreakpointException : FaultRecord -> M unit*)

val _ = Define `
 ((AArch64_BreakpointException:FaultRecord ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) fault=  (sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS (((w__0.ProcState_EL <> EL3))) "((PSTATE).EL != EL3)")
   (sail2_state$and_boolS
     (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__1 : bool) .  sail2_state_monad$returnS ((~ w__1)))))
        (sail2_state$or_boolS
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__3 : ProcState) . 
            sail2_state_monad$returnS (((w__3.ProcState_EL = EL0)))))
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__4 : ProcState) . 
            sail2_state_monad$returnS (((w__4.ProcState_EL = EL1)))))))
     (sail2_state$or_boolS
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__7 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__7 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS MDCR_EL2_ref  : ( 32 words$word) M) (\ (w__8 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__8 (( 8 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))))) (\ (route_to_el2 : bool) .  sail2_state_monad$bindS
   (ThisInstrAddr (( 64 : int):ii) ()   : ( 64 words$word) M) (\ (preferred_exception_return : 64 bits) . 
   let (vect_offset : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (vaddress : 64 bits) .  sail2_state_monad$bindS
   (AArch64_AbortSyndrome Exception_Breakpoint fault vaddress) (\ (exception : ExceptionRecord) .  sail2_state_monad$bindS
   (sail2_state$or_boolS
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__10 : ProcState) .  sail2_state_monad$returnS (((w__10.ProcState_EL = EL2)))))
     (sail2_state_monad$returnS route_to_el2)) (\ (w__11 : bool) . 
   if w__11 then AArch64_TakeException EL2 exception preferred_exception_return vect_offset
   else AArch64_TakeException EL1 exception preferred_exception_return vect_offset))))))))`;


(*val AArch64_Abort : mword ty64 -> FaultRecord -> M unit*)

val _ = Define `
 ((AArch64_Abort:(64)words$word -> FaultRecord ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) vaddress fault=  (sail2_state_monad$bindS
   (IsDebugException fault) (\ (w__0 : bool) . 
   if w__0 then
     if (((fault.FaultRecord_acctype = AccType_IFETCH))) then sail2_state_monad$bindS
       (sail2_state$and_boolS ((UsingAArch32 () ))
         (sail2_state_monad$returnS (((fault.FaultRecord_debugmoe = DebugException_VectorCatch))))) (\ (w__2 :
         bool) . 
       if w__2 then AArch64_VectorCatchException fault
       else AArch64_BreakpointException fault)
     else AArch64_WatchpointException vaddress fault
   else if (((fault.FaultRecord_acctype = AccType_IFETCH))) then
     AArch64_InstructionAbort vaddress fault
   else AArch64_DataAbort vaddress fault)))`;


(*val AArch64_CheckAlignment : mword ty64 -> ii -> AccType -> bool -> M bool*)

val _ = Define `
 ((AArch64_CheckAlignment:(64)words$word -> int -> AccType -> bool ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) address alignment acctype iswrite=
    (let (aligned : bool) = (address = ((Align__1 address alignment  :  64 words$word))) in
   let (atomic : bool) = ((((acctype = AccType_ATOMIC))) \/ (((acctype = AccType_ATOMICRW)))) in
   let (ordered : bool) =
     ((((acctype = AccType_ORDERED))) \/ ((((((acctype = AccType_ORDEREDRW))) \/ (((acctype = AccType_LIMITEDORDERED))))))) in
   let (vector_name : bool) = (acctype = AccType_VEC) in sail2_state_monad$bindS
   (sail2_state$or_boolS (sail2_state_monad$returnS (((atomic \/ ordered))))
     ( sail2_state_monad$bindS(aget_SCTLR__1 ()   : ( 32 words$word) M) (\ (w__0 :  32 words$word) . 
      sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__0 (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (check' : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (secondstage : bool) .  sail2_state_monad$seqS
   (if (((check' /\ ((~ aligned))))) then
      let secondstage = F in sail2_state_monad$bindS
      (AArch64_AlignmentFault acctype iswrite secondstage) (\ (w__1 : FaultRecord) . 
      AArch64_Abort address w__1)
    else sail2_state_monad$returnS () )
   (sail2_state_monad$returnS aligned)))))`;


(*val AArch32_EnterMode : mword ty5 -> mword ty32 -> ii -> ii -> M unit*)

val _ = Define `
 ((AArch32_EnterMode:(5)words$word ->(32)words$word -> int -> int ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) target_mode preferred_exception_return lr_offset vect_offset=
    (let (_ : unit) = (SynchronizeContext () ) in sail2_state_monad$bindS
   (sail2_state$and_boolS ((ELUsingAArch32 EL1))
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__1 : ProcState) .  sail2_state_monad$returnS (((w__1.ProcState_EL <> EL2)))))) (\ (w__2 :
     bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS w__2 "(ELUsingAArch32(EL1) && ((PSTATE).EL != EL2))")
   (GetPSRFromPSTATE ()   : ( 32 words$word) M)) (\ (spsr : 32 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__3 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (if (((w__3.ProcState_M = M32_Monitor))) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS SCR_ref  : ( 32 words$word) M) (\ (w__4 :  32 words$word) . 
      sail2_state_monad$write_regS
        SCR_ref
        ((set_slice (( 32 : int):ii) (( 1 : int):ii) w__4 (( 0 : int):ii) (vec_of_bits [B0]  :  1 words$word)  :  32 words$word)))
    else sail2_state_monad$returnS () )
   (AArch32_WriteMode target_mode))
   (aset_SPSR spsr))
   (aset_R (( 14 : int):ii) ((add_vec_int preferred_exception_return lr_offset  :  32 words$word))))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__5 : ProcState) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS SCTLR_ref  : ( 32 words$word) M) (\ (w__6 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS
     PSTATE_ref
     (w__5 with<| ProcState_T := ((vec_of_bits [access_vec_dec w__6 (( 30 : int):ii)]  :  1 words$word))|>))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__7 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__7 with<| ProcState_SS := ((vec_of_bits [B0]  :  1 words$word))|>))
   (if (((target_mode = M32_FIQ))) then
      let split_vec = ((vec_of_bits [B1;B1;B1]  :  3 words$word)) in
      let (tup__0, tup__1, tup__2) =
        ((subrange_vec_dec split_vec (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__8 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__8 with<| ProcState_A := tup__0|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__9 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__9 with<| ProcState_I := tup__1|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__10 : ProcState) . 
      sail2_state_monad$write_regS PSTATE_ref (w__10 with<| ProcState_F := tup__2|>))))
    else if ((((((target_mode = M32_Abort))) \/ (((target_mode = M32_IRQ)))))) then
      let split_vec = ((vec_of_bits [B1;B1]  :  2 words$word)) in
      let (tup__0, tup__1) =
        ((subrange_vec_dec split_vec (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__11 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__11 with<| ProcState_A := tup__0|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__12 : ProcState) . 
      sail2_state_monad$write_regS PSTATE_ref (w__12 with<| ProcState_I := tup__1|>)))
    else sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__13 : ProcState) . 
      sail2_state_monad$write_regS PSTATE_ref (w__13 with<| ProcState_I := ((vec_of_bits [B1]  :  1 words$word))|>))))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__14 : ProcState) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS SCTLR_ref  : ( 32 words$word) M) (\ (w__15 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS
     PSTATE_ref
     (w__14 with<| ProcState_E := ((vec_of_bits [access_vec_dec w__15 (( 25 : int):ii)]  :  1 words$word))|>))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__16 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__16 with<| ProcState_IL := ((vec_of_bits [B0]  :  1 words$word))|>))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__17 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS
     PSTATE_ref
     (w__17 with<| ProcState_IT := ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0]  :  8 words$word))|>))
   (sail2_state$and_boolS (sail2_state_monad$returnS ((HavePANExt () )))
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCTLR_ref  : ( 32 words$word) M) (\ (w__18 : 32 bits) . 
      sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__18 (( 23 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))))))) (\ (w__19 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (if w__19 then sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__20 : ProcState) . 
      sail2_state_monad$write_regS PSTATE_ref (w__20 with<| ProcState_PAN := ((vec_of_bits [B1]  :  1 words$word))|>))
    else sail2_state_monad$returnS () )
   (ExcVectorBase ()   : ( 32 words$word) M)) (\ (w__21 :  32 words$word) .  sail2_state_monad$seqS
   (BranchTo
     ((concat_vec ((slice w__21 (( 5 : int):ii) (( 27 : int):ii)  :  27 words$word))
         ((GetSlice_int ((make_the_value (( 5 : int):ii)  :  5 itself)) vect_offset (( 0 : int):ii)  :  5 words$word))
        :  32 words$word)) BranchType_UNKNOWN)
   (EndOfInstruction () )))))))))))))))`;


(*val AArch64_AdvSIMDFPAccessTrap : mword ty2 -> M unit*)

val _ = Define `
 ((AArch64_AdvSIMDFPAccessTrap:(2)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) target_el=  (sail2_state_monad$bindS
   (ThisInstrAddr (( 64 : int):ii) ()   : ( 64 words$word) M) (\ (preferred_exception_return : 64 bits) . 
   let (vect_offset : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
   (sail2_state$and_boolS
     (sail2_state$and_boolS (sail2_state_monad$returnS ((((((target_el = EL1))) /\ ((HaveEL EL2))))))
        ( sail2_state_monad$bindS(IsSecure () ) (\ (w__0 : bool) .  sail2_state_monad$returnS ((~ w__0)))))
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__2 : 64 bits) . 
      sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__2 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (route_to_el2 : bool) .  sail2_state_monad$bindS
   (undefined_ExceptionRecord () ) (\ (exception : ExceptionRecord) . 
   if route_to_el2 then sail2_state_monad$bindS
     (ExceptionSyndrome Exception_Uncategorized) (\ (w__3 : ExceptionRecord) . 
     let exception = w__3 in
     AArch64_TakeException EL2 exception preferred_exception_return vect_offset)
   else sail2_state_monad$bindS
     (ExceptionSyndrome Exception_AdvSIMDFPAccessTrap) (\ (w__4 : ExceptionRecord) . 
     let exception = w__4 in
     let (tmp_2610 : 25 bits) = (exception.ExceptionRecord_syndrome) in sail2_state_monad$bindS
     (ConditionSyndrome ()   : ( 5 words$word) M) (\ (w__5 :  5 words$word) . 
     let tmp_2610 = ((set_slice (( 25 : int):ii) (( 5 : int):ii) tmp_2610 (( 20 : int):ii) w__5  :  25 words$word)) in
     let exception = ((exception with<| ExceptionRecord_syndrome := tmp_2610|>)) in
     AArch64_TakeException target_el exception preferred_exception_return vect_offset)))))))`;


(*val AArch64_CheckFPAdvSIMDTrap : unit -> M unit*)

val _ = Define `
 ((AArch64_CheckFPAdvSIMDTrap:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (disabled : bool) .  sail2_state_monad$bindS
   (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2))) ( sail2_state_monad$bindS(IsSecure () ) (\ (w__0 : bool) .  sail2_state_monad$returnS ((~ w__0))))) (\ (w__1 :
     bool) .  sail2_state_monad$seqS
   (if w__1 then sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveVirtHostExt () )))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__2 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__2 (( 34 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__3 : bool) . 
      if w__3 then sail2_state_monad$bindS
        (sail2_state_monad$read_regS CPTR_EL2_ref  : ( 32 words$word) M) (\ (w__4 : 32 bits) . 
        let p__283 = ((slice w__4 (( 20 : int):ii) (( 2 : int):ii)  :  2 words$word)) in
        let v__94 = p__283 in sail2_state_monad$bindS
        (if (((((subrange_vec_dec v__94 (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) = (vec_of_bits [B0]  :  1 words$word)))) then sail2_state_monad$bindS
           (sail2_state$and_boolS
             ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__5 : ProcState) . 
              sail2_state_monad$returnS (((w__5.ProcState_EL = EL1)))))
             ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__6 : 64 bits) . 
              sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__6 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__7 : bool) . 
           let (disabled : bool) = (~ w__7) in
           sail2_state_monad$returnS disabled)
         else if (((v__94 = (vec_of_bits [B0;B1]  :  2 words$word)))) then
           sail2_state$and_boolS
             ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__8 : ProcState) . 
              sail2_state_monad$returnS (((w__8.ProcState_EL = EL0)))))
             ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__9 : 64 bits) . 
              sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__9 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))
         else sail2_state_monad$returnS F) (\ (disabled : bool) . 
        if disabled then AArch64_AdvSIMDFPAccessTrap EL2
        else sail2_state_monad$returnS () ))
      else sail2_state_monad$bindS
        (sail2_state_monad$read_regS CPTR_EL2_ref  : ( 32 words$word) M) (\ (w__11 : 32 bits) . 
        if ((((vec_of_bits [access_vec_dec w__11 (( 10 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
          AArch64_AdvSIMDFPAccessTrap EL2
        else sail2_state_monad$returnS () ))
    else sail2_state_monad$returnS () )
   (if ((HaveEL EL3)) then sail2_state_monad$bindS
     (sail2_state_monad$read_regS CPTR_EL3_ref  : ( 32 words$word) M) (\ (w__12 : 32 bits) . 
     if ((((vec_of_bits [access_vec_dec w__12 (( 10 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
       AArch64_AdvSIMDFPAccessTrap EL3
     else sail2_state_monad$returnS () )
   else sail2_state_monad$returnS () )))))`;


(*val AArch64_CheckFPAdvSIMDEnabled : unit -> M unit*)

val _ = Define `
 ((AArch64_CheckFPAdvSIMDEnabled:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (disabled : bool) .  sail2_state_monad$bindS
   (sail2_state$or_boolS
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) .  sail2_state_monad$returnS (((w__0.ProcState_EL = EL0)))))
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__1 : ProcState) .  sail2_state_monad$returnS (((w__1.ProcState_EL = EL1)))))) (\ (w__2 :
     bool) .  sail2_state_monad$seqS
   (if w__2 then sail2_state_monad$bindS
      (aget_CPACR ()   : ( 32 words$word) M) (\ (w__3 :  32 words$word) . 
      let p__282 = ((slice w__3 (( 20 : int):ii) (( 2 : int):ii)  :  2 words$word)) in
      let v__96 = p__282 in sail2_state_monad$bindS
      (if (((((subrange_vec_dec v__96 (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) = (vec_of_bits [B0]  :  1 words$word)))) then
         sail2_state_monad$returnS T
       else if (((v__96 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$bindS
         (sail2_state_monad$read_regS PSTATE_ref) (\ (w__4 : ProcState) . 
         let (disabled : bool) = (w__4.ProcState_EL = EL0) in
         sail2_state_monad$returnS disabled)
       else sail2_state_monad$returnS F) (\ (disabled : bool) . 
      if disabled then AArch64_AdvSIMDFPAccessTrap EL1
      else sail2_state_monad$returnS () ))
    else sail2_state_monad$returnS () )
   (AArch64_CheckFPAdvSIMDTrap () )))))`;


(*val CheckFPAdvSIMDEnabled64 : unit -> M unit*)

val _ = Define `
 ((CheckFPAdvSIMDEnabled64:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (AArch64_CheckFPAdvSIMDEnabled () ))`;


(*val aarch64_float_move_fp_select : mword ty4 -> ii -> ii -> ii -> ii -> M unit*)

val _ = Define `
 ((aarch64_float_move_fp_select:(4)words$word -> int -> int -> int -> int ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) condition d l__133 m n=
    (if (((l__133 = (( 8 : int):ii)))) then
     let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (ConditionHolds condition)) (\ (w__0 : bool) .  sail2_state_monad$bindS
     (if w__0 then (aget_V (( 8 : int):ii) n  : ( 8 words$word) M)
      else (aget_V (( 8 : int):ii) m  : ( 8 words$word) M)) (\ (result : 8 bits) . 
     aset_V d result))
   else if (((l__133 = (( 16 : int):ii)))) then
     let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (ConditionHolds condition)) (\ (w__3 : bool) .  sail2_state_monad$bindS
     (if w__3 then (aget_V (( 16 : int):ii) n  : ( 16 words$word) M)
      else (aget_V (( 16 : int):ii) m  : ( 16 words$word) M)) (\ (result : 16 bits) . 
     aset_V d result))
   else if (((l__133 = (( 32 : int):ii)))) then
     let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (ConditionHolds condition)) (\ (w__6 : bool) .  sail2_state_monad$bindS
     (if w__6 then (aget_V (( 32 : int):ii) n  : ( 32 words$word) M)
      else (aget_V (( 32 : int):ii) m  : ( 32 words$word) M)) (\ (result : 32 bits) . 
     aset_V d result))
   else if (((l__133 = (( 64 : int):ii)))) then
     let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (ConditionHolds condition)) (\ (w__9 : bool) .  sail2_state_monad$bindS
     (if w__9 then (aget_V (( 64 : int):ii) n  : ( 64 words$word) M)
      else (aget_V (( 64 : int):ii) m  : ( 64 words$word) M)) (\ (result : 64 bits) . 
     aset_V d result))
   else if (((l__133 = (( 128 : int):ii)))) then
     let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (ConditionHolds condition)) (\ (w__12 : bool) .  sail2_state_monad$bindS
     (if w__12 then (aget_V (( 128 : int):ii) n  : ( 128 words$word) M)
      else (aget_V (( 128 : int):ii) m  : ( 128 words$word) M)) (\ (result : 128 bits) . 
     aset_V d result))
   else
     let dbytes = (ex_int ((l__133 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint"))`;


(*val aarch64_float_move_fp_imm : forall 'datasize. Size 'datasize => ii -> itself 'datasize -> mword 'datasize -> M unit*)

val _ = Define `
 ((aarch64_float_move_fp_imm:int -> 'datasize itself -> 'datasize words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d datasize imm=
    (let datasize = (size_itself_int datasize) in
   let dbytes = (ex_int ((datasize / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS T "datasize constraint")
   (sail2_state_monad$assert_expS T "dbytes constraint")) (CheckFPAdvSIMDEnabled64 () )) (aset_V d imm)))`;


(*val aarch64_float_convert_int : forall 'fltsize 'intsize . Size 'fltsize, Size 'intsize => ii -> itself 'fltsize -> itself 'intsize -> ii -> FPConvOp -> ii -> FPRounding -> bool -> M unit*)

val _ = Define `
 ((aarch64_float_convert_int:int -> 'fltsize itself -> 'intsize itself -> int -> FPConvOp -> int -> FPRounding -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d fltsize intsize n op part rounding unsigned=
    (let intsize = (size_itself_int intsize) in
   let fltsize = (size_itself_int fltsize) in sail2_state_monad$bindS (sail2_state_monad$seqS
   (CheckFPAdvSIMDEnabled64 () )
   (undefined_bitvector fltsize  : ( 'fltsize words$word) M)) (\ (fltval : 'fltsize bits) .  sail2_state_monad$bindS
   (undefined_bitvector intsize  : ( 'intsize words$word) M) (\ (intval : 'intsize bits) . 
   (case op of
     FPConvOp_CVT_FtoI => sail2_state_monad$bindS
      (aget_V fltsize n  : ( 'fltsize words$word) M) (\ (w__0 : 'fltsize bits) . 
      let fltval = w__0 in sail2_state_monad$bindS
      (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__1 :  32 words$word) .  sail2_state_monad$bindS
      (FPToFixed intsize fltval (( 0 : int):ii) unsigned w__1 rounding  : ( 'intsize words$word) M) (\ (w__2 : 'intsize
        bits) . 
      let intval = w__2 in
      aset_X d intval)))
   | FPConvOp_CVT_ItoF => sail2_state_monad$bindS
      (aget_X intsize n  : ( 'intsize words$word) M) (\ (w__3 : 'intsize bits) . 
      let intval = w__3 in sail2_state_monad$bindS
      (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__4 :  32 words$word) .  sail2_state_monad$bindS
      (FixedToFP fltsize intval (( 0 : int):ii) unsigned w__4 rounding  : ( 'fltsize words$word) M) (\ (w__5 : 'fltsize
        bits) . 
      let fltval = w__5 in
      aset_V d fltval)))
   | FPConvOp_MOV_FtoI => sail2_state_monad$bindS
      (aget_Vpart fltsize n part  : ( 'fltsize words$word) M) (\ (w__6 : 'fltsize bits) . 
      let fltval = w__6 in sail2_state_monad$bindS
      (ZeroExtend__0 fltval ((make_the_value intsize  :  'intsize itself))  : ( 'intsize words$word) M) (\ (w__7 : 'intsize
        bits) . 
      let intval = w__7 in
      aset_X d intval))
   | FPConvOp_MOV_ItoF => sail2_state_monad$bindS
      (aget_X intsize n  : ( 'intsize words$word) M) (\ (w__8 : 'intsize bits) . 
      let intval = w__8 in
      let fltval = ((slice intval (( 0 : int):ii) fltsize  :  'fltsize words$word)) in
      aset_Vpart d part fltval)
   | FPConvOp_CVT_FtoI_JS => sail2_state_monad$bindS
      (aget_V fltsize n  : ( 'fltsize words$word) M) (\ (w__9 : 'fltsize bits) . 
      let fltval = w__9 in sail2_state_monad$bindS
      (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__10 :  32 words$word) .  sail2_state_monad$bindS
      (FPToFixedJS intsize fltval w__10 T  : ( 'intsize words$word) M) (\ (w__11 : 'intsize bits) . 
      let intval = w__11 in sail2_state_monad$bindS
      (ZeroExtend__0 ((slice intval (( 0 : int):ii) (( 32 : int):ii)  :  32 words$word))
         ((make_the_value (( 64 : int):ii)  :  64 itself))
        : ( 64 words$word) M) (\ (w__12 :  64 words$word) . 
      aset_X d w__12))))
   )))))`;


(*val aarch64_float_convert_fp : forall 'dstsize 'srcsize . Size 'dstsize, Size 'srcsize => ii -> itself 'dstsize -> ii -> itself 'srcsize -> M unit*)

val _ = Define `
 ((aarch64_float_convert_fp:int -> 'dstsize itself -> int -> 'srcsize itself ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d dstsize n srcsize=
    (let srcsize = (size_itself_int srcsize) in
   let dstsize = (size_itself_int dstsize) in sail2_state_monad$bindS (sail2_state_monad$seqS
   (CheckFPAdvSIMDEnabled64 () )
   (undefined_bitvector dstsize  : ( 'dstsize words$word) M)) (\ (result : 'dstsize bits) .  sail2_state_monad$bindS
   (aget_V srcsize n  : ( 'srcsize words$word) M) (\ (operand : 'srcsize bits) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__0 :  32 words$word) .  sail2_state_monad$bindS
   (FPConvert__1 dstsize operand w__0  : ( 'dstsize words$word) M) (\ (w__1 : 'dstsize bits) . 
   let result = w__1 in
   aset_V d result))))))`;


(*val aarch64_float_convert_fix : forall 'fltsize 'intsize . Size 'fltsize, Size 'intsize => ii -> itself 'fltsize -> ii -> itself 'intsize -> ii -> FPConvOp -> FPRounding -> bool -> M unit*)

val _ = Define `
 ((aarch64_float_convert_fix:int -> 'fltsize itself -> int -> 'intsize itself -> int -> FPConvOp -> FPRounding -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d fltsize fracbits intsize n op rounding unsigned=
    (let intsize = (size_itself_int intsize) in
   let fltsize = (size_itself_int fltsize) in sail2_state_monad$bindS (sail2_state_monad$seqS
   (CheckFPAdvSIMDEnabled64 () )
   (undefined_bitvector fltsize  : ( 'fltsize words$word) M)) (\ (fltval : 'fltsize bits) .  sail2_state_monad$bindS
   (undefined_bitvector intsize  : ( 'intsize words$word) M) (\ (intval : 'intsize bits) . 
   (case op of
     FPConvOp_CVT_FtoI => sail2_state_monad$bindS
      (aget_V fltsize n  : ( 'fltsize words$word) M) (\ (w__0 : 'fltsize bits) . 
      let fltval = w__0 in sail2_state_monad$bindS
      (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__1 :  32 words$word) .  sail2_state_monad$bindS
      (FPToFixed intsize fltval fracbits unsigned w__1 rounding  : ( 'intsize words$word) M) (\ (w__2 : 'intsize
        bits) . 
      let intval = w__2 in
      aset_X d intval)))
   | FPConvOp_CVT_ItoF => sail2_state_monad$bindS
      (aget_X intsize n  : ( 'intsize words$word) M) (\ (w__3 : 'intsize bits) . 
      let intval = w__3 in sail2_state_monad$bindS
      (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__4 :  32 words$word) .  sail2_state_monad$bindS
      (FixedToFP fltsize intval fracbits unsigned w__4 rounding  : ( 'fltsize words$word) M) (\ (w__5 : 'fltsize
        bits) . 
      let fltval = w__5 in
      aset_V d fltval)))
   )))))`;


(*val aarch64_float_compare_uncond : bool -> ii -> ii -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_float_compare_uncond:bool -> int -> int -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) cmp_with_zero l__128 m n signal_all_nans=
    (if (((l__128 = (( 8 : int):ii)))) then
     let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (aget_V (( 8 : int):ii) n  : ( 8 words$word) M)) (\ (operand1 : 8 bits) .  sail2_state_monad$bindS
     (if cmp_with_zero then (FPZero (( 8 : int):ii) (vec_of_bits [B0]  :  1 words$word)  : ( 8 words$word) M)
      else (aget_V (( 8 : int):ii) m  : ( 8 words$word) M)) (\ (operand2 : 8 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__2 :  32 words$word) .  sail2_state_monad$bindS
     (FPCompare operand1 operand2 signal_all_nans w__2  : ( 4 words$word) M) (\ split_vec . 
     let (tup__0, tup__1, tup__2, tup__3) =
       ((subrange_vec_dec split_vec (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
        (subrange_vec_dec split_vec (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
        (subrange_vec_dec split_vec (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
        (subrange_vec_dec split_vec (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__3 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__3 with<| ProcState_N := tup__0|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__4 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__4 with<| ProcState_Z := tup__1|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__5 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__5 with<| ProcState_C := tup__2|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__6 : ProcState) . 
     sail2_state_monad$write_regS PSTATE_ref (w__6 with<| ProcState_V := tup__3|>)))))))))
   else if (((l__128 = (( 16 : int):ii)))) then
     let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (aget_V (( 16 : int):ii) n  : ( 16 words$word) M)) (\ (operand1 : 16 bits) .  sail2_state_monad$bindS
     (if cmp_with_zero then (FPZero (( 16 : int):ii) (vec_of_bits [B0]  :  1 words$word)  : ( 16 words$word) M)
      else (aget_V (( 16 : int):ii) m  : ( 16 words$word) M)) (\ (operand2 : 16 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__9 :  32 words$word) .  sail2_state_monad$bindS
     (FPCompare operand1 operand2 signal_all_nans w__9  : ( 4 words$word) M) (\ split_vec . 
     let (tup__0, tup__1, tup__2, tup__3) =
       ((subrange_vec_dec split_vec (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
        (subrange_vec_dec split_vec (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
        (subrange_vec_dec split_vec (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
        (subrange_vec_dec split_vec (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__10 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__10 with<| ProcState_N := tup__0|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__11 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__11 with<| ProcState_Z := tup__1|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__12 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__12 with<| ProcState_C := tup__2|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__13 : ProcState) . 
     sail2_state_monad$write_regS PSTATE_ref (w__13 with<| ProcState_V := tup__3|>)))))))))
   else if (((l__128 = (( 32 : int):ii)))) then
     let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (aget_V (( 32 : int):ii) n  : ( 32 words$word) M)) (\ (operand1 : 32 bits) .  sail2_state_monad$bindS
     (if cmp_with_zero then (FPZero (( 32 : int):ii) (vec_of_bits [B0]  :  1 words$word)  : ( 32 words$word) M)
      else (aget_V (( 32 : int):ii) m  : ( 32 words$word) M)) (\ (operand2 : 32 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__16 :  32 words$word) .  sail2_state_monad$bindS
     (FPCompare operand1 operand2 signal_all_nans w__16  : ( 4 words$word) M) (\ split_vec . 
     let (tup__0, tup__1, tup__2, tup__3) =
       ((subrange_vec_dec split_vec (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
        (subrange_vec_dec split_vec (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
        (subrange_vec_dec split_vec (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
        (subrange_vec_dec split_vec (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__17 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__17 with<| ProcState_N := tup__0|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__18 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__18 with<| ProcState_Z := tup__1|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__19 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__19 with<| ProcState_C := tup__2|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__20 : ProcState) . 
     sail2_state_monad$write_regS PSTATE_ref (w__20 with<| ProcState_V := tup__3|>)))))))))
   else if (((l__128 = (( 64 : int):ii)))) then
     let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (aget_V (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (operand1 : 64 bits) .  sail2_state_monad$bindS
     (if cmp_with_zero then (FPZero (( 64 : int):ii) (vec_of_bits [B0]  :  1 words$word)  : ( 64 words$word) M)
      else (aget_V (( 64 : int):ii) m  : ( 64 words$word) M)) (\ (operand2 : 64 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__23 :  32 words$word) .  sail2_state_monad$bindS
     (FPCompare operand1 operand2 signal_all_nans w__23  : ( 4 words$word) M) (\ split_vec . 
     let (tup__0, tup__1, tup__2, tup__3) =
       ((subrange_vec_dec split_vec (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
        (subrange_vec_dec split_vec (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
        (subrange_vec_dec split_vec (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
        (subrange_vec_dec split_vec (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__24 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__24 with<| ProcState_N := tup__0|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__25 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__25 with<| ProcState_Z := tup__1|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__26 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__26 with<| ProcState_C := tup__2|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__27 : ProcState) . 
     sail2_state_monad$write_regS PSTATE_ref (w__27 with<| ProcState_V := tup__3|>)))))))))
   else if (((l__128 = (( 128 : int):ii)))) then
     let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (aget_V (( 128 : int):ii) n  : ( 128 words$word) M)) (\ (operand1 : 128 bits) .  sail2_state_monad$bindS
     (if cmp_with_zero then (FPZero (( 128 : int):ii) (vec_of_bits [B0]  :  1 words$word)  : ( 128 words$word) M)
      else (aget_V (( 128 : int):ii) m  : ( 128 words$word) M)) (\ (operand2 : 128 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__30 :  32 words$word) .  sail2_state_monad$bindS
     (FPCompare operand1 operand2 signal_all_nans w__30  : ( 4 words$word) M) (\ split_vec . 
     let (tup__0, tup__1, tup__2, tup__3) =
       ((subrange_vec_dec split_vec (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
        (subrange_vec_dec split_vec (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
        (subrange_vec_dec split_vec (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
        (subrange_vec_dec split_vec (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__31 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__31 with<| ProcState_N := tup__0|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__32 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__32 with<| ProcState_Z := tup__1|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__33 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__33 with<| ProcState_C := tup__2|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__34 : ProcState) . 
     sail2_state_monad$write_regS PSTATE_ref (w__34 with<| ProcState_V := tup__3|>)))))))))
   else
     let dbytes = (ex_int ((l__128 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint"))`;


(*val aarch64_float_compare_cond : mword ty4 -> ii -> mword ty4 -> ii -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_float_compare_cond:(4)words$word -> int ->(4)words$word -> int -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) condition l__123 flags__arg m n signal_all_nans=
    (if (((l__123 = (( 8 : int):ii)))) then
     let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let flags = flags__arg in sail2_state_monad$bindS (sail2_state_monad$seqS
     (CheckFPAdvSIMDEnabled64 () )
     (aget_V (( 8 : int):ii) n  : ( 8 words$word) M)) (\ (operand1 : 8 bits) .  sail2_state_monad$bindS
     (aget_V (( 8 : int):ii) m  : ( 8 words$word) M) (\ (operand2 : 8 bits) .  sail2_state_monad$bindS
     (ConditionHolds condition) (\ (w__0 : bool) .  sail2_state_monad$bindS
     (if w__0 then sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__1 :  32 words$word) . 
        (FPCompare operand1 operand2 signal_all_nans w__1  : ( 4 words$word) M))
      else sail2_state_monad$returnS flags) (\ (flags :  4 words$word) . 
     let (tup__0, tup__1, tup__2, tup__3) =
       ((subrange_vec_dec flags (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
        (subrange_vec_dec flags (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
        (subrange_vec_dec flags (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
        (subrange_vec_dec flags (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__3 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__3 with<| ProcState_N := tup__0|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__4 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__4 with<| ProcState_Z := tup__1|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__5 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__5 with<| ProcState_C := tup__2|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__6 : ProcState) . 
     sail2_state_monad$write_regS PSTATE_ref (w__6 with<| ProcState_V := tup__3|>))))))))))
   else if (((l__123 = (( 16 : int):ii)))) then
     let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let flags = flags__arg in sail2_state_monad$bindS (sail2_state_monad$seqS
     (CheckFPAdvSIMDEnabled64 () )
     (aget_V (( 16 : int):ii) n  : ( 16 words$word) M)) (\ (operand1 : 16 bits) .  sail2_state_monad$bindS
     (aget_V (( 16 : int):ii) m  : ( 16 words$word) M) (\ (operand2 : 16 bits) .  sail2_state_monad$bindS
     (ConditionHolds condition) (\ (w__7 : bool) .  sail2_state_monad$bindS
     (if w__7 then sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__8 :  32 words$word) . 
        (FPCompare operand1 operand2 signal_all_nans w__8  : ( 4 words$word) M))
      else sail2_state_monad$returnS flags) (\ (flags :  4 words$word) . 
     let (tup__0, tup__1, tup__2, tup__3) =
       ((subrange_vec_dec flags (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
        (subrange_vec_dec flags (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
        (subrange_vec_dec flags (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
        (subrange_vec_dec flags (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__10 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__10 with<| ProcState_N := tup__0|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__11 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__11 with<| ProcState_Z := tup__1|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__12 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__12 with<| ProcState_C := tup__2|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__13 : ProcState) . 
     sail2_state_monad$write_regS PSTATE_ref (w__13 with<| ProcState_V := tup__3|>))))))))))
   else if (((l__123 = (( 32 : int):ii)))) then
     let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let flags = flags__arg in sail2_state_monad$bindS (sail2_state_monad$seqS
     (CheckFPAdvSIMDEnabled64 () )
     (aget_V (( 32 : int):ii) n  : ( 32 words$word) M)) (\ (operand1 : 32 bits) .  sail2_state_monad$bindS
     (aget_V (( 32 : int):ii) m  : ( 32 words$word) M) (\ (operand2 : 32 bits) .  sail2_state_monad$bindS
     (ConditionHolds condition) (\ (w__14 : bool) .  sail2_state_monad$bindS
     (if w__14 then sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__15 :  32 words$word) . 
        (FPCompare operand1 operand2 signal_all_nans w__15  : ( 4 words$word) M))
      else sail2_state_monad$returnS flags) (\ (flags :  4 words$word) . 
     let (tup__0, tup__1, tup__2, tup__3) =
       ((subrange_vec_dec flags (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
        (subrange_vec_dec flags (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
        (subrange_vec_dec flags (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
        (subrange_vec_dec flags (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__17 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__17 with<| ProcState_N := tup__0|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__18 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__18 with<| ProcState_Z := tup__1|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__19 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__19 with<| ProcState_C := tup__2|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__20 : ProcState) . 
     sail2_state_monad$write_regS PSTATE_ref (w__20 with<| ProcState_V := tup__3|>))))))))))
   else if (((l__123 = (( 64 : int):ii)))) then
     let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let flags = flags__arg in sail2_state_monad$bindS (sail2_state_monad$seqS
     (CheckFPAdvSIMDEnabled64 () )
     (aget_V (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (operand1 : 64 bits) .  sail2_state_monad$bindS
     (aget_V (( 64 : int):ii) m  : ( 64 words$word) M) (\ (operand2 : 64 bits) .  sail2_state_monad$bindS
     (ConditionHolds condition) (\ (w__21 : bool) .  sail2_state_monad$bindS
     (if w__21 then sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__22 :  32 words$word) . 
        (FPCompare operand1 operand2 signal_all_nans w__22  : ( 4 words$word) M))
      else sail2_state_monad$returnS flags) (\ (flags :  4 words$word) . 
     let (tup__0, tup__1, tup__2, tup__3) =
       ((subrange_vec_dec flags (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
        (subrange_vec_dec flags (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
        (subrange_vec_dec flags (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
        (subrange_vec_dec flags (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__24 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__24 with<| ProcState_N := tup__0|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__25 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__25 with<| ProcState_Z := tup__1|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__26 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__26 with<| ProcState_C := tup__2|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__27 : ProcState) . 
     sail2_state_monad$write_regS PSTATE_ref (w__27 with<| ProcState_V := tup__3|>))))))))))
   else if (((l__123 = (( 128 : int):ii)))) then
     let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let flags = flags__arg in sail2_state_monad$bindS (sail2_state_monad$seqS
     (CheckFPAdvSIMDEnabled64 () )
     (aget_V (( 128 : int):ii) n  : ( 128 words$word) M)) (\ (operand1 : 128 bits) .  sail2_state_monad$bindS
     (aget_V (( 128 : int):ii) m  : ( 128 words$word) M) (\ (operand2 : 128 bits) .  sail2_state_monad$bindS
     (ConditionHolds condition) (\ (w__28 : bool) .  sail2_state_monad$bindS
     (if w__28 then sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__29 :  32 words$word) . 
        (FPCompare operand1 operand2 signal_all_nans w__29  : ( 4 words$word) M))
      else sail2_state_monad$returnS flags) (\ (flags :  4 words$word) . 
     let (tup__0, tup__1, tup__2, tup__3) =
       ((subrange_vec_dec flags (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
        (subrange_vec_dec flags (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
        (subrange_vec_dec flags (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
        (subrange_vec_dec flags (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__31 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__31 with<| ProcState_N := tup__0|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__32 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__32 with<| ProcState_Z := tup__1|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__33 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS PSTATE_ref (w__33 with<| ProcState_C := tup__2|>))
     (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__34 : ProcState) . 
     sail2_state_monad$write_regS PSTATE_ref (w__34 with<| ProcState_V := tup__3|>))))))))))
   else
     let dbytes = (ex_int ((l__123 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint"))`;


(*val aarch64_float_arithmetic_unary : ii -> ii -> FPUnaryOp -> ii -> M unit*)

val _ = Define `
 ((aarch64_float_arithmetic_unary:int -> int -> FPUnaryOp -> int ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d l__118 fpop n=
    (if (((l__118 = (( 8 : int):ii)))) then
     let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M)) (\ (result : 8 bits) .  sail2_state_monad$bindS
     (aget_V (( 8 : int):ii) n  : ( 8 words$word) M) (\ (operand : 8 bits) .  sail2_state_monad$bindS
     (case fpop of
       FPUnaryOp_MOV => sail2_state_monad$returnS operand
     | FPUnaryOp_ABS => (FPAbs operand  : ( 8 words$word) M)
     | FPUnaryOp_NEG => (FPNeg operand  : ( 8 words$word) M)
     | FPUnaryOp_SQRT => sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__2 :  32 words$word) . 
        (FPSqrt operand w__2  : ( 8 words$word) M))
     ) (\ (result : 8 bits) . 
     aset_V d result)))
   else if (((l__118 = (( 16 : int):ii)))) then
     let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M)) (\ (result : 16 bits) .  sail2_state_monad$bindS
     (aget_V (( 16 : int):ii) n  : ( 16 words$word) M) (\ (operand : 16 bits) .  sail2_state_monad$bindS
     (case fpop of
       FPUnaryOp_MOV => sail2_state_monad$returnS operand
     | FPUnaryOp_ABS => (FPAbs operand  : ( 16 words$word) M)
     | FPUnaryOp_NEG => (FPNeg operand  : ( 16 words$word) M)
     | FPUnaryOp_SQRT => sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__6 :  32 words$word) . 
        (FPSqrt operand w__6  : ( 16 words$word) M))
     ) (\ (result : 16 bits) . 
     aset_V d result)))
   else if (((l__118 = (( 32 : int):ii)))) then
     let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (result : 32 bits) .  sail2_state_monad$bindS
     (aget_V (( 32 : int):ii) n  : ( 32 words$word) M) (\ (operand : 32 bits) .  sail2_state_monad$bindS
     (case fpop of
       FPUnaryOp_MOV => sail2_state_monad$returnS operand
     | FPUnaryOp_ABS => (FPAbs operand  : ( 32 words$word) M)
     | FPUnaryOp_NEG => (FPNeg operand  : ( 32 words$word) M)
     | FPUnaryOp_SQRT => sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__10 :  32 words$word) . 
        (FPSqrt operand w__10  : ( 32 words$word) M))
     ) (\ (result : 32 bits) . 
     aset_V d result)))
   else if (((l__118 = (( 64 : int):ii)))) then
     let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (result : 64 bits) .  sail2_state_monad$bindS
     (aget_V (( 64 : int):ii) n  : ( 64 words$word) M) (\ (operand : 64 bits) .  sail2_state_monad$bindS
     (case fpop of
       FPUnaryOp_MOV => sail2_state_monad$returnS operand
     | FPUnaryOp_ABS => (FPAbs operand  : ( 64 words$word) M)
     | FPUnaryOp_NEG => (FPNeg operand  : ( 64 words$word) M)
     | FPUnaryOp_SQRT => sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__14 :  32 words$word) . 
        (FPSqrt operand w__14  : ( 64 words$word) M))
     ) (\ (result : 64 bits) . 
     aset_V d result)))
   else if (((l__118 = (( 128 : int):ii)))) then
     let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M)) (\ (result : 128 bits) .  sail2_state_monad$bindS
     (aget_V (( 128 : int):ii) n  : ( 128 words$word) M) (\ (operand : 128 bits) .  sail2_state_monad$bindS
     (case fpop of
       FPUnaryOp_MOV => sail2_state_monad$returnS operand
     | FPUnaryOp_ABS => (FPAbs operand  : ( 128 words$word) M)
     | FPUnaryOp_NEG => (FPNeg operand  : ( 128 words$word) M)
     | FPUnaryOp_SQRT => sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__18 :  32 words$word) . 
        (FPSqrt operand w__18  : ( 128 words$word) M))
     ) (\ (result : 128 bits) . 
     aset_V d result)))
   else
     let dbytes = (ex_int ((l__118 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint"))`;


(*val aarch64_float_arithmetic_round : ii -> ii -> bool -> ii -> FPRounding -> M unit*)

val _ = Define `
 ((aarch64_float_arithmetic_round:int -> int -> bool -> int -> FPRounding ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d l__113 exact n rounding=
    (if (((l__113 = (( 8 : int):ii)))) then
     let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M)) (\ (result : 8 bits) .  sail2_state_monad$bindS
     (aget_V (( 8 : int):ii) n  : ( 8 words$word) M) (\ (operand : 8 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__0 :  32 words$word) .  sail2_state_monad$bindS
     (FPRoundInt operand w__0 rounding exact  : ( 8 words$word) M) (\ (w__1 : 8 bits) . 
     let result = w__1 in
     aset_V d result))))
   else if (((l__113 = (( 16 : int):ii)))) then
     let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M)) (\ (result : 16 bits) .  sail2_state_monad$bindS
     (aget_V (( 16 : int):ii) n  : ( 16 words$word) M) (\ (operand : 16 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__2 :  32 words$word) .  sail2_state_monad$bindS
     (FPRoundInt operand w__2 rounding exact  : ( 16 words$word) M) (\ (w__3 : 16 bits) . 
     let result = w__3 in
     aset_V d result))))
   else if (((l__113 = (( 32 : int):ii)))) then
     let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (result : 32 bits) .  sail2_state_monad$bindS
     (aget_V (( 32 : int):ii) n  : ( 32 words$word) M) (\ (operand : 32 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__4 :  32 words$word) .  sail2_state_monad$bindS
     (FPRoundInt operand w__4 rounding exact  : ( 32 words$word) M) (\ (w__5 : 32 bits) . 
     let result = w__5 in
     aset_V d result))))
   else if (((l__113 = (( 64 : int):ii)))) then
     let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (result : 64 bits) .  sail2_state_monad$bindS
     (aget_V (( 64 : int):ii) n  : ( 64 words$word) M) (\ (operand : 64 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__6 :  32 words$word) .  sail2_state_monad$bindS
     (FPRoundInt operand w__6 rounding exact  : ( 64 words$word) M) (\ (w__7 : 64 bits) . 
     let result = w__7 in
     aset_V d result))))
   else if (((l__113 = (( 128 : int):ii)))) then
     let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M)) (\ (result : 128 bits) .  sail2_state_monad$bindS
     (aget_V (( 128 : int):ii) n  : ( 128 words$word) M) (\ (operand : 128 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__8 :  32 words$word) .  sail2_state_monad$bindS
     (FPRoundInt operand w__8 rounding exact  : ( 128 words$word) M) (\ (w__9 : 128 bits) . 
     let result = w__9 in
     aset_V d result))))
   else
     let dbytes = (ex_int ((l__113 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint"))`;


(*val aarch64_float_arithmetic_mul_product : ii -> ii -> ii -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_float_arithmetic_mul_product:int -> int -> int -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d l__108 m n negated=
    (if (((l__108 = (( 8 : int):ii)))) then
     let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M)) (\ (result : 8 bits) .  sail2_state_monad$bindS
     (aget_V (( 8 : int):ii) n  : ( 8 words$word) M) (\ (operand1 : 8 bits) .  sail2_state_monad$bindS
     (aget_V (( 8 : int):ii) m  : ( 8 words$word) M) (\ (operand2 : 8 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__0 :  32 words$word) .  sail2_state_monad$bindS
     (FPMul operand1 operand2 w__0  : ( 8 words$word) M) (\ (w__1 : 8 bits) . 
     let result = w__1 in sail2_state_monad$bindS
     (if negated then (FPNeg result  : ( 8 words$word) M)
      else sail2_state_monad$returnS result) (\ (result : 8 bits) . 
     aset_V d result))))))
   else if (((l__108 = (( 16 : int):ii)))) then
     let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M)) (\ (result : 16 bits) .  sail2_state_monad$bindS
     (aget_V (( 16 : int):ii) n  : ( 16 words$word) M) (\ (operand1 : 16 bits) .  sail2_state_monad$bindS
     (aget_V (( 16 : int):ii) m  : ( 16 words$word) M) (\ (operand2 : 16 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__3 :  32 words$word) .  sail2_state_monad$bindS
     (FPMul operand1 operand2 w__3  : ( 16 words$word) M) (\ (w__4 : 16 bits) . 
     let result = w__4 in sail2_state_monad$bindS
     (if negated then (FPNeg result  : ( 16 words$word) M)
      else sail2_state_monad$returnS result) (\ (result : 16 bits) . 
     aset_V d result))))))
   else if (((l__108 = (( 32 : int):ii)))) then
     let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (result : 32 bits) .  sail2_state_monad$bindS
     (aget_V (( 32 : int):ii) n  : ( 32 words$word) M) (\ (operand1 : 32 bits) .  sail2_state_monad$bindS
     (aget_V (( 32 : int):ii) m  : ( 32 words$word) M) (\ (operand2 : 32 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__6 :  32 words$word) .  sail2_state_monad$bindS
     (FPMul operand1 operand2 w__6  : ( 32 words$word) M) (\ (w__7 : 32 bits) . 
     let result = w__7 in sail2_state_monad$bindS
     (if negated then (FPNeg result  : ( 32 words$word) M)
      else sail2_state_monad$returnS result) (\ (result : 32 bits) . 
     aset_V d result))))))
   else if (((l__108 = (( 64 : int):ii)))) then
     let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (result : 64 bits) .  sail2_state_monad$bindS
     (aget_V (( 64 : int):ii) n  : ( 64 words$word) M) (\ (operand1 : 64 bits) .  sail2_state_monad$bindS
     (aget_V (( 64 : int):ii) m  : ( 64 words$word) M) (\ (operand2 : 64 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__9 :  32 words$word) .  sail2_state_monad$bindS
     (FPMul operand1 operand2 w__9  : ( 64 words$word) M) (\ (w__10 : 64 bits) . 
     let result = w__10 in sail2_state_monad$bindS
     (if negated then (FPNeg result  : ( 64 words$word) M)
      else sail2_state_monad$returnS result) (\ (result : 64 bits) . 
     aset_V d result))))))
   else if (((l__108 = (( 128 : int):ii)))) then
     let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M)) (\ (result : 128 bits) .  sail2_state_monad$bindS
     (aget_V (( 128 : int):ii) n  : ( 128 words$word) M) (\ (operand1 : 128 bits) .  sail2_state_monad$bindS
     (aget_V (( 128 : int):ii) m  : ( 128 words$word) M) (\ (operand2 : 128 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__12 :  32 words$word) .  sail2_state_monad$bindS
     (FPMul operand1 operand2 w__12  : ( 128 words$word) M) (\ (w__13 : 128 bits) . 
     let result = w__13 in sail2_state_monad$bindS
     (if negated then (FPNeg result  : ( 128 words$word) M)
      else sail2_state_monad$returnS result) (\ (result : 128 bits) . 
     aset_V d result))))))
   else
     let dbytes = (ex_int ((l__108 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint"))`;


(*val aarch64_float_arithmetic_mul_addsub : ii -> ii -> ii -> ii -> ii -> bool -> bool -> M unit*)

val _ = Define `
 ((aarch64_float_arithmetic_mul_addsub:int -> int -> int -> int -> int -> bool -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) a d l__103 m n op1_neg opa_neg=
    (if (((l__103 = (( 8 : int):ii)))) then
     let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M)) (\ (result : 8 bits) .  sail2_state_monad$bindS
     (aget_V (( 8 : int):ii) a  : ( 8 words$word) M) (\ (operanda : 8 bits) .  sail2_state_monad$bindS
     (aget_V (( 8 : int):ii) n  : ( 8 words$word) M) (\ (operand1 : 8 bits) .  sail2_state_monad$bindS
     (aget_V (( 8 : int):ii) m  : ( 8 words$word) M) (\ (operand2 : 8 bits) .  sail2_state_monad$bindS
     (if opa_neg then (FPNeg operanda  : ( 8 words$word) M)
      else sail2_state_monad$returnS operanda) (\ (operanda : 8 bits) .  sail2_state_monad$bindS
     (if op1_neg then (FPNeg operand1  : ( 8 words$word) M)
      else sail2_state_monad$returnS operand1) (\ (operand1 : 8 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__2 :  32 words$word) .  sail2_state_monad$bindS
     (FPMulAdd operanda operand1 operand2 w__2  : ( 8 words$word) M) (\ (w__3 : 8 bits) . 
     let result = w__3 in
     aset_V d result))))))))
   else if (((l__103 = (( 16 : int):ii)))) then
     let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M)) (\ (result : 16 bits) .  sail2_state_monad$bindS
     (aget_V (( 16 : int):ii) a  : ( 16 words$word) M) (\ (operanda : 16 bits) .  sail2_state_monad$bindS
     (aget_V (( 16 : int):ii) n  : ( 16 words$word) M) (\ (operand1 : 16 bits) .  sail2_state_monad$bindS
     (aget_V (( 16 : int):ii) m  : ( 16 words$word) M) (\ (operand2 : 16 bits) .  sail2_state_monad$bindS
     (if opa_neg then (FPNeg operanda  : ( 16 words$word) M)
      else sail2_state_monad$returnS operanda) (\ (operanda : 16 bits) .  sail2_state_monad$bindS
     (if op1_neg then (FPNeg operand1  : ( 16 words$word) M)
      else sail2_state_monad$returnS operand1) (\ (operand1 : 16 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__6 :  32 words$word) .  sail2_state_monad$bindS
     (FPMulAdd operanda operand1 operand2 w__6  : ( 16 words$word) M) (\ (w__7 : 16 bits) . 
     let result = w__7 in
     aset_V d result))))))))
   else if (((l__103 = (( 32 : int):ii)))) then
     let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (result : 32 bits) .  sail2_state_monad$bindS
     (aget_V (( 32 : int):ii) a  : ( 32 words$word) M) (\ (operanda : 32 bits) .  sail2_state_monad$bindS
     (aget_V (( 32 : int):ii) n  : ( 32 words$word) M) (\ (operand1 : 32 bits) .  sail2_state_monad$bindS
     (aget_V (( 32 : int):ii) m  : ( 32 words$word) M) (\ (operand2 : 32 bits) .  sail2_state_monad$bindS
     (if opa_neg then (FPNeg operanda  : ( 32 words$word) M)
      else sail2_state_monad$returnS operanda) (\ (operanda : 32 bits) .  sail2_state_monad$bindS
     (if op1_neg then (FPNeg operand1  : ( 32 words$word) M)
      else sail2_state_monad$returnS operand1) (\ (operand1 : 32 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__10 :  32 words$word) .  sail2_state_monad$bindS
     (FPMulAdd operanda operand1 operand2 w__10  : ( 32 words$word) M) (\ (w__11 : 32 bits) . 
     let result = w__11 in
     aset_V d result))))))))
   else if (((l__103 = (( 64 : int):ii)))) then
     let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (result : 64 bits) .  sail2_state_monad$bindS
     (aget_V (( 64 : int):ii) a  : ( 64 words$word) M) (\ (operanda : 64 bits) .  sail2_state_monad$bindS
     (aget_V (( 64 : int):ii) n  : ( 64 words$word) M) (\ (operand1 : 64 bits) .  sail2_state_monad$bindS
     (aget_V (( 64 : int):ii) m  : ( 64 words$word) M) (\ (operand2 : 64 bits) .  sail2_state_monad$bindS
     (if opa_neg then (FPNeg operanda  : ( 64 words$word) M)
      else sail2_state_monad$returnS operanda) (\ (operanda : 64 bits) .  sail2_state_monad$bindS
     (if op1_neg then (FPNeg operand1  : ( 64 words$word) M)
      else sail2_state_monad$returnS operand1) (\ (operand1 : 64 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__14 :  32 words$word) .  sail2_state_monad$bindS
     (FPMulAdd operanda operand1 operand2 w__14  : ( 64 words$word) M) (\ (w__15 : 64 bits) . 
     let result = w__15 in
     aset_V d result))))))))
   else if (((l__103 = (( 128 : int):ii)))) then
     let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M)) (\ (result : 128 bits) .  sail2_state_monad$bindS
     (aget_V (( 128 : int):ii) a  : ( 128 words$word) M) (\ (operanda : 128 bits) .  sail2_state_monad$bindS
     (aget_V (( 128 : int):ii) n  : ( 128 words$word) M) (\ (operand1 : 128 bits) .  sail2_state_monad$bindS
     (aget_V (( 128 : int):ii) m  : ( 128 words$word) M) (\ (operand2 : 128 bits) .  sail2_state_monad$bindS
     (if opa_neg then (FPNeg operanda  : ( 128 words$word) M)
      else sail2_state_monad$returnS operanda) (\ (operanda : 128 bits) .  sail2_state_monad$bindS
     (if op1_neg then (FPNeg operand1  : ( 128 words$word) M)
      else sail2_state_monad$returnS operand1) (\ (operand1 : 128 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__18 :  32 words$word) .  sail2_state_monad$bindS
     (FPMulAdd operanda operand1 operand2 w__18  : ( 128 words$word) M) (\ (w__19 : 128 bits) . 
     let result = w__19 in
     aset_V d result))))))))
   else
     let dbytes = (ex_int ((l__103 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint"))`;


(*val aarch64_float_arithmetic_maxmin : ii -> ii -> ii -> ii -> FPMaxMinOp -> M unit*)

val _ = Define `
 ((aarch64_float_arithmetic_maxmin:int -> int -> int -> int -> FPMaxMinOp ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d l__98 m n operation=
    (if (((l__98 = (( 8 : int):ii)))) then
     let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M)) (\ (result : 8 bits) .  sail2_state_monad$bindS
     (aget_V (( 8 : int):ii) n  : ( 8 words$word) M) (\ (operand1 : 8 bits) .  sail2_state_monad$bindS
     (aget_V (( 8 : int):ii) m  : ( 8 words$word) M) (\ (operand2 : 8 bits) .  sail2_state_monad$bindS
     (case operation of
       FPMaxMinOp_MAX => sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__0 :  32 words$word) . 
        (FPMax operand1 operand2 w__0  : ( 8 words$word) M))
     | FPMaxMinOp_MIN => sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__2 :  32 words$word) . 
        (FPMin operand1 operand2 w__2  : ( 8 words$word) M))
     | FPMaxMinOp_MAXNUM => sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__4 :  32 words$word) . 
        (FPMaxNum operand1 operand2 w__4  : ( 8 words$word) M))
     | FPMaxMinOp_MINNUM => sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__6 :  32 words$word) . 
        (FPMinNum operand1 operand2 w__6  : ( 8 words$word) M))
     ) (\ (result : 8 bits) . 
     aset_V d result))))
   else if (((l__98 = (( 16 : int):ii)))) then
     let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M)) (\ (result : 16 bits) .  sail2_state_monad$bindS
     (aget_V (( 16 : int):ii) n  : ( 16 words$word) M) (\ (operand1 : 16 bits) .  sail2_state_monad$bindS
     (aget_V (( 16 : int):ii) m  : ( 16 words$word) M) (\ (operand2 : 16 bits) .  sail2_state_monad$bindS
     (case operation of
       FPMaxMinOp_MAX => sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__8 :  32 words$word) . 
        (FPMax operand1 operand2 w__8  : ( 16 words$word) M))
     | FPMaxMinOp_MIN => sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__10 :  32 words$word) . 
        (FPMin operand1 operand2 w__10  : ( 16 words$word) M))
     | FPMaxMinOp_MAXNUM => sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__12 :  32 words$word) . 
        (FPMaxNum operand1 operand2 w__12  : ( 16 words$word) M))
     | FPMaxMinOp_MINNUM => sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__14 :  32 words$word) . 
        (FPMinNum operand1 operand2 w__14  : ( 16 words$word) M))
     ) (\ (result : 16 bits) . 
     aset_V d result))))
   else if (((l__98 = (( 32 : int):ii)))) then
     let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (result : 32 bits) .  sail2_state_monad$bindS
     (aget_V (( 32 : int):ii) n  : ( 32 words$word) M) (\ (operand1 : 32 bits) .  sail2_state_monad$bindS
     (aget_V (( 32 : int):ii) m  : ( 32 words$word) M) (\ (operand2 : 32 bits) .  sail2_state_monad$bindS
     (case operation of
       FPMaxMinOp_MAX => sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__16 :  32 words$word) . 
        (FPMax operand1 operand2 w__16  : ( 32 words$word) M))
     | FPMaxMinOp_MIN => sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__18 :  32 words$word) . 
        (FPMin operand1 operand2 w__18  : ( 32 words$word) M))
     | FPMaxMinOp_MAXNUM => sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__20 :  32 words$word) . 
        (FPMaxNum operand1 operand2 w__20  : ( 32 words$word) M))
     | FPMaxMinOp_MINNUM => sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__22 :  32 words$word) . 
        (FPMinNum operand1 operand2 w__22  : ( 32 words$word) M))
     ) (\ (result : 32 bits) . 
     aset_V d result))))
   else if (((l__98 = (( 64 : int):ii)))) then
     let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (result : 64 bits) .  sail2_state_monad$bindS
     (aget_V (( 64 : int):ii) n  : ( 64 words$word) M) (\ (operand1 : 64 bits) .  sail2_state_monad$bindS
     (aget_V (( 64 : int):ii) m  : ( 64 words$word) M) (\ (operand2 : 64 bits) .  sail2_state_monad$bindS
     (case operation of
       FPMaxMinOp_MAX => sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__24 :  32 words$word) . 
        (FPMax operand1 operand2 w__24  : ( 64 words$word) M))
     | FPMaxMinOp_MIN => sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__26 :  32 words$word) . 
        (FPMin operand1 operand2 w__26  : ( 64 words$word) M))
     | FPMaxMinOp_MAXNUM => sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__28 :  32 words$word) . 
        (FPMaxNum operand1 operand2 w__28  : ( 64 words$word) M))
     | FPMaxMinOp_MINNUM => sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__30 :  32 words$word) . 
        (FPMinNum operand1 operand2 w__30  : ( 64 words$word) M))
     ) (\ (result : 64 bits) . 
     aset_V d result))))
   else if (((l__98 = (( 128 : int):ii)))) then
     let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M)) (\ (result : 128 bits) .  sail2_state_monad$bindS
     (aget_V (( 128 : int):ii) n  : ( 128 words$word) M) (\ (operand1 : 128 bits) .  sail2_state_monad$bindS
     (aget_V (( 128 : int):ii) m  : ( 128 words$word) M) (\ (operand2 : 128 bits) .  sail2_state_monad$bindS
     (case operation of
       FPMaxMinOp_MAX => sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__32 :  32 words$word) . 
        (FPMax operand1 operand2 w__32  : ( 128 words$word) M))
     | FPMaxMinOp_MIN => sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__34 :  32 words$word) . 
        (FPMin operand1 operand2 w__34  : ( 128 words$word) M))
     | FPMaxMinOp_MAXNUM => sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__36 :  32 words$word) . 
        (FPMaxNum operand1 operand2 w__36  : ( 128 words$word) M))
     | FPMaxMinOp_MINNUM => sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__38 :  32 words$word) . 
        (FPMinNum operand1 operand2 w__38  : ( 128 words$word) M))
     ) (\ (result : 128 bits) . 
     aset_V d result))))
   else
     let dbytes = (ex_int ((l__98 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint"))`;


(*val aarch64_float_arithmetic_div : ii -> ii -> ii -> ii -> M unit*)

val _ = Define `
 ((aarch64_float_arithmetic_div:int -> int -> int -> int ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d l__93 m n=
    (if (((l__93 = (( 8 : int):ii)))) then
     let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M)) (\ (result : 8 bits) .  sail2_state_monad$bindS
     (aget_V (( 8 : int):ii) n  : ( 8 words$word) M) (\ (operand1 : 8 bits) .  sail2_state_monad$bindS
     (aget_V (( 8 : int):ii) m  : ( 8 words$word) M) (\ (operand2 : 8 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__0 :  32 words$word) .  sail2_state_monad$bindS
     (FPDiv operand1 operand2 w__0  : ( 8 words$word) M) (\ (w__1 : 8 bits) . 
     let result = w__1 in
     aset_V d result)))))
   else if (((l__93 = (( 16 : int):ii)))) then
     let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M)) (\ (result : 16 bits) .  sail2_state_monad$bindS
     (aget_V (( 16 : int):ii) n  : ( 16 words$word) M) (\ (operand1 : 16 bits) .  sail2_state_monad$bindS
     (aget_V (( 16 : int):ii) m  : ( 16 words$word) M) (\ (operand2 : 16 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__2 :  32 words$word) .  sail2_state_monad$bindS
     (FPDiv operand1 operand2 w__2  : ( 16 words$word) M) (\ (w__3 : 16 bits) . 
     let result = w__3 in
     aset_V d result)))))
   else if (((l__93 = (( 32 : int):ii)))) then
     let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (result : 32 bits) .  sail2_state_monad$bindS
     (aget_V (( 32 : int):ii) n  : ( 32 words$word) M) (\ (operand1 : 32 bits) .  sail2_state_monad$bindS
     (aget_V (( 32 : int):ii) m  : ( 32 words$word) M) (\ (operand2 : 32 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__4 :  32 words$word) .  sail2_state_monad$bindS
     (FPDiv operand1 operand2 w__4  : ( 32 words$word) M) (\ (w__5 : 32 bits) . 
     let result = w__5 in
     aset_V d result)))))
   else if (((l__93 = (( 64 : int):ii)))) then
     let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (result : 64 bits) .  sail2_state_monad$bindS
     (aget_V (( 64 : int):ii) n  : ( 64 words$word) M) (\ (operand1 : 64 bits) .  sail2_state_monad$bindS
     (aget_V (( 64 : int):ii) m  : ( 64 words$word) M) (\ (operand2 : 64 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__6 :  32 words$word) .  sail2_state_monad$bindS
     (FPDiv operand1 operand2 w__6  : ( 64 words$word) M) (\ (w__7 : 64 bits) . 
     let result = w__7 in
     aset_V d result)))))
   else if (((l__93 = (( 128 : int):ii)))) then
     let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M)) (\ (result : 128 bits) .  sail2_state_monad$bindS
     (aget_V (( 128 : int):ii) n  : ( 128 words$word) M) (\ (operand1 : 128 bits) .  sail2_state_monad$bindS
     (aget_V (( 128 : int):ii) m  : ( 128 words$word) M) (\ (operand2 : 128 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__8 :  32 words$word) .  sail2_state_monad$bindS
     (FPDiv operand1 operand2 w__8  : ( 128 words$word) M) (\ (w__9 : 128 bits) . 
     let result = w__9 in
     aset_V d result)))))
   else
     let dbytes = (ex_int ((l__93 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint"))`;


(*val aarch64_float_arithmetic_addsub : ii -> ii -> ii -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_float_arithmetic_addsub:int -> int -> int -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d l__88 m n sub_op=
    (if (((l__88 = (( 8 : int):ii)))) then
     let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M)) (\ (result : 8 bits) .  sail2_state_monad$bindS
     (aget_V (( 8 : int):ii) n  : ( 8 words$word) M) (\ (operand1 : 8 bits) .  sail2_state_monad$bindS
     (aget_V (( 8 : int):ii) m  : ( 8 words$word) M) (\ (operand2 : 8 bits) .  sail2_state_monad$bindS
     (if sub_op then sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__0 :  32 words$word) . 
        (FPSub operand1 operand2 w__0  : ( 8 words$word) M))
      else sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__2 :  32 words$word) . 
        (FPAdd operand1 operand2 w__2  : ( 8 words$word) M))) (\ (result : 8 bits) . 
     aset_V d result))))
   else if (((l__88 = (( 16 : int):ii)))) then
     let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M)) (\ (result : 16 bits) .  sail2_state_monad$bindS
     (aget_V (( 16 : int):ii) n  : ( 16 words$word) M) (\ (operand1 : 16 bits) .  sail2_state_monad$bindS
     (aget_V (( 16 : int):ii) m  : ( 16 words$word) M) (\ (operand2 : 16 bits) .  sail2_state_monad$bindS
     (if sub_op then sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__4 :  32 words$word) . 
        (FPSub operand1 operand2 w__4  : ( 16 words$word) M))
      else sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__6 :  32 words$word) . 
        (FPAdd operand1 operand2 w__6  : ( 16 words$word) M))) (\ (result : 16 bits) . 
     aset_V d result))))
   else if (((l__88 = (( 32 : int):ii)))) then
     let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (result : 32 bits) .  sail2_state_monad$bindS
     (aget_V (( 32 : int):ii) n  : ( 32 words$word) M) (\ (operand1 : 32 bits) .  sail2_state_monad$bindS
     (aget_V (( 32 : int):ii) m  : ( 32 words$word) M) (\ (operand2 : 32 bits) .  sail2_state_monad$bindS
     (if sub_op then sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__8 :  32 words$word) . 
        (FPSub operand1 operand2 w__8  : ( 32 words$word) M))
      else sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__10 :  32 words$word) . 
        (FPAdd operand1 operand2 w__10  : ( 32 words$word) M))) (\ (result : 32 bits) . 
     aset_V d result))))
   else if (((l__88 = (( 64 : int):ii)))) then
     let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (result : 64 bits) .  sail2_state_monad$bindS
     (aget_V (( 64 : int):ii) n  : ( 64 words$word) M) (\ (operand1 : 64 bits) .  sail2_state_monad$bindS
     (aget_V (( 64 : int):ii) m  : ( 64 words$word) M) (\ (operand2 : 64 bits) .  sail2_state_monad$bindS
     (if sub_op then sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__12 :  32 words$word) . 
        (FPSub operand1 operand2 w__12  : ( 64 words$word) M))
      else sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__14 :  32 words$word) . 
        (FPAdd operand1 operand2 w__14  : ( 64 words$word) M))) (\ (result : 64 bits) . 
     aset_V d result))))
   else if (((l__88 = (( 128 : int):ii)))) then
     let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M)) (\ (result : 128 bits) .  sail2_state_monad$bindS
     (aget_V (( 128 : int):ii) n  : ( 128 words$word) M) (\ (operand1 : 128 bits) .  sail2_state_monad$bindS
     (aget_V (( 128 : int):ii) m  : ( 128 words$word) M) (\ (operand2 : 128 bits) .  sail2_state_monad$bindS
     (if sub_op then sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__16 :  32 words$word) . 
        (FPSub operand1 operand2 w__16  : ( 128 words$word) M))
      else sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__18 :  32 words$word) . 
        (FPAdd operand1 operand2 w__18  : ( 128 words$word) M))) (\ (result : 128 bits) . 
     aset_V d result))))
   else
     let dbytes = (ex_int ((l__88 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint"))`;


(*val AArch64_AccessIsPrivileged : AccType -> M bool*)

val _ = Define `
 ((AArch64_AccessIsPrivileged:AccType ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) acctype=  (sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (ispriv : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) . 
   if (((w__0.ProcState_EL = EL0))) then sail2_state_monad$returnS F
   else sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__1 : ProcState) . 
     if (((w__1.ProcState_EL = EL3))) then sail2_state_monad$returnS T
     else sail2_state_monad$bindS
       (sail2_state$and_boolS
         ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) .  sail2_state_monad$returnS (((w__2.ProcState_EL = EL2)))))
         (sail2_state$or_boolS ( sail2_state_monad$bindS(IsInHost () ) (\ (w__3 : bool) .  sail2_state_monad$returnS ((~ w__3))))
            ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__4 : 64 bits) . 
             sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__4 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))))))) (\ (w__6 : bool) . 
       if w__6 then sail2_state_monad$returnS T
       else sail2_state_monad$bindS
         (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveUAOExt () )))
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__7 : ProcState) . 
            sail2_state_monad$returnS (((w__7.ProcState_UAO = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__8 :
           bool) . 
         let (ispriv : bool) = (if w__8 then T else (acctype <> AccType_UNPRIV)) in
         sail2_state_monad$returnS ispriv)))))))`;


(*val AArch64_CheckWatchpoint : mword ty64 -> AccType -> bool -> ii -> M FaultRecord*)

val _ = Define `
 ((AArch64_CheckWatchpoint:(64)words$word -> AccType -> bool -> int ->(regstate)sail2_state_monad$sequential_state ->(((FaultRecord),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) vaddress acctype iswrite size1=  (sail2_state_monad$bindS
   (S1TranslationRegime__1 ()   : ( 2 words$word) M) (\ (w__0 :  2 words$word) .  sail2_state_monad$bindS
   (ELUsingAArch32 w__0) (\ (w__1 : bool) .  sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((~ w__1)) "!(ELUsingAArch32(S1TranslationRegime()))")
   (let (val_match : bool) = F in sail2_state_monad$bindS
   (AArch64_AccessIsPrivileged acctype) (\ (ispriv : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS ID_AA64DFR0_EL1_ref  : ( 64 words$word) M) (\ (w__2 : 64 bits) .  sail2_state_monad$bindS
   (sail2_state$foreachS (index_list (( 0 : int):ii) ((lem$w2ui ((slice w__2 (( 20 : int):ii) (( 4 : int):ii)  :  4 words$word)))) (( 1 : int):ii)) val_match
     (\ i val_match . 
       sail2_state$or_boolS (sail2_state_monad$returnS val_match) ((AArch64_WatchpointMatch i vaddress size1 ispriv iswrite)))) (\ (val_match :
     bool) .  sail2_state_monad$bindS
   (undefined_bitvector (( 6 : int):ii)  : ( 6 words$word) M) (\ (reason : 6 bits) .  sail2_state_monad$bindS
   (sail2_state$and_boolS (sail2_state_monad$returnS val_match) ((HaltOnBreakpointOrWatchpoint () ))) (\ (w__6 : bool) . 
   if w__6 then
     let reason = DebugHalt_Watchpoint in sail2_state_monad$seqS
     (Halt reason) (undefined_FaultRecord () )
   else sail2_state_monad$bindS
     (sail2_state$and_boolS
       (sail2_state$and_boolS (sail2_state_monad$returnS val_match)
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS MDSCR_EL1_ref  : ( 32 words$word) M) (\ (w__8 : 32 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__8 (( 15 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) ((AArch64_GenerateDebugExceptions () ))) (\ (w__11 :
       bool) . 
     if w__11 then AArch64_DebugFault acctype iswrite
     else AArch64_NoFault () )))))))))))`;


(*val AArch64_CheckDebug : mword ty64 -> AccType -> bool -> ii -> M FaultRecord*)

val _ = Define `
 ((AArch64_CheckDebug:(64)words$word -> AccType -> bool -> int ->(regstate)sail2_state_monad$sequential_state ->(((FaultRecord),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) vaddress acctype iswrite size1=  (sail2_state_monad$bindS
   (AArch64_NoFault () ) (\ (fault : FaultRecord) . 
   let (d_side : bool) = (acctype <> AccType_IFETCH) in sail2_state_monad$bindS
   (sail2_state$and_boolS ((AArch64_GenerateDebugExceptions () ))
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS MDSCR_EL1_ref  : ( 32 words$word) M) (\ (w__1 : 32 bits) . 
      sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__1 (( 15 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (generate_exception : bool) .  sail2_state_monad$bindS
   (HaltOnBreakpointOrWatchpoint () ) (\ (halt : bool) . 
   if (((generate_exception \/ halt))) then
     if d_side then AArch64_CheckWatchpoint vaddress acctype iswrite size1
     else AArch64_CheckBreakpoint vaddress size1
   else sail2_state_monad$returnS fault)))))`;


(*val AArch64_CheckPermission : Permissions -> mword ty64 -> ii -> mword ty1 -> AccType -> bool -> M FaultRecord*)

val _ = Define `
 ((AArch64_CheckPermission:Permissions ->(64)words$word -> int ->(1)words$word -> AccType -> bool ->(regstate)sail2_state_monad$sequential_state ->(((FaultRecord),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) perms vaddress level NS acctype iswrite=  (sail2_state_monad$bindS
   (S1TranslationRegime__1 ()   : ( 2 words$word) M) (\ (w__0 :  2 words$word) .  sail2_state_monad$bindS
   (ELUsingAArch32 w__0) (\ (w__1 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((~ w__1)) "!(ELUsingAArch32(S1TranslationRegime()))")
   (aget_SCTLR__1 ()   : ( 32 words$word) M)) (\ (w__2 :  32 words$word) . 
   let (wxn : bool) =
     ((vec_of_bits [access_vec_dec w__2 (( 19 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (xn : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (w : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (r : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (priv_xn : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (user_xn : bool) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (pan : 1 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (ispriv : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (user_w : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (user_r : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (priv_w : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (priv_r : bool) .  sail2_state_monad$bindS
   (sail2_state$or_boolS
     (sail2_state$or_boolS
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__3 : ProcState) .  sail2_state_monad$returnS (((w__3.ProcState_EL = EL0)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__4 : ProcState) .  sail2_state_monad$returnS (((w__4.ProcState_EL = EL1))))))
     ((IsInHost () ))) (\ (w__7 : bool) .  sail2_state_monad$bindS
   (if w__7 then
      let priv_r = T in
      let priv_w =
        ((vec_of_bits [access_vec_dec perms.Permissions_ap (( 2 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)) in
      let user_r =
        ((vec_of_bits [access_vec_dec perms.Permissions_ap (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
      let user_w =
        (((slice perms.Permissions_ap (( 1 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)) in sail2_state_monad$bindS
      (AArch64_AccessIsPrivileged acctype) (\ (w__8 : bool) . 
      let ispriv = w__8 in sail2_state_monad$bindS
      (if ((HavePANExt () )) then sail2_state_monad$bindS
         (sail2_state_monad$read_regS PSTATE_ref) (\ (w__9 : ProcState) .  sail2_state_monad$returnS w__9.ProcState_PAN)
       else sail2_state_monad$returnS (vec_of_bits [B0]  :  1 words$word)) (\ (w__10 :  1 words$word) . 
      let pan = w__10 in sail2_state_monad$bindS
      (sail2_state$and_boolS
        (sail2_state$and_boolS
           (sail2_state$and_boolS
              (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveNVExt () )) /\ ((HaveEL EL2))))))
                 ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__11 : 64 bits) . 
                  sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__11 (( 42 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
              ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__13 : 64 bits) . 
               sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__13 (( 43 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__15 : bool) .  sail2_state_monad$returnS ((~ w__15)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__17 : ProcState) .  sail2_state_monad$returnS (((w__17.ProcState_EL = EL1)))))) (\ (w__18 :
        bool) . 
      let (pan : 1 bits) = (if w__18 then (vec_of_bits [B0]  :  1 words$word) else pan) in sail2_state_monad$bindS
      (sail2_state$or_boolS
        (sail2_state_monad$returnS ((((((((((((pan = (vec_of_bits [B1]  :  1 words$word)))) /\ user_r))) /\ ispriv))) /\ ((~ ((((((acctype = AccType_DC))) \/ ((((((acctype = AccType_AT))) \/ (((acctype = AccType_IFETCH)))))))))))))))
        (sail2_state$and_boolS (sail2_state_monad$returnS (((acctype = AccType_AT)))) ((AArch64_ExecutingATS1xPInstr () )))) (\ (w__21 :
        bool) . 
      let ((priv_r : bool), (priv_w : bool)) =
        (if w__21 then
          let (priv_r : bool) = F in
          let (priv_w : bool) = F in
          (priv_r, priv_w)
        else (priv_r, priv_w)) in
      let (user_xn : bool) =
        ((((perms.Permissions_xn = (vec_of_bits [B1]  :  1 words$word)))) \/ (((user_w /\ wxn)))) in
      let (priv_xn : bool) =
        (((((((perms.Permissions_pxn = (vec_of_bits [B1]  :  1 words$word)))) \/ (((priv_w /\ wxn)))))) \/ user_w) in
      let ((r : bool), (w : bool), (xn : bool)) =
        (if ispriv then
          let (tup__0, tup__1, tup__2) = (priv_r, priv_w, priv_xn) in
          let (r : bool) = tup__0 in
          let (w : bool) = tup__1 in
          let (xn : bool) = tup__2 in
          (r, w, xn)
        else
          let (tup__0, tup__1, tup__2) = (user_r, user_w, user_xn) in
          let (r : bool) = tup__0 in
          let (w : bool) = tup__1 in
          let (xn : bool) = tup__2 in
          (r, w, xn)) in
      sail2_state_monad$returnS (r, w, xn)))))
    else
      let (r : bool) = T in
      let (w : bool) =
        ((vec_of_bits [access_vec_dec perms.Permissions_ap (( 2 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)) in
      let (xn : bool) =
        ((((perms.Permissions_xn = (vec_of_bits [B1]  :  1 words$word)))) \/ (((w /\ wxn)))) in
      sail2_state_monad$returnS (r, w, xn)) (\ varstup .  let ((r : bool), (w : bool), (xn : bool)) = varstup in sail2_state_monad$bindS
   (sail2_state$and_boolS
     (sail2_state$and_boolS (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL3))) ((IsSecure () )))
        (sail2_state_monad$returnS (((NS = (vec_of_bits [B1]  :  1 words$word))))))
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__25 : 32 bits) . 
      sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__25 (( 9 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__26 : bool) . 
   let (xn : bool) = (if w__26 then T else xn) in sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (failedread : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (fail1 : bool) . 
   let ((fail1 : bool), (failedread : bool)) =
     (if (((acctype = AccType_IFETCH))) then
       let (fail1 : bool) = xn in
       let (failedread : bool) = T in
       (fail1, failedread)
     else
       let ((fail1 : bool), (failedread : bool)) =
         (if ((((((acctype = AccType_ATOMICRW))) \/ (((acctype = AccType_ORDEREDRW)))))) then
           let (fail1 : bool) = (((~ r)) \/ ((~ w))) in
           let (failedread : bool) = (~ r) in
           (fail1, failedread)
         else
           let ((fail1 : bool), (failedread : bool)) =
             (if iswrite then
               let (fail1 : bool) = (~ w) in
               let (failedread : bool) = F in
               (fail1, failedread)
             else
               let (fail1 : bool) = (~ r) in
               let (failedread : bool) = T in
               (fail1, failedread)) in
           (fail1, failedread)) in
       (fail1, failedread)) in sail2_state_monad$bindS
   (undefined_bitvector (( 52 : int):ii)  : ( 52 words$word) M) (\ (ipaddress : 52 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (s2fs1walk : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (secondstage : bool) . 
   if fail1 then
     let secondstage = F in
     let s2fs1walk = F in sail2_state_monad$bindS
     (undefined_bitvector (( 52 : int):ii)  : ( 52 words$word) M) (\ (w__27 : 52 bits) . 
     let ipaddress = w__27 in
     AArch64_PermissionFault ipaddress level acctype ((~ failedread)) secondstage s2fs1walk)
   else AArch64_NoFault () ))))))))))))))))))))))))`;


(*val AArch64_FirstStageTranslate : mword ty64 -> AccType -> bool -> bool -> ii -> M AddressDescriptor*)

val _ = Define `
 ((AArch64_FirstStageTranslate:(64)words$word -> AccType -> bool -> bool -> int ->(regstate)sail2_state_monad$sequential_state ->(((AddressDescriptor),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) vaddress acctype iswrite wasaligned size1=  (sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (s1_enabled : bool) .  sail2_state_monad$bindS
   (HasS2Translation () ) (\ (w__0 : bool) .  sail2_state_monad$bindS
   (if w__0 then
      sail2_state$and_boolS
        (sail2_state$and_boolS
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__1 : 64 bits) . 
            sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__1 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__2 : 64 bits) . 
            sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__2 (( 12 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCTLR_EL1_ref  : ( 32 words$word) M) (\ (w__4 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__4 (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))
    else sail2_state_monad$bindS
      (aget_SCTLR__1 ()   : ( 32 words$word) M) (\ (w__6 :  32 words$word) . 
      let (s1_enabled : bool) =
        ((vec_of_bits [access_vec_dec w__6 (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
      sail2_state_monad$returnS s1_enabled)) (\ (s1_enabled : bool) .  sail2_state_monad$bindS
   (undefined_bitvector (( 52 : int):ii)  : ( 52 words$word) M) (\ (ipaddress : 52 bits) . 
   let (secondstage : bool) = F in
   let (s2fs1walk : bool) = F in sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (nTLSMD : 1 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (permissioncheck : bool) .  sail2_state_monad$bindS
   (undefined_TLBRecord () ) (\ (S1 : TLBRecord) .  sail2_state_monad$bindS
   (if s1_enabled then sail2_state_monad$bindS
      (AArch64_TranslationTableWalk ipaddress vaddress acctype iswrite secondstage s2fs1walk size1) (\ (w__7 :
        TLBRecord) . 
      let (S1 : TLBRecord) = w__7 in
      let (permissioncheck : bool) = T in
      sail2_state_monad$returnS (S1, permissioncheck))
    else sail2_state_monad$bindS
      (AArch64_TranslateAddressS1Off vaddress acctype iswrite) (\ (w__8 : TLBRecord) . 
      let S1 = w__8 in
      let permissioncheck = F in sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state$and_boolS ((UsingAArch32 () )) (sail2_state_monad$returnS ((HaveTrapLoadStoreMultipleDeviceExt () ))))
        ((AArch32_ExecutingLSMInstr () ))) (\ (w__12 : bool) .  sail2_state_monad$bindS
      (if w__12 then
         if ((((((S1.TLBRecord_addrdesc.AddressDescriptor_memattrs.MemoryAttributes_typ = MemType_Device))) /\ (((S1.TLBRecord_addrdesc.AddressDescriptor_memattrs.MemoryAttributes_device <> DeviceType_GRE)))))) then sail2_state_monad$bindS
           (S1TranslationRegime__1 ()   : ( 2 words$word) M) (\ (w__13 :  2 words$word) .  sail2_state_monad$bindS
           (if (((w__13 = EL2))) then sail2_state_monad$bindS
              (sail2_state_monad$read_regS SCTLR_EL2_ref  : ( 32 words$word) M) (\ (w__14 : 32 bits) . 
              sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__14 (( 28 : int):ii)]  :  1 words$word))
            else sail2_state_monad$bindS
              (sail2_state_monad$read_regS SCTLR_EL1_ref  : ( 32 words$word) M) (\ (w__15 : 32 bits) . 
              sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__15 (( 28 : int):ii)]  :  1 words$word))) (\ (w__16 :
              1 words$word) . 
           let nTLSMD = w__16 in
           if (((nTLSMD = (vec_of_bits [B0]  :  1 words$word)))) then
             let (tmp_2460 : AddressDescriptor) = (S1.TLBRecord_addrdesc) in sail2_state_monad$bindS
             (AArch64_AlignmentFault acctype iswrite secondstage) (\ (w__17 : FaultRecord) . 
             let (tmp_2460 : AddressDescriptor) =
               ((tmp_2460 with<| AddressDescriptor_fault := w__17|>)) in
             let (S1 : TLBRecord) = ((S1 with<| TLBRecord_addrdesc := tmp_2460|>)) in
             sail2_state_monad$returnS S1)
           else sail2_state_monad$returnS S1))
         else sail2_state_monad$returnS S1
       else sail2_state_monad$returnS S1) (\ (S1 : TLBRecord) . 
      sail2_state_monad$returnS (S1, permissioncheck))))) (\ varstup .  let ((S1 : TLBRecord), (permissioncheck :
     bool)) = varstup in sail2_state_monad$bindS
   (if ((((((((((((((~ wasaligned)) /\ (((acctype <> AccType_IFETCH)))))) \/ (((acctype = AccType_DCZVA)))))) /\ (((S1.TLBRecord_addrdesc.AddressDescriptor_memattrs.MemoryAttributes_typ = MemType_Device)))))) /\ ((~ ((IsFault S1.TLBRecord_addrdesc))))))) then
      let (tmp_2470 : AddressDescriptor) = (S1.TLBRecord_addrdesc) in sail2_state_monad$bindS
      (AArch64_AlignmentFault acctype iswrite secondstage) (\ (w__18 : FaultRecord) . 
      let (tmp_2470 : AddressDescriptor) = ((tmp_2470 with<| AddressDescriptor_fault := w__18|>)) in
      let (S1 : TLBRecord) = ((S1 with<| TLBRecord_addrdesc := tmp_2470|>)) in
      sail2_state_monad$returnS S1)
    else sail2_state_monad$returnS S1) (\ (S1 : TLBRecord) .  sail2_state_monad$bindS
   (if (((((~ ((IsFault S1.TLBRecord_addrdesc)))) /\ permissioncheck))) then
      let (tmp_2480 : AddressDescriptor) = (S1.TLBRecord_addrdesc) in sail2_state_monad$bindS
      (AArch64_CheckPermission S1.TLBRecord_perms vaddress S1.TLBRecord_level
        S1.TLBRecord_addrdesc.AddressDescriptor_paddress.FullAddress_NS acctype iswrite) (\ (w__19 :
        FaultRecord) . 
      let (tmp_2480 : AddressDescriptor) = ((tmp_2480 with<| AddressDescriptor_fault := w__19|>)) in
      let (S1 : TLBRecord) = ((S1 with<| TLBRecord_addrdesc := tmp_2480|>)) in
      sail2_state_monad$returnS S1)
    else sail2_state_monad$returnS S1) (\ (S1 : TLBRecord) .  sail2_state_monad$bindS
   (if ((((((((~ ((IsFault S1.TLBRecord_addrdesc)))) /\ (((S1.TLBRecord_addrdesc.AddressDescriptor_memattrs.MemoryAttributes_typ = MemType_Device)))))) /\ (((acctype = AccType_IFETCH)))))) then sail2_state_monad$bindS
      (AArch64_InstructionDevice S1.TLBRecord_addrdesc vaddress ipaddress S1.TLBRecord_level acctype
        iswrite secondstage s2fs1walk) (\ (w__20 : AddressDescriptor) . 
      let (S1 : TLBRecord) = ((S1 with<| TLBRecord_addrdesc := w__20|>)) in
      sail2_state_monad$returnS S1)
    else sail2_state_monad$returnS S1) (\ (S1 : TLBRecord) . 
   let (hwupdatewalk : bool) = F in
   let s2fs1walk = F in
   let (tmp_2490 : AddressDescriptor) = (S1.TLBRecord_addrdesc) in sail2_state_monad$bindS
   (AArch64_CheckAndUpdateDescriptor S1.TLBRecord_descupdate
     S1.TLBRecord_addrdesc.AddressDescriptor_fault secondstage vaddress acctype iswrite s2fs1walk
     hwupdatewalk) (\ (w__21 : FaultRecord) . 
   let (tmp_2490 : AddressDescriptor) = ((tmp_2490 with<| AddressDescriptor_fault := w__21|>)) in
   let (S1 : TLBRecord) = ((S1 with<| TLBRecord_addrdesc := tmp_2490|>)) in
   sail2_state_monad$returnS S1.TLBRecord_addrdesc))))))))))))))`;


(*val AArch64_FullTranslate : mword ty64 -> AccType -> bool -> bool -> ii -> M AddressDescriptor*)

val _ = Define `
 ((AArch64_FullTranslate:(64)words$word -> AccType -> bool -> bool -> int ->(regstate)sail2_state_monad$sequential_state ->(((AddressDescriptor),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) vaddress acctype iswrite wasaligned size1=  (sail2_state_monad$bindS
   (AArch64_FirstStageTranslate vaddress acctype iswrite wasaligned size1) (\ (S1 :
     AddressDescriptor) .  sail2_state_monad$bindS
   (undefined_AddressDescriptor () ) (\ (result : AddressDescriptor) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (hwupdatewalk : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (s2fs1walk : bool) .  sail2_state_monad$bindS
   (sail2_state$and_boolS (sail2_state_monad$returnS ((~ ((IsFault S1))))) ((HasS2Translation () ))) (\ (w__1 : bool) . 
   if w__1 then
     let s2fs1walk = F in
     let hwupdatewalk = F in
     AArch64_SecondStageTranslate S1 vaddress acctype iswrite wasaligned s2fs1walk size1 hwupdatewalk
   else sail2_state_monad$returnS S1)))))))`;


(*val AArch64_TranslateAddress : mword ty64 -> AccType -> bool -> bool -> ii -> M AddressDescriptor*)

val _ = Define `
 ((AArch64_TranslateAddress:(64)words$word -> AccType -> bool -> bool -> int ->(regstate)sail2_state_monad$sequential_state ->(((AddressDescriptor),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) vaddress acctype iswrite wasaligned size1=  (sail2_state_monad$bindS
   (AArch64_FullTranslate vaddress acctype iswrite wasaligned size1) (\ (result :
     AddressDescriptor) .  sail2_state_monad$bindS
   (if (((((~ ((((((acctype = AccType_PTW))) \/ ((((((acctype = AccType_IC))) \/ (((acctype = AccType_AT))))))))))) /\ ((~ ((IsFault result))))))) then sail2_state_monad$bindS
      (AArch64_CheckDebug vaddress acctype iswrite size1) (\ (w__0 : FaultRecord) . 
      let (result : AddressDescriptor) = ((result with<| AddressDescriptor_fault := w__0|>)) in
      sail2_state_monad$returnS result)
    else sail2_state_monad$returnS result) (\ (result : AddressDescriptor) .  sail2_state_monad$bindS
   (ZeroExtend__1 (( 64 : int):ii) vaddress  : ( 64 words$word) M) (\ (w__1 : 64 bits) . 
   let (result : AddressDescriptor) = ((result with<| AddressDescriptor_vaddress := w__1|>)) in
   sail2_state_monad$returnS result)))))`;


(*val AArch64_aset_MemSingle : forall   'p8_times_size_ . Size 'p8_times_size_ => mword ty64 -> integer -> AccType -> bool -> mword 'p8_times_size_ -> M unit*)

val _ = Define `
 ((AArch64_aset_MemSingle:(64)words$word -> int -> AccType -> bool -> 'p8_times_size_ words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) address size1 acctype wasaligned value_name=  (sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((((size1 = (( 1 : int):ii)))) \/ ((((((size1 = (( 2 : int):ii)))) \/ ((((((size1 = (( 4 : int):ii)))) \/ ((((((size1 = (( 8 : int):ii)))) \/ (((size1 = (( 16 : int):ii)))))))))))))))) "((size == 1) || ((size == 2) || ((size == 4) || ((size == 8) || (size == 16)))))")
   (sail2_state_monad$assert_expS (((address = ((Align__1 address size1  :  64 words$word))))) "(address == Align(address, size))"))
   (undefined_AddressDescriptor () )) (\ (memaddrdesc : AddressDescriptor) . 
   let (iswrite : bool) = T in sail2_state_monad$bindS
   (AArch64_TranslateAddress address acctype iswrite wasaligned size1) (\ (w__0 :
     AddressDescriptor) . 
   let memaddrdesc = w__0 in sail2_state_monad$seqS
   (if ((IsFault memaddrdesc)) then AArch64_Abort address memaddrdesc.AddressDescriptor_fault
    else sail2_state_monad$returnS () )
   (let (_ : unit) =
     (if memaddrdesc.AddressDescriptor_memattrs.MemoryAttributes_shareable then
       ClearExclusiveByAddress memaddrdesc.AddressDescriptor_paddress ((ProcessorID () )) size1
     else () ) in sail2_state_monad$bindS
   (CreateAccessDescriptor acctype) (\ (accdesc : AccessDescriptor) . 
   aset__Mem memaddrdesc size1 accdesc value_name))))))`;


(*val aset_Mem : forall   'p8_times_size_ . Size 'p8_times_size_ => mword ty64 -> integer -> AccType -> mword 'p8_times_size_ -> M unit*)

val _ = Define `
 ((aset_Mem:(64)words$word -> int -> AccType -> 'p8_times_size_ words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) address size1 acctype value_name__arg=
    (let value_name = value_name__arg in sail2_state_monad$bindS
   (undefined_int () ) (\ (i : ii) . 
   let (iswrite : bool) = T in sail2_state_monad$bindS
   (BigEndian () ) (\ (w__0 : bool) .  sail2_state_monad$bindS
   (if w__0 then (BigEndianReverse value_name  : ( 'p8_times_size_ words$word) M)
    else sail2_state_monad$returnS value_name) (\ value_name .  sail2_state_monad$bindS
   (AArch64_CheckAlignment address size1 acctype iswrite) (\ (aligned : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (atomic : bool) . 
   let (atomic : bool) =
     (if ((((((size1 <> (( 16 : int):ii)))) \/ ((~ ((((((acctype = AccType_VEC))) \/ (((acctype = AccType_VECSTREAM))))))))))) then
       aligned
     else (address = ((Align__1 address (( 8 : int):ii)  :  64 words$word)))) in sail2_state_monad$bindS
   (undefined_Constraint () ) (\ (c : Constraint) . 
   if ((~ atomic)) then sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS ((size1 > (( 1 : int):ii))) "(size > 1)")
     (AArch64_aset_MemSingle address (( 1 : int):ii) acctype aligned
       ((slice value_name (( 0 : int):ii) (( 8 : int):ii)  :  8 words$word))))
     (if ((~ aligned)) then
        let c = (ConstrainUnpredictable Unpredictable_DEVPAGE2) in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((c = Constraint_FAULT))) \/ (((c = Constraint_NONE)))))) "((c == Constraint_FAULT) || (c == Constraint_NONE))")
        (let (aligned : bool) = (if (((c = Constraint_NONE))) then T else aligned) in
        sail2_state_monad$returnS aligned)
      else sail2_state_monad$returnS aligned)) (\ (aligned : bool) . 
     (sail2_state$foreachS (index_list (( 1 : int):ii) ((size1 - (( 1 : int):ii))) (( 1 : int):ii)) () 
       (\ i unit_var . 
         AArch64_aset_MemSingle ((add_vec_int address i  :  64 words$word)) (( 1 : int):ii) acctype aligned
           ((slice value_name (((( 8 : int):ii) * i)) (( 8 : int):ii)  :  8 words$word)))))
   else if ((((((size1 = (( 16 : int):ii)))) /\ ((((((acctype = AccType_VEC))) \/ (((acctype = AccType_VECSTREAM))))))))) then sail2_state_monad$seqS
     (AArch64_aset_MemSingle address (( 8 : int):ii) acctype aligned
       ((slice value_name (( 0 : int):ii) (( 64 : int):ii)  :  64 words$word)))
     (AArch64_aset_MemSingle ((add_vec_int address (( 8 : int):ii)  :  64 words$word)) (( 8 : int):ii) acctype aligned
       ((slice value_name (( 64 : int):ii) (( 64 : int):ii)  :  64 words$word)))
   else AArch64_aset_MemSingle address size1 acctype aligned value_name))))))))`;


(*val AArch64_aget_MemSingle : forall   'p8_times_size_ . Size 'p8_times_size_ => mword ty64 -> integer -> AccType -> bool -> M (mword 'p8_times_size_)*)

val _ = Define `
 ((AArch64_aget_MemSingle:(64)words$word -> int -> AccType -> bool ->(regstate)sail2_state_monad$sequential_state ->((('p8_times_size_ words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) address size1 acctype wasaligned=  (sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((((size1 = (( 1 : int):ii)))) \/ ((((((size1 = (( 2 : int):ii)))) \/ ((((((size1 = (( 4 : int):ii)))) \/ ((((((size1 = (( 8 : int):ii)))) \/ (((size1 = (( 16 : int):ii)))))))))))))))) "((size == 1) || ((size == 2) || ((size == 4) || ((size == 8) || (size == 16)))))")
   (sail2_state_monad$assert_expS (((address = ((Align__1 address size1  :  64 words$word))))) "(address == Align(address, size))"))
   (undefined_AddressDescriptor () )) (\ (memaddrdesc : AddressDescriptor) .  sail2_state_monad$bindS
   (undefined_bitvector (((( 8 : int):ii) * size1))  : ( 'p8_times_size_ words$word) M) (\ value_name . 
   let (iswrite : bool) = F in sail2_state_monad$bindS
   (AArch64_TranslateAddress address acctype iswrite wasaligned size1) (\ (w__0 :
     AddressDescriptor) . 
   let memaddrdesc = w__0 in sail2_state_monad$bindS (sail2_state_monad$seqS
   (if ((IsFault memaddrdesc)) then AArch64_Abort address memaddrdesc.AddressDescriptor_fault
    else sail2_state_monad$returnS () )
   (CreateAccessDescriptor acctype)) (\ (accdesc : AccessDescriptor) . 
   (aget__Mem memaddrdesc size1 accdesc  : ( 'p8_times_size_ words$word) M)))))))`;


(*val aget_Mem : forall   'p8_times_size_ . Size 'p8_times_size_ => mword ty64 -> integer -> AccType -> M (mword 'p8_times_size_)*)

val _ = Define `
 ((aget_Mem:(64)words$word -> int -> AccType ->(regstate)sail2_state_monad$sequential_state ->((('p8_times_size_ words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) address size1 acctype=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((((((size1 = (( 1 : int):ii)))) \/ ((((((size1 = (( 2 : int):ii)))) \/ ((((((size1 = (( 4 : int):ii)))) \/ ((((((size1 = (( 8 : int):ii)))) \/ (((size1 = (( 16 : int):ii)))))))))))))))) "((size == 1) || ((size == 2) || ((size == 4) || ((size == 8) || (size == 16)))))")
   (undefined_bitvector (((( 8 : int):ii) * size1))  : ( 'p8_times_size_ words$word) M)) (\ value_name .  sail2_state_monad$bindS
   (undefined_int () ) (\ (i : ii) . 
   let (iswrite : bool) = F in sail2_state_monad$bindS
   (AArch64_CheckAlignment address size1 acctype iswrite) (\ (aligned : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (atomic : bool) . 
   let (atomic : bool) =
     (if ((((((size1 <> (( 16 : int):ii)))) \/ ((~ ((((((acctype = AccType_VEC))) \/ (((acctype = AccType_VECSTREAM))))))))))) then
       aligned
     else (address = ((Align__1 address (( 8 : int):ii)  :  64 words$word)))) in sail2_state_monad$bindS
   (undefined_Constraint () ) (\ (c : Constraint) .  sail2_state_monad$bindS
   (if ((~ atomic)) then sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$assert_expS ((size1 > (( 1 : int):ii))) "(size > 1)")
      (AArch64_aget_MemSingle address (( 1 : int):ii) acctype aligned  : ( 8 words$word) M)) (\ (w__0 :
         8 words$word) . 
      let value_name =
        ((set_slice (((( 8 : int):ii) * size1)) (( 8 : int):ii) value_name (( 0 : int):ii) w__0
          :  'p8_times_size_ words$word)) in sail2_state_monad$bindS
      (if ((~ aligned)) then
         let c = (ConstrainUnpredictable Unpredictable_DEVPAGE2) in sail2_state_monad$seqS
         (sail2_state_monad$assert_expS ((((((c = Constraint_FAULT))) \/ (((c = Constraint_NONE)))))) "((c == Constraint_FAULT) || (c == Constraint_NONE))")
         (let (aligned : bool) = (if (((c = Constraint_NONE))) then T else aligned) in
         sail2_state_monad$returnS aligned)
       else sail2_state_monad$returnS aligned) (\ (aligned : bool) . 
      (sail2_state$foreachS (index_list (( 1 : int):ii) ((size1 - (( 1 : int):ii))) (( 1 : int):ii)) value_name
        (\ i value_name .  sail2_state_monad$bindS
          (AArch64_aget_MemSingle ((add_vec_int address i  :  64 words$word)) (( 1 : int):ii) acctype aligned
            : ( 8 words$word) M) (\ (w__1 :  8 words$word) . 
          let value_name =
            ((set_slice (((( 8 : int):ii) * size1)) (( 8 : int):ii) value_name (((( 8 : int):ii) * i)) w__1
              :  'p8_times_size_ words$word)) in
          sail2_state_monad$returnS value_name)))))
    else if ((((((size1 = (( 16 : int):ii)))) /\ ((((((acctype = AccType_VEC))) \/ (((acctype = AccType_VECSTREAM))))))))) then sail2_state_monad$bindS
      (AArch64_aget_MemSingle address (( 8 : int):ii) acctype aligned  : ( 64 words$word) M) (\ (w__2 :
         64 words$word) . 
      let value_name =
        ((set_slice (((( 8 : int):ii) * (( 16 : int):ii))) (( 64 : int):ii) value_name (( 0 : int):ii) w__2
          :  'p8_times_size_ words$word)) in sail2_state_monad$bindS
      (AArch64_aget_MemSingle ((add_vec_int address (( 8 : int):ii)  :  64 words$word)) (( 8 : int):ii) acctype aligned
        : ( 64 words$word) M) (\ (w__3 :  64 words$word) . 
      let value_name =
        ((set_slice (((( 8 : int):ii) * (( 16 : int):ii))) (( 64 : int):ii) value_name (( 64 : int):ii) w__3
          :  'p8_times_size_ words$word)) in
      sail2_state_monad$returnS value_name))
    else (AArch64_aget_MemSingle address size1 acctype aligned  : ( 'p8_times_size_ words$word) M)) (\ value_name .  sail2_state_monad$bindS
   (BigEndian () ) (\ (w__5 : bool) . 
   if w__5 then (BigEndianReverse value_name  : ( 'p8_times_size_ words$word) M)
   else sail2_state_monad$returnS value_name)))))))))`;


(*val aarch64_memory_vector_single_nowb : forall 'datasize 'esize . Size 'datasize, Size 'esize => itself 'datasize -> itself 'esize -> ii -> ii -> MemOp -> ii -> bool -> integer -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_memory_vector_single_nowb:'datasize itself -> 'esize itself -> int -> int -> MemOp -> int -> bool -> int -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) datasize esize index m memop n replicate selem t__arg wback=
    (let esize = (size_itself_int esize) in
   let datasize = (size_itself_int datasize) in sail2_state_monad$seqS
   (sail2_state_monad$assert_expS T "")
   (let (t : ii) = t__arg in sail2_state_monad$bindS (sail2_state_monad$seqS
   (CheckFPAdvSIMDEnabled64 () )
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (offs : 64 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M) (\ (rval : 128 bits) .  sail2_state_monad$bindS
   (undefined_bitvector esize  : ( 'esize words$word) M) (\ (element1 : 'esize bits) .  sail2_state_monad$bindS
   (undefined_int () ) (\ (s : ii) . 
   let (ebytes : int) = (ex_int ((esize / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS T "")
   (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
    else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M))) (\ (address : 64 bits) . 
   let offs = ((Zeros__1 (( 64 : int):ii) ()   :  64 words$word)) in sail2_state_monad$bindS
   (if replicate then sail2_state_monad$bindS
      (sail2_state$foreachS (index_list (( 0 : int):ii) ((selem - (( 1 : int):ii))) (( 1 : int):ii)) (element1, offs, t)
        (\ s varstup .  let (element1, offs, t) = varstup in sail2_state_monad$bindS
          (aget_Mem ((add_vec address offs  :  64 words$word)) ebytes AccType_VEC  : ( 'esize words$word) M) (\ (w__2 : 'esize
            bits) . 
          let element1 = w__2 in
          let (v : int) = (ex_int ((datasize / esize))) in sail2_state_monad$seqS (sail2_state_monad$seqS
          (sail2_state_monad$assert_expS T "")
          (aset_V t ((replicate_bits element1 v  :  'datasize words$word))))
          (let (offs : 64 bits) = ((add_vec_int offs ebytes  :  64 words$word)) in
          let (t : ii) = (((((ex_int t)) + (( 1 : int):ii))) % (( 32 : int):ii)) in
          sail2_state_monad$returnS (element1, offs, t))))) (\ varstup .  let ((element1 : 'esize bits), (offs : 64
        bits), (t : ii)) = varstup in
      sail2_state_monad$returnS offs)
    else sail2_state_monad$bindS
      (sail2_state$foreachS (index_list (( 0 : int):ii) ((selem - (( 1 : int):ii))) (( 1 : int):ii)) (offs, rval, t)
        (\ s varstup .  let (offs, rval, t) = varstup in sail2_state_monad$bindS
          (aget_V (( 128 : int):ii) t  : ( 128 words$word) M) (\ (w__3 : 128 bits) . 
          let rval = w__3 in sail2_state_monad$bindS
          (if (((memop = MemOp_LOAD))) then sail2_state_monad$bindS
             (aget_Mem ((add_vec address offs  :  64 words$word)) ebytes AccType_VEC  : ( 'esize words$word) M) (\ (w__4 :
                'esize words$word) .  sail2_state_monad$bindS
             (aset_Elem__0 rval index ((make_the_value esize  :  'esize itself)) w__4
               : ( 128 words$word) M) (\ (w__5 : 128 bits) . 
             let rval = w__5 in sail2_state_monad$seqS
             (aset_V t rval) (sail2_state_monad$returnS rval)))
           else sail2_state_monad$bindS
             (aget_Elem__0 rval index ((make_the_value esize  :  'esize itself))  : ( 'esize words$word) M) (\ w__6 .  sail2_state_monad$seqS
             (aset_Mem ((add_vec address offs  :  64 words$word)) ebytes AccType_VEC w__6) (sail2_state_monad$returnS rval))) (\ (rval : 128
            bits) . 
          let (offs : 64 bits) = ((add_vec_int offs ebytes  :  64 words$word)) in
          let (t : ii) = (((((ex_int t)) + (( 1 : int):ii))) % (( 32 : int):ii)) in
          sail2_state_monad$returnS (offs, rval, t))))) (\ varstup .  let ((offs : 64 bits), (rval : 128 bits), (t :
        ii)) = varstup in
      sail2_state_monad$returnS offs)) (\ (offs : 64 bits) . 
   if wback then sail2_state_monad$bindS
     (if (((m <> (( 31 : int):ii)))) then (aget_X (( 64 : int):ii) m  : ( 64 words$word) M)
      else sail2_state_monad$returnS offs) (\ (offs : 64 bits) . 
     if (((n = (( 31 : int):ii)))) then aset_SP ((add_vec address offs  :  64 words$word))
     else aset_X n ((add_vec address offs  :  64 words$word)))
   else sail2_state_monad$returnS () ))))))))))`;


(*val aarch64_memory_vector_multiple_nowb : forall 'datasize 'esize   . Size 'datasize, Size 'esize => itself 'datasize -> integer -> itself 'esize -> ii -> MemOp -> ii -> integer -> integer -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_memory_vector_multiple_nowb:'datasize itself -> int -> 'esize itself -> int -> MemOp -> int -> int -> int -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) datasize elements esize m memop n rpt selem t wback=
    (let esize = (size_itself_int esize) in
   let datasize = (size_itself_int datasize) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS T "datasize constraint")
   (CheckFPAdvSIMDEnabled64 () ))
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (offs : 64 bits) .  sail2_state_monad$bindS
   (undefined_bitvector datasize  : ( 'datasize words$word) M) (\ (rval : 'datasize bits) .  sail2_state_monad$bindS
   (undefined_int () ) (\ (e : ii) .  sail2_state_monad$bindS
   (undefined_int () ) (\ (r : ii) .  sail2_state_monad$bindS
   (undefined_int () ) (\ (s : ii) .  sail2_state_monad$bindS
   (undefined_int () ) (\ (tt : ii) . 
   let ebytes = (ex_int ((esize / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS T "")
   (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
    else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M))) (\ (address : 64 bits) . 
   let offs = ((Zeros__1 (( 64 : int):ii) ()   :  64 words$word)) in sail2_state_monad$bindS
   (sail2_state$foreachS (index_list (( 0 : int):ii) ((rpt - (( 1 : int):ii))) (( 1 : int):ii)) (offs, rval, tt)
     (\ r varstup .  let (offs, rval, tt) = varstup in
       (sail2_state$foreachS (index_list (( 0 : int):ii) ((elements - (( 1 : int):ii))) (( 1 : int):ii)) (offs, rval, tt)
         (\ e varstup .  let (offs, rval, tt) = varstup in
           let tt = (((t + r)) % (( 32 : int):ii)) in
           (sail2_state$foreachS (index_list (( 0 : int):ii) ((selem - (( 1 : int):ii))) (( 1 : int):ii)) (offs, rval, tt)
             (\ s varstup .  let (offs, rval, tt) = varstup in sail2_state_monad$bindS
               (aget_V datasize tt  : ( 'datasize words$word) M) (\ (w__2 : 'datasize bits) . 
               let rval = w__2 in sail2_state_monad$bindS
               (if (((memop = MemOp_LOAD))) then sail2_state_monad$bindS
                  (aget_Mem ((add_vec address offs  :  64 words$word)) ebytes AccType_VEC
                    : ( 'esize words$word) M) (\ (w__3 :  'esize words$word) .  sail2_state_monad$bindS
                  (aset_Elem__0 rval e ((make_the_value esize  :  'esize itself)) w__3
                    : ( 'datasize words$word) M) (\ (w__4 : 'datasize bits) . 
                  let rval = w__4 in sail2_state_monad$seqS
                  (aset_V tt rval) (sail2_state_monad$returnS rval)))
                else sail2_state_monad$bindS
                  (aget_Elem__0 rval e ((make_the_value esize  :  'esize itself))  : ( 'esize words$word) M) (\ w__5 .  sail2_state_monad$seqS
                  (aset_Mem ((add_vec address offs  :  64 words$word)) ebytes AccType_VEC w__5)
                  (sail2_state_monad$returnS rval))) (\ (rval : 'datasize bits) . 
               let (offs : 64 bits) = ((add_vec_int offs ebytes  :  64 words$word)) in
               let (tt : ii) = (((((ex_int tt)) + (( 1 : int):ii))) % (( 32 : int):ii)) in
               sail2_state_monad$returnS (offs, rval, tt))))))))) (\ varstup .  let ((offs : 64 bits), (rval : 'datasize
     bits), (tt : ii)) = varstup in
   if wback then sail2_state_monad$bindS
     (if (((m <> (( 31 : int):ii)))) then (aget_X (( 64 : int):ii) m  : ( 64 words$word) M)
      else sail2_state_monad$returnS offs) (\ (offs : 64 bits) . 
     if (((n = (( 31 : int):ii)))) then aset_SP ((add_vec address offs  :  64 words$word))
     else aset_X n ((add_vec address offs  :  64 words$word)))
   else sail2_state_monad$returnS () )))))))))))`;


(*val aarch64_memory_single_simdfp_register : AccType -> ii -> ExtendType -> ii -> MemOp -> ii -> bool -> ii -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_memory_single_simdfp_register:AccType -> int -> ExtendType -> int -> MemOp -> int -> bool -> int -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) acctype l__83 extend_type m memop n postindex shift t wback=
    (if (((l__83 = (( 8 : int):ii)))) then
     let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (ExtendReg (( 64 : int):ii) m extend_type shift  : ( 64 words$word) M)) (\ (offset : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (CheckFPAdvSIMDEnabled64 () )
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M) (\ (data : 8 bits) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (aget_V (( 8 : int):ii) t  : ( 8 words$word) M) (\ (w__2 : 8 bits) . 
        let data = w__2 in
        aset_Mem address (((( 8 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 8 : int):ii) / (( 8 : int):ii))) acctype  : ( 8 words$word) M) (\ (w__3 : 8
          bits) . 
        let data = w__3 in
        aset_V t data)
     )
     (if wback then
       let (address : 64 bits) =
         (if postindex then (add_vec address offset  :  64 words$word)
         else address) in
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address
     else sail2_state_monad$returnS () )))))
   else if (((l__83 = (( 16 : int):ii)))) then
     let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (ExtendReg (( 64 : int):ii) m extend_type shift  : ( 64 words$word) M)) (\ (offset : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (CheckFPAdvSIMDEnabled64 () )
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M) (\ (data : 16 bits) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (aget_V (( 16 : int):ii) t  : ( 16 words$word) M) (\ (w__6 : 16 bits) . 
        let data = w__6 in
        aset_Mem address (((( 16 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 16 : int):ii) / (( 8 : int):ii))) acctype  : ( 16 words$word) M) (\ (w__7 : 16
          bits) . 
        let data = w__7 in
        aset_V t data)
     )
     (if wback then
       let (address : 64 bits) =
         (if postindex then (add_vec address offset  :  64 words$word)
         else address) in
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address
     else sail2_state_monad$returnS () )))))
   else if (((l__83 = (( 32 : int):ii)))) then
     let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (ExtendReg (( 64 : int):ii) m extend_type shift  : ( 64 words$word) M)) (\ (offset : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (CheckFPAdvSIMDEnabled64 () )
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (data : 32 bits) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (aget_V (( 32 : int):ii) t  : ( 32 words$word) M) (\ (w__10 : 32 bits) . 
        let data = w__10 in
        aset_Mem address (((( 32 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 32 : int):ii) / (( 8 : int):ii))) acctype  : ( 32 words$word) M) (\ (w__11 : 32
          bits) . 
        let data = w__11 in
        aset_V t data)
     )
     (if wback then
       let (address : 64 bits) =
         (if postindex then (add_vec address offset  :  64 words$word)
         else address) in
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address
     else sail2_state_monad$returnS () )))))
   else if (((l__83 = (( 64 : int):ii)))) then
     let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (ExtendReg (( 64 : int):ii) m extend_type shift  : ( 64 words$word) M)) (\ (offset : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (CheckFPAdvSIMDEnabled64 () )
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (data : 64 bits) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (aget_V (( 64 : int):ii) t  : ( 64 words$word) M) (\ (w__14 : 64 bits) . 
        let data = w__14 in
        aset_Mem address (((( 64 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 64 : int):ii) / (( 8 : int):ii))) acctype  : ( 64 words$word) M) (\ (w__15 : 64
          bits) . 
        let data = w__15 in
        aset_V t data)
     )
     (if wback then
       let (address : 64 bits) =
         (if postindex then (add_vec address offset  :  64 words$word)
         else address) in
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address
     else sail2_state_monad$returnS () )))))
   else if (((l__83 = (( 128 : int):ii)))) then
     let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (ExtendReg (( 64 : int):ii) m extend_type shift  : ( 64 words$word) M)) (\ (offset : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (CheckFPAdvSIMDEnabled64 () )
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M) (\ (data : 128 bits) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (aget_V (( 128 : int):ii) t  : ( 128 words$word) M) (\ (w__18 : 128 bits) . 
        let data = w__18 in
        aset_Mem address (((( 128 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 128 : int):ii) / (( 8 : int):ii))) acctype  : ( 128 words$word) M) (\ (w__19 : 128
          bits) . 
        let data = w__19 in
        aset_V t data)
     )
     (if wback then
       let (address : 64 bits) =
         (if postindex then (add_vec address offset  :  64 words$word)
         else address) in
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address
     else sail2_state_monad$returnS () )))))
   else
     let dbytes = (ex_int ((l__83 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint"))`;


(*val aarch64_memory_single_simdfp_immediate_signed_postidx : AccType -> ii -> MemOp -> ii -> mword ty64 -> bool -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_memory_single_simdfp_immediate_signed_postidx:AccType -> int -> MemOp -> int ->(64)words$word -> bool -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) acctype l__78 memop n offset postindex t wback=
    (if (((l__78 = (( 8 : int):ii)))) then
     let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M) (\ (data : 8 bits) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (aget_V (( 8 : int):ii) t  : ( 8 words$word) M) (\ (w__2 : 8 bits) . 
        let data = w__2 in
        aset_Mem address (((( 8 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 8 : int):ii) / (( 8 : int):ii))) acctype  : ( 8 words$word) M) (\ (w__3 : 8
          bits) . 
        let data = w__3 in
        aset_V t data)
     )
     (if wback then
       let (address : 64 bits) =
         (if postindex then (add_vec address offset  :  64 words$word)
         else address) in
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address
     else sail2_state_monad$returnS () ))))
   else if (((l__78 = (( 16 : int):ii)))) then
     let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M) (\ (data : 16 bits) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (aget_V (( 16 : int):ii) t  : ( 16 words$word) M) (\ (w__6 : 16 bits) . 
        let data = w__6 in
        aset_Mem address (((( 16 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 16 : int):ii) / (( 8 : int):ii))) acctype  : ( 16 words$word) M) (\ (w__7 : 16
          bits) . 
        let data = w__7 in
        aset_V t data)
     )
     (if wback then
       let (address : 64 bits) =
         (if postindex then (add_vec address offset  :  64 words$word)
         else address) in
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address
     else sail2_state_monad$returnS () ))))
   else if (((l__78 = (( 32 : int):ii)))) then
     let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (data : 32 bits) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (aget_V (( 32 : int):ii) t  : ( 32 words$word) M) (\ (w__10 : 32 bits) . 
        let data = w__10 in
        aset_Mem address (((( 32 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 32 : int):ii) / (( 8 : int):ii))) acctype  : ( 32 words$word) M) (\ (w__11 : 32
          bits) . 
        let data = w__11 in
        aset_V t data)
     )
     (if wback then
       let (address : 64 bits) =
         (if postindex then (add_vec address offset  :  64 words$word)
         else address) in
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address
     else sail2_state_monad$returnS () ))))
   else if (((l__78 = (( 64 : int):ii)))) then
     let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (data : 64 bits) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (aget_V (( 64 : int):ii) t  : ( 64 words$word) M) (\ (w__14 : 64 bits) . 
        let data = w__14 in
        aset_Mem address (((( 64 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 64 : int):ii) / (( 8 : int):ii))) acctype  : ( 64 words$word) M) (\ (w__15 : 64
          bits) . 
        let data = w__15 in
        aset_V t data)
     )
     (if wback then
       let (address : 64 bits) =
         (if postindex then (add_vec address offset  :  64 words$word)
         else address) in
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address
     else sail2_state_monad$returnS () ))))
   else if (((l__78 = (( 128 : int):ii)))) then
     let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M) (\ (data : 128 bits) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (aget_V (( 128 : int):ii) t  : ( 128 words$word) M) (\ (w__18 : 128 bits) . 
        let data = w__18 in
        aset_Mem address (((( 128 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 128 : int):ii) / (( 8 : int):ii))) acctype  : ( 128 words$word) M) (\ (w__19 : 128
          bits) . 
        let data = w__19 in
        aset_V t data)
     )
     (if wback then
       let (address : 64 bits) =
         (if postindex then (add_vec address offset  :  64 words$word)
         else address) in
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address
     else sail2_state_monad$returnS () ))))
   else
     let dbytes = (ex_int ((l__78 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint"))`;


(*val aarch64_memory_single_simdfp_immediate_signed_offset_normal : AccType -> ii -> MemOp -> ii -> mword ty64 -> bool -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_memory_single_simdfp_immediate_signed_offset_normal:AccType -> int -> MemOp -> int ->(64)words$word -> bool -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) acctype l__73 memop n offset postindex t wback=
    (if (((l__73 = (( 8 : int):ii)))) then
     let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M) (\ (data : 8 bits) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (aget_V (( 8 : int):ii) t  : ( 8 words$word) M) (\ (w__2 : 8 bits) . 
        let data = w__2 in
        aset_Mem address (((( 8 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 8 : int):ii) / (( 8 : int):ii))) acctype  : ( 8 words$word) M) (\ (w__3 : 8
          bits) . 
        let data = w__3 in
        aset_V t data)
     )
     (if wback then
       let (address : 64 bits) =
         (if postindex then (add_vec address offset  :  64 words$word)
         else address) in
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address
     else sail2_state_monad$returnS () ))))
   else if (((l__73 = (( 16 : int):ii)))) then
     let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M) (\ (data : 16 bits) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (aget_V (( 16 : int):ii) t  : ( 16 words$word) M) (\ (w__6 : 16 bits) . 
        let data = w__6 in
        aset_Mem address (((( 16 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 16 : int):ii) / (( 8 : int):ii))) acctype  : ( 16 words$word) M) (\ (w__7 : 16
          bits) . 
        let data = w__7 in
        aset_V t data)
     )
     (if wback then
       let (address : 64 bits) =
         (if postindex then (add_vec address offset  :  64 words$word)
         else address) in
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address
     else sail2_state_monad$returnS () ))))
   else if (((l__73 = (( 32 : int):ii)))) then
     let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (data : 32 bits) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (aget_V (( 32 : int):ii) t  : ( 32 words$word) M) (\ (w__10 : 32 bits) . 
        let data = w__10 in
        aset_Mem address (((( 32 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 32 : int):ii) / (( 8 : int):ii))) acctype  : ( 32 words$word) M) (\ (w__11 : 32
          bits) . 
        let data = w__11 in
        aset_V t data)
     )
     (if wback then
       let (address : 64 bits) =
         (if postindex then (add_vec address offset  :  64 words$word)
         else address) in
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address
     else sail2_state_monad$returnS () ))))
   else if (((l__73 = (( 64 : int):ii)))) then
     let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (data : 64 bits) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (aget_V (( 64 : int):ii) t  : ( 64 words$word) M) (\ (w__14 : 64 bits) . 
        let data = w__14 in
        aset_Mem address (((( 64 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 64 : int):ii) / (( 8 : int):ii))) acctype  : ( 64 words$word) M) (\ (w__15 : 64
          bits) . 
        let data = w__15 in
        aset_V t data)
     )
     (if wback then
       let (address : 64 bits) =
         (if postindex then (add_vec address offset  :  64 words$word)
         else address) in
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address
     else sail2_state_monad$returnS () ))))
   else if (((l__73 = (( 128 : int):ii)))) then
     let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (CheckFPAdvSIMDEnabled64 () ))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M) (\ (data : 128 bits) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (aget_V (( 128 : int):ii) t  : ( 128 words$word) M) (\ (w__18 : 128 bits) . 
        let data = w__18 in
        aset_Mem address (((( 128 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 128 : int):ii) / (( 8 : int):ii))) acctype  : ( 128 words$word) M) (\ (w__19 : 128
          bits) . 
        let data = w__19 in
        aset_V t data)
     )
     (if wback then
       let (address : 64 bits) =
         (if postindex then (add_vec address offset  :  64 words$word)
         else address) in
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address
     else sail2_state_monad$returnS () ))))
   else
     let dbytes = (ex_int ((l__73 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint"))`;


(*val aarch64_memory_ordered : forall 'datasize 'regsize. Size 'datasize, Size 'regsize => AccType -> itself 'datasize -> MemOp -> ii -> itself 'regsize -> ii -> M unit*)

val _ = Define `
 ((aarch64_memory_ordered:AccType -> 'datasize itself -> MemOp -> int -> 'regsize itself -> int ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) acctype datasize memop n regsize t=
    (let regsize = (size_itself_int regsize) in
   let datasize = (size_itself_int datasize) in sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS T "datasize constraint")
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
   (undefined_bitvector datasize  : ( 'datasize words$word) M) (\ (data : 'datasize bits) . 
   let dbytes = (ex_int ((datasize / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS T "")
   (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
    else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M))) (\ (address : 64 bits) . 
   (case memop of
     MemOp_STORE => sail2_state_monad$bindS
      (aget_X ((int_of_num (words$word_len data))) t  : ( 'datasize words$word) M) (\ (w__2 : 'datasize bits) . 
      let data = w__2 in
      aset_Mem address dbytes acctype data)
   | MemOp_LOAD => sail2_state_monad$bindS
      (aget_Mem address dbytes acctype  : ( 'datasize words$word) M) (\ (w__3 : 'datasize bits) . 
      let data = w__3 in sail2_state_monad$bindS
      (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__4 :
         'regsize words$word) . 
      aset_X t w__4))
   ))))))`;


(*val memory_ordered_decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_ordered_decode:(2)words$word ->(1)words$word ->(1)words$word ->(1)words$word ->(5)words$word ->(1)words$word ->(5)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 o2 L o1 Rs o0 Rt2 Rn Rt=
    (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (s : ii) = (lem$w2ui Rs) in
     let (acctype : AccType) =
       (if (((o0 = (vec_of_bits [B0]  :  1 words$word)))) then AccType_LIMITEDORDERED
       else AccType_ORDERED) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (elsize : ii) = ((( 8 : int):ii)) in
     let (regsize : ii) = ((( 32 : int):ii)) in
     let (datasize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_ordered acctype ((make_the_value (( 8 : int):ii)  :  8 itself)) memop n
       ((make_the_value (( 32 : int):ii)  :  32 itself)) t)
   else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (s : ii) = (lem$w2ui Rs) in
     let (acctype : AccType) =
       (if (((o0 = (vec_of_bits [B0]  :  1 words$word)))) then AccType_LIMITEDORDERED
       else AccType_ORDERED) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (elsize : ii) = ((( 16 : int):ii)) in
     let (regsize : ii) = ((( 32 : int):ii)) in
     let (datasize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_ordered acctype ((make_the_value (( 16 : int):ii)  :  16 itself)) memop n
       ((make_the_value (( 32 : int):ii)  :  32 itself)) t)
   else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (s : ii) = (lem$w2ui Rs) in
     let (acctype : AccType) =
       (if (((o0 = (vec_of_bits [B0]  :  1 words$word)))) then AccType_LIMITEDORDERED
       else AccType_ORDERED) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (elsize : ii) = ((( 32 : int):ii)) in
     let (regsize : ii) = ((( 32 : int):ii)) in
     let (datasize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_ordered acctype ((make_the_value (( 32 : int):ii)  :  32 itself)) memop n
       ((make_the_value (( 32 : int):ii)  :  32 itself)) t)
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (s : ii) = (lem$w2ui Rs) in
     let (acctype : AccType) =
       (if (((o0 = (vec_of_bits [B0]  :  1 words$word)))) then AccType_LIMITEDORDERED
       else AccType_ORDERED) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (elsize : ii) = ((( 64 : int):ii)) in
     let (regsize : ii) = ((( 64 : int):ii)) in
     let (datasize : ii) = ((( 64 : int):ii)) in
     aarch64_memory_ordered acctype ((make_the_value (( 64 : int):ii)  :  64 itself)) memop n
       ((make_the_value (( 64 : int):ii)  :  64 itself)) t)))`;


(*val aarch64_memory_orderedrcpc : forall 'datasize 'regsize. Size 'datasize, Size 'regsize => AccType -> itself 'datasize -> ii -> itself 'regsize -> ii -> M unit*)

val _ = Define `
 ((aarch64_memory_orderedrcpc:AccType -> 'datasize itself -> int -> 'regsize itself -> int ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) acctype datasize n regsize t=
    (let regsize = (size_itself_int regsize) in
   let datasize = (size_itself_int datasize) in sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS T "datasize constraint")
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
   (undefined_bitvector datasize  : ( 'datasize words$word) M) (\ (data : 'datasize bits) . 
   let dbytes = (ex_int ((datasize / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS T "")
   (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
    else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M))) (\ (address : 64 bits) .  sail2_state_monad$bindS
   (aget_Mem address dbytes acctype  : ( 'datasize words$word) M) (\ (w__2 : 'datasize bits) . 
   let data = w__2 in sail2_state_monad$bindS
   (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__3 :
      'regsize words$word) . 
   aset_X t w__3)))))))`;


(*val memory_orderedrcpc_decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty3 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_orderedrcpc_decode:(2)words$word ->(1)words$word ->(1)words$word ->(1)words$word ->(5)words$word ->(1)words$word ->(3)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 V1 A R1 Rs o3 opc Rn Rt=
    (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (s : ii) = (lem$w2ui Rs) in
     let (acctype : AccType) = AccType_ORDERED in
     let (elsize : ii) = ((( 8 : int):ii)) in
     let (regsize : ii) = ((( 32 : int):ii)) in
     let (datasize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_orderedrcpc AccType_ORDERED ((make_the_value (( 8 : int):ii)  :  8 itself)) n
       ((make_the_value (( 32 : int):ii)  :  32 itself)) t)
   else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (s : ii) = (lem$w2ui Rs) in
     let (acctype : AccType) = AccType_ORDERED in
     let (elsize : ii) = ((( 16 : int):ii)) in
     let (regsize : ii) = ((( 32 : int):ii)) in
     let (datasize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_orderedrcpc AccType_ORDERED ((make_the_value (( 16 : int):ii)  :  16 itself)) n
       ((make_the_value (( 32 : int):ii)  :  32 itself)) t)
   else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (s : ii) = (lem$w2ui Rs) in
     let (acctype : AccType) = AccType_ORDERED in
     let (elsize : ii) = ((( 32 : int):ii)) in
     let (regsize : ii) = ((( 32 : int):ii)) in
     let (datasize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_orderedrcpc AccType_ORDERED ((make_the_value (( 32 : int):ii)  :  32 itself)) n
       ((make_the_value (( 32 : int):ii)  :  32 itself)) t)
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (s : ii) = (lem$w2ui Rs) in
     let (acctype : AccType) = AccType_ORDERED in
     let (elsize : ii) = ((( 64 : int):ii)) in
     let (regsize : ii) = ((( 64 : int):ii)) in
     let (datasize : ii) = ((( 64 : int):ii)) in
     aarch64_memory_orderedrcpc AccType_ORDERED ((make_the_value (( 64 : int):ii)  :  64 itself)) n
       ((make_the_value (( 64 : int):ii)  :  64 itself)) t)))`;


(*val aarch64_memory_literal_simdfp : mword ty64 -> integer -> ii -> M unit*)

val _ = Define `
 ((aarch64_memory_literal_simdfp:(64)words$word -> int -> int ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) offset l__70 t=
    (if (((l__70 = (( 4 : int):ii)))) then sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (sail2_state_monad$assert_expS T ""))
     (aget_PC ()   : ( 64 words$word) M)) (\ (w__0 :  64 words$word) . 
     let (address : 64 bits) = ((add_vec w__0 offset  :  64 words$word)) in sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (data : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (CheckFPAdvSIMDEnabled64 () )
     (aget_Mem address (( 4 : int):ii) AccType_VEC  : ( 32 words$word) M)) (\ (w__1 : 32 bits) . 
     let data = w__1 in
     aset_V t data)))
   else if (((l__70 = (( 8 : int):ii)))) then sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (sail2_state_monad$assert_expS T ""))
     (aget_PC ()   : ( 64 words$word) M)) (\ (w__2 :  64 words$word) . 
     let (address : 64 bits) = ((add_vec w__2 offset  :  64 words$word)) in sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (data : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (CheckFPAdvSIMDEnabled64 () )
     (aget_Mem address (( 8 : int):ii) AccType_VEC  : ( 64 words$word) M)) (\ (w__3 : 64 bits) . 
     let data = w__3 in
     aset_V t data)))
   else if (((l__70 = (( 16 : int):ii)))) then sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (sail2_state_monad$assert_expS T ""))
     (aget_PC ()   : ( 64 words$word) M)) (\ (w__4 :  64 words$word) . 
     let (address : 64 bits) = ((add_vec w__4 offset  :  64 words$word)) in sail2_state_monad$bindS
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M) (\ (data : 128 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (CheckFPAdvSIMDEnabled64 () )
     (aget_Mem address (( 16 : int):ii) AccType_VEC  : ( 128 words$word) M)) (\ (w__5 : 128 bits) . 
     let data = w__5 in
     aset_V t data)))
   else sail2_state_monad$seqS (sail2_state_monad$assert_expS T "") (sail2_state_monad$assert_expS T "")))`;


(*val aarch64_memory_literal_general : forall 'size. Size 'size => MemOp -> mword ty64 -> bool -> itself 'size -> ii -> M unit*)

val _ = Define `
 ((aarch64_memory_literal_general:MemOp ->(64)words$word -> bool -> 'size itself -> int ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) memop offset signed size1 t=
    (let size1 = (size_itself_int size1) in sail2_state_monad$bindS
   (aget_PC ()   : ( 64 words$word) M) (\ (w__0 :  64 words$word) . 
   let (address : 64 bits) = ((add_vec w__0 offset  :  64 words$word)) in sail2_state_monad$bindS
   (undefined_bitvector size1  : ( 'size words$word) M) (\ (data : 'size bits) . 
   (case memop of
     MemOp_LOAD => sail2_state_monad$seqS
      (sail2_state_monad$assert_expS T "")
      (let bytes = (size1 / (( 8 : int):ii)) in sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$assert_expS T "")
      (aget_Mem address bytes AccType_NORMAL  : ( 'size words$word) M)) (\ (w__1 : 'size bits) . 
      let data = w__1 in
      if signed then sail2_state_monad$bindS
        (SignExtend__0 data ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__2 :
           64 words$word) . 
        aset_X t w__2)
      else aset_X t data))
   | MemOp_PREFETCH =>
      Prefetch address
        ((GetSlice_int ((make_the_value (( 5 : int):ii)  :  5 itself)) t (( 0 : int):ii)  :  5 words$word))
   )))))`;


(*val memory_literal_general_decode : mword ty2 -> mword ty1 -> mword ty19 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_literal_general_decode:(2)words$word ->(1)words$word ->(19)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 V1 imm19 Rt=
    (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (memop : MemOp) = MemOp_LOAD in
     let (signed : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (size1 : ii) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let size1 = ((( 4 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 ((concat_vec imm19 (vec_of_bits [B0;B0]  :  2 words$word)  :  21 words$word))
        ((make_the_value (( 64 : int):ii)  :  64 itself))
       : ( 64 words$word) M) (\ (w__0 : 64 bits) . 
     let offset = w__0 in
     aarch64_memory_literal_general MemOp_LOAD offset F
       ((make_the_value (( 32 : int):ii)  :  32 itself)) t))))
   else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (memop : MemOp) = MemOp_LOAD in
     let (signed : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (size1 : ii) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let size1 = ((( 8 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 ((concat_vec imm19 (vec_of_bits [B0;B0]  :  2 words$word)  :  21 words$word))
        ((make_the_value (( 64 : int):ii)  :  64 itself))
       : ( 64 words$word) M) (\ (w__1 : 64 bits) . 
     let offset = w__1 in
     aarch64_memory_literal_general MemOp_LOAD offset F
       ((make_the_value (( 64 : int):ii)  :  64 itself)) t))))
   else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (memop : MemOp) = MemOp_LOAD in
     let (signed : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (size1 : ii) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let size1 = ((( 4 : int):ii)) in
     let signed = T in sail2_state_monad$bindS
     (SignExtend__0 ((concat_vec imm19 (vec_of_bits [B0;B0]  :  2 words$word)  :  21 words$word))
        ((make_the_value (( 64 : int):ii)  :  64 itself))
       : ( 64 words$word) M) (\ (w__2 : 64 bits) . 
     let offset = w__2 in
     aarch64_memory_literal_general MemOp_LOAD offset T ((make_the_value (( 32 : int):ii)  :  32 itself))
       t))))
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (memop : MemOp) = MemOp_LOAD in
     let (signed : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (size1 : ii) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let memop = MemOp_PREFETCH in sail2_state_monad$bindS
     (SignExtend__0 ((concat_vec imm19 (vec_of_bits [B0;B0]  :  2 words$word)  :  21 words$word))
        ((make_the_value (( 64 : int):ii)  :  64 itself))
       : ( 64 words$word) M) (\ (w__3 : 64 bits) . 
     let offset = w__3 in
     aarch64_memory_literal_general MemOp_PREFETCH offset F
       ((make_the_value (((( 8 : int):ii) * (( 32 : int):ii)))  :  256 itself)) t))))))`;


(*val aarch64_memory_atomicops_swp : forall 'regsize. Size 'regsize => ii -> AccType -> ii -> itself 'regsize -> ii -> AccType -> ii -> M unit*)

val _ = Define `
 ((aarch64_memory_atomicops_swp:int -> AccType -> int -> 'regsize itself -> int -> AccType -> int ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) l__65 ldacctype n regsize s stacctype t=
    (if (((l__65 = (( 8 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M) (\ (data : 8 bits) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (aget_Mem address (((( 8 : int):ii) / (( 8 : int):ii))) ldacctype  : ( 8 words$word) M) (\ (w__2 : 8
       bits) . 
     let data = w__2 in sail2_state_monad$bindS
     (aget_X ((int_of_num (words$word_len data))) s  : ( 8 words$word) M) (\ w__3 .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (aset_Mem address (((( 8 : int):ii) / (( 8 : int):ii))) stacctype w__3)
     (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M)) (\ (w__4 :
        'regsize words$word) . 
     aset_X t w__4)))))))
   else if (((l__65 = (( 16 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M) (\ (data : 16 bits) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (aget_Mem address (((( 16 : int):ii) / (( 8 : int):ii))) ldacctype  : ( 16 words$word) M) (\ (w__7 : 16
       bits) . 
     let data = w__7 in sail2_state_monad$bindS
     (aget_X ((int_of_num (words$word_len data))) s  : ( 16 words$word) M) (\ w__8 .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (aset_Mem address (((( 16 : int):ii) / (( 8 : int):ii))) stacctype w__8)
     (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M)) (\ (w__9 :
        'regsize words$word) . 
     aset_X t w__9)))))))
   else if (((l__65 = (( 32 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (data : 32 bits) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (aget_Mem address (((( 32 : int):ii) / (( 8 : int):ii))) ldacctype  : ( 32 words$word) M) (\ (w__12 : 32
       bits) . 
     let data = w__12 in sail2_state_monad$bindS
     (aget_X ((int_of_num (words$word_len data))) s  : ( 32 words$word) M) (\ w__13 .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (aset_Mem address (((( 32 : int):ii) / (( 8 : int):ii))) stacctype w__13)
     (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M)) (\ (w__14 :
        'regsize words$word) . 
     aset_X t w__14)))))))
   else if (((l__65 = (( 64 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (data : 64 bits) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (aget_Mem address (((( 64 : int):ii) / (( 8 : int):ii))) ldacctype  : ( 64 words$word) M) (\ (w__17 : 64
       bits) . 
     let data = w__17 in sail2_state_monad$bindS
     (aget_X ((int_of_num (words$word_len address))) s  : ( 64 words$word) M) (\ w__18 .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (aset_Mem address (((( 64 : int):ii) / (( 8 : int):ii))) stacctype w__18)
     (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M)) (\ (w__19 :
        'regsize words$word) . 
     aset_X t w__19)))))))
   else if (((l__65 = (( 128 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M) (\ (data : 128 bits) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (aget_Mem address (((( 128 : int):ii) / (( 8 : int):ii))) ldacctype  : ( 128 words$word) M) (\ (w__22 : 128
       bits) . 
     let data = w__22 in sail2_state_monad$bindS
     (aget_X ((int_of_num (words$word_len data))) s  : ( 128 words$word) M) (\ w__23 .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (aset_Mem address (((( 128 : int):ii) / (( 8 : int):ii))) stacctype w__23)
     (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M)) (\ (w__24 :
        'regsize words$word) . 
     aset_X t w__24)))))))
   else
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int ((l__65 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint")))`;


(*val aarch64_memory_atomicops_st : ii -> AccType -> ii -> MemAtomicOp -> ii -> AccType -> M unit*)

val _ = Define `
 ((aarch64_memory_atomicops_st:int -> AccType -> int -> MemAtomicOp -> int -> AccType ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) l__60 ldacctype n op s stacctype=
    (if (((l__60 = (( 8 : int):ii)))) then
     let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M) (\ (value_name : 8 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M) (\ (data : 8 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M) (\ (result : 8 bits) .  sail2_state_monad$bindS
     (aget_X (( 8 : int):ii) s  : ( 8 words$word) M) (\ (w__0 : 8 bits) . 
     let value_name = w__0 in sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (aget_Mem address (((( 8 : int):ii) / (( 8 : int):ii))) ldacctype  : ( 8 words$word) M) (\ (w__3 : 8
       bits) . 
     let data = w__3 in
     let (result : 8 bits) =
       ((case op of
         MemAtomicOp_ADD => (add_vec data value_name  :  8 words$word)
       | MemAtomicOp_BIC => (and_vec data ((not_vec value_name  :  8 words$word))  :  8 words$word)
       | MemAtomicOp_EOR => (xor_vec data value_name  :  8 words$word)
       | MemAtomicOp_ORR => (or_vec data value_name  :  8 words$word)
       | MemAtomicOp_SMAX => if ((((integer_word$w2i data)) > ((integer_word$w2i value_name)))) then data else value_name
       | MemAtomicOp_SMIN => if ((((integer_word$w2i data)) > ((integer_word$w2i value_name)))) then value_name else data
       | MemAtomicOp_UMAX => if ((((lem$w2ui data)) > ((lem$w2ui value_name)))) then data else value_name
       | MemAtomicOp_UMIN => if ((((lem$w2ui data)) > ((lem$w2ui value_name)))) then value_name else data
       )) in
     aset_Mem address (((( 8 : int):ii) / (( 8 : int):ii))) stacctype result)))))))
   else if (((l__60 = (( 16 : int):ii)))) then
     let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M) (\ (value_name : 16 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M) (\ (data : 16 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M) (\ (result : 16 bits) .  sail2_state_monad$bindS
     (aget_X (( 16 : int):ii) s  : ( 16 words$word) M) (\ (w__4 : 16 bits) . 
     let value_name = w__4 in sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (aget_Mem address (((( 16 : int):ii) / (( 8 : int):ii))) ldacctype  : ( 16 words$word) M) (\ (w__7 : 16
       bits) . 
     let data = w__7 in
     let (result : 16 bits) =
       ((case op of
         MemAtomicOp_ADD => (add_vec data value_name  :  16 words$word)
       | MemAtomicOp_BIC => (and_vec data ((not_vec value_name  :  16 words$word))  :  16 words$word)
       | MemAtomicOp_EOR => (xor_vec data value_name  :  16 words$word)
       | MemAtomicOp_ORR => (or_vec data value_name  :  16 words$word)
       | MemAtomicOp_SMAX => if ((((integer_word$w2i data)) > ((integer_word$w2i value_name)))) then data else value_name
       | MemAtomicOp_SMIN => if ((((integer_word$w2i data)) > ((integer_word$w2i value_name)))) then value_name else data
       | MemAtomicOp_UMAX => if ((((lem$w2ui data)) > ((lem$w2ui value_name)))) then data else value_name
       | MemAtomicOp_UMIN => if ((((lem$w2ui data)) > ((lem$w2ui value_name)))) then value_name else data
       )) in
     aset_Mem address (((( 16 : int):ii) / (( 8 : int):ii))) stacctype result)))))))
   else if (((l__60 = (( 32 : int):ii)))) then
     let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (value_name : 32 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (data : 32 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (result : 32 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) s  : ( 32 words$word) M) (\ (w__8 : 32 bits) . 
     let value_name = w__8 in sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (aget_Mem address (((( 32 : int):ii) / (( 8 : int):ii))) ldacctype  : ( 32 words$word) M) (\ (w__11 : 32
       bits) . 
     let data = w__11 in
     let (result : 32 bits) =
       ((case op of
         MemAtomicOp_ADD => (add_vec data value_name  :  32 words$word)
       | MemAtomicOp_BIC => (and_vec data ((not_vec value_name  :  32 words$word))  :  32 words$word)
       | MemAtomicOp_EOR => (xor_vec data value_name  :  32 words$word)
       | MemAtomicOp_ORR => (or_vec data value_name  :  32 words$word)
       | MemAtomicOp_SMAX => if ((((integer_word$w2i data)) > ((integer_word$w2i value_name)))) then data else value_name
       | MemAtomicOp_SMIN => if ((((integer_word$w2i data)) > ((integer_word$w2i value_name)))) then value_name else data
       | MemAtomicOp_UMAX => if ((((lem$w2ui data)) > ((lem$w2ui value_name)))) then data else value_name
       | MemAtomicOp_UMIN => if ((((lem$w2ui data)) > ((lem$w2ui value_name)))) then value_name else data
       )) in
     aset_Mem address (((( 32 : int):ii) / (( 8 : int):ii))) stacctype result)))))))
   else if (((l__60 = (( 64 : int):ii)))) then
     let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (value_name : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (data : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (result : 64 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) s  : ( 64 words$word) M) (\ (w__12 : 64 bits) . 
     let value_name = w__12 in sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (aget_Mem address (((( 64 : int):ii) / (( 8 : int):ii))) ldacctype  : ( 64 words$word) M) (\ (w__15 : 64
       bits) . 
     let data = w__15 in
     let (result : 64 bits) =
       ((case op of
         MemAtomicOp_ADD => (add_vec data value_name  :  64 words$word)
       | MemAtomicOp_BIC => (and_vec data ((not_vec value_name  :  64 words$word))  :  64 words$word)
       | MemAtomicOp_EOR => (xor_vec data value_name  :  64 words$word)
       | MemAtomicOp_ORR => (or_vec data value_name  :  64 words$word)
       | MemAtomicOp_SMAX => if ((((integer_word$w2i data)) > ((integer_word$w2i value_name)))) then data else value_name
       | MemAtomicOp_SMIN => if ((((integer_word$w2i data)) > ((integer_word$w2i value_name)))) then value_name else data
       | MemAtomicOp_UMAX => if ((((lem$w2ui data)) > ((lem$w2ui value_name)))) then data else value_name
       | MemAtomicOp_UMIN => if ((((lem$w2ui data)) > ((lem$w2ui value_name)))) then value_name else data
       )) in
     aset_Mem address (((( 64 : int):ii) / (( 8 : int):ii))) stacctype result)))))))
   else if (((l__60 = (( 128 : int):ii)))) then
     let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M) (\ (value_name : 128 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M) (\ (data : 128 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M) (\ (result : 128 bits) .  sail2_state_monad$bindS
     (aget_X (( 128 : int):ii) s  : ( 128 words$word) M) (\ (w__16 : 128 bits) . 
     let value_name = w__16 in sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (aget_Mem address (((( 128 : int):ii) / (( 8 : int):ii))) ldacctype  : ( 128 words$word) M) (\ (w__19 : 128
       bits) . 
     let data = w__19 in
     let (result : 128 bits) =
       ((case op of
         MemAtomicOp_ADD => (add_vec data value_name  :  128 words$word)
       | MemAtomicOp_BIC => (and_vec data ((not_vec value_name  :  128 words$word))  :  128 words$word)
       | MemAtomicOp_EOR => (xor_vec data value_name  :  128 words$word)
       | MemAtomicOp_ORR => (or_vec data value_name  :  128 words$word)
       | MemAtomicOp_SMAX => if ((((integer_word$w2i data)) > ((integer_word$w2i value_name)))) then data else value_name
       | MemAtomicOp_SMIN => if ((((integer_word$w2i data)) > ((integer_word$w2i value_name)))) then value_name else data
       | MemAtomicOp_UMAX => if ((((lem$w2ui data)) > ((lem$w2ui value_name)))) then data else value_name
       | MemAtomicOp_UMIN => if ((((lem$w2ui data)) > ((lem$w2ui value_name)))) then value_name else data
       )) in
     aset_Mem address (((( 128 : int):ii) / (( 8 : int):ii))) stacctype result)))))))
   else
     let dbytes = (ex_int ((l__60 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint"))`;


(*val aarch64_memory_atomicops_ld : forall 'regsize. Size 'regsize => ii -> AccType -> ii -> MemAtomicOp -> itself 'regsize -> ii -> AccType -> ii -> M unit*)

val _ = Define `
 ((aarch64_memory_atomicops_ld:int -> AccType -> int -> MemAtomicOp -> 'regsize itself -> int -> AccType -> int ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) l__55 ldacctype n op regsize s stacctype t=
    (if (((l__55 = (( 8 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M) (\ (value_name : 8 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M) (\ (data : 8 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M) (\ (result : 8 bits) .  sail2_state_monad$bindS
     (aget_X (( 8 : int):ii) s  : ( 8 words$word) M) (\ (w__0 : 8 bits) . 
     let value_name = w__0 in sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (aget_Mem address (((( 8 : int):ii) / (( 8 : int):ii))) ldacctype  : ( 8 words$word) M) (\ (w__3 : 8
       bits) . 
     let data = w__3 in
     let (result : 8 bits) =
       ((case op of
         MemAtomicOp_ADD => (add_vec data value_name  :  8 words$word)
       | MemAtomicOp_BIC => (and_vec data ((not_vec value_name  :  8 words$word))  :  8 words$word)
       | MemAtomicOp_EOR => (xor_vec data value_name  :  8 words$word)
       | MemAtomicOp_ORR => (or_vec data value_name  :  8 words$word)
       | MemAtomicOp_SMAX => if ((((integer_word$w2i data)) > ((integer_word$w2i value_name)))) then data else value_name
       | MemAtomicOp_SMIN => if ((((integer_word$w2i data)) > ((integer_word$w2i value_name)))) then value_name else data
       | MemAtomicOp_UMAX => if ((((lem$w2ui data)) > ((lem$w2ui value_name)))) then data else value_name
       | MemAtomicOp_UMIN => if ((((lem$w2ui data)) > ((lem$w2ui value_name)))) then value_name else data
       )) in sail2_state_monad$bindS (sail2_state_monad$seqS
     (aset_Mem address (((( 8 : int):ii) / (( 8 : int):ii))) stacctype result)
     (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M)) (\ (w__4 :
        'regsize words$word) . 
     aset_X t w__4)))))))))
   else if (((l__55 = (( 16 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M) (\ (value_name : 16 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M) (\ (data : 16 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M) (\ (result : 16 bits) .  sail2_state_monad$bindS
     (aget_X (( 16 : int):ii) s  : ( 16 words$word) M) (\ (w__5 : 16 bits) . 
     let value_name = w__5 in sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (aget_Mem address (((( 16 : int):ii) / (( 8 : int):ii))) ldacctype  : ( 16 words$word) M) (\ (w__8 : 16
       bits) . 
     let data = w__8 in
     let (result : 16 bits) =
       ((case op of
         MemAtomicOp_ADD => (add_vec data value_name  :  16 words$word)
       | MemAtomicOp_BIC => (and_vec data ((not_vec value_name  :  16 words$word))  :  16 words$word)
       | MemAtomicOp_EOR => (xor_vec data value_name  :  16 words$word)
       | MemAtomicOp_ORR => (or_vec data value_name  :  16 words$word)
       | MemAtomicOp_SMAX => if ((((integer_word$w2i data)) > ((integer_word$w2i value_name)))) then data else value_name
       | MemAtomicOp_SMIN => if ((((integer_word$w2i data)) > ((integer_word$w2i value_name)))) then value_name else data
       | MemAtomicOp_UMAX => if ((((lem$w2ui data)) > ((lem$w2ui value_name)))) then data else value_name
       | MemAtomicOp_UMIN => if ((((lem$w2ui data)) > ((lem$w2ui value_name)))) then value_name else data
       )) in sail2_state_monad$bindS (sail2_state_monad$seqS
     (aset_Mem address (((( 16 : int):ii) / (( 8 : int):ii))) stacctype result)
     (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M)) (\ (w__9 :
        'regsize words$word) . 
     aset_X t w__9)))))))))
   else if (((l__55 = (( 32 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (value_name : 32 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (data : 32 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (result : 32 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) s  : ( 32 words$word) M) (\ (w__10 : 32 bits) . 
     let value_name = w__10 in sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (aget_Mem address (((( 32 : int):ii) / (( 8 : int):ii))) ldacctype  : ( 32 words$word) M) (\ (w__13 : 32
       bits) . 
     let data = w__13 in
     let (result : 32 bits) =
       ((case op of
         MemAtomicOp_ADD => (add_vec data value_name  :  32 words$word)
       | MemAtomicOp_BIC => (and_vec data ((not_vec value_name  :  32 words$word))  :  32 words$word)
       | MemAtomicOp_EOR => (xor_vec data value_name  :  32 words$word)
       | MemAtomicOp_ORR => (or_vec data value_name  :  32 words$word)
       | MemAtomicOp_SMAX => if ((((integer_word$w2i data)) > ((integer_word$w2i value_name)))) then data else value_name
       | MemAtomicOp_SMIN => if ((((integer_word$w2i data)) > ((integer_word$w2i value_name)))) then value_name else data
       | MemAtomicOp_UMAX => if ((((lem$w2ui data)) > ((lem$w2ui value_name)))) then data else value_name
       | MemAtomicOp_UMIN => if ((((lem$w2ui data)) > ((lem$w2ui value_name)))) then value_name else data
       )) in sail2_state_monad$bindS (sail2_state_monad$seqS
     (aset_Mem address (((( 32 : int):ii) / (( 8 : int):ii))) stacctype result)
     (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M)) (\ (w__14 :
        'regsize words$word) . 
     aset_X t w__14)))))))))
   else if (((l__55 = (( 64 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (value_name : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (data : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (result : 64 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) s  : ( 64 words$word) M) (\ (w__15 : 64 bits) . 
     let value_name = w__15 in sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (aget_Mem address (((( 64 : int):ii) / (( 8 : int):ii))) ldacctype  : ( 64 words$word) M) (\ (w__18 : 64
       bits) . 
     let data = w__18 in
     let (result : 64 bits) =
       ((case op of
         MemAtomicOp_ADD => (add_vec data value_name  :  64 words$word)
       | MemAtomicOp_BIC => (and_vec data ((not_vec value_name  :  64 words$word))  :  64 words$word)
       | MemAtomicOp_EOR => (xor_vec data value_name  :  64 words$word)
       | MemAtomicOp_ORR => (or_vec data value_name  :  64 words$word)
       | MemAtomicOp_SMAX => if ((((integer_word$w2i data)) > ((integer_word$w2i value_name)))) then data else value_name
       | MemAtomicOp_SMIN => if ((((integer_word$w2i data)) > ((integer_word$w2i value_name)))) then value_name else data
       | MemAtomicOp_UMAX => if ((((lem$w2ui data)) > ((lem$w2ui value_name)))) then data else value_name
       | MemAtomicOp_UMIN => if ((((lem$w2ui data)) > ((lem$w2ui value_name)))) then value_name else data
       )) in sail2_state_monad$bindS (sail2_state_monad$seqS
     (aset_Mem address (((( 64 : int):ii) / (( 8 : int):ii))) stacctype result)
     (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M)) (\ (w__19 :
        'regsize words$word) . 
     aset_X t w__19)))))))))
   else if (((l__55 = (( 128 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M) (\ (value_name : 128 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M) (\ (data : 128 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M) (\ (result : 128 bits) .  sail2_state_monad$bindS
     (aget_X (( 128 : int):ii) s  : ( 128 words$word) M) (\ (w__20 : 128 bits) . 
     let value_name = w__20 in sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (aget_Mem address (((( 128 : int):ii) / (( 8 : int):ii))) ldacctype  : ( 128 words$word) M) (\ (w__23 : 128
       bits) . 
     let data = w__23 in
     let (result : 128 bits) =
       ((case op of
         MemAtomicOp_ADD => (add_vec data value_name  :  128 words$word)
       | MemAtomicOp_BIC => (and_vec data ((not_vec value_name  :  128 words$word))  :  128 words$word)
       | MemAtomicOp_EOR => (xor_vec data value_name  :  128 words$word)
       | MemAtomicOp_ORR => (or_vec data value_name  :  128 words$word)
       | MemAtomicOp_SMAX => if ((((integer_word$w2i data)) > ((integer_word$w2i value_name)))) then data else value_name
       | MemAtomicOp_SMIN => if ((((integer_word$w2i data)) > ((integer_word$w2i value_name)))) then value_name else data
       | MemAtomicOp_UMAX => if ((((lem$w2ui data)) > ((lem$w2ui value_name)))) then data else value_name
       | MemAtomicOp_UMIN => if ((((lem$w2ui data)) > ((lem$w2ui value_name)))) then value_name else data
       )) in sail2_state_monad$bindS (sail2_state_monad$seqS
     (aset_Mem address (((( 128 : int):ii) / (( 8 : int):ii))) stacctype result)
     (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M)) (\ (w__24 :
        'regsize words$word) . 
     aset_X t w__24)))))))))
   else
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int ((l__55 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint")))`;


(*val aarch64_memory_atomicops_cas_single : forall 'regsize. Size 'regsize => ii -> AccType -> ii -> itself 'regsize -> ii -> AccType -> ii -> M unit*)

val _ = Define `
 ((aarch64_memory_atomicops_cas_single:int -> AccType -> int -> 'regsize itself -> int -> AccType -> int ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) l__50 ldacctype n regsize s stacctype t=
    (if (((l__50 = (( 8 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M) (\ (comparevalue : 8 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M) (\ (newvalue : 8 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M) (\ (data : 8 bits) .  sail2_state_monad$bindS
     (aget_X (( 8 : int):ii) s  : ( 8 words$word) M) (\ (w__0 : 8 bits) . 
     let comparevalue = w__0 in sail2_state_monad$bindS
     (aget_X (( 8 : int):ii) t  : ( 8 words$word) M) (\ (w__1 : 8 bits) . 
     let newvalue = w__1 in sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (aget_Mem address (((( 8 : int):ii) / (( 8 : int):ii))) ldacctype  : ( 8 words$word) M) (\ (w__4 : 8
       bits) . 
     let data = w__4 in sail2_state_monad$bindS (sail2_state_monad$seqS
     (if (((data = comparevalue))) then
        aset_Mem address (((( 8 : int):ii) / (( 8 : int):ii))) stacctype newvalue
      else sail2_state_monad$returnS () )
     (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M)) (\ (w__5 :
        'regsize words$word) . 
     aset_X s w__5))))))))))
   else if (((l__50 = (( 16 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M) (\ (comparevalue : 16 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M) (\ (newvalue : 16 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M) (\ (data : 16 bits) .  sail2_state_monad$bindS
     (aget_X (( 16 : int):ii) s  : ( 16 words$word) M) (\ (w__6 : 16 bits) . 
     let comparevalue = w__6 in sail2_state_monad$bindS
     (aget_X (( 16 : int):ii) t  : ( 16 words$word) M) (\ (w__7 : 16 bits) . 
     let newvalue = w__7 in sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (aget_Mem address (((( 16 : int):ii) / (( 8 : int):ii))) ldacctype  : ( 16 words$word) M) (\ (w__10 : 16
       bits) . 
     let data = w__10 in sail2_state_monad$bindS (sail2_state_monad$seqS
     (if (((data = comparevalue))) then
        aset_Mem address (((( 16 : int):ii) / (( 8 : int):ii))) stacctype newvalue
      else sail2_state_monad$returnS () )
     (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M)) (\ (w__11 :
        'regsize words$word) . 
     aset_X s w__11))))))))))
   else if (((l__50 = (( 32 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (comparevalue : 32 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (newvalue : 32 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (data : 32 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) s  : ( 32 words$word) M) (\ (w__12 : 32 bits) . 
     let comparevalue = w__12 in sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) t  : ( 32 words$word) M) (\ (w__13 : 32 bits) . 
     let newvalue = w__13 in sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (aget_Mem address (((( 32 : int):ii) / (( 8 : int):ii))) ldacctype  : ( 32 words$word) M) (\ (w__16 : 32
       bits) . 
     let data = w__16 in sail2_state_monad$bindS (sail2_state_monad$seqS
     (if (((data = comparevalue))) then
        aset_Mem address (((( 32 : int):ii) / (( 8 : int):ii))) stacctype newvalue
      else sail2_state_monad$returnS () )
     (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M)) (\ (w__17 :
        'regsize words$word) . 
     aset_X s w__17))))))))))
   else if (((l__50 = (( 64 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (comparevalue : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (newvalue : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (data : 64 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) s  : ( 64 words$word) M) (\ (w__18 : 64 bits) . 
     let comparevalue = w__18 in sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) t  : ( 64 words$word) M) (\ (w__19 : 64 bits) . 
     let newvalue = w__19 in sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (aget_Mem address (((( 64 : int):ii) / (( 8 : int):ii))) ldacctype  : ( 64 words$word) M) (\ (w__22 : 64
       bits) . 
     let data = w__22 in sail2_state_monad$bindS (sail2_state_monad$seqS
     (if (((data = comparevalue))) then
        aset_Mem address (((( 64 : int):ii) / (( 8 : int):ii))) stacctype newvalue
      else sail2_state_monad$returnS () )
     (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M)) (\ (w__23 :
        'regsize words$word) . 
     aset_X s w__23))))))))))
   else if (((l__50 = (( 128 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M) (\ (comparevalue : 128 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M) (\ (newvalue : 128 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M) (\ (data : 128 bits) .  sail2_state_monad$bindS
     (aget_X (( 128 : int):ii) s  : ( 128 words$word) M) (\ (w__24 : 128 bits) . 
     let comparevalue = w__24 in sail2_state_monad$bindS
     (aget_X (( 128 : int):ii) t  : ( 128 words$word) M) (\ (w__25 : 128 bits) . 
     let newvalue = w__25 in sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (aget_Mem address (((( 128 : int):ii) / (( 8 : int):ii))) ldacctype  : ( 128 words$word) M) (\ (w__28 : 128
       bits) . 
     let data = w__28 in sail2_state_monad$bindS (sail2_state_monad$seqS
     (if (((data = comparevalue))) then
        aset_Mem address (((( 128 : int):ii) / (( 8 : int):ii))) stacctype newvalue
      else sail2_state_monad$returnS () )
     (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M)) (\ (w__29 :
        'regsize words$word) . 
     aset_X s w__29))))))))))
   else
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int ((l__50 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint")))`;


(*val aarch64_memory_atomicops_cas_pair : forall 'regsize. Size 'regsize => ii -> AccType -> ii -> itself 'regsize -> ii -> AccType -> ii -> M unit*)

val _ = Define `
 ((aarch64_memory_atomicops_cas_pair:int -> AccType -> int -> 'regsize itself -> int -> AccType -> int ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) l__45 ldacctype n regsize s stacctype t=
    (if (((l__45 = (( 8 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M) (\ (comparevalue : 16 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M) (\ (newvalue : 16 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M) (\ (data : 16 bits) .  sail2_state_monad$bindS
     (aget_X (( 8 : int):ii) s  : ( 8 words$word) M) (\ (s1 : 8 bits) .  sail2_state_monad$bindS
     (aget_X (( 8 : int):ii) ((s + (( 1 : int):ii)))  : ( 8 words$word) M) (\ (s2 : 8 bits) .  sail2_state_monad$bindS
     (aget_X (( 8 : int):ii) t  : ( 8 words$word) M) (\ (t1 : 8 bits) .  sail2_state_monad$bindS
     (aget_X (( 8 : int):ii) ((t + (( 1 : int):ii)))  : ( 8 words$word) M) (\ (t2 : 8 bits) .  sail2_state_monad$bindS
     (BigEndian () ) (\ (w__0 : bool) . 
     let comparevalue =
       (if w__0 then (concat_vec s1 s2  :  16 words$word)
       else (concat_vec s2 s1  :  16 words$word)) in sail2_state_monad$bindS
     (BigEndian () ) (\ (w__1 : bool) . 
     let newvalue =
       (if w__1 then (concat_vec t1 t2  :  16 words$word)
       else (concat_vec t2 t1  :  16 words$word)) in sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (aget_Mem address (((( 16 : int):ii) / (( 8 : int):ii))) ldacctype  : ( 16 words$word) M) (\ (w__4 : 16
       bits) . 
     let data = w__4 in sail2_state_monad$bindS (sail2_state_monad$seqS
     (if (((data = comparevalue))) then
        aset_Mem address (((( 16 : int):ii) / (( 8 : int):ii))) stacctype newvalue
      else sail2_state_monad$returnS () )
     (BigEndian () )) (\ (w__5 : bool) . 
     if w__5 then sail2_state_monad$bindS
       (ZeroExtend__0 ((slice data (( 8 : int):ii) (( 8 : int):ii)  :  8 words$word))
          ((make_the_value regsize  :  'regsize itself))
         : ( 'regsize words$word) M) (\ (w__6 :  'regsize words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
       (aset_X s w__6)
       (ZeroExtend__0 ((slice data (( 0 : int):ii) (( 8 : int):ii)  :  8 words$word))
          ((make_the_value regsize  :  'regsize itself))
         : ( 'regsize words$word) M)) (\ (w__7 :  'regsize words$word) . 
       aset_X ((s + (( 1 : int):ii))) w__7))
     else sail2_state_monad$bindS
       (ZeroExtend__0 ((slice data (( 0 : int):ii) (( 8 : int):ii)  :  8 words$word))
          ((make_the_value regsize  :  'regsize itself))
         : ( 'regsize words$word) M) (\ (w__8 :  'regsize words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
       (aset_X s w__8)
       (ZeroExtend__0 ((slice data (( 8 : int):ii) (( 8 : int):ii)  :  8 words$word))
          ((make_the_value regsize  :  'regsize itself))
         : ( 'regsize words$word) M)) (\ (w__9 :  'regsize words$word) . 
       aset_X ((s + (( 1 : int):ii))) w__9))))))))))))))))
   else if (((l__45 = (( 16 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (comparevalue : 32 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (newvalue : 32 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (data : 32 bits) .  sail2_state_monad$bindS
     (aget_X (( 16 : int):ii) s  : ( 16 words$word) M) (\ (s1 : 16 bits) .  sail2_state_monad$bindS
     (aget_X (( 16 : int):ii) ((s + (( 1 : int):ii)))  : ( 16 words$word) M) (\ (s2 : 16 bits) .  sail2_state_monad$bindS
     (aget_X (( 16 : int):ii) t  : ( 16 words$word) M) (\ (t1 : 16 bits) .  sail2_state_monad$bindS
     (aget_X (( 16 : int):ii) ((t + (( 1 : int):ii)))  : ( 16 words$word) M) (\ (t2 : 16 bits) .  sail2_state_monad$bindS
     (BigEndian () ) (\ (w__10 : bool) . 
     let comparevalue =
       (if w__10 then (concat_vec s1 s2  :  32 words$word)
       else (concat_vec s2 s1  :  32 words$word)) in sail2_state_monad$bindS
     (BigEndian () ) (\ (w__11 : bool) . 
     let newvalue =
       (if w__11 then (concat_vec t1 t2  :  32 words$word)
       else (concat_vec t2 t1  :  32 words$word)) in sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (aget_Mem address (((( 32 : int):ii) / (( 8 : int):ii))) ldacctype  : ( 32 words$word) M) (\ (w__14 : 32
       bits) . 
     let data = w__14 in sail2_state_monad$bindS (sail2_state_monad$seqS
     (if (((data = comparevalue))) then
        aset_Mem address (((( 32 : int):ii) / (( 8 : int):ii))) stacctype newvalue
      else sail2_state_monad$returnS () )
     (BigEndian () )) (\ (w__15 : bool) . 
     if w__15 then sail2_state_monad$bindS
       (ZeroExtend__0 ((slice data (( 16 : int):ii) (( 16 : int):ii)  :  16 words$word))
          ((make_the_value regsize  :  'regsize itself))
         : ( 'regsize words$word) M) (\ (w__16 :  'regsize words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
       (aset_X s w__16)
       (ZeroExtend__0 ((slice data (( 0 : int):ii) (( 16 : int):ii)  :  16 words$word))
          ((make_the_value regsize  :  'regsize itself))
         : ( 'regsize words$word) M)) (\ (w__17 :  'regsize words$word) . 
       aset_X ((s + (( 1 : int):ii))) w__17))
     else sail2_state_monad$bindS
       (ZeroExtend__0 ((slice data (( 0 : int):ii) (( 16 : int):ii)  :  16 words$word))
          ((make_the_value regsize  :  'regsize itself))
         : ( 'regsize words$word) M) (\ (w__18 :  'regsize words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
       (aset_X s w__18)
       (ZeroExtend__0 ((slice data (( 16 : int):ii) (( 16 : int):ii)  :  16 words$word))
          ((make_the_value regsize  :  'regsize itself))
         : ( 'regsize words$word) M)) (\ (w__19 :  'regsize words$word) . 
       aset_X ((s + (( 1 : int):ii))) w__19))))))))))))))))
   else if (((l__45 = (( 32 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (comparevalue : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (newvalue : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (data : 64 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) s  : ( 32 words$word) M) (\ (s1 : 32 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) ((s + (( 1 : int):ii)))  : ( 32 words$word) M) (\ (s2 : 32 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) t  : ( 32 words$word) M) (\ (t1 : 32 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) ((t + (( 1 : int):ii)))  : ( 32 words$word) M) (\ (t2 : 32 bits) .  sail2_state_monad$bindS
     (BigEndian () ) (\ (w__20 : bool) . 
     let comparevalue =
       (if w__20 then (concat_vec s1 s2  :  64 words$word)
       else (concat_vec s2 s1  :  64 words$word)) in sail2_state_monad$bindS
     (BigEndian () ) (\ (w__21 : bool) . 
     let newvalue =
       (if w__21 then (concat_vec t1 t2  :  64 words$word)
       else (concat_vec t2 t1  :  64 words$word)) in sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (aget_Mem address (((( 64 : int):ii) / (( 8 : int):ii))) ldacctype  : ( 64 words$word) M) (\ (w__24 : 64
       bits) . 
     let data = w__24 in sail2_state_monad$bindS (sail2_state_monad$seqS
     (if (((data = comparevalue))) then
        aset_Mem address (((( 64 : int):ii) / (( 8 : int):ii))) stacctype newvalue
      else sail2_state_monad$returnS () )
     (BigEndian () )) (\ (w__25 : bool) . 
     if w__25 then sail2_state_monad$bindS
       (ZeroExtend__0 ((slice data (( 32 : int):ii) (( 32 : int):ii)  :  32 words$word))
          ((make_the_value regsize  :  'regsize itself))
         : ( 'regsize words$word) M) (\ (w__26 :  'regsize words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
       (aset_X s w__26)
       (ZeroExtend__0 ((slice data (( 0 : int):ii) (( 32 : int):ii)  :  32 words$word))
          ((make_the_value regsize  :  'regsize itself))
         : ( 'regsize words$word) M)) (\ (w__27 :  'regsize words$word) . 
       aset_X ((s + (( 1 : int):ii))) w__27))
     else sail2_state_monad$bindS
       (ZeroExtend__0 ((slice data (( 0 : int):ii) (( 32 : int):ii)  :  32 words$word))
          ((make_the_value regsize  :  'regsize itself))
         : ( 'regsize words$word) M) (\ (w__28 :  'regsize words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
       (aset_X s w__28)
       (ZeroExtend__0 ((slice data (( 32 : int):ii) (( 32 : int):ii)  :  32 words$word))
          ((make_the_value regsize  :  'regsize itself))
         : ( 'regsize words$word) M)) (\ (w__29 :  'regsize words$word) . 
       aset_X ((s + (( 1 : int):ii))) w__29))))))))))))))))
   else if (((l__45 = (( 64 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M) (\ (comparevalue : 128 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M) (\ (newvalue : 128 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M) (\ (data : 128 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) s  : ( 64 words$word) M) (\ (s1 : 64 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) ((s + (( 1 : int):ii)))  : ( 64 words$word) M) (\ (s2 : 64 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) t  : ( 64 words$word) M) (\ (t1 : 64 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) ((t + (( 1 : int):ii)))  : ( 64 words$word) M) (\ (t2 : 64 bits) .  sail2_state_monad$bindS
     (BigEndian () ) (\ (w__30 : bool) . 
     let comparevalue =
       (if w__30 then (concat_vec s1 s2  :  128 words$word)
       else (concat_vec s2 s1  :  128 words$word)) in sail2_state_monad$bindS
     (BigEndian () ) (\ (w__31 : bool) . 
     let newvalue =
       (if w__31 then (concat_vec t1 t2  :  128 words$word)
       else (concat_vec t2 t1  :  128 words$word)) in sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (aget_Mem address (((( 128 : int):ii) / (( 8 : int):ii))) ldacctype  : ( 128 words$word) M) (\ (w__34 : 128
       bits) . 
     let data = w__34 in sail2_state_monad$bindS (sail2_state_monad$seqS
     (if (((data = comparevalue))) then
        aset_Mem address (((( 128 : int):ii) / (( 8 : int):ii))) stacctype newvalue
      else sail2_state_monad$returnS () )
     (BigEndian () )) (\ (w__35 : bool) . 
     if w__35 then sail2_state_monad$bindS
       (ZeroExtend__0 ((slice data (( 64 : int):ii) (( 64 : int):ii)  :  64 words$word))
          ((make_the_value regsize  :  'regsize itself))
         : ( 'regsize words$word) M) (\ (w__36 :  'regsize words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
       (aset_X s w__36)
       (ZeroExtend__0 ((slice data (( 0 : int):ii) (( 64 : int):ii)  :  64 words$word))
          ((make_the_value regsize  :  'regsize itself))
         : ( 'regsize words$word) M)) (\ (w__37 :  'regsize words$word) . 
       aset_X ((s + (( 1 : int):ii))) w__37))
     else sail2_state_monad$bindS
       (ZeroExtend__0 ((slice data (( 0 : int):ii) (( 64 : int):ii)  :  64 words$word))
          ((make_the_value regsize  :  'regsize itself))
         : ( 'regsize words$word) M) (\ (w__38 :  'regsize words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
       (aset_X s w__38)
       (ZeroExtend__0 ((slice data (( 64 : int):ii) (( 64 : int):ii)  :  64 words$word))
          ((make_the_value regsize  :  'regsize itself))
         : ( 'regsize words$word) M)) (\ (w__39 :  'regsize words$word) . 
       aset_X ((s + (( 1 : int):ii))) w__39))))))))))))))))
   else if (((l__45 = (( 128 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 256 : int):ii)  : ( 256 words$word) M) (\ (comparevalue : 256 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 256 : int):ii)  : ( 256 words$word) M) (\ (newvalue : 256 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 256 : int):ii)  : ( 256 words$word) M) (\ (data : 256 bits) .  sail2_state_monad$bindS
     (aget_X (( 128 : int):ii) s  : ( 128 words$word) M) (\ (s1 : 128 bits) .  sail2_state_monad$bindS
     (aget_X (( 128 : int):ii) ((s + (( 1 : int):ii)))  : ( 128 words$word) M) (\ (s2 : 128 bits) .  sail2_state_monad$bindS
     (aget_X (( 128 : int):ii) t  : ( 128 words$word) M) (\ (t1 : 128 bits) .  sail2_state_monad$bindS
     (aget_X (( 128 : int):ii) ((t + (( 1 : int):ii)))  : ( 128 words$word) M) (\ (t2 : 128 bits) .  sail2_state_monad$bindS
     (BigEndian () ) (\ (w__40 : bool) . 
     let comparevalue =
       (if w__40 then (concat_vec s1 s2  :  256 words$word)
       else (concat_vec s2 s1  :  256 words$word)) in sail2_state_monad$bindS
     (BigEndian () ) (\ (w__41 : bool) . 
     let newvalue =
       (if w__41 then (concat_vec t1 t2  :  256 words$word)
       else (concat_vec t2 t1  :  256 words$word)) in sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (aget_Mem address (((( 256 : int):ii) / (( 8 : int):ii))) ldacctype  : ( 256 words$word) M) (\ (w__44 : 256
       bits) . 
     let data = w__44 in sail2_state_monad$bindS (sail2_state_monad$seqS
     (if (((data = comparevalue))) then
        aset_Mem address (((( 256 : int):ii) / (( 8 : int):ii))) stacctype newvalue
      else sail2_state_monad$returnS () )
     (BigEndian () )) (\ (w__45 : bool) . 
     if w__45 then sail2_state_monad$bindS
       (ZeroExtend__0 ((slice data (( 128 : int):ii) (( 128 : int):ii)  :  128 words$word))
          ((make_the_value regsize  :  'regsize itself))
         : ( 'regsize words$word) M) (\ (w__46 :  'regsize words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
       (aset_X s w__46)
       (ZeroExtend__0 ((slice data (( 0 : int):ii) (( 128 : int):ii)  :  128 words$word))
          ((make_the_value regsize  :  'regsize itself))
         : ( 'regsize words$word) M)) (\ (w__47 :  'regsize words$word) . 
       aset_X ((s + (( 1 : int):ii))) w__47))
     else sail2_state_monad$bindS
       (ZeroExtend__0 ((slice data (( 0 : int):ii) (( 128 : int):ii)  :  128 words$word))
          ((make_the_value regsize  :  'regsize itself))
         : ( 'regsize words$word) M) (\ (w__48 :  'regsize words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
       (aset_X s w__48)
       (ZeroExtend__0 ((slice data (( 128 : int):ii) (( 128 : int):ii)  :  128 words$word))
          ((make_the_value regsize  :  'regsize itself))
         : ( 'regsize words$word) M)) (\ (w__49 :  'regsize words$word) . 
       aset_X ((s + (( 1 : int):ii))) w__49))))))))))))))))
   else
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int ((l__45 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint")))`;


(*val AArch64_SetExclusiveMonitors : mword ty64 -> ii -> M unit*)

val _ = Define `
 ((AArch64_SetExclusiveMonitors:(64)words$word -> int ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) address size1=
    (let (acctype : AccType) = AccType_ATOMIC in
   let (iswrite : bool) = F in
   let (aligned : bool) = (address <> ((Align__1 address size1  :  64 words$word))) in sail2_state_monad$bindS
   (AArch64_TranslateAddress address acctype iswrite aligned size1) (\ (memaddrdesc :
     AddressDescriptor) . 
   let (_ : unit) = (if ((IsFault memaddrdesc)) then ()  else () ) in sail2_state_monad$seqS (sail2_state_monad$seqS
   (if memaddrdesc.AddressDescriptor_memattrs.MemoryAttributes_shareable then
      MarkExclusiveGlobal memaddrdesc.AddressDescriptor_paddress ((ProcessorID () )) size1
    else sail2_state_monad$returnS () )
   (MarkExclusiveLocal memaddrdesc.AddressDescriptor_paddress ((ProcessorID () )) size1))
   (AArch64_MarkExclusiveVA address ((ProcessorID () )) size1))))`;


(*val AArch64_ExclusiveMonitorsPass : mword ty64 -> ii -> M bool*)

val _ = Define `
 ((AArch64_ExclusiveMonitorsPass:(64)words$word -> int ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) address size1=
    (let (acctype : AccType) = AccType_ATOMIC in
   let (iswrite : bool) = T in
   let (aligned : bool) = (address = ((Align__1 address size1  :  64 words$word))) in sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (secondstage : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (if ((~ aligned)) then
      let secondstage = F in sail2_state_monad$bindS
      (AArch64_AlignmentFault acctype iswrite secondstage) (\ (w__0 : FaultRecord) . 
      AArch64_Abort address w__0)
    else sail2_state_monad$returnS () )
   (AArch64_IsExclusiveVA address ((ProcessorID () )) size1)) (\ (passed : bool) . 
   if ((~ passed)) then sail2_state_monad$returnS F
   else sail2_state_monad$bindS
     (AArch64_TranslateAddress address acctype iswrite aligned size1) (\ (memaddrdesc :
       AddressDescriptor) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (if ((IsFault memaddrdesc)) then AArch64_Abort address memaddrdesc.AddressDescriptor_fault
      else sail2_state_monad$returnS () )
     (IsExclusiveLocal memaddrdesc.AddressDescriptor_paddress ((ProcessorID () )) size1)) (\ (w__1 :
       bool) . 
     let passed = w__1 in
     if passed then sail2_state_monad$seqS
       (ClearExclusiveLocal ((ProcessorID () )))
       (if memaddrdesc.AddressDescriptor_memattrs.MemoryAttributes_shareable then
         IsExclusiveGlobal memaddrdesc.AddressDescriptor_paddress ((ProcessorID () )) size1
       else sail2_state_monad$returnS passed)
     else sail2_state_monad$returnS passed))))))`;


(*val AArch32_SelfHostedSecurePrivilegedInvasiveDebugEnabled : unit -> M bool*)

val _ = Define `
 ((AArch32_SelfHostedSecurePrivilegedInvasiveDebugEnabled:unit ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (sail2_state$and_boolS (sail2_state_monad$returnS ((~ ((HaveEL EL3)))))
     ( sail2_state_monad$bindS(IsSecure () ) (\ (w__0 : bool) .  sail2_state_monad$returnS ((~ w__0))))) (\ (w__1 : bool) . 
   if w__1 then sail2_state_monad$returnS F
   else
     sail2_state$and_boolS ( sail2_state_monad$bindS(sail2_state_monad$read_regS DBGEN_ref) (\ (w__2 : signal) .  sail2_state_monad$returnS (((w__2 = HIGH)))))
       ( sail2_state_monad$bindS(sail2_state_monad$read_regS SPIDEN_ref) (\ (w__3 : signal) .  sail2_state_monad$returnS (((w__3 = HIGH))))))))`;


(*val AArch32_GenerateDebugExceptionsFrom : mword ty2 -> bool -> M bool*)

val _ = Define `
 ((AArch32_GenerateDebugExceptionsFrom:(2)words$word -> bool ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) from secure=  (sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (mask : 1 bits) .  sail2_state_monad$bindS
   (sail2_state$and_boolS (sail2_state_monad$returnS (((from = EL0))))
     ( sail2_state_monad$bindS(ELStateUsingAArch32 EL1 secure) (\ (w__0 : bool) .  sail2_state_monad$returnS ((~ w__0))))) (\ (w__1 :
     bool) . 
   if w__1 then sail2_state_monad$bindS
     (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (w__2 : 1 bits) . 
     let mask = w__2 in
     AArch64_GenerateDebugExceptionsFrom from secure mask)
   else sail2_state_monad$bindS
     (sail2_state$or_boolS
       (sail2_state$or_boolS
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS DBGOSLSR_ref  : ( 32 words$word) M) (\ (w__4 : 32 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__4 (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))) ((DoubleLockStatus () ))) ((Halted () ))) (\ (w__8 :
       bool) . 
     if w__8 then sail2_state_monad$returnS F
     else sail2_state_monad$bindS
       (sail2_state_monad$undefined_boolS () ) (\ (enabled : bool) .  sail2_state_monad$bindS
       (undefined_bitvector (( 2 : int):ii)  : ( 2 words$word) M) (\ (spd : 2 bits) . 
       if (((((HaveEL EL3)) /\ secure))) then sail2_state_monad$bindS
         (ELUsingAArch32 EL3) (\ (w__9 : bool) .  sail2_state_monad$bindS
         (if w__9 then sail2_state_monad$bindS
            (sail2_state_monad$read_regS SDCR_ref  : ( 32 words$word) M) (\ (w__10 : 32 bits) . 
            sail2_state_monad$returnS ((slice w__10 (( 14 : int):ii) (( 2 : int):ii)  :  2 words$word)))
          else sail2_state_monad$bindS
            (sail2_state_monad$read_regS MDCR_EL3_ref  : ( 32 words$word) M) (\ (w__11 : 32 bits) . 
            sail2_state_monad$returnS ((slice w__11 (( 14 : int):ii) (( 2 : int):ii)  :  2 words$word)))) (\ (w__12 :  2 words$word) . 
         let spd = w__12 in sail2_state_monad$bindS
         (if ((((vec_of_bits [access_vec_dec spd (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
            let (enabled : bool) =
              ((vec_of_bits [access_vec_dec spd (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
            sail2_state_monad$returnS enabled
          else AArch32_SelfHostedSecurePrivilegedInvasiveDebugEnabled () ) (\ (enabled : bool) . 
         if (((from = EL0))) then
           sail2_state$or_boolS (sail2_state_monad$returnS enabled)
             ( sail2_state_monad$bindS(sail2_state_monad$read_regS SDER_ref  : ( 32 words$word) M) (\ (w__14 : 32 bits) . 
              sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__14 (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))
         else sail2_state_monad$returnS enabled)))
       else
         let (enabled : bool) = (from <> EL2) in
         sail2_state_monad$returnS enabled)))))))`;


(*val AArch32_GenerateDebugExceptions : unit -> M bool*)

val _ = Define `
 ((AArch32_GenerateDebugExceptions:unit ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) .  sail2_state_monad$bindS
   (IsSecure () ) (\ (w__1 : bool) .  AArch32_GenerateDebugExceptionsFrom w__0.ProcState_EL w__1))))`;


(*val DebugExceptionReturnSS : mword ty32 -> M (mword ty1)*)

val _ = Define `
 ((DebugExceptionReturnSS:(32)words$word ->(regstate)sail2_state_monad$sequential_state ->((((1)words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) spsr=  (sail2_state_monad$bindS
   (sail2_state$or_boolS (sail2_state$or_boolS ((Halted () )) ((Restarting () )))
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__3 : ProcState) .  sail2_state_monad$returnS (((w__3.ProcState_EL <> EL0)))))) (\ (w__4 :
     bool) .  sail2_state_monad$seqS
   (sail2_state_monad$assert_expS w__4 "((Halted() || Restarting()) || ((PSTATE).EL != EL0))")
   (let (SS_bit : 1 bits) = ((vec_of_bits [B0]  :  1 words$word)) in sail2_state_monad$bindS
   (undefined_bitvector (( 2 : int):ii)  : ( 2 words$word) M) (\ (ELd : 2 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M) (\ (mask : 1 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (enabled_at_dest : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (secure : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (valid_name : bool) .  sail2_state_monad$bindS
   (undefined_bitvector (( 2 : int):ii)  : ( 2 words$word) M) (\ (dest : 2 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (enabled_at_source : bool) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS MDSCR_EL1_ref  : ( 32 words$word) M) (\ (w__5 : 32 bits) . 
   if ((((vec_of_bits [access_vec_dec w__5 (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then sail2_state_monad$bindS
     (Restarting () ) (\ (w__6 : bool) .  sail2_state_monad$bindS
     (if w__6 then sail2_state_monad$returnS F
      else sail2_state_monad$bindS
        (UsingAArch32 () ) (\ (w__7 : bool) . 
        if w__7 then AArch32_GenerateDebugExceptions () 
        else AArch64_GenerateDebugExceptions () )) (\ (enabled_at_source : bool) .  sail2_state_monad$bindS
     (IllegalExceptionReturn spsr) (\ (w__10 : bool) .  sail2_state_monad$bindS
     (if w__10 then sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__11 : ProcState) . 
        let (dest : 2 bits) = (w__11.ProcState_EL) in
        sail2_state_monad$returnS dest)
      else sail2_state_monad$bindS
        (ELFromSPSR spsr  : ((bool #  2 words$word)) M) (\ varstup .  let (tup__0, tup__1) = varstup in
        let valid_name = tup__0 in
        let dest = tup__1 in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS valid_name "valid") (sail2_state_monad$returnS dest))) (\ (dest : 2 bits) .  sail2_state_monad$bindS
     (sail2_state$or_boolS ((IsSecureBelowEL3 () )) (sail2_state_monad$returnS (((dest = EL3))))) (\ (w__13 : bool) . 
     let secure = w__13 in sail2_state_monad$bindS
     (ELUsingAArch32 dest) (\ (w__14 : bool) .  sail2_state_monad$bindS
     (if w__14 then AArch32_GenerateDebugExceptionsFrom dest secure
      else
        let mask = ((vec_of_bits [access_vec_dec spsr (( 9 : int):ii)]  :  1 words$word)) in
        AArch64_GenerateDebugExceptionsFrom dest secure mask) (\ (enabled_at_dest : bool) .  sail2_state_monad$bindS
     (DebugTargetFrom secure  : ( 2 words$word) M) (\ (w__17 : 2 bits) . 
     let ELd = w__17 in sail2_state_monad$bindS
     (sail2_state$and_boolS
       (sail2_state$and_boolS ( sail2_state_monad$bindS(ELUsingAArch32 ELd) (\ (w__18 : bool) .  sail2_state_monad$returnS ((~ w__18))))
          (sail2_state_monad$returnS ((~ enabled_at_source)))) (sail2_state_monad$returnS enabled_at_dest)) (\ (w__20 : bool) . 
     let (SS_bit : 1 bits) =
       (if w__20 then (vec_of_bits [access_vec_dec spsr (( 21 : int):ii)]  :  1 words$word)
       else SS_bit) in
     sail2_state_monad$returnS SS_bit)))))))))
   else sail2_state_monad$returnS SS_bit))))))))))))`;


(*val SetPSTATEFromPSR : mword ty32 -> M unit*)

val _ = Define `
 ((SetPSTATEFromPSR:(32)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) spsr__arg=
    (let spsr = spsr__arg in sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) .  sail2_state_monad$bindS
   (DebugExceptionReturnSS spsr  : ( 1 words$word) M) (\ (w__1 : 1 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__0 with<| ProcState_SS := w__1|>))
   (IllegalExceptionReturn spsr)) (\ (w__2 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (if w__2 then sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__3 : ProcState) . 
      sail2_state_monad$write_regS PSTATE_ref (w__3 with<| ProcState_IL := ((vec_of_bits [B1]  :  1 words$word))|>))
    else sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__4 : ProcState) .  sail2_state_monad$seqS
      (sail2_state_monad$write_regS
        PSTATE_ref
        (w__4 with<| ProcState_IL := ((vec_of_bits [access_vec_dec spsr (( 20 : int):ii)]  :  1 words$word))|>))
      (if ((((vec_of_bits [access_vec_dec spsr (( 4 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
        AArch32_WriteMode ((slice spsr (( 0 : int):ii) (( 5 : int):ii)  :  5 words$word))
      else sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__5 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__5 with<| ProcState_nRW := ((vec_of_bits [B0]  :  1 words$word))|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__6 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (sail2_state_monad$write_regS PSTATE_ref (w__6 with<| ProcState_EL := ((slice spsr (( 2 : int):ii) (( 2 : int):ii)  :  2 words$word))|>))
        (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__7 : ProcState) . 
        sail2_state_monad$write_regS
          PSTATE_ref
          (w__7 with<| ProcState_SP := ((vec_of_bits [access_vec_dec spsr (( 0 : int):ii)]  :  1 words$word))|>)))))))
   (sail2_state$and_boolS
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__8 : ProcState) . 
      sail2_state_monad$returnS (((w__8.ProcState_IL = (vec_of_bits [B1]  :  1 words$word))))))
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__9 : ProcState) . 
      sail2_state_monad$returnS (((w__9.ProcState_nRW = (vec_of_bits [B1]  :  1 words$word)))))))) (\ (w__10 : bool) .  sail2_state_monad$bindS
   (if w__10 then sail2_state_monad$bindS
      (ConstrainUnpredictableBool Unpredictable_ILZEROT) (\ (w__11 : bool) . 
      let (spsr :  32 words$word) =
        (if w__11 then
          (set_slice (( 32 : int):ii) (( 1 : int):ii) spsr (( 5 : int):ii) (vec_of_bits [B0]  :  1 words$word)  :  32 words$word)
        else spsr) in
      sail2_state_monad$returnS spsr)
    else sail2_state_monad$returnS spsr) (\ (spsr :  32 words$word) . 
   let split_vec = ((slice spsr (( 28 : int):ii) (( 4 : int):ii)  :  4 words$word)) in
   let (tup__0, tup__1, tup__2, tup__3) =
     ((subrange_vec_dec split_vec (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
      (subrange_vec_dec split_vec (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
      (subrange_vec_dec split_vec (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
      (subrange_vec_dec split_vec (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__12 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__12 with<| ProcState_N := tup__0|>))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__13 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__13 with<| ProcState_Z := tup__1|>))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__14 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__14 with<| ProcState_C := tup__2|>))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__15 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__15 with<| ProcState_V := tup__3|>))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__16 : ProcState) .  sail2_state_monad$seqS (sail2_state_monad$seqS
   (if (((w__16.ProcState_nRW = (vec_of_bits [B1]  :  1 words$word)))) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__17 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS
        PSTATE_ref
        (w__17 with<| ProcState_Q := ((vec_of_bits [access_vec_dec spsr (( 27 : int):ii)]  :  1 words$word))|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__18 : ProcState) .  sail2_state_monad$bindS
      (RestoredITBits spsr  : ( 8 words$word) M) (\ (w__19 : 8 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__18 with<| ProcState_IT := w__19|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__20 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__20 with<| ProcState_GE := ((slice spsr (( 16 : int):ii) (( 4 : int):ii)  :  4 words$word))|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__21 : ProcState) .  sail2_state_monad$seqS
      (sail2_state_monad$write_regS
        PSTATE_ref
        (w__21 with<| ProcState_E := ((vec_of_bits [access_vec_dec spsr (( 9 : int):ii)]  :  1 words$word))|>))
      (let split_vec = ((slice spsr (( 6 : int):ii) (( 3 : int):ii)  :  3 words$word)) in
      let (tup__0, tup__1, tup__2) =
        ((subrange_vec_dec split_vec (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__22 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__22 with<| ProcState_A := tup__0|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__23 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__23 with<| ProcState_I := tup__1|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__24 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__24 with<| ProcState_F := tup__2|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__25 : ProcState) . 
      sail2_state_monad$write_regS
        PSTATE_ref
        (w__25 with<| ProcState_T := ((vec_of_bits [access_vec_dec spsr (( 5 : int):ii)]  :  1 words$word))|>)))))))))))
    else
      let split_vec = ((slice spsr (( 6 : int):ii) (( 4 : int):ii)  :  4 words$word)) in
      let (tup__0, tup__1, tup__2, tup__3) =
        ((subrange_vec_dec split_vec (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__26 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__26 with<| ProcState_D := tup__0|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__27 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__27 with<| ProcState_A := tup__1|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__28 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__28 with<| ProcState_I := tup__2|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__29 : ProcState) . 
      sail2_state_monad$write_regS PSTATE_ref (w__29 with<| ProcState_F := tup__3|>))))))
   (if ((HavePANExt () )) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__30 : ProcState) . 
      sail2_state_monad$write_regS
        PSTATE_ref
        (w__30 with<| ProcState_PAN := ((vec_of_bits [access_vec_dec spsr (( 22 : int):ii)]  :  1 words$word))|>))
    else sail2_state_monad$returnS () ))
   (if ((HaveUAOExt () )) then sail2_state_monad$bindS
     (sail2_state_monad$read_regS PSTATE_ref) (\ (w__31 : ProcState) . 
     sail2_state_monad$write_regS
       PSTATE_ref
       (w__31 with<| ProcState_UAO := ((vec_of_bits [access_vec_dec spsr (( 23 : int):ii)]  :  1 words$word))|>))
   else sail2_state_monad$returnS () )))))))))))))`;


(*val DRPSInstruction : unit -> M unit*)

val _ = Define `
 ((DRPSInstruction:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (let (_ : unit) = (SynchronizeContext () ) in sail2_state_monad$bindS
   (sail2_state$and_boolS
     (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveRASExt () )))
        ( sail2_state_monad$bindS(aget_SCTLR__1 ()   : ( 32 words$word) M) (\ (w__0 :  32 words$word) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__0 (( 21 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
     ((ConstrainUnpredictableBool Unpredictable_IESBinDebug))) (\ (w__3 : bool) . 
   let (_ : unit) =
     (if w__3 then ErrorSynchronizationBarrier MBReqDomain_FullSystem MBReqTypes_All
     else () ) in sail2_state_monad$bindS
   (aget_SPSR ()   : ( 32 words$word) M) (\ (w__4 :  32 words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (SetPSTATEFromPSR w__4)
   (UsingAArch32 () )) (\ (w__5 : bool) .  sail2_state_monad$seqS
   (if w__5 then sail2_state_monad$bindS
      (undefined_bitvector (( 13 : int):ii)  : ( 13 words$word) M) (\ (w__6 : 13 bits) . 
      let split_vec = w__6 in
      let (tup__0, tup__1, tup__2, tup__3, tup__4, tup__5, tup__6, tup__7, tup__8, tup__9) =
        ((subrange_vec_dec split_vec (( 12 : int):ii) (( 12 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 11 : int):ii) (( 11 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 10 : int):ii) (( 10 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 9 : int):ii) (( 9 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 8 : int):ii) (( 8 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 7 : int):ii) (( 4 : int):ii)  :  4 words$word),
         (subrange_vec_dec split_vec (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__7 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__7 with<| ProcState_N := tup__0|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__8 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__8 with<| ProcState_Z := tup__1|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__9 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__9 with<| ProcState_C := tup__2|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__10 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__10 with<| ProcState_V := tup__3|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__11 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__11 with<| ProcState_Q := tup__4|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__12 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__12 with<| ProcState_GE := tup__5|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__13 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__13 with<| ProcState_SS := tup__6|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__14 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__14 with<| ProcState_A := tup__7|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__15 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__15 with<| ProcState_I := tup__8|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__16 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__16 with<| ProcState_F := tup__9|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__17 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS
        PSTATE_ref
        (w__17 with<| ProcState_IT := ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0]  :  8 words$word))|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__18 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__18 with<| ProcState_T := ((vec_of_bits [B1]  :  1 words$word))|>))
      (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__19 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS DLR_ref w__19)
      (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__20 : 32 bits) . 
      sail2_state_monad$write_regS DSPSR_ref w__20)))))))))))))))
    else sail2_state_monad$bindS
      (undefined_bitvector (( 9 : int):ii)  : ( 9 words$word) M) (\ (w__21 : 9 bits) . 
      let split_vec = w__21 in
      let (tup__0, tup__1, tup__2, tup__3, tup__4, tup__5, tup__6, tup__7, tup__8) =
        ((subrange_vec_dec split_vec (( 8 : int):ii) (( 8 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 7 : int):ii) (( 7 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 6 : int):ii) (( 6 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 5 : int):ii) (( 5 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 4 : int):ii) (( 4 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word),
         (subrange_vec_dec split_vec (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)) in sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__22 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__22 with<| ProcState_N := tup__0|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__23 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__23 with<| ProcState_Z := tup__1|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__24 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__24 with<| ProcState_C := tup__2|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__25 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__25 with<| ProcState_V := tup__3|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__26 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__26 with<| ProcState_SS := tup__4|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__27 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__27 with<| ProcState_D := tup__5|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__28 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__28 with<| ProcState_A := tup__6|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__29 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__29 with<| ProcState_I := tup__7|>))
      (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__30 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS PSTATE_ref (w__30 with<| ProcState_F := tup__8|>))
      (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__31 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
      (sail2_state_monad$write_regS DLR_EL0_ref w__31)
      (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__32 : 32 bits) . 
      sail2_state_monad$write_regS DSPSR_EL0_ref w__32)))))))))))))
   (UpdateEDSCRFields () ))))))`;


(*val aarch64_branch_unconditional_dret : unit -> M unit*)

val _ = Define `
 ((aarch64_branch_unconditional_dret:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (DRPSInstruction () ))`;


(*val AArch64_ExceptionReturn : mword ty64 -> mword ty32 -> M unit*)

val _ = Define `
 ((AArch64_ExceptionReturn:(64)words$word ->(32)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) new_pc__arg spsr=
    (let new_pc = new_pc__arg in
   let (_ : unit) = (SynchronizeContext () ) in sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (iesb_req : bool) .  sail2_state_monad$bindS
   (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveRASExt () )))
     ( sail2_state_monad$bindS(aget_SCTLR__1 ()   : ( 32 words$word) M) (\ (w__0 :  32 words$word) . 
      sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__0 (( 21 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__1 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (if w__1 then
      let (_ : unit) = (ErrorSynchronizationBarrier MBReqDomain_FullSystem MBReqTypes_All) in
      let iesb_req = T in
      TakeUnmaskedPhysicalSErrorInterrupts iesb_req
    else sail2_state_monad$returnS () )
   (SetPSTATEFromPSR spsr))
   (ClearExclusiveLocal ((ProcessorID () ))))
   (SendEventLocal () ))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__2 : ProcState) .  sail2_state_monad$bindS
   (if (((w__2.ProcState_IL = (vec_of_bits [B1]  :  1 words$word)))) then sail2_state_monad$bindS
      (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (w__3 :  32 words$word) . 
      let new_pc = ((set_slice (( 64 : int):ii) (( 32 : int):ii) new_pc (( 32 : int):ii) w__3  :  64 words$word)) in sail2_state_monad$bindS
      (undefined_bitvector (( 2 : int):ii)  : ( 2 words$word) M) (\ (w__4 :  2 words$word) . 
      let (new_pc :  64 words$word) = ((set_slice (( 64 : int):ii) (( 2 : int):ii) new_pc (( 0 : int):ii) w__4  :  64 words$word)) in
      sail2_state_monad$returnS new_pc))
    else sail2_state_monad$bindS
      (UsingAArch32 () ) (\ (w__5 : bool) . 
      if w__5 then sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__6 : ProcState) . 
        let (new_pc :  64 words$word) =
          (if (((w__6.ProcState_T = (vec_of_bits [B0]  :  1 words$word)))) then
            (set_slice (( 64 : int):ii) (( 1 : int):ii) new_pc (( 0 : int):ii) (vec_of_bits [B0]  :  1 words$word)  :  64 words$word)
          else
            (set_slice (( 64 : int):ii) (( 2 : int):ii) new_pc (( 0 : int):ii) (vec_of_bits [B0;B0]  :  2 words$word)  :  64 words$word)) in
        sail2_state_monad$returnS new_pc)
      else (AArch64_BranchAddr new_pc  : ( 64 words$word) M))) (\ (new_pc :  64 words$word) .  sail2_state_monad$bindS
   (UsingAArch32 () ) (\ (w__8 : bool) . 
   if w__8 then BranchTo ((slice new_pc (( 0 : int):ii) (( 32 : int):ii)  :  32 words$word)) BranchType_UNKNOWN
   else BranchToAddr new_pc BranchType_ERET)))))))`;


(*val aarch64_branch_unconditional_eret : bool -> bool -> M unit*)

val _ = Define `
 ((aarch64_branch_unconditional_eret:bool -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) pac use_key_a=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (AArch64_CheckForERetTrap pac use_key_a)
   (aget_ELR__1 ()   : ( 64 words$word) M)) (\ (target : 64 bits) .  sail2_state_monad$bindS
   (if pac then
      if use_key_a then sail2_state_monad$bindS
        (aget_ELR__1 ()   : ( 64 words$word) M) (\ (w__0 :  64 words$word) .  sail2_state_monad$bindS
        (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M) (\ (w__1 :  64 words$word) . 
        (AuthIA w__0 w__1  : ( 64 words$word) M)))
      else sail2_state_monad$bindS
        (aget_ELR__1 ()   : ( 64 words$word) M) (\ (w__3 :  64 words$word) .  sail2_state_monad$bindS
        (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M) (\ (w__4 :  64 words$word) . 
        (AuthIB w__3 w__4  : ( 64 words$word) M)))
    else sail2_state_monad$returnS target) (\ (target : 64 bits) .  sail2_state_monad$bindS
   (aget_SPSR ()   : ( 32 words$word) M) (\ (w__6 :  32 words$word) . 
   AArch64_ExceptionReturn target w__6)))))`;


(*val AArch32_GeneralExceptionsToAArch64 : unit -> M bool*)

val _ = Define `
 ((AArch32_GeneralExceptionsToAArch64:unit ->(regstate)sail2_state_monad$sequential_state ->(((bool),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =
    (sail2_state$or_boolS
     (sail2_state$and_boolS
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) .  sail2_state_monad$returnS (((w__0.ProcState_EL = EL0)))))
        ( sail2_state_monad$bindS(ELUsingAArch32 EL1) (\ (w__1 : bool) .  sail2_state_monad$returnS ((~ w__1)))))
     (sail2_state$and_boolS
        (sail2_state$and_boolS
           (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
              ( sail2_state_monad$bindS(IsSecure () ) (\ (w__3 : bool) .  sail2_state_monad$returnS ((~ w__3)))))
           ( sail2_state_monad$bindS(ELUsingAArch32 EL2) (\ (w__5 : bool) .  sail2_state_monad$returnS ((~ w__5)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__7 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__7 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))))`;


(*val AArch32_EnterHypMode : ExceptionRecord -> mword ty32 -> ii -> M unit*)

val _ = Define `
 ((AArch32_EnterHypMode:ExceptionRecord ->(32)words$word -> int ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) exception preferred_exception_return vect_offset=
    (let (_ : unit) = (SynchronizeContext () ) in sail2_state_monad$bindS
   (sail2_state$and_boolS
     (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2))) ( sail2_state_monad$bindS(IsSecure () ) (\ (w__0 : bool) .  sail2_state_monad$returnS ((~ w__0)))))
     ((ELUsingAArch32 EL2))) (\ (w__3 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS w__3 "((HaveEL(EL2) && !(IsSecure())) && ELUsingAArch32(EL2))")
   (GetPSRFromPSTATE ()   : ( 32 words$word) M)) (\ (spsr : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (if ((~ ((((((exception.ExceptionRecord_typ = Exception_IRQ))) \/ (((exception.ExceptionRecord_typ = Exception_FIQ)))))))) then
      AArch32_ReportHypEntry exception
    else sail2_state_monad$returnS () )
   (AArch32_WriteMode M32_Hyp))
   (aset_SPSR spsr))
   (sail2_state_monad$write_regS ELR_hyp_ref preferred_exception_return))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__4 : ProcState) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS HSCTLR_ref  : ( 32 words$word) M) (\ (w__5 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS
     PSTATE_ref
     (w__4 with<| ProcState_T := ((vec_of_bits [access_vec_dec w__5 (( 30 : int):ii)]  :  1 words$word))|>))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__6 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__6 with<| ProcState_SS := ((vec_of_bits [B0]  :  1 words$word))|>))
   (sail2_state$or_boolS (sail2_state_monad$returnS ((~ ((HaveEL EL3)))))
     ( sail2_state_monad$bindS(aget_SCR_GEN ()   : ( 32 words$word) M) (\ (w__7 :  32 words$word) . 
      sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__7 (( 3 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))))))) (\ (w__8 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (if w__8 then sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__9 : ProcState) . 
      sail2_state_monad$write_regS PSTATE_ref (w__9 with<| ProcState_A := ((vec_of_bits [B1]  :  1 words$word))|>))
    else sail2_state_monad$returnS () )
   (sail2_state$or_boolS (sail2_state_monad$returnS ((~ ((HaveEL EL3)))))
     ( sail2_state_monad$bindS(aget_SCR_GEN ()   : ( 32 words$word) M) (\ (w__10 :  32 words$word) . 
      sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__10 (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))))))) (\ (w__11 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (if w__11 then sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__12 : ProcState) . 
      sail2_state_monad$write_regS PSTATE_ref (w__12 with<| ProcState_I := ((vec_of_bits [B1]  :  1 words$word))|>))
    else sail2_state_monad$returnS () )
   (sail2_state$or_boolS (sail2_state_monad$returnS ((~ ((HaveEL EL3)))))
     ( sail2_state_monad$bindS(aget_SCR_GEN ()   : ( 32 words$word) M) (\ (w__13 :  32 words$word) . 
      sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__13 (( 2 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))))))) (\ (w__14 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (if w__14 then sail2_state_monad$bindS
      (sail2_state_monad$read_regS PSTATE_ref) (\ (w__15 : ProcState) . 
      sail2_state_monad$write_regS PSTATE_ref (w__15 with<| ProcState_F := ((vec_of_bits [B1]  :  1 words$word))|>))
    else sail2_state_monad$returnS () )
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__16 : ProcState) .  sail2_state_monad$bindS
   (sail2_state_monad$read_regS HSCTLR_ref  : ( 32 words$word) M) (\ (w__17 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS
     PSTATE_ref
     (w__16 with<| ProcState_E := ((vec_of_bits [access_vec_dec w__17 (( 25 : int):ii)]  :  1 words$word))|>))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__18 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref (w__18 with<| ProcState_IL := ((vec_of_bits [B0]  :  1 words$word))|>))
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__19 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS
     PSTATE_ref
     (w__19 with<| ProcState_IT := ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0]  :  8 words$word))|>))
   (sail2_state_monad$read_regS HVBAR_ref  : ( 32 words$word) M)) (\ (w__20 : 32 bits) .  sail2_state_monad$seqS
   (BranchTo
     ((concat_vec ((slice w__20 (( 5 : int):ii) (( 27 : int):ii)  :  27 words$word))
         ((GetSlice_int ((make_the_value (( 5 : int):ii)  :  5 itself)) vect_offset (( 0 : int):ii)  :  5 words$word))
        :  32 words$word)) BranchType_UNKNOWN)
   (EndOfInstruction () ))))))))))))))))`;


(*val AArch32_TakeUndefInstrException__0 : unit -> M unit*)

(*val AArch32_TakeUndefInstrException__1 : ExceptionRecord -> M unit*)

val _ = Define `
 ((AArch32_TakeUndefInstrException__1:ExceptionRecord ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) exception=  (sail2_state_monad$bindS
   (sail2_state$and_boolS
     (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__0 : bool) .  sail2_state_monad$returnS ((~ w__0)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) .  sail2_state_monad$returnS (((w__2.ProcState_EL = EL0))))))
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_ref  : ( 32 words$word) M) (\ (w__4 : 32 bits) . 
      sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__4 (( 27 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (route_to_hyp : bool) .  sail2_state_monad$bindS
   (ThisInstrAddr (( 32 : int):ii) ()   : ( 32 words$word) M) (\ (preferred_exception_return : 32 bits) . 
   let (vect_offset : ii) = ((( 4 : int):ii)) in sail2_state_monad$bindS
   (CurrentInstrSet () ) (\ (w__5 : InstrSet) . 
   let (lr_offset : ii) = (if (((w__5 = InstrSet_A32))) then (( 4 : int):ii) else (( 2 : int):ii)) in sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__6 : ProcState) . 
   if (((w__6.ProcState_EL = EL2))) then
     AArch32_EnterHypMode exception preferred_exception_return vect_offset
   else if route_to_hyp then AArch32_EnterHypMode exception preferred_exception_return (( 20 : int):ii)
   else AArch32_EnterMode M32_Undef preferred_exception_return lr_offset vect_offset))))))`;


val _ = Define `
 ((AArch32_TakeUndefInstrException__0:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (ExceptionSyndrome Exception_Uncategorized) (\ (exception : ExceptionRecord) . 
   AArch32_TakeUndefInstrException__1 exception)))`;


(*val UnallocatedEncoding : unit -> M unit*)

val _ = Define `
 ((UnallocatedEncoding:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (sail2_state$and_boolS ((UsingAArch32 () )) ((AArch32_ExecutingCP10or11Instr () ))) (\ (w__2 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (if w__2 then sail2_state_monad$bindS
      (sail2_state_monad$read_regS FPEXC_ref  : ( 32 words$word) M) (\ (w__3 :  32 words$word) . 
      sail2_state_monad$write_regS
        FPEXC_ref
        ((set_slice (( 32 : int):ii) (( 1 : int):ii) w__3 (( 29 : int):ii) (vec_of_bits [B0]  :  1 words$word)  :  32 words$word)))
    else sail2_state_monad$returnS () )
   (sail2_state$and_boolS ((UsingAArch32 () ))
     ( sail2_state_monad$bindS(AArch32_GeneralExceptionsToAArch64 () ) (\ (w__5 : bool) .  sail2_state_monad$returnS ((~ w__5)))))) (\ (w__6 :
     bool) . 
   if w__6 then AArch32_TakeUndefInstrException__0 () 
   else AArch64_UndefinedFault () ))))`;


(*val aarch64_system_exceptions_runtime_hvc : mword ty16 -> M unit*)

val _ = Define `
 ((aarch64_system_exceptions_runtime_hvc:(16)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) imm=  (sail2_state_monad$bindS
   (sail2_state$or_boolS
     (sail2_state$or_boolS (sail2_state_monad$returnS ((~ ((HaveEL EL2)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) .  sail2_state_monad$returnS (((w__0.ProcState_EL = EL0))))))
     (sail2_state$and_boolS
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__2 : ProcState) .  sail2_state_monad$returnS (((w__2.ProcState_EL = EL1)))))
        ((IsSecure () )))) (\ (w__5 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (if w__5 then UnallocatedEncoding () 
    else sail2_state_monad$returnS () )
   (if ((HaveEL EL3)) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M) (\ (w__6 : 32 bits) . 
      sail2_state_monad$returnS (vec_of_bits [access_vec_dec w__6 (( 8 : int):ii)]  :  1 words$word))
    else sail2_state_monad$bindS
      (sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__7 : 64 bits) . 
      sail2_state_monad$returnS ((not_vec (vec_of_bits [access_vec_dec w__7 (( 29 : int):ii)]  :  1 words$word)  :  1 words$word))))) (\ (hvc_enable : 1
     bits) . 
   if (((hvc_enable = (vec_of_bits [B0]  :  1 words$word)))) then AArch64_UndefinedFault () 
   else AArch64_CallHypervisor imm))))`;


(*val system_exceptions_runtime_hvc_decode : mword ty3 -> mword ty16 -> mword ty3 -> mword ty2 -> M unit*)

val _ = Define `
 ((system_exceptions_runtime_hvc_decode:(3)words$word ->(16)words$word ->(3)words$word ->(2)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) opc imm16 op2 LL=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (imm : 16 bits) = imm16 in
   aarch64_system_exceptions_runtime_hvc imm)))`;


(*val aarch64_memory_single_general_register : forall 'regsize. Size 'regsize => AccType -> ii -> ExtendType -> ii -> MemOp -> ii -> bool -> itself 'regsize -> ii -> bool -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_memory_single_general_register:AccType -> int -> ExtendType -> int -> MemOp -> int -> bool -> 'regsize itself -> int -> bool -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) acctype l__40 extend_type m memop n postindex regsize shift signed t wback__arg=
    (if (((l__40 = (( 8 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let wback = wback__arg in sail2_state_monad$bindS
     (ExtendReg (( 64 : int):ii) m extend_type shift  : ( 64 words$word) M) (\ (offset : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M) (\ (data : 8 bits) . 
     let (wb_unknown : bool) = F in
     let (rt_unknown : bool) = F in sail2_state_monad$bindS
     (undefined_Constraint () ) (\ (c : Constraint) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_LOAD))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_WBSUPPRESS in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \/ (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) "((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS wback) (\ (wback : bool) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_STORE))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_NONE in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS
        (if (((memop <> MemOp_PREFETCH))) then CheckSPAlignment () 
         else sail2_state_monad$returnS () )
        (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M)
         else (aget_X (( 8 : int):ii) t  : ( 8 words$word) M)) (\ (data : 8 bits) . 
        aset_Mem address (((( 8 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 8 : int):ii) / (( 8 : int):ii))) acctype  : ( 8 words$word) M) (\ (w__4 : 8
          bits) . 
        let data = w__4 in
        if signed then sail2_state_monad$bindS
          (SignExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__5 :
             'regsize words$word) . 
          aset_X t w__5)
        else sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__6 :
             'regsize words$word) . 
          aset_X t w__6))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 : int):ii)  :  5 itself)) t (( 0 : int):ii)  :  5 words$word))
     )
     (if wback then sail2_state_monad$bindS
       (if wb_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
        else
          let (address : 64 bits) =
            (if postindex then (add_vec address offset  :  64 words$word)
            else address) in
          sail2_state_monad$returnS address) (\ (address : 64 bits) . 
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address)
     else sail2_state_monad$returnS () ))))))))))
   else if (((l__40 = (( 16 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let wback = wback__arg in sail2_state_monad$bindS
     (ExtendReg (( 64 : int):ii) m extend_type shift  : ( 64 words$word) M) (\ (offset : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M) (\ (data : 16 bits) . 
     let (wb_unknown : bool) = F in
     let (rt_unknown : bool) = F in sail2_state_monad$bindS
     (undefined_Constraint () ) (\ (c : Constraint) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_LOAD))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_WBSUPPRESS in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \/ (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) "((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS wback) (\ (wback : bool) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_STORE))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_NONE in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS
        (if (((memop <> MemOp_PREFETCH))) then CheckSPAlignment () 
         else sail2_state_monad$returnS () )
        (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M)
         else (aget_X (( 16 : int):ii) t  : ( 16 words$word) M)) (\ (data : 16 bits) . 
        aset_Mem address (((( 16 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 16 : int):ii) / (( 8 : int):ii))) acctype  : ( 16 words$word) M) (\ (w__12 : 16
          bits) . 
        let data = w__12 in
        if signed then sail2_state_monad$bindS
          (SignExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__13 :
             'regsize words$word) . 
          aset_X t w__13)
        else sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__14 :
             'regsize words$word) . 
          aset_X t w__14))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 : int):ii)  :  5 itself)) t (( 0 : int):ii)  :  5 words$word))
     )
     (if wback then sail2_state_monad$bindS
       (if wb_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
        else
          let (address : 64 bits) =
            (if postindex then (add_vec address offset  :  64 words$word)
            else address) in
          sail2_state_monad$returnS address) (\ (address : 64 bits) . 
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address)
     else sail2_state_monad$returnS () ))))))))))
   else if (((l__40 = (( 32 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let wback = wback__arg in sail2_state_monad$bindS
     (ExtendReg (( 64 : int):ii) m extend_type shift  : ( 64 words$word) M) (\ (offset : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (data : 32 bits) . 
     let (wb_unknown : bool) = F in
     let (rt_unknown : bool) = F in sail2_state_monad$bindS
     (undefined_Constraint () ) (\ (c : Constraint) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_LOAD))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_WBSUPPRESS in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \/ (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) "((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS wback) (\ (wback : bool) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_STORE))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_NONE in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS
        (if (((memop <> MemOp_PREFETCH))) then CheckSPAlignment () 
         else sail2_state_monad$returnS () )
        (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)
         else (aget_X (( 32 : int):ii) t  : ( 32 words$word) M)) (\ (data : 32 bits) . 
        aset_Mem address (((( 32 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 32 : int):ii) / (( 8 : int):ii))) acctype  : ( 32 words$word) M) (\ (w__20 : 32
          bits) . 
        let data = w__20 in
        if signed then sail2_state_monad$bindS
          (SignExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__21 :
             'regsize words$word) . 
          aset_X t w__21)
        else sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__22 :
             'regsize words$word) . 
          aset_X t w__22))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 : int):ii)  :  5 itself)) t (( 0 : int):ii)  :  5 words$word))
     )
     (if wback then sail2_state_monad$bindS
       (if wb_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
        else
          let (address : 64 bits) =
            (if postindex then (add_vec address offset  :  64 words$word)
            else address) in
          sail2_state_monad$returnS address) (\ (address : 64 bits) . 
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address)
     else sail2_state_monad$returnS () ))))))))))
   else if (((l__40 = (( 64 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let wback = wback__arg in sail2_state_monad$bindS
     (ExtendReg (( 64 : int):ii) m extend_type shift  : ( 64 words$word) M) (\ (offset : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (data : 64 bits) . 
     let (wb_unknown : bool) = F in
     let (rt_unknown : bool) = F in sail2_state_monad$bindS
     (undefined_Constraint () ) (\ (c : Constraint) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_LOAD))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_WBSUPPRESS in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \/ (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) "((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS wback) (\ (wback : bool) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_STORE))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_NONE in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS
        (if (((memop <> MemOp_PREFETCH))) then CheckSPAlignment () 
         else sail2_state_monad$returnS () )
        (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
         else (aget_X (( 64 : int):ii) t  : ( 64 words$word) M)) (\ (data : 64 bits) . 
        aset_Mem address (((( 64 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 64 : int):ii) / (( 8 : int):ii))) acctype  : ( 64 words$word) M) (\ (w__28 : 64
          bits) . 
        let data = w__28 in
        if signed then sail2_state_monad$bindS
          (SignExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__29 :
             'regsize words$word) . 
          aset_X t w__29)
        else sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__30 :
             'regsize words$word) . 
          aset_X t w__30))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 : int):ii)  :  5 itself)) t (( 0 : int):ii)  :  5 words$word))
     )
     (if wback then sail2_state_monad$bindS
       (if wb_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
        else
          let (address : 64 bits) =
            (if postindex then (add_vec address offset  :  64 words$word)
            else address) in
          sail2_state_monad$returnS address) (\ (address : 64 bits) . 
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address)
     else sail2_state_monad$returnS () ))))))))))
   else if (((l__40 = (( 128 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let wback = wback__arg in sail2_state_monad$bindS
     (ExtendReg (( 64 : int):ii) m extend_type shift  : ( 64 words$word) M) (\ (offset : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M) (\ (data : 128 bits) . 
     let (wb_unknown : bool) = F in
     let (rt_unknown : bool) = F in sail2_state_monad$bindS
     (undefined_Constraint () ) (\ (c : Constraint) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_LOAD))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_WBSUPPRESS in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \/ (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) "((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS wback) (\ (wback : bool) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_STORE))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_NONE in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS
        (if (((memop <> MemOp_PREFETCH))) then CheckSPAlignment () 
         else sail2_state_monad$returnS () )
        (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M)
         else (aget_X (( 128 : int):ii) t  : ( 128 words$word) M)) (\ (data : 128 bits) . 
        aset_Mem address (((( 128 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 128 : int):ii) / (( 8 : int):ii))) acctype  : ( 128 words$word) M) (\ (w__36 : 128
          bits) . 
        let data = w__36 in
        if signed then sail2_state_monad$bindS
          (SignExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__37 :
             'regsize words$word) . 
          aset_X t w__37)
        else sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__38 :
             'regsize words$word) . 
          aset_X t w__38))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 : int):ii)  :  5 itself)) t (( 0 : int):ii)  :  5 words$word))
     )
     (if wback then sail2_state_monad$bindS
       (if wb_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
        else
          let (address : 64 bits) =
            (if postindex then (add_vec address offset  :  64 words$word)
            else address) in
          sail2_state_monad$returnS address) (\ (address : 64 bits) . 
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address)
     else sail2_state_monad$returnS () ))))))))))
   else
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int ((l__40 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint")))`;


(*val aarch64_memory_single_general_immediate_unsigned : forall 'regsize. Size 'regsize => AccType -> ii -> MemOp -> ii -> mword ty64 -> bool -> itself 'regsize -> bool -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_memory_single_general_immediate_unsigned:AccType -> int -> MemOp -> int ->(64)words$word -> bool -> 'regsize itself -> bool -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) acctype l__35 memop n offset postindex regsize signed t wback__arg=
    (if (((l__35 = (( 8 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let wback = wback__arg in sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M) (\ (data : 8 bits) . 
     let (wb_unknown : bool) = F in
     let (rt_unknown : bool) = F in sail2_state_monad$bindS
     (undefined_Constraint () ) (\ (c : Constraint) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_LOAD))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_WBSUPPRESS in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \/ (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) "((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS wback) (\ (wback : bool) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_STORE))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_NONE in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS
        (if (((memop <> MemOp_PREFETCH))) then CheckSPAlignment () 
         else sail2_state_monad$returnS () )
        (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M)
         else (aget_X (( 8 : int):ii) t  : ( 8 words$word) M)) (\ (data : 8 bits) . 
        aset_Mem address (((( 8 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 8 : int):ii) / (( 8 : int):ii))) acctype  : ( 8 words$word) M) (\ (w__4 : 8
          bits) . 
        let data = w__4 in
        if signed then sail2_state_monad$bindS
          (SignExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__5 :
             'regsize words$word) . 
          aset_X t w__5)
        else sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__6 :
             'regsize words$word) . 
          aset_X t w__6))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 : int):ii)  :  5 itself)) t (( 0 : int):ii)  :  5 words$word))
     )
     (if wback then sail2_state_monad$bindS
       (if wb_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
        else
          let (address : 64 bits) =
            (if postindex then (add_vec address offset  :  64 words$word)
            else address) in
          sail2_state_monad$returnS address) (\ (address : 64 bits) . 
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address)
     else sail2_state_monad$returnS () )))))))))
   else if (((l__35 = (( 16 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let wback = wback__arg in sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M) (\ (data : 16 bits) . 
     let (wb_unknown : bool) = F in
     let (rt_unknown : bool) = F in sail2_state_monad$bindS
     (undefined_Constraint () ) (\ (c : Constraint) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_LOAD))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_WBSUPPRESS in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \/ (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) "((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS wback) (\ (wback : bool) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_STORE))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_NONE in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS
        (if (((memop <> MemOp_PREFETCH))) then CheckSPAlignment () 
         else sail2_state_monad$returnS () )
        (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M)
         else (aget_X (( 16 : int):ii) t  : ( 16 words$word) M)) (\ (data : 16 bits) . 
        aset_Mem address (((( 16 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 16 : int):ii) / (( 8 : int):ii))) acctype  : ( 16 words$word) M) (\ (w__12 : 16
          bits) . 
        let data = w__12 in
        if signed then sail2_state_monad$bindS
          (SignExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__13 :
             'regsize words$word) . 
          aset_X t w__13)
        else sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__14 :
             'regsize words$word) . 
          aset_X t w__14))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 : int):ii)  :  5 itself)) t (( 0 : int):ii)  :  5 words$word))
     )
     (if wback then sail2_state_monad$bindS
       (if wb_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
        else
          let (address : 64 bits) =
            (if postindex then (add_vec address offset  :  64 words$word)
            else address) in
          sail2_state_monad$returnS address) (\ (address : 64 bits) . 
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address)
     else sail2_state_monad$returnS () )))))))))
   else if (((l__35 = (( 32 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let wback = wback__arg in sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (data : 32 bits) . 
     let (wb_unknown : bool) = F in
     let (rt_unknown : bool) = F in sail2_state_monad$bindS
     (undefined_Constraint () ) (\ (c : Constraint) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_LOAD))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_WBSUPPRESS in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \/ (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) "((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS wback) (\ (wback : bool) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_STORE))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_NONE in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS
        (if (((memop <> MemOp_PREFETCH))) then CheckSPAlignment () 
         else sail2_state_monad$returnS () )
        (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)
         else (aget_X (( 32 : int):ii) t  : ( 32 words$word) M)) (\ (data : 32 bits) . 
        aset_Mem address (((( 32 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 32 : int):ii) / (( 8 : int):ii))) acctype  : ( 32 words$word) M) (\ (w__20 : 32
          bits) . 
        let data = w__20 in
        if signed then sail2_state_monad$bindS
          (SignExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__21 :
             'regsize words$word) . 
          aset_X t w__21)
        else sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__22 :
             'regsize words$word) . 
          aset_X t w__22))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 : int):ii)  :  5 itself)) t (( 0 : int):ii)  :  5 words$word))
     )
     (if wback then sail2_state_monad$bindS
       (if wb_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
        else
          let (address : 64 bits) =
            (if postindex then (add_vec address offset  :  64 words$word)
            else address) in
          sail2_state_monad$returnS address) (\ (address : 64 bits) . 
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address)
     else sail2_state_monad$returnS () )))))))))
   else if (((l__35 = (( 64 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let wback = wback__arg in sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (data : 64 bits) . 
     let (wb_unknown : bool) = F in
     let (rt_unknown : bool) = F in sail2_state_monad$bindS
     (undefined_Constraint () ) (\ (c : Constraint) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_LOAD))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_WBSUPPRESS in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \/ (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) "((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS wback) (\ (wback : bool) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_STORE))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_NONE in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS
        (if (((memop <> MemOp_PREFETCH))) then CheckSPAlignment () 
         else sail2_state_monad$returnS () )
        (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
         else (aget_X (( 64 : int):ii) t  : ( 64 words$word) M)) (\ (data : 64 bits) . 
        aset_Mem address (((( 64 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 64 : int):ii) / (( 8 : int):ii))) acctype  : ( 64 words$word) M) (\ (w__28 : 64
          bits) . 
        let data = w__28 in
        if signed then sail2_state_monad$bindS
          (SignExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__29 :
             'regsize words$word) . 
          aset_X t w__29)
        else sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__30 :
             'regsize words$word) . 
          aset_X t w__30))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 : int):ii)  :  5 itself)) t (( 0 : int):ii)  :  5 words$word))
     )
     (if wback then sail2_state_monad$bindS
       (if wb_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
        else
          let (address : 64 bits) =
            (if postindex then (add_vec address offset  :  64 words$word)
            else address) in
          sail2_state_monad$returnS address) (\ (address : 64 bits) . 
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address)
     else sail2_state_monad$returnS () )))))))))
   else if (((l__35 = (( 128 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let wback = wback__arg in sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M) (\ (data : 128 bits) . 
     let (wb_unknown : bool) = F in
     let (rt_unknown : bool) = F in sail2_state_monad$bindS
     (undefined_Constraint () ) (\ (c : Constraint) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_LOAD))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_WBSUPPRESS in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \/ (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) "((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS wback) (\ (wback : bool) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_STORE))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_NONE in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS
        (if (((memop <> MemOp_PREFETCH))) then CheckSPAlignment () 
         else sail2_state_monad$returnS () )
        (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M)
         else (aget_X (( 128 : int):ii) t  : ( 128 words$word) M)) (\ (data : 128 bits) . 
        aset_Mem address (((( 128 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 128 : int):ii) / (( 8 : int):ii))) acctype  : ( 128 words$word) M) (\ (w__36 : 128
          bits) . 
        let data = w__36 in
        if signed then sail2_state_monad$bindS
          (SignExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__37 :
             'regsize words$word) . 
          aset_X t w__37)
        else sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__38 :
             'regsize words$word) . 
          aset_X t w__38))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 : int):ii)  :  5 itself)) t (( 0 : int):ii)  :  5 words$word))
     )
     (if wback then sail2_state_monad$bindS
       (if wb_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
        else
          let (address : 64 bits) =
            (if postindex then (add_vec address offset  :  64 words$word)
            else address) in
          sail2_state_monad$returnS address) (\ (address : 64 bits) . 
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address)
     else sail2_state_monad$returnS () )))))))))
   else
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int ((l__35 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint")))`;


(*val aarch64_memory_single_general_immediate_signed_postidx : forall 'regsize. Size 'regsize => AccType -> ii -> MemOp -> ii -> mword ty64 -> bool -> itself 'regsize -> bool -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_memory_single_general_immediate_signed_postidx:AccType -> int -> MemOp -> int ->(64)words$word -> bool -> 'regsize itself -> bool -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) acctype l__30 memop n offset postindex regsize signed t wback__arg=
    (if (((l__30 = (( 8 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let wback = wback__arg in sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M) (\ (data : 8 bits) . 
     let (wb_unknown : bool) = F in
     let (rt_unknown : bool) = F in sail2_state_monad$bindS
     (undefined_Constraint () ) (\ (c : Constraint) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_LOAD))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_WBSUPPRESS in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \/ (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) "((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS wback) (\ (wback : bool) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_STORE))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_NONE in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS
        (if (((memop <> MemOp_PREFETCH))) then CheckSPAlignment () 
         else sail2_state_monad$returnS () )
        (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M)
         else (aget_X (( 8 : int):ii) t  : ( 8 words$word) M)) (\ (data : 8 bits) . 
        aset_Mem address (((( 8 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 8 : int):ii) / (( 8 : int):ii))) acctype  : ( 8 words$word) M) (\ (w__4 : 8
          bits) . 
        let data = w__4 in
        if signed then sail2_state_monad$bindS
          (SignExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__5 :
             'regsize words$word) . 
          aset_X t w__5)
        else sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__6 :
             'regsize words$word) . 
          aset_X t w__6))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 : int):ii)  :  5 itself)) t (( 0 : int):ii)  :  5 words$word))
     )
     (if wback then sail2_state_monad$bindS
       (if wb_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
        else
          let (address : 64 bits) =
            (if postindex then (add_vec address offset  :  64 words$word)
            else address) in
          sail2_state_monad$returnS address) (\ (address : 64 bits) . 
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address)
     else sail2_state_monad$returnS () )))))))))
   else if (((l__30 = (( 16 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let wback = wback__arg in sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M) (\ (data : 16 bits) . 
     let (wb_unknown : bool) = F in
     let (rt_unknown : bool) = F in sail2_state_monad$bindS
     (undefined_Constraint () ) (\ (c : Constraint) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_LOAD))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_WBSUPPRESS in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \/ (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) "((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS wback) (\ (wback : bool) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_STORE))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_NONE in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS
        (if (((memop <> MemOp_PREFETCH))) then CheckSPAlignment () 
         else sail2_state_monad$returnS () )
        (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M)
         else (aget_X (( 16 : int):ii) t  : ( 16 words$word) M)) (\ (data : 16 bits) . 
        aset_Mem address (((( 16 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 16 : int):ii) / (( 8 : int):ii))) acctype  : ( 16 words$word) M) (\ (w__12 : 16
          bits) . 
        let data = w__12 in
        if signed then sail2_state_monad$bindS
          (SignExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__13 :
             'regsize words$word) . 
          aset_X t w__13)
        else sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__14 :
             'regsize words$word) . 
          aset_X t w__14))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 : int):ii)  :  5 itself)) t (( 0 : int):ii)  :  5 words$word))
     )
     (if wback then sail2_state_monad$bindS
       (if wb_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
        else
          let (address : 64 bits) =
            (if postindex then (add_vec address offset  :  64 words$word)
            else address) in
          sail2_state_monad$returnS address) (\ (address : 64 bits) . 
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address)
     else sail2_state_monad$returnS () )))))))))
   else if (((l__30 = (( 32 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let wback = wback__arg in sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (data : 32 bits) . 
     let (wb_unknown : bool) = F in
     let (rt_unknown : bool) = F in sail2_state_monad$bindS
     (undefined_Constraint () ) (\ (c : Constraint) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_LOAD))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_WBSUPPRESS in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \/ (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) "((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS wback) (\ (wback : bool) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_STORE))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_NONE in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS
        (if (((memop <> MemOp_PREFETCH))) then CheckSPAlignment () 
         else sail2_state_monad$returnS () )
        (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)
         else (aget_X (( 32 : int):ii) t  : ( 32 words$word) M)) (\ (data : 32 bits) . 
        aset_Mem address (((( 32 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 32 : int):ii) / (( 8 : int):ii))) acctype  : ( 32 words$word) M) (\ (w__20 : 32
          bits) . 
        let data = w__20 in
        if signed then sail2_state_monad$bindS
          (SignExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__21 :
             'regsize words$word) . 
          aset_X t w__21)
        else sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__22 :
             'regsize words$word) . 
          aset_X t w__22))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 : int):ii)  :  5 itself)) t (( 0 : int):ii)  :  5 words$word))
     )
     (if wback then sail2_state_monad$bindS
       (if wb_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
        else
          let (address : 64 bits) =
            (if postindex then (add_vec address offset  :  64 words$word)
            else address) in
          sail2_state_monad$returnS address) (\ (address : 64 bits) . 
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address)
     else sail2_state_monad$returnS () )))))))))
   else if (((l__30 = (( 64 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let wback = wback__arg in sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (data : 64 bits) . 
     let (wb_unknown : bool) = F in
     let (rt_unknown : bool) = F in sail2_state_monad$bindS
     (undefined_Constraint () ) (\ (c : Constraint) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_LOAD))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_WBSUPPRESS in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \/ (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) "((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS wback) (\ (wback : bool) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_STORE))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_NONE in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS
        (if (((memop <> MemOp_PREFETCH))) then CheckSPAlignment () 
         else sail2_state_monad$returnS () )
        (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
         else (aget_X (( 64 : int):ii) t  : ( 64 words$word) M)) (\ (data : 64 bits) . 
        aset_Mem address (((( 64 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 64 : int):ii) / (( 8 : int):ii))) acctype  : ( 64 words$word) M) (\ (w__28 : 64
          bits) . 
        let data = w__28 in
        if signed then sail2_state_monad$bindS
          (SignExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__29 :
             'regsize words$word) . 
          aset_X t w__29)
        else sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__30 :
             'regsize words$word) . 
          aset_X t w__30))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 : int):ii)  :  5 itself)) t (( 0 : int):ii)  :  5 words$word))
     )
     (if wback then sail2_state_monad$bindS
       (if wb_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
        else
          let (address : 64 bits) =
            (if postindex then (add_vec address offset  :  64 words$word)
            else address) in
          sail2_state_monad$returnS address) (\ (address : 64 bits) . 
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address)
     else sail2_state_monad$returnS () )))))))))
   else if (((l__30 = (( 128 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let wback = wback__arg in sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M) (\ (data : 128 bits) . 
     let (wb_unknown : bool) = F in
     let (rt_unknown : bool) = F in sail2_state_monad$bindS
     (undefined_Constraint () ) (\ (c : Constraint) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_LOAD))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_WBSUPPRESS in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \/ (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) "((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS wback) (\ (wback : bool) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_STORE))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_NONE in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS
        (if (((memop <> MemOp_PREFETCH))) then CheckSPAlignment () 
         else sail2_state_monad$returnS () )
        (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M)
         else (aget_X (( 128 : int):ii) t  : ( 128 words$word) M)) (\ (data : 128 bits) . 
        aset_Mem address (((( 128 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 128 : int):ii) / (( 8 : int):ii))) acctype  : ( 128 words$word) M) (\ (w__36 : 128
          bits) . 
        let data = w__36 in
        if signed then sail2_state_monad$bindS
          (SignExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__37 :
             'regsize words$word) . 
          aset_X t w__37)
        else sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__38 :
             'regsize words$word) . 
          aset_X t w__38))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 : int):ii)  :  5 itself)) t (( 0 : int):ii)  :  5 words$word))
     )
     (if wback then sail2_state_monad$bindS
       (if wb_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
        else
          let (address : 64 bits) =
            (if postindex then (add_vec address offset  :  64 words$word)
            else address) in
          sail2_state_monad$returnS address) (\ (address : 64 bits) . 
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address)
     else sail2_state_monad$returnS () )))))))))
   else
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int ((l__30 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint")))`;


(*val aarch64_memory_single_general_immediate_signed_pac : ii -> mword ty64 -> ii -> bool -> bool -> M unit*)

val _ = Define `
 ((aarch64_memory_single_general_immediate_signed_pac:int ->(64)words$word -> int -> bool -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) n offset t use_key_a wback__arg=
    (let wback = wback__arg in sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (address : 64 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (data : 64 bits) . 
   let (wb_unknown : bool) = F in sail2_state_monad$bindS
   (undefined_Constraint () ) (\ (c : Constraint) .  sail2_state_monad$bindS
   (if ((((((wback /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
      let c = (ConstrainUnpredictable Unpredictable_WBOVERLAPLD) in sail2_state_monad$seqS
      (sail2_state_monad$assert_expS ((((((c = Constraint_WBSUPPRESS))) \/ ((((((c = Constraint_UNKNOWN))) \/ ((((((c = Constraint_UNDEF))) \/ (((c = Constraint_NOP)))))))))))) "((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
      (case c of
        Constraint_WBSUPPRESS =>
         let (wback : bool) = F in
         sail2_state_monad$returnS (wb_unknown, wback)
      | Constraint_UNKNOWN =>
         let (wb_unknown : bool) = T in
         sail2_state_monad$returnS (wb_unknown, wback)
      | Constraint_UNDEF => sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS (wb_unknown, wback))
      | Constraint_NOP => sail2_state_monad$seqS (EndOfInstruction () ) (sail2_state_monad$returnS (wb_unknown, wback))
      )
    else sail2_state_monad$returnS (wb_unknown, wback)) (\ varstup .  let ((wb_unknown : bool), (wback : bool)) = varstup in sail2_state_monad$bindS
   (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
    else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
   (if use_key_a then sail2_state_monad$bindS
      (aget_X (( 64 : int):ii) (( 31 : int):ii)  : ( 64 words$word) M) (\ (w__2 :  64 words$word) . 
      (AuthDA address w__2  : ( 64 words$word) M))
    else sail2_state_monad$bindS
      (aget_X (( 64 : int):ii) (( 31 : int):ii)  : ( 64 words$word) M) (\ (w__4 :  64 words$word) . 
      (AuthDB address w__4  : ( 64 words$word) M))) (\ (address : 64 bits) . 
   let address = ((add_vec address offset  :  64 words$word)) in sail2_state_monad$bindS
   (aget_Mem address (( 8 : int):ii) AccType_NORMAL  : ( 64 words$word) M) (\ (w__6 : 64 bits) . 
   let data = w__6 in sail2_state_monad$seqS
   (aset_X t data)
   (if wback then sail2_state_monad$bindS
     (if wb_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
      else sail2_state_monad$returnS address) (\ (address : 64 bits) . 
     if (((n = (( 31 : int):ii)))) then aset_SP address
     else aset_X n address)
   else sail2_state_monad$returnS () ))))))))))`;


(*val aarch64_memory_single_general_immediate_signed_offset_unpriv : forall 'regsize. Size 'regsize => AccType -> ii -> MemOp -> ii -> mword ty64 -> bool -> itself 'regsize -> bool -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_memory_single_general_immediate_signed_offset_unpriv:AccType -> int -> MemOp -> int ->(64)words$word -> bool -> 'regsize itself -> bool -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) acctype l__25 memop n offset postindex regsize signed t wback__arg=
    (if (((l__25 = (( 8 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let wback = wback__arg in sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M) (\ (data : 8 bits) . 
     let (wb_unknown : bool) = F in
     let (rt_unknown : bool) = F in sail2_state_monad$bindS
     (undefined_Constraint () ) (\ (c : Constraint) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_LOAD))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_WBSUPPRESS in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \/ (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) "((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS wback) (\ (wback : bool) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_STORE))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_NONE in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS
        (if (((memop <> MemOp_PREFETCH))) then CheckSPAlignment () 
         else sail2_state_monad$returnS () )
        (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M)
         else (aget_X (( 8 : int):ii) t  : ( 8 words$word) M)) (\ (data : 8 bits) . 
        aset_Mem address (((( 8 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 8 : int):ii) / (( 8 : int):ii))) acctype  : ( 8 words$word) M) (\ (w__4 : 8
          bits) . 
        let data = w__4 in
        if signed then sail2_state_monad$bindS
          (SignExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__5 :
             'regsize words$word) . 
          aset_X t w__5)
        else sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__6 :
             'regsize words$word) . 
          aset_X t w__6))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 : int):ii)  :  5 itself)) t (( 0 : int):ii)  :  5 words$word))
     )
     (if wback then sail2_state_monad$bindS
       (if wb_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
        else
          let (address : 64 bits) =
            (if postindex then (add_vec address offset  :  64 words$word)
            else address) in
          sail2_state_monad$returnS address) (\ (address : 64 bits) . 
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address)
     else sail2_state_monad$returnS () )))))))))
   else if (((l__25 = (( 16 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let wback = wback__arg in sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M) (\ (data : 16 bits) . 
     let (wb_unknown : bool) = F in
     let (rt_unknown : bool) = F in sail2_state_monad$bindS
     (undefined_Constraint () ) (\ (c : Constraint) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_LOAD))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_WBSUPPRESS in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \/ (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) "((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS wback) (\ (wback : bool) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_STORE))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_NONE in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS
        (if (((memop <> MemOp_PREFETCH))) then CheckSPAlignment () 
         else sail2_state_monad$returnS () )
        (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M)
         else (aget_X (( 16 : int):ii) t  : ( 16 words$word) M)) (\ (data : 16 bits) . 
        aset_Mem address (((( 16 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 16 : int):ii) / (( 8 : int):ii))) acctype  : ( 16 words$word) M) (\ (w__12 : 16
          bits) . 
        let data = w__12 in
        if signed then sail2_state_monad$bindS
          (SignExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__13 :
             'regsize words$word) . 
          aset_X t w__13)
        else sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__14 :
             'regsize words$word) . 
          aset_X t w__14))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 : int):ii)  :  5 itself)) t (( 0 : int):ii)  :  5 words$word))
     )
     (if wback then sail2_state_monad$bindS
       (if wb_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
        else
          let (address : 64 bits) =
            (if postindex then (add_vec address offset  :  64 words$word)
            else address) in
          sail2_state_monad$returnS address) (\ (address : 64 bits) . 
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address)
     else sail2_state_monad$returnS () )))))))))
   else if (((l__25 = (( 32 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let wback = wback__arg in sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (data : 32 bits) . 
     let (wb_unknown : bool) = F in
     let (rt_unknown : bool) = F in sail2_state_monad$bindS
     (undefined_Constraint () ) (\ (c : Constraint) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_LOAD))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_WBSUPPRESS in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \/ (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) "((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS wback) (\ (wback : bool) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_STORE))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_NONE in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS
        (if (((memop <> MemOp_PREFETCH))) then CheckSPAlignment () 
         else sail2_state_monad$returnS () )
        (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)
         else (aget_X (( 32 : int):ii) t  : ( 32 words$word) M)) (\ (data : 32 bits) . 
        aset_Mem address (((( 32 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 32 : int):ii) / (( 8 : int):ii))) acctype  : ( 32 words$word) M) (\ (w__20 : 32
          bits) . 
        let data = w__20 in
        if signed then sail2_state_monad$bindS
          (SignExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__21 :
             'regsize words$word) . 
          aset_X t w__21)
        else sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__22 :
             'regsize words$word) . 
          aset_X t w__22))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 : int):ii)  :  5 itself)) t (( 0 : int):ii)  :  5 words$word))
     )
     (if wback then sail2_state_monad$bindS
       (if wb_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
        else
          let (address : 64 bits) =
            (if postindex then (add_vec address offset  :  64 words$word)
            else address) in
          sail2_state_monad$returnS address) (\ (address : 64 bits) . 
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address)
     else sail2_state_monad$returnS () )))))))))
   else if (((l__25 = (( 64 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let wback = wback__arg in sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (data : 64 bits) . 
     let (wb_unknown : bool) = F in
     let (rt_unknown : bool) = F in sail2_state_monad$bindS
     (undefined_Constraint () ) (\ (c : Constraint) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_LOAD))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_WBSUPPRESS in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \/ (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) "((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS wback) (\ (wback : bool) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_STORE))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_NONE in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS
        (if (((memop <> MemOp_PREFETCH))) then CheckSPAlignment () 
         else sail2_state_monad$returnS () )
        (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
         else (aget_X (( 64 : int):ii) t  : ( 64 words$word) M)) (\ (data : 64 bits) . 
        aset_Mem address (((( 64 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 64 : int):ii) / (( 8 : int):ii))) acctype  : ( 64 words$word) M) (\ (w__28 : 64
          bits) . 
        let data = w__28 in
        if signed then sail2_state_monad$bindS
          (SignExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__29 :
             'regsize words$word) . 
          aset_X t w__29)
        else sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__30 :
             'regsize words$word) . 
          aset_X t w__30))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 : int):ii)  :  5 itself)) t (( 0 : int):ii)  :  5 words$word))
     )
     (if wback then sail2_state_monad$bindS
       (if wb_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
        else
          let (address : 64 bits) =
            (if postindex then (add_vec address offset  :  64 words$word)
            else address) in
          sail2_state_monad$returnS address) (\ (address : 64 bits) . 
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address)
     else sail2_state_monad$returnS () )))))))))
   else if (((l__25 = (( 128 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let wback = wback__arg in sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M) (\ (data : 128 bits) . 
     let (wb_unknown : bool) = F in
     let (rt_unknown : bool) = F in sail2_state_monad$bindS
     (undefined_Constraint () ) (\ (c : Constraint) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_LOAD))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_WBSUPPRESS in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \/ (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) "((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS wback) (\ (wback : bool) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_STORE))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_NONE in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS
        (if (((memop <> MemOp_PREFETCH))) then CheckSPAlignment () 
         else sail2_state_monad$returnS () )
        (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M)
         else (aget_X (( 128 : int):ii) t  : ( 128 words$word) M)) (\ (data : 128 bits) . 
        aset_Mem address (((( 128 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 128 : int):ii) / (( 8 : int):ii))) acctype  : ( 128 words$word) M) (\ (w__36 : 128
          bits) . 
        let data = w__36 in
        if signed then sail2_state_monad$bindS
          (SignExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__37 :
             'regsize words$word) . 
          aset_X t w__37)
        else sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__38 :
             'regsize words$word) . 
          aset_X t w__38))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 : int):ii)  :  5 itself)) t (( 0 : int):ii)  :  5 words$word))
     )
     (if wback then sail2_state_monad$bindS
       (if wb_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
        else
          let (address : 64 bits) =
            (if postindex then (add_vec address offset  :  64 words$word)
            else address) in
          sail2_state_monad$returnS address) (\ (address : 64 bits) . 
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address)
     else sail2_state_monad$returnS () )))))))))
   else
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int ((l__25 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint")))`;


(*val aarch64_memory_single_general_immediate_signed_offset_normal : forall 'regsize. Size 'regsize => AccType -> ii -> MemOp -> ii -> mword ty64 -> bool -> itself 'regsize -> bool -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_memory_single_general_immediate_signed_offset_normal:AccType -> int -> MemOp -> int ->(64)words$word -> bool -> 'regsize itself -> bool -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) acctype l__20 memop n offset postindex regsize signed t wback__arg=
    (if (((l__20 = (( 8 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let wback = wback__arg in sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M) (\ (data : 8 bits) . 
     let (wb_unknown : bool) = F in
     let (rt_unknown : bool) = F in sail2_state_monad$bindS
     (undefined_Constraint () ) (\ (c : Constraint) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_LOAD))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_WBSUPPRESS in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \/ (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) "((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS wback) (\ (wback : bool) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_STORE))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_NONE in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS
        (if (((memop <> MemOp_PREFETCH))) then CheckSPAlignment () 
         else sail2_state_monad$returnS () )
        (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M)
         else (aget_X (( 8 : int):ii) t  : ( 8 words$word) M)) (\ (data : 8 bits) . 
        aset_Mem address (((( 8 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 8 : int):ii) / (( 8 : int):ii))) acctype  : ( 8 words$word) M) (\ (w__4 : 8
          bits) . 
        let data = w__4 in
        if signed then sail2_state_monad$bindS
          (SignExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__5 :
             'regsize words$word) . 
          aset_X t w__5)
        else sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__6 :
             'regsize words$word) . 
          aset_X t w__6))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 : int):ii)  :  5 itself)) t (( 0 : int):ii)  :  5 words$word))
     )
     (if wback then sail2_state_monad$bindS
       (if wb_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
        else
          let (address : 64 bits) =
            (if postindex then (add_vec address offset  :  64 words$word)
            else address) in
          sail2_state_monad$returnS address) (\ (address : 64 bits) . 
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address)
     else sail2_state_monad$returnS () )))))))))
   else if (((l__20 = (( 16 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let wback = wback__arg in sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M) (\ (data : 16 bits) . 
     let (wb_unknown : bool) = F in
     let (rt_unknown : bool) = F in sail2_state_monad$bindS
     (undefined_Constraint () ) (\ (c : Constraint) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_LOAD))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_WBSUPPRESS in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \/ (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) "((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS wback) (\ (wback : bool) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_STORE))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_NONE in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS
        (if (((memop <> MemOp_PREFETCH))) then CheckSPAlignment () 
         else sail2_state_monad$returnS () )
        (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M)
         else (aget_X (( 16 : int):ii) t  : ( 16 words$word) M)) (\ (data : 16 bits) . 
        aset_Mem address (((( 16 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 16 : int):ii) / (( 8 : int):ii))) acctype  : ( 16 words$word) M) (\ (w__12 : 16
          bits) . 
        let data = w__12 in
        if signed then sail2_state_monad$bindS
          (SignExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__13 :
             'regsize words$word) . 
          aset_X t w__13)
        else sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__14 :
             'regsize words$word) . 
          aset_X t w__14))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 : int):ii)  :  5 itself)) t (( 0 : int):ii)  :  5 words$word))
     )
     (if wback then sail2_state_monad$bindS
       (if wb_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
        else
          let (address : 64 bits) =
            (if postindex then (add_vec address offset  :  64 words$word)
            else address) in
          sail2_state_monad$returnS address) (\ (address : 64 bits) . 
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address)
     else sail2_state_monad$returnS () )))))))))
   else if (((l__20 = (( 32 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let wback = wback__arg in sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (data : 32 bits) . 
     let (wb_unknown : bool) = F in
     let (rt_unknown : bool) = F in sail2_state_monad$bindS
     (undefined_Constraint () ) (\ (c : Constraint) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_LOAD))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_WBSUPPRESS in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \/ (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) "((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS wback) (\ (wback : bool) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_STORE))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_NONE in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS
        (if (((memop <> MemOp_PREFETCH))) then CheckSPAlignment () 
         else sail2_state_monad$returnS () )
        (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)
         else (aget_X (( 32 : int):ii) t  : ( 32 words$word) M)) (\ (data : 32 bits) . 
        aset_Mem address (((( 32 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 32 : int):ii) / (( 8 : int):ii))) acctype  : ( 32 words$word) M) (\ (w__20 : 32
          bits) . 
        let data = w__20 in
        if signed then sail2_state_monad$bindS
          (SignExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__21 :
             'regsize words$word) . 
          aset_X t w__21)
        else sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__22 :
             'regsize words$word) . 
          aset_X t w__22))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 : int):ii)  :  5 itself)) t (( 0 : int):ii)  :  5 words$word))
     )
     (if wback then sail2_state_monad$bindS
       (if wb_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
        else
          let (address : 64 bits) =
            (if postindex then (add_vec address offset  :  64 words$word)
            else address) in
          sail2_state_monad$returnS address) (\ (address : 64 bits) . 
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address)
     else sail2_state_monad$returnS () )))))))))
   else if (((l__20 = (( 64 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let wback = wback__arg in sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (data : 64 bits) . 
     let (wb_unknown : bool) = F in
     let (rt_unknown : bool) = F in sail2_state_monad$bindS
     (undefined_Constraint () ) (\ (c : Constraint) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_LOAD))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_WBSUPPRESS in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \/ (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) "((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS wback) (\ (wback : bool) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_STORE))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_NONE in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS
        (if (((memop <> MemOp_PREFETCH))) then CheckSPAlignment () 
         else sail2_state_monad$returnS () )
        (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
         else (aget_X (( 64 : int):ii) t  : ( 64 words$word) M)) (\ (data : 64 bits) . 
        aset_Mem address (((( 64 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 64 : int):ii) / (( 8 : int):ii))) acctype  : ( 64 words$word) M) (\ (w__28 : 64
          bits) . 
        let data = w__28 in
        if signed then sail2_state_monad$bindS
          (SignExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__29 :
             'regsize words$word) . 
          aset_X t w__29)
        else sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__30 :
             'regsize words$word) . 
          aset_X t w__30))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 : int):ii)  :  5 itself)) t (( 0 : int):ii)  :  5 words$word))
     )
     (if wback then sail2_state_monad$bindS
       (if wb_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
        else
          let (address : 64 bits) =
            (if postindex then (add_vec address offset  :  64 words$word)
            else address) in
          sail2_state_monad$returnS address) (\ (address : 64 bits) . 
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address)
     else sail2_state_monad$returnS () )))))))))
   else if (((l__20 = (( 128 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (let wback = wback__arg in sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M) (\ (data : 128 bits) . 
     let (wb_unknown : bool) = F in
     let (rt_unknown : bool) = F in sail2_state_monad$bindS
     (undefined_Constraint () ) (\ (c : Constraint) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_LOAD))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_WBSUPPRESS in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \/ ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \/ (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) "((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS wback) (\ (wback : bool) .  sail2_state_monad$bindS
     (if ((((((((((((memop = MemOp_STORE))) /\ wback))) /\ (((n = t)))))) /\ (((n <> (( 31 : int):ii))))))) then
        let c = Constraint_NONE in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
        (sail2_state_monad$returnS F)
      else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS
        (if (((memop <> MemOp_PREFETCH))) then CheckSPAlignment () 
         else sail2_state_monad$returnS () )
        (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
     let (address : 64 bits) =
       (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
       else address) in sail2_state_monad$seqS
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M)
         else (aget_X (( 128 : int):ii) t  : ( 128 words$word) M)) (\ (data : 128 bits) . 
        aset_Mem address (((( 128 : int):ii) / (( 8 : int):ii))) acctype data)
     | MemOp_LOAD => sail2_state_monad$bindS
        (aget_Mem address (((( 128 : int):ii) / (( 8 : int):ii))) acctype  : ( 128 words$word) M) (\ (w__36 : 128
          bits) . 
        let data = w__36 in
        if signed then sail2_state_monad$bindS
          (SignExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__37 :
             'regsize words$word) . 
          aset_X t w__37)
        else sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__38 :
             'regsize words$word) . 
          aset_X t w__38))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 : int):ii)  :  5 itself)) t (( 0 : int):ii)  :  5 words$word))
     )
     (if wback then sail2_state_monad$bindS
       (if wb_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
        else
          let (address : 64 bits) =
            (if postindex then (add_vec address offset  :  64 words$word)
            else address) in
          sail2_state_monad$returnS address) (\ (address : 64 bits) . 
       if (((n = (( 31 : int):ii)))) then aset_SP address
       else aset_X n address)
     else sail2_state_monad$returnS () )))))))))
   else
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int ((l__20 / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint")))`;


(*val aarch64_memory_pair_simdfp_postidx : forall 'datasize. Size 'datasize => AccType -> itself 'datasize -> MemOp -> ii -> mword ty64 -> bool -> ii -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_memory_pair_simdfp_postidx:AccType -> 'datasize itself -> MemOp -> int ->(64)words$word -> bool -> int -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) acctype datasize memop n offset postindex t t2 wback=
    (let datasize = (size_itself_int datasize) in
   let dbytes = (ex_int ((datasize / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS T "datasize constraint")
   (sail2_state_monad$assert_expS T "dbytes constraint"))
   (CheckFPAdvSIMDEnabled64 () ))
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
   (undefined_bitvector datasize  : ( 'datasize words$word) M) (\ (data1 : 'datasize bits) .  sail2_state_monad$bindS
   (undefined_bitvector ((int_of_num (words$word_len data1)))  : ( 'datasize words$word) M) (\ (data2 : 'datasize bits) . 
   let (rt_unknown : bool) = F in sail2_state_monad$bindS
   (if ((((((memop = MemOp_LOAD))) /\ (((t = t2)))))) then
      let (c : Constraint) = (ConstrainUnpredictable Unpredictable_LDPOVERLAP) in sail2_state_monad$seqS
      (sail2_state_monad$assert_expS ((((((c = Constraint_UNKNOWN))) \/ ((((((c = Constraint_UNDEF))) \/ (((c = Constraint_NOP))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP)))")
      (case c of
        Constraint_UNKNOWN => sail2_state_monad$returnS T
      | Constraint_UNDEF => sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS rt_unknown)
      | Constraint_NOP => sail2_state_monad$seqS (EndOfInstruction () ) (sail2_state_monad$returnS rt_unknown)
      )
    else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
   (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
    else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
   let (address : 64 bits) =
     (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
     else address) in sail2_state_monad$seqS
   (case memop of
     MemOp_STORE => sail2_state_monad$bindS
      (aget_V ((int_of_num (words$word_len data1))) t  : ( 'datasize words$word) M) (\ (w__2 : 'datasize bits) . 
      let data1 = w__2 in sail2_state_monad$bindS
      (aget_V ((int_of_num (words$word_len data1))) t2  : ( 'datasize words$word) M) (\ (w__3 : 'datasize bits) . 
      let data2 = w__3 in sail2_state_monad$seqS
      (aset_Mem ((add_vec_int address (( 0 : int):ii)  :  64 words$word)) dbytes acctype data1)
      (aset_Mem ((add_vec_int address dbytes  :  64 words$word)) dbytes acctype data2)))
   | MemOp_LOAD => sail2_state_monad$bindS
      (aget_Mem ((add_vec_int address (( 0 : int):ii)  :  64 words$word)) dbytes acctype  : ( 'datasize words$word) M) (\ (w__4 : 'datasize
        bits) . 
      let data1 = w__4 in sail2_state_monad$bindS
      (aget_Mem ((add_vec_int address dbytes  :  64 words$word)) dbytes acctype  : ( 'datasize words$word) M) (\ (w__5 : 'datasize
        bits) . 
      let data2 = w__5 in sail2_state_monad$bindS
      (if rt_unknown then sail2_state_monad$bindS
         (undefined_bitvector ((int_of_num (words$word_len data1)))  : ( 'datasize words$word) M) (\ (w__6 : 'datasize
           bits) . 
         let data1 = w__6 in sail2_state_monad$bindS
         (undefined_bitvector ((int_of_num (words$word_len data1)))  : ( 'datasize words$word) M) (\ (w__7 : 'datasize
           bits) . 
         let (data2 : 'datasize bits) = w__7 in
         sail2_state_monad$returnS (data1, data2)))
       else sail2_state_monad$returnS (data1, data2)) (\ varstup .  let ((data1 : 'datasize bits), (data2 : 'datasize
        bits)) = varstup in sail2_state_monad$seqS
      (aset_V t data1) (aset_V t2 data2))))
   )
   (if wback then
     let (address : 64 bits) =
       (if postindex then (add_vec address offset  :  64 words$word)
       else address) in
     if (((n = (( 31 : int):ii)))) then aset_SP address
     else aset_X n address
   else sail2_state_monad$returnS () ))))))))`;


(*val aarch64_memory_pair_simdfp_noalloc : forall 'datasize. Size 'datasize => AccType -> itself 'datasize -> MemOp -> ii -> mword ty64 -> bool -> ii -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_memory_pair_simdfp_noalloc:AccType -> 'datasize itself -> MemOp -> int ->(64)words$word -> bool -> int -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) acctype datasize memop n offset postindex t t2 wback=
    (let datasize = (size_itself_int datasize) in
   let dbytes = (ex_int ((datasize / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS T "datasize constraint")
   (sail2_state_monad$assert_expS T "dbytes constraint"))
   (CheckFPAdvSIMDEnabled64 () ))
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
   (undefined_bitvector datasize  : ( 'datasize words$word) M) (\ (data1 : 'datasize bits) .  sail2_state_monad$bindS
   (undefined_bitvector ((int_of_num (words$word_len data1)))  : ( 'datasize words$word) M) (\ (data2 : 'datasize bits) . 
   let (rt_unknown : bool) = F in sail2_state_monad$bindS
   (if ((((((memop = MemOp_LOAD))) /\ (((t = t2)))))) then
      let (c : Constraint) = (ConstrainUnpredictable Unpredictable_LDPOVERLAP) in sail2_state_monad$seqS
      (sail2_state_monad$assert_expS ((((((c = Constraint_UNKNOWN))) \/ ((((((c = Constraint_UNDEF))) \/ (((c = Constraint_NOP))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP)))")
      (case c of
        Constraint_UNKNOWN => sail2_state_monad$returnS T
      | Constraint_UNDEF => sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS rt_unknown)
      | Constraint_NOP => sail2_state_monad$seqS (EndOfInstruction () ) (sail2_state_monad$returnS rt_unknown)
      )
    else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
   (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
    else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
   let (address : 64 bits) =
     (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
     else address) in sail2_state_monad$seqS
   (case memop of
     MemOp_STORE => sail2_state_monad$bindS
      (aget_V ((int_of_num (words$word_len data1))) t  : ( 'datasize words$word) M) (\ (w__2 : 'datasize bits) . 
      let data1 = w__2 in sail2_state_monad$bindS
      (aget_V ((int_of_num (words$word_len data1))) t2  : ( 'datasize words$word) M) (\ (w__3 : 'datasize bits) . 
      let data2 = w__3 in sail2_state_monad$seqS
      (aset_Mem ((add_vec_int address (( 0 : int):ii)  :  64 words$word)) dbytes acctype data1)
      (aset_Mem ((add_vec_int address dbytes  :  64 words$word)) dbytes acctype data2)))
   | MemOp_LOAD => sail2_state_monad$bindS
      (aget_Mem ((add_vec_int address (( 0 : int):ii)  :  64 words$word)) dbytes acctype  : ( 'datasize words$word) M) (\ (w__4 : 'datasize
        bits) . 
      let data1 = w__4 in sail2_state_monad$bindS
      (aget_Mem ((add_vec_int address dbytes  :  64 words$word)) dbytes acctype  : ( 'datasize words$word) M) (\ (w__5 : 'datasize
        bits) . 
      let data2 = w__5 in sail2_state_monad$bindS
      (if rt_unknown then sail2_state_monad$bindS
         (undefined_bitvector ((int_of_num (words$word_len data1)))  : ( 'datasize words$word) M) (\ (w__6 : 'datasize
           bits) . 
         let data1 = w__6 in sail2_state_monad$bindS
         (undefined_bitvector ((int_of_num (words$word_len data1)))  : ( 'datasize words$word) M) (\ (w__7 : 'datasize
           bits) . 
         let (data2 : 'datasize bits) = w__7 in
         sail2_state_monad$returnS (data1, data2)))
       else sail2_state_monad$returnS (data1, data2)) (\ varstup .  let ((data1 : 'datasize bits), (data2 : 'datasize
        bits)) = varstup in sail2_state_monad$seqS
      (aset_V t data1) (aset_V t2 data2))))
   )
   (if wback then
     let (address : 64 bits) =
       (if postindex then (add_vec address offset  :  64 words$word)
       else address) in
     if (((n = (( 31 : int):ii)))) then aset_SP address
     else aset_X n address
   else sail2_state_monad$returnS () ))))))))`;


(*val aarch64_memory_pair_general_postidx : forall 'datasize. Size 'datasize => AccType -> itself 'datasize -> MemOp -> ii -> mword ty64 -> bool -> bool -> ii -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_memory_pair_general_postidx:AccType -> 'datasize itself -> MemOp -> int ->(64)words$word -> bool -> bool -> int -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) acctype datasize memop n offset postindex signed t t2 wback__arg=
    (let datasize = (size_itself_int datasize) in
   let dbytes = (ex_int ((datasize / (( 8 : int):ii)))) in sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS T "datasize constraint")
   (sail2_state_monad$assert_expS T "dbytes constraint"))
   (let wback = wback__arg in sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (address : 64 bits) .  sail2_state_monad$bindS
   (undefined_bitvector datasize  : ( 'datasize words$word) M) (\ (data1 : 'datasize bits) .  sail2_state_monad$bindS
   (undefined_bitvector ((int_of_num (words$word_len data1)))  : ( 'datasize words$word) M) (\ (data2 : 'datasize bits) . 
   let (rt_unknown : bool) = F in
   let (wb_unknown : bool) = F in sail2_state_monad$bindS
   (if ((((((((((((memop = MemOp_LOAD))) /\ wback))) /\ ((((((t = n))) \/ (((t2 = n))))))))) /\ (((n <> (( 31 : int):ii))))))) then
      let (c : Constraint) = (ConstrainUnpredictable Unpredictable_WBOVERLAPLD) in sail2_state_monad$seqS
      (sail2_state_monad$assert_expS ((((((c = Constraint_WBSUPPRESS))) \/ ((((((c = Constraint_UNKNOWN))) \/ ((((((c = Constraint_UNDEF))) \/ (((c = Constraint_NOP)))))))))))) "((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
      (case c of
        Constraint_WBSUPPRESS =>
         let (wback : bool) = F in
         sail2_state_monad$returnS (wb_unknown, wback)
      | Constraint_UNKNOWN =>
         let (wb_unknown : bool) = T in
         sail2_state_monad$returnS (wb_unknown, wback)
      | Constraint_UNDEF => sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS (wb_unknown, wback))
      | Constraint_NOP => sail2_state_monad$seqS (EndOfInstruction () ) (sail2_state_monad$returnS (wb_unknown, wback))
      )
    else sail2_state_monad$returnS (wb_unknown, wback)) (\ varstup .  let ((wb_unknown : bool), (wback : bool)) = varstup in sail2_state_monad$bindS
   (if ((((((((((((memop = MemOp_STORE))) /\ wback))) /\ ((((((t = n))) \/ (((t2 = n))))))))) /\ (((n <> (( 31 : int):ii))))))) then
      let (c : Constraint) = (ConstrainUnpredictable Unpredictable_WBOVERLAPST) in sail2_state_monad$seqS
      (sail2_state_monad$assert_expS ((((((c = Constraint_NONE))) \/ ((((((c = Constraint_UNKNOWN))) \/ ((((((c = Constraint_UNDEF))) \/ (((c = Constraint_NOP)))))))))))) "((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
      (case c of
        Constraint_NONE => sail2_state_monad$returnS F
      | Constraint_UNKNOWN => sail2_state_monad$returnS T
      | Constraint_UNDEF => sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS rt_unknown)
      | Constraint_NOP => sail2_state_monad$seqS (EndOfInstruction () ) (sail2_state_monad$returnS rt_unknown)
      )
    else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
   (if ((((((memop = MemOp_LOAD))) /\ (((t = t2)))))) then
      let (c : Constraint) = (ConstrainUnpredictable Unpredictable_LDPOVERLAP) in sail2_state_monad$seqS
      (sail2_state_monad$assert_expS ((((((c = Constraint_UNKNOWN))) \/ ((((((c = Constraint_UNDEF))) \/ (((c = Constraint_NOP))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP)))")
      (case c of
        Constraint_UNKNOWN => sail2_state_monad$returnS T
      | Constraint_UNDEF => sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS rt_unknown)
      | Constraint_NOP => sail2_state_monad$seqS (EndOfInstruction () ) (sail2_state_monad$returnS rt_unknown)
      )
    else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
   (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
    else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
   let (address : 64 bits) =
     (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
     else address) in sail2_state_monad$seqS
   (case memop of
     MemOp_STORE => sail2_state_monad$bindS
      (if (((rt_unknown /\ (((t = n)))))) then
         (undefined_bitvector ((int_of_num (words$word_len data1)))  : ( 'datasize words$word) M)
       else (aget_X ((int_of_num (words$word_len data1))) t  : ( 'datasize words$word) M)) (\ (data1 : 'datasize bits) .  sail2_state_monad$bindS
      (if (((rt_unknown /\ (((t2 = n)))))) then
         (undefined_bitvector ((int_of_num (words$word_len data1)))  : ( 'datasize words$word) M)
       else (aget_X ((int_of_num (words$word_len data1))) t2  : ( 'datasize words$word) M)) (\ (data2 : 'datasize bits) .  sail2_state_monad$seqS
      (aset_Mem ((add_vec_int address (( 0 : int):ii)  :  64 words$word)) dbytes acctype data1)
      (aset_Mem ((add_vec_int address dbytes  :  64 words$word)) dbytes acctype data2)))
   | MemOp_LOAD => sail2_state_monad$bindS
      (aget_Mem ((add_vec_int address (( 0 : int):ii)  :  64 words$word)) dbytes acctype  : ( 'datasize words$word) M) (\ (w__6 : 'datasize
        bits) . 
      let data1 = w__6 in sail2_state_monad$bindS
      (aget_Mem ((add_vec_int address dbytes  :  64 words$word)) dbytes acctype  : ( 'datasize words$word) M) (\ (w__7 : 'datasize
        bits) . 
      let data2 = w__7 in sail2_state_monad$bindS
      (if rt_unknown then sail2_state_monad$bindS
         (undefined_bitvector ((int_of_num (words$word_len data1)))  : ( 'datasize words$word) M) (\ (w__8 : 'datasize
           bits) . 
         let data1 = w__8 in sail2_state_monad$bindS
         (undefined_bitvector ((int_of_num (words$word_len data1)))  : ( 'datasize words$word) M) (\ (w__9 : 'datasize
           bits) . 
         let (data2 : 'datasize bits) = w__9 in
         sail2_state_monad$returnS (data1, data2)))
       else sail2_state_monad$returnS (data1, data2)) (\ varstup .  let ((data1 : 'datasize bits), (data2 : 'datasize
        bits)) = varstup in
      if signed then sail2_state_monad$bindS
        (SignExtend__0 data1 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__10 :
           64 words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
        (aset_X t w__10)
        (SignExtend__0 data2 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M)) (\ (w__11 :
           64 words$word) . 
        aset_X t2 w__11))
      else sail2_state_monad$seqS (aset_X t data1) (aset_X t2 data2))))
   )
   (if wback then sail2_state_monad$bindS
     (if wb_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
      else
        let (address : 64 bits) =
          (if postindex then (add_vec address offset  :  64 words$word)
          else address) in
        sail2_state_monad$returnS address) (\ (address : 64 bits) . 
     if (((n = (( 31 : int):ii)))) then aset_SP address
     else aset_X n address)
   else sail2_state_monad$returnS () )))))))))))`;


(*val aarch64_memory_pair_general_noalloc : forall 'datasize. Size 'datasize => AccType -> itself 'datasize -> MemOp -> ii -> mword ty64 -> bool -> ii -> ii -> bool -> M unit*)

val _ = Define `
 ((aarch64_memory_pair_general_noalloc:AccType -> 'datasize itself -> MemOp -> int ->(64)words$word -> bool -> int -> int -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) acctype datasize memop n offset postindex t t2 wback=
    (let datasize = (size_itself_int datasize) in
   let dbytes = (ex_int ((datasize / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS T "datasize constraint")
   (sail2_state_monad$assert_expS T "dbytes constraint"))
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
   (undefined_bitvector datasize  : ( 'datasize words$word) M) (\ (data1 : 'datasize bits) .  sail2_state_monad$bindS
   (undefined_bitvector ((int_of_num (words$word_len data1)))  : ( 'datasize words$word) M) (\ (data2 : 'datasize bits) . 
   let (rt_unknown : bool) = F in sail2_state_monad$bindS
   (if ((((((memop = MemOp_LOAD))) /\ (((t = t2)))))) then
      let (c : Constraint) = (ConstrainUnpredictable Unpredictable_LDPOVERLAP) in sail2_state_monad$seqS
      (sail2_state_monad$assert_expS ((((((c = Constraint_UNKNOWN))) \/ ((((((c = Constraint_UNDEF))) \/ (((c = Constraint_NOP))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP)))")
      (case c of
        Constraint_UNKNOWN => sail2_state_monad$returnS T
      | Constraint_UNDEF => sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS rt_unknown)
      | Constraint_NOP => sail2_state_monad$seqS (EndOfInstruction () ) (sail2_state_monad$returnS rt_unknown)
      )
    else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
   (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
    else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) . 
   let (address : 64 bits) =
     (if ((~ postindex)) then (add_vec address offset  :  64 words$word)
     else address) in sail2_state_monad$seqS
   (case memop of
     MemOp_STORE => sail2_state_monad$bindS
      (if (((rt_unknown /\ (((t = n)))))) then
         (undefined_bitvector ((int_of_num (words$word_len data1)))  : ( 'datasize words$word) M)
       else (aget_X ((int_of_num (words$word_len data1))) t  : ( 'datasize words$word) M)) (\ (data1 : 'datasize bits) .  sail2_state_monad$bindS
      (if (((rt_unknown /\ (((t2 = n)))))) then
         (undefined_bitvector ((int_of_num (words$word_len data1)))  : ( 'datasize words$word) M)
       else (aget_X ((int_of_num (words$word_len data1))) t2  : ( 'datasize words$word) M)) (\ (data2 : 'datasize bits) .  sail2_state_monad$seqS
      (aset_Mem ((add_vec_int address (( 0 : int):ii)  :  64 words$word)) dbytes acctype data1)
      (aset_Mem ((add_vec_int address dbytes  :  64 words$word)) dbytes acctype data2)))
   | MemOp_LOAD => sail2_state_monad$bindS
      (aget_Mem ((add_vec_int address (( 0 : int):ii)  :  64 words$word)) dbytes acctype  : ( 'datasize words$word) M) (\ (w__6 : 'datasize
        bits) . 
      let data1 = w__6 in sail2_state_monad$bindS
      (aget_Mem ((add_vec_int address dbytes  :  64 words$word)) dbytes acctype  : ( 'datasize words$word) M) (\ (w__7 : 'datasize
        bits) . 
      let data2 = w__7 in sail2_state_monad$bindS
      (if rt_unknown then sail2_state_monad$bindS
         (undefined_bitvector ((int_of_num (words$word_len data1)))  : ( 'datasize words$word) M) (\ (w__8 : 'datasize
           bits) . 
         let data1 = w__8 in sail2_state_monad$bindS
         (undefined_bitvector ((int_of_num (words$word_len data1)))  : ( 'datasize words$word) M) (\ (w__9 : 'datasize
           bits) . 
         let (data2 : 'datasize bits) = w__9 in
         sail2_state_monad$returnS (data1, data2)))
       else sail2_state_monad$returnS (data1, data2)) (\ varstup .  let ((data1 : 'datasize bits), (data2 : 'datasize
        bits)) = varstup in sail2_state_monad$seqS
      (aset_X t data1) (aset_X t2 data2))))
   )
   (if wback then
     let (address : 64 bits) =
       (if postindex then (add_vec address offset  :  64 words$word)
       else address) in
     if (((n = (( 31 : int):ii)))) then aset_SP address
     else aset_X n address
   else sail2_state_monad$returnS () ))))))))`;


(*val aarch64_memory_exclusive_single : forall 'datasize  'regsize. Size 'datasize, Size 'regsize => AccType -> itself 'datasize -> integer -> MemOp -> ii -> bool -> itself 'regsize -> ii -> ii -> ii -> M unit*)

val _ = Define `
 ((aarch64_memory_exclusive_single:AccType -> 'datasize itself -> int -> MemOp -> int -> bool -> 'regsize itself -> int -> int -> int ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) acctype p_1 elsize memop n pair regsize s t t2=
    (if (((((size_itself_int p_1)) = (( 8 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "destsize constraint")
     (let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M) (\ (data : 8 bits) . 
     let (rt_unknown : bool) = F in
     let (rn_unknown : bool) = F in sail2_state_monad$bindS (sail2_state_monad$seqS
     (if (((((((((memop = MemOp_LOAD))) /\ pair))) /\ (((t = t2)))))) then
        let (c : Constraint) = Constraint_UNDEF in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_UNDEF = Constraint_UNKNOWN))) \/ ((((((Constraint_UNDEF = Constraint_UNDEF))) \/ (((Constraint_UNDEF = Constraint_NOP))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP)))")
        (UnallocatedEncoding () )
      else sail2_state_monad$returnS () )
     (if (((memop = MemOp_STORE))) then sail2_state_monad$bindS
        (if ((((((s = t))) \/ (((pair /\ (((s = t2))))))))) then
           let (c : Constraint) = Constraint_NONE in sail2_state_monad$seqS
           (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
           (sail2_state_monad$returnS F)
         else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
        (if ((((((s = n))) /\ (((n <> (( 31 : int):ii))))))) then
           let (c : Constraint) = Constraint_NONE in sail2_state_monad$seqS
           (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
           (sail2_state_monad$returnS F)
         else sail2_state_monad$returnS rn_unknown) (\ (rn_unknown : bool) . 
        sail2_state_monad$returnS (rn_unknown, rt_unknown)))
      else sail2_state_monad$returnS (rn_unknown, rt_unknown))) (\ varstup .  let ((rn_unknown : bool), (rt_unknown :
       bool)) = varstup in sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else if rn_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (secondstage : bool) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (iswrite : bool) . 
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M)
         else if pair then
           let v = (ex_int (((( 8 : int):ii) / (( 2 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS
           (sail2_state_monad$assert_expS T "")
           (aget_X ((int_of_num (words$word_len DebugException_VectorCatch))) t  : ( 4 words$word) M)) (\ el1 .  sail2_state_monad$bindS
           (aget_X ((int_of_num (words$word_len DebugException_VectorCatch))) t2  : ( 4 words$word) M) (\ el2 .  sail2_state_monad$bindS
           (BigEndian () ) (\ (w__4 : bool) . 
           let (data : 8 bits) =
             (if w__4 then (concat_vec el1 el2  :  8 words$word)
             else (concat_vec el2 el1  :  8 words$word)) in
           sail2_state_monad$returnS data)))
         else (aget_X (( 8 : int):ii) t  : ( 8 words$word) M)) (\ (data : 8 bits) . 
        let (status : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in sail2_state_monad$bindS
        (AArch64_ExclusiveMonitorsPass address dbytes) (\ (w__6 : bool) .  sail2_state_monad$bindS
        (if w__6 then sail2_state_monad$seqS
           (aset_Mem address dbytes acctype data) (ExclusiveMonitorsStatus ()   : ( 1 words$word) M)
         else sail2_state_monad$returnS status) (\ (status : 1 bits) .  sail2_state_monad$bindS
        (ZeroExtend__0 status ((make_the_value (( 32 : int):ii)  :  32 itself))  : ( 32 words$word) M) (\ (w__8 :
           32 words$word) . 
        aset_X s w__8))))
     | MemOp_LOAD => sail2_state_monad$seqS
        (AArch64_SetExclusiveMonitors address dbytes)
        (if pair then sail2_state_monad$seqS
          (sail2_state_monad$assert_expS T "")
          (if rt_unknown then sail2_state_monad$bindS
            (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (w__9 : 32 bits) . 
            aset_X t w__9)
          else sail2_state_monad$bindS (sail2_state_monad$seqS
            (if (((address <> ((Align__1 address dbytes  :  64 words$word))))) then
               let iswrite = F in
               let secondstage = F in sail2_state_monad$bindS
               (AArch64_AlignmentFault acctype F F) (\ (w__10 : FaultRecord) . 
               AArch64_Abort address w__10)
             else sail2_state_monad$returnS () )
            (aget_Mem ((add_vec_int address (( 0 : int):ii)  :  64 words$word)) (( 8 : int):ii) acctype  : ( 64 words$word) M)) (\ (w__11 :
               64 words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
            (aset_X t w__11)
            (aget_Mem ((add_vec_int address (( 8 : int):ii)  :  64 words$word)) (( 8 : int):ii) acctype  : ( 64 words$word) M)) (\ (w__12 :
               64 words$word) . 
            aset_X t2 w__12)))
        else sail2_state_monad$bindS
          (aget_Mem address dbytes acctype  : ( 8 words$word) M) (\ (w__13 : 8 bits) . 
          let data = w__13 in sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__14 :
             'regsize words$word) . 
          aset_X t w__14)))
     ))))))))
   else if (((((size_itself_int p_1)) = (( 16 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "destsize constraint")
     (let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M) (\ (data : 16 bits) . 
     let (rt_unknown : bool) = F in
     let (rn_unknown : bool) = F in sail2_state_monad$bindS (sail2_state_monad$seqS
     (if (((((((((memop = MemOp_LOAD))) /\ pair))) /\ (((t = t2)))))) then
        let (c : Constraint) = Constraint_UNDEF in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_UNDEF = Constraint_UNKNOWN))) \/ ((((((Constraint_UNDEF = Constraint_UNDEF))) \/ (((Constraint_UNDEF = Constraint_NOP))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP)))")
        (UnallocatedEncoding () )
      else sail2_state_monad$returnS () )
     (if (((memop = MemOp_STORE))) then sail2_state_monad$bindS
        (if ((((((s = t))) \/ (((pair /\ (((s = t2))))))))) then
           let (c : Constraint) = Constraint_NONE in sail2_state_monad$seqS
           (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
           (sail2_state_monad$returnS F)
         else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
        (if ((((((s = n))) /\ (((n <> (( 31 : int):ii))))))) then
           let (c : Constraint) = Constraint_NONE in sail2_state_monad$seqS
           (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
           (sail2_state_monad$returnS F)
         else sail2_state_monad$returnS rn_unknown) (\ (rn_unknown : bool) . 
        sail2_state_monad$returnS (rn_unknown, rt_unknown)))
      else sail2_state_monad$returnS (rn_unknown, rt_unknown))) (\ varstup .  let ((rn_unknown : bool), (rt_unknown :
       bool)) = varstup in sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else if rn_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (secondstage : bool) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (iswrite : bool) . 
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M)
         else if pair then
           let v = (ex_int (((( 16 : int):ii) / (( 2 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS
           (sail2_state_monad$assert_expS T "")
           (aget_X v t  : ( 8 words$word) M)) (\ el1 .  sail2_state_monad$bindS
           (aget_X ((int_of_num (words$word_len el1))) t2  : ( 8 words$word) M) (\ el2 .  sail2_state_monad$bindS
           (BigEndian () ) (\ (w__19 : bool) . 
           let (data : 16 bits) =
             (if w__19 then (concat_vec el1 el2  :  16 words$word)
             else (concat_vec el2 el1  :  16 words$word)) in
           sail2_state_monad$returnS data)))
         else (aget_X (( 16 : int):ii) t  : ( 16 words$word) M)) (\ (data : 16 bits) . 
        let (status : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in sail2_state_monad$bindS
        (AArch64_ExclusiveMonitorsPass address dbytes) (\ (w__21 : bool) .  sail2_state_monad$bindS
        (if w__21 then sail2_state_monad$seqS
           (aset_Mem address dbytes acctype data) (ExclusiveMonitorsStatus ()   : ( 1 words$word) M)
         else sail2_state_monad$returnS status) (\ (status : 1 bits) .  sail2_state_monad$bindS
        (ZeroExtend__0 status ((make_the_value (( 32 : int):ii)  :  32 itself))  : ( 32 words$word) M) (\ (w__23 :
           32 words$word) . 
        aset_X s w__23))))
     | MemOp_LOAD => sail2_state_monad$seqS
        (AArch64_SetExclusiveMonitors address dbytes)
        (if pair then sail2_state_monad$seqS
          (sail2_state_monad$assert_expS T "")
          (if rt_unknown then sail2_state_monad$bindS
            (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (w__24 : 32 bits) . 
            aset_X t w__24)
          else sail2_state_monad$bindS (sail2_state_monad$seqS
            (if (((address <> ((Align__1 address dbytes  :  64 words$word))))) then
               let iswrite = F in
               let secondstage = F in sail2_state_monad$bindS
               (AArch64_AlignmentFault acctype F F) (\ (w__25 : FaultRecord) . 
               AArch64_Abort address w__25)
             else sail2_state_monad$returnS () )
            (aget_Mem ((add_vec_int address (( 0 : int):ii)  :  64 words$word)) (( 8 : int):ii) acctype  : ( 64 words$word) M)) (\ (w__26 :
               64 words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
            (aset_X t w__26)
            (aget_Mem ((add_vec_int address (( 8 : int):ii)  :  64 words$word)) (( 8 : int):ii) acctype  : ( 64 words$word) M)) (\ (w__27 :
               64 words$word) . 
            aset_X t2 w__27)))
        else sail2_state_monad$bindS
          (aget_Mem address dbytes acctype  : ( 16 words$word) M) (\ (w__28 : 16 bits) . 
          let data = w__28 in sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__29 :
             'regsize words$word) . 
          aset_X t w__29)))
     ))))))))
   else if (((((size_itself_int p_1)) = (( 32 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "destsize constraint")
     (let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (data : 32 bits) . 
     let (rt_unknown : bool) = F in
     let (rn_unknown : bool) = F in sail2_state_monad$bindS (sail2_state_monad$seqS
     (if (((((((((memop = MemOp_LOAD))) /\ pair))) /\ (((t = t2)))))) then
        let (c : Constraint) = Constraint_UNDEF in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_UNDEF = Constraint_UNKNOWN))) \/ ((((((Constraint_UNDEF = Constraint_UNDEF))) \/ (((Constraint_UNDEF = Constraint_NOP))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP)))")
        (UnallocatedEncoding () )
      else sail2_state_monad$returnS () )
     (if (((memop = MemOp_STORE))) then sail2_state_monad$bindS
        (if ((((((s = t))) \/ (((pair /\ (((s = t2))))))))) then
           let (c : Constraint) = Constraint_NONE in sail2_state_monad$seqS
           (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
           (sail2_state_monad$returnS F)
         else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
        (if ((((((s = n))) /\ (((n <> (( 31 : int):ii))))))) then
           let (c : Constraint) = Constraint_NONE in sail2_state_monad$seqS
           (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
           (sail2_state_monad$returnS F)
         else sail2_state_monad$returnS rn_unknown) (\ (rn_unknown : bool) . 
        sail2_state_monad$returnS (rn_unknown, rt_unknown)))
      else sail2_state_monad$returnS (rn_unknown, rt_unknown))) (\ varstup .  let ((rn_unknown : bool), (rt_unknown :
       bool)) = varstup in sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else if rn_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (secondstage : bool) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (iswrite : bool) . 
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)
         else if pair then
           let v = (ex_int (((( 32 : int):ii) / (( 2 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS
           (sail2_state_monad$assert_expS T "")
           (aget_X v t  : ( 16 words$word) M)) (\ el1 .  sail2_state_monad$bindS
           (aget_X ((int_of_num (words$word_len el1))) t2  : ( 16 words$word) M) (\ el2 .  sail2_state_monad$bindS
           (BigEndian () ) (\ (w__34 : bool) . 
           let (data : 32 bits) =
             (if w__34 then (concat_vec el1 el2  :  32 words$word)
             else (concat_vec el2 el1  :  32 words$word)) in
           sail2_state_monad$returnS data)))
         else (aget_X (( 32 : int):ii) t  : ( 32 words$word) M)) (\ (data : 32 bits) . 
        let (status : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in sail2_state_monad$bindS
        (AArch64_ExclusiveMonitorsPass address dbytes) (\ (w__36 : bool) .  sail2_state_monad$bindS
        (if w__36 then sail2_state_monad$seqS
           (aset_Mem address dbytes acctype data) (ExclusiveMonitorsStatus ()   : ( 1 words$word) M)
         else sail2_state_monad$returnS status) (\ (status : 1 bits) .  sail2_state_monad$bindS
        (ZeroExtend__0 status ((make_the_value (( 32 : int):ii)  :  32 itself))  : ( 32 words$word) M) (\ (w__38 :
           32 words$word) . 
        aset_X s w__38))))
     | MemOp_LOAD => sail2_state_monad$seqS
        (AArch64_SetExclusiveMonitors address dbytes)
        (if pair then sail2_state_monad$seqS
          (sail2_state_monad$assert_expS T "")
          (if rt_unknown then sail2_state_monad$bindS
            (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (w__39 : 32 bits) . 
            aset_X t w__39)
          else sail2_state_monad$bindS (sail2_state_monad$seqS
            (if (((address <> ((Align__1 address dbytes  :  64 words$word))))) then
               let iswrite = F in
               let secondstage = F in sail2_state_monad$bindS
               (AArch64_AlignmentFault acctype F F) (\ (w__40 : FaultRecord) . 
               AArch64_Abort address w__40)
             else sail2_state_monad$returnS () )
            (aget_Mem ((add_vec_int address (( 0 : int):ii)  :  64 words$word)) (( 8 : int):ii) acctype  : ( 64 words$word) M)) (\ (w__41 :
               64 words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
            (aset_X t w__41)
            (aget_Mem ((add_vec_int address (( 8 : int):ii)  :  64 words$word)) (( 8 : int):ii) acctype  : ( 64 words$word) M)) (\ (w__42 :
               64 words$word) . 
            aset_X t2 w__42)))
        else sail2_state_monad$bindS
          (aget_Mem address dbytes acctype  : ( 32 words$word) M) (\ (w__43 : 32 bits) . 
          let data = w__43 in sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__44 :
             'regsize words$word) . 
          aset_X t w__44)))
     ))))))))
   else if (((((size_itself_int p_1)) = (( 64 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "destsize constraint")
     (let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (data : 64 bits) . 
     let (rt_unknown : bool) = F in
     let (rn_unknown : bool) = F in sail2_state_monad$bindS (sail2_state_monad$seqS
     (if (((((((((memop = MemOp_LOAD))) /\ pair))) /\ (((t = t2)))))) then
        let (c : Constraint) = Constraint_UNDEF in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_UNDEF = Constraint_UNKNOWN))) \/ ((((((Constraint_UNDEF = Constraint_UNDEF))) \/ (((Constraint_UNDEF = Constraint_NOP))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP)))")
        (UnallocatedEncoding () )
      else sail2_state_monad$returnS () )
     (if (((memop = MemOp_STORE))) then sail2_state_monad$bindS
        (if ((((((s = t))) \/ (((pair /\ (((s = t2))))))))) then
           let (c : Constraint) = Constraint_NONE in sail2_state_monad$seqS
           (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
           (sail2_state_monad$returnS F)
         else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
        (if ((((((s = n))) /\ (((n <> (( 31 : int):ii))))))) then
           let (c : Constraint) = Constraint_NONE in sail2_state_monad$seqS
           (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
           (sail2_state_monad$returnS F)
         else sail2_state_monad$returnS rn_unknown) (\ (rn_unknown : bool) . 
        sail2_state_monad$returnS (rn_unknown, rt_unknown)))
      else sail2_state_monad$returnS (rn_unknown, rt_unknown))) (\ varstup .  let ((rn_unknown : bool), (rt_unknown :
       bool)) = varstup in sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else if rn_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (secondstage : bool) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (iswrite : bool) . 
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
         else if pair then
           let v = (ex_int (((( 64 : int):ii) / (( 2 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS
           (sail2_state_monad$assert_expS T "")
           (aget_X v t  : ( 32 words$word) M)) (\ el1 .  sail2_state_monad$bindS
           (aget_X ((int_of_num (words$word_len el1))) t2  : ( 32 words$word) M) (\ el2 .  sail2_state_monad$bindS
           (BigEndian () ) (\ (w__49 : bool) . 
           let (data : 64 bits) =
             (if w__49 then (concat_vec el1 el2  :  64 words$word)
             else (concat_vec el2 el1  :  64 words$word)) in
           sail2_state_monad$returnS data)))
         else (aget_X (( 64 : int):ii) t  : ( 64 words$word) M)) (\ (data : 64 bits) . 
        let (status : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in sail2_state_monad$bindS
        (AArch64_ExclusiveMonitorsPass address dbytes) (\ (w__51 : bool) .  sail2_state_monad$bindS
        (if w__51 then sail2_state_monad$seqS
           (aset_Mem address dbytes acctype data) (ExclusiveMonitorsStatus ()   : ( 1 words$word) M)
         else sail2_state_monad$returnS status) (\ (status : 1 bits) .  sail2_state_monad$bindS
        (ZeroExtend__0 status ((make_the_value (( 32 : int):ii)  :  32 itself))  : ( 32 words$word) M) (\ (w__53 :
           32 words$word) . 
        aset_X s w__53))))
     | MemOp_LOAD => sail2_state_monad$seqS
        (AArch64_SetExclusiveMonitors address dbytes)
        (if pair then sail2_state_monad$seqS
          (sail2_state_monad$assert_expS T "")
          (if rt_unknown then sail2_state_monad$bindS
            (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (w__54 : 32 bits) . 
            aset_X t w__54)
          else if (((elsize = (( 32 : int):ii)))) then sail2_state_monad$bindS
            (aget_Mem address dbytes acctype  : ( 64 words$word) M) (\ (w__55 : 64 bits) . 
            let data = w__55 in sail2_state_monad$bindS
            (BigEndian () ) (\ (w__56 : bool) . 
            if w__56 then sail2_state_monad$seqS
              (aset_X t
                ((slice data (( 32 : int):ii) ((((~ (( 32 : int):ii))) + (( 64 : int):ii)))  :  32 words$word)))
              (aset_X t2 ((slice data (( 0 : int):ii) (( 32 : int):ii)  :  32 words$word)))
            else sail2_state_monad$seqS
              (aset_X t ((slice data (( 0 : int):ii) (( 32 : int):ii)  :  32 words$word)))
              (aset_X t2
                ((slice data (( 32 : int):ii) ((((~ (( 32 : int):ii))) + (( 64 : int):ii)))  :  32 words$word)))))
          else sail2_state_monad$bindS (sail2_state_monad$seqS
            (if (((address <> ((Align__1 address dbytes  :  64 words$word))))) then
               let iswrite = F in
               let secondstage = F in sail2_state_monad$bindS
               (AArch64_AlignmentFault acctype F F) (\ (w__57 : FaultRecord) . 
               AArch64_Abort address w__57)
             else sail2_state_monad$returnS () )
            (aget_Mem ((add_vec_int address (( 0 : int):ii)  :  64 words$word)) (( 8 : int):ii) acctype  : ( 64 words$word) M)) (\ (w__58 :
               64 words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
            (aset_X t w__58)
            (aget_Mem ((add_vec_int address (( 8 : int):ii)  :  64 words$word)) (( 8 : int):ii) acctype  : ( 64 words$word) M)) (\ (w__59 :
               64 words$word) . 
            aset_X t2 w__59)))
        else sail2_state_monad$bindS
          (aget_Mem address dbytes acctype  : ( 64 words$word) M) (\ (w__60 : 64 bits) . 
          let data = w__60 in sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__61 :
             'regsize words$word) . 
          aset_X t w__61)))
     ))))))))
   else if (((((size_itself_int p_1)) = (( 128 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "destsize constraint")
     (let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M) (\ (data : 128 bits) . 
     let (rt_unknown : bool) = F in
     let (rn_unknown : bool) = F in sail2_state_monad$bindS (sail2_state_monad$seqS
     (if (((((((((memop = MemOp_LOAD))) /\ pair))) /\ (((t = t2)))))) then
        let (c : Constraint) = Constraint_UNDEF in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_UNDEF = Constraint_UNKNOWN))) \/ ((((((Constraint_UNDEF = Constraint_UNDEF))) \/ (((Constraint_UNDEF = Constraint_NOP))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP)))")
        (UnallocatedEncoding () )
      else sail2_state_monad$returnS () )
     (if (((memop = MemOp_STORE))) then sail2_state_monad$bindS
        (if ((((((s = t))) \/ (((pair /\ (((s = t2))))))))) then
           let (c : Constraint) = Constraint_NONE in sail2_state_monad$seqS
           (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
           (sail2_state_monad$returnS F)
         else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
        (if ((((((s = n))) /\ (((n <> (( 31 : int):ii))))))) then
           let (c : Constraint) = Constraint_NONE in sail2_state_monad$seqS
           (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
           (sail2_state_monad$returnS F)
         else sail2_state_monad$returnS rn_unknown) (\ (rn_unknown : bool) . 
        sail2_state_monad$returnS (rn_unknown, rt_unknown)))
      else sail2_state_monad$returnS (rn_unknown, rt_unknown))) (\ varstup .  let ((rn_unknown : bool), (rt_unknown :
       bool)) = varstup in sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else if rn_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (secondstage : bool) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (iswrite : bool) . 
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M)
         else if pair then
           let v = (ex_int (((( 128 : int):ii) / (( 2 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS
           (sail2_state_monad$assert_expS T "")
           (aget_X ((int_of_num (words$word_len address))) t  : ( 64 words$word) M)) (\ el1 .  sail2_state_monad$bindS
           (aget_X ((int_of_num (words$word_len address))) t2  : ( 64 words$word) M) (\ el2 .  sail2_state_monad$bindS
           (BigEndian () ) (\ (w__66 : bool) . 
           let (data : 128 bits) =
             (if w__66 then (concat_vec el1 el2  :  128 words$word)
             else (concat_vec el2 el1  :  128 words$word)) in
           sail2_state_monad$returnS data)))
         else (aget_X (( 128 : int):ii) t  : ( 128 words$word) M)) (\ (data : 128 bits) . 
        let (status : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in sail2_state_monad$bindS
        (AArch64_ExclusiveMonitorsPass address dbytes) (\ (w__68 : bool) .  sail2_state_monad$bindS
        (if w__68 then sail2_state_monad$seqS
           (aset_Mem address dbytes acctype data) (ExclusiveMonitorsStatus ()   : ( 1 words$word) M)
         else sail2_state_monad$returnS status) (\ (status : 1 bits) .  sail2_state_monad$bindS
        (ZeroExtend__0 status ((make_the_value (( 32 : int):ii)  :  32 itself))  : ( 32 words$word) M) (\ (w__70 :
           32 words$word) . 
        aset_X s w__70))))
     | MemOp_LOAD => sail2_state_monad$seqS
        (AArch64_SetExclusiveMonitors address dbytes)
        (if pair then sail2_state_monad$seqS
          (sail2_state_monad$assert_expS T "")
          (if rt_unknown then sail2_state_monad$bindS
            (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (w__71 : 32 bits) . 
            aset_X t w__71)
          else if (((elsize = (( 32 : int):ii)))) then sail2_state_monad$bindS
            (aget_Mem address dbytes acctype  : ( 128 words$word) M) (\ (w__72 : 128 bits) . 
            let data = w__72 in sail2_state_monad$bindS
            (BigEndian () ) (\ (w__73 : bool) . 
            if w__73 then sail2_state_monad$seqS
              (aset_X t
                ((slice data (( 32 : int):ii) ((((~ (( 32 : int):ii))) + (( 128 : int):ii)))  :  96 words$word)))
              (aset_X t2 ((slice data (( 0 : int):ii) (( 32 : int):ii)  :  32 words$word)))
            else sail2_state_monad$seqS
              (aset_X t ((slice data (( 0 : int):ii) (( 32 : int):ii)  :  32 words$word)))
              (aset_X t2
                ((slice data (( 32 : int):ii) ((((~ (( 32 : int):ii))) + (( 128 : int):ii)))  :  96 words$word)))))
          else sail2_state_monad$bindS (sail2_state_monad$seqS
            (if (((address <> ((Align__1 address dbytes  :  64 words$word))))) then
               let iswrite = F in
               let secondstage = F in sail2_state_monad$bindS
               (AArch64_AlignmentFault acctype F F) (\ (w__74 : FaultRecord) . 
               AArch64_Abort address w__74)
             else sail2_state_monad$returnS () )
            (aget_Mem ((add_vec_int address (( 0 : int):ii)  :  64 words$word)) (( 8 : int):ii) acctype  : ( 64 words$word) M)) (\ (w__75 :
               64 words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
            (aset_X t w__75)
            (aget_Mem ((add_vec_int address (( 8 : int):ii)  :  64 words$word)) (( 8 : int):ii) acctype  : ( 64 words$word) M)) (\ (w__76 :
               64 words$word) . 
            aset_X t2 w__76)))
        else sail2_state_monad$bindS
          (aget_Mem address dbytes acctype  : ( 128 words$word) M) (\ (w__77 : 128 bits) . 
          let data = w__77 in sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__78 :
             'regsize words$word) . 
          aset_X t w__78)))
     ))))))))
   else
     let regsize = (size_itself_int regsize) in
     let datasize = (size_itself_int p_1) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "destsize constraint")
     (let dbytes = (ex_int ((datasize / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint")))`;


(*val memory_exclusive_single_decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_exclusive_single_decode:(2)words$word ->(1)words$word ->(1)words$word ->(1)words$word ->(5)words$word ->(1)words$word ->(5)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 o2 L o1 Rs o0 Rt2 Rn Rt=
    (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (s : ii) = (lem$w2ui Rs) in
     let (acctype : AccType) =
       (if (((o0 = (vec_of_bits [B1]  :  1 words$word)))) then AccType_ORDERED
       else AccType_ATOMIC) in
     let (pair : bool) = F in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (elsize : ii) = ((( 8 : int):ii)) in
     let (regsize : ii) = ((( 32 : int):ii)) in
     let (datasize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_exclusive_single acctype ((make_the_value (( 8 : int):ii)  :  8 itself)) (( 8 : int):ii) memop n
       F ((make_the_value (( 32 : int):ii)  :  32 itself)) s t t2)
   else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (s : ii) = (lem$w2ui Rs) in
     let (acctype : AccType) =
       (if (((o0 = (vec_of_bits [B1]  :  1 words$word)))) then AccType_ORDERED
       else AccType_ATOMIC) in
     let (pair : bool) = F in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (elsize : ii) = ((( 16 : int):ii)) in
     let (regsize : ii) = ((( 32 : int):ii)) in
     let (datasize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_exclusive_single acctype ((make_the_value (( 16 : int):ii)  :  16 itself)) (( 16 : int):ii) memop
       n F ((make_the_value (( 32 : int):ii)  :  32 itself)) s t t2)
   else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (s : ii) = (lem$w2ui Rs) in
     let (acctype : AccType) =
       (if (((o0 = (vec_of_bits [B1]  :  1 words$word)))) then AccType_ORDERED
       else AccType_ATOMIC) in
     let (pair : bool) = F in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (elsize : ii) = ((( 32 : int):ii)) in
     let (regsize : ii) = ((( 32 : int):ii)) in
     let (datasize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_exclusive_single acctype ((make_the_value (( 32 : int):ii)  :  32 itself)) (( 32 : int):ii) memop
       n F ((make_the_value (( 32 : int):ii)  :  32 itself)) s t t2)
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (s : ii) = (lem$w2ui Rs) in
     let (acctype : AccType) =
       (if (((o0 = (vec_of_bits [B1]  :  1 words$word)))) then AccType_ORDERED
       else AccType_ATOMIC) in
     let (pair : bool) = F in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (elsize : ii) = ((( 64 : int):ii)) in
     let (regsize : ii) = ((( 64 : int):ii)) in
     let (datasize : ii) = ((( 64 : int):ii)) in
     aarch64_memory_exclusive_single acctype ((make_the_value (( 64 : int):ii)  :  64 itself)) (( 64 : int):ii) memop
       n F ((make_the_value (( 64 : int):ii)  :  64 itself)) s t t2)))`;


(*val aarch64_memory_exclusive_pair : forall 'datasize 'regsize . Size 'datasize, Size 'regsize => AccType -> itself 'datasize -> integer -> MemOp -> ii -> bool -> itself 'regsize -> ii -> ii -> ii -> M unit*)

val _ = Define `
 ((aarch64_memory_exclusive_pair:AccType -> 'datasize itself -> int -> MemOp -> int -> bool -> 'regsize itself -> int -> int -> int ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) acctype p_1 elsize memop n pair regsize s t t2=
    (if (((((size_itself_int p_1)) = (( 8 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 8 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M) (\ (data : 8 bits) . 
     let (rt_unknown : bool) = F in
     let (rn_unknown : bool) = F in sail2_state_monad$bindS (sail2_state_monad$seqS
     (if (((((((((memop = MemOp_LOAD))) /\ pair))) /\ (((t = t2)))))) then
        let (c : Constraint) = Constraint_UNDEF in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_UNDEF = Constraint_UNKNOWN))) \/ ((((((Constraint_UNDEF = Constraint_UNDEF))) \/ (((Constraint_UNDEF = Constraint_NOP))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP)))")
        (UnallocatedEncoding () )
      else sail2_state_monad$returnS () )
     (if (((memop = MemOp_STORE))) then sail2_state_monad$bindS
        (if ((((((s = t))) \/ (((pair /\ (((s = t2))))))))) then
           let (c : Constraint) = Constraint_NONE in sail2_state_monad$seqS
           (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
           (sail2_state_monad$returnS F)
         else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
        (if ((((((s = n))) /\ (((n <> (( 31 : int):ii))))))) then
           let (c : Constraint) = Constraint_NONE in sail2_state_monad$seqS
           (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
           (sail2_state_monad$returnS F)
         else sail2_state_monad$returnS rn_unknown) (\ (rn_unknown : bool) . 
        sail2_state_monad$returnS (rn_unknown, rt_unknown)))
      else sail2_state_monad$returnS (rn_unknown, rt_unknown))) (\ varstup .  let ((rn_unknown : bool), (rt_unknown :
       bool)) = varstup in sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else if rn_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (secondstage : bool) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (iswrite : bool) . 
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 8 : int):ii)  : ( 8 words$word) M)
         else if pair then
           let v = (ex_int (((( 8 : int):ii) / (( 2 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS
           (sail2_state_monad$assert_expS T "")
           (aget_X ((int_of_num (words$word_len DebugException_VectorCatch))) t  : ( 4 words$word) M)) (\ el1 .  sail2_state_monad$bindS
           (aget_X ((int_of_num (words$word_len DebugException_VectorCatch))) t2  : ( 4 words$word) M) (\ el2 .  sail2_state_monad$bindS
           (BigEndian () ) (\ (w__4 : bool) . 
           let (data : 8 bits) =
             (if w__4 then (concat_vec el1 el2  :  8 words$word)
             else (concat_vec el2 el1  :  8 words$word)) in
           sail2_state_monad$returnS data)))
         else (aget_X (( 8 : int):ii) t  : ( 8 words$word) M)) (\ (data : 8 bits) . 
        let (status : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in sail2_state_monad$bindS
        (AArch64_ExclusiveMonitorsPass address dbytes) (\ (w__6 : bool) .  sail2_state_monad$bindS
        (if w__6 then sail2_state_monad$seqS
           (aset_Mem address dbytes acctype data) (ExclusiveMonitorsStatus ()   : ( 1 words$word) M)
         else sail2_state_monad$returnS status) (\ (status : 1 bits) .  sail2_state_monad$bindS
        (ZeroExtend__0 status ((make_the_value (( 32 : int):ii)  :  32 itself))  : ( 32 words$word) M) (\ (w__8 :
           32 words$word) . 
        aset_X s w__8))))
     | MemOp_LOAD => sail2_state_monad$seqS
        (AArch64_SetExclusiveMonitors address dbytes)
        (if pair then sail2_state_monad$seqS
          (sail2_state_monad$assert_expS T "datasize constraint")
          (if rt_unknown then sail2_state_monad$bindS
            (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (w__9 : 32 bits) . 
            aset_X t w__9)
          else sail2_state_monad$bindS (sail2_state_monad$seqS
            (if (((address <> ((Align__1 address dbytes  :  64 words$word))))) then
               let iswrite = F in
               let secondstage = F in sail2_state_monad$bindS
               (AArch64_AlignmentFault acctype F F) (\ (w__10 : FaultRecord) . 
               AArch64_Abort address w__10)
             else sail2_state_monad$returnS () )
            (aget_Mem ((add_vec_int address (( 0 : int):ii)  :  64 words$word)) (( 8 : int):ii) acctype  : ( 64 words$word) M)) (\ (w__11 :
               64 words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
            (aset_X t w__11)
            (aget_Mem ((add_vec_int address (( 8 : int):ii)  :  64 words$word)) (( 8 : int):ii) acctype  : ( 64 words$word) M)) (\ (w__12 :
               64 words$word) . 
            aset_X t2 w__12)))
        else sail2_state_monad$bindS
          (aget_Mem address dbytes acctype  : ( 8 words$word) M) (\ (w__13 : 8 bits) . 
          let data = w__13 in sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__14 :
             'regsize words$word) . 
          aset_X t w__14)))
     ))))))))
   else if (((((size_itself_int p_1)) = (( 16 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 16 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M) (\ (data : 16 bits) . 
     let (rt_unknown : bool) = F in
     let (rn_unknown : bool) = F in sail2_state_monad$bindS (sail2_state_monad$seqS
     (if (((((((((memop = MemOp_LOAD))) /\ pair))) /\ (((t = t2)))))) then
        let (c : Constraint) = Constraint_UNDEF in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_UNDEF = Constraint_UNKNOWN))) \/ ((((((Constraint_UNDEF = Constraint_UNDEF))) \/ (((Constraint_UNDEF = Constraint_NOP))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP)))")
        (UnallocatedEncoding () )
      else sail2_state_monad$returnS () )
     (if (((memop = MemOp_STORE))) then sail2_state_monad$bindS
        (if ((((((s = t))) \/ (((pair /\ (((s = t2))))))))) then
           let (c : Constraint) = Constraint_NONE in sail2_state_monad$seqS
           (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
           (sail2_state_monad$returnS F)
         else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
        (if ((((((s = n))) /\ (((n <> (( 31 : int):ii))))))) then
           let (c : Constraint) = Constraint_NONE in sail2_state_monad$seqS
           (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
           (sail2_state_monad$returnS F)
         else sail2_state_monad$returnS rn_unknown) (\ (rn_unknown : bool) . 
        sail2_state_monad$returnS (rn_unknown, rt_unknown)))
      else sail2_state_monad$returnS (rn_unknown, rt_unknown))) (\ varstup .  let ((rn_unknown : bool), (rt_unknown :
       bool)) = varstup in sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else if rn_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (secondstage : bool) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (iswrite : bool) . 
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 16 : int):ii)  : ( 16 words$word) M)
         else if pair then
           let v = (ex_int (((( 16 : int):ii) / (( 2 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS
           (sail2_state_monad$assert_expS T "")
           (aget_X v t  : ( 8 words$word) M)) (\ el1 .  sail2_state_monad$bindS
           (aget_X ((int_of_num (words$word_len el1))) t2  : ( 8 words$word) M) (\ el2 .  sail2_state_monad$bindS
           (BigEndian () ) (\ (w__19 : bool) . 
           let (data : 16 bits) =
             (if w__19 then (concat_vec el1 el2  :  16 words$word)
             else (concat_vec el2 el1  :  16 words$word)) in
           sail2_state_monad$returnS data)))
         else (aget_X (( 16 : int):ii) t  : ( 16 words$word) M)) (\ (data : 16 bits) . 
        let (status : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in sail2_state_monad$bindS
        (AArch64_ExclusiveMonitorsPass address dbytes) (\ (w__21 : bool) .  sail2_state_monad$bindS
        (if w__21 then sail2_state_monad$seqS
           (aset_Mem address dbytes acctype data) (ExclusiveMonitorsStatus ()   : ( 1 words$word) M)
         else sail2_state_monad$returnS status) (\ (status : 1 bits) .  sail2_state_monad$bindS
        (ZeroExtend__0 status ((make_the_value (( 32 : int):ii)  :  32 itself))  : ( 32 words$word) M) (\ (w__23 :
           32 words$word) . 
        aset_X s w__23))))
     | MemOp_LOAD => sail2_state_monad$seqS
        (AArch64_SetExclusiveMonitors address dbytes)
        (if pair then sail2_state_monad$seqS
          (sail2_state_monad$assert_expS T "datasize constraint")
          (if rt_unknown then sail2_state_monad$bindS
            (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (w__24 : 32 bits) . 
            aset_X t w__24)
          else sail2_state_monad$bindS (sail2_state_monad$seqS
            (if (((address <> ((Align__1 address dbytes  :  64 words$word))))) then
               let iswrite = F in
               let secondstage = F in sail2_state_monad$bindS
               (AArch64_AlignmentFault acctype F F) (\ (w__25 : FaultRecord) . 
               AArch64_Abort address w__25)
             else sail2_state_monad$returnS () )
            (aget_Mem ((add_vec_int address (( 0 : int):ii)  :  64 words$word)) (( 8 : int):ii) acctype  : ( 64 words$word) M)) (\ (w__26 :
               64 words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
            (aset_X t w__26)
            (aget_Mem ((add_vec_int address (( 8 : int):ii)  :  64 words$word)) (( 8 : int):ii) acctype  : ( 64 words$word) M)) (\ (w__27 :
               64 words$word) . 
            aset_X t2 w__27)))
        else sail2_state_monad$bindS
          (aget_Mem address dbytes acctype  : ( 16 words$word) M) (\ (w__28 : 16 bits) . 
          let data = w__28 in sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__29 :
             'regsize words$word) . 
          aset_X t w__29)))
     ))))))))
   else if (((((size_itself_int p_1)) = (( 32 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 32 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (data : 32 bits) . 
     let (rt_unknown : bool) = F in
     let (rn_unknown : bool) = F in sail2_state_monad$bindS (sail2_state_monad$seqS
     (if (((((((((memop = MemOp_LOAD))) /\ pair))) /\ (((t = t2)))))) then
        let (c : Constraint) = Constraint_UNDEF in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_UNDEF = Constraint_UNKNOWN))) \/ ((((((Constraint_UNDEF = Constraint_UNDEF))) \/ (((Constraint_UNDEF = Constraint_NOP))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP)))")
        (UnallocatedEncoding () )
      else sail2_state_monad$returnS () )
     (if (((memop = MemOp_STORE))) then sail2_state_monad$bindS
        (if ((((((s = t))) \/ (((pair /\ (((s = t2))))))))) then
           let (c : Constraint) = Constraint_NONE in sail2_state_monad$seqS
           (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
           (sail2_state_monad$returnS F)
         else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
        (if ((((((s = n))) /\ (((n <> (( 31 : int):ii))))))) then
           let (c : Constraint) = Constraint_NONE in sail2_state_monad$seqS
           (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
           (sail2_state_monad$returnS F)
         else sail2_state_monad$returnS rn_unknown) (\ (rn_unknown : bool) . 
        sail2_state_monad$returnS (rn_unknown, rt_unknown)))
      else sail2_state_monad$returnS (rn_unknown, rt_unknown))) (\ varstup .  let ((rn_unknown : bool), (rt_unknown :
       bool)) = varstup in sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else if rn_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (secondstage : bool) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (iswrite : bool) . 
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)
         else if pair then
           let v = (ex_int (((( 32 : int):ii) / (( 2 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS
           (sail2_state_monad$assert_expS T "")
           (aget_X v t  : ( 16 words$word) M)) (\ el1 .  sail2_state_monad$bindS
           (aget_X ((int_of_num (words$word_len el1))) t2  : ( 16 words$word) M) (\ el2 .  sail2_state_monad$bindS
           (BigEndian () ) (\ (w__34 : bool) . 
           let (data : 32 bits) =
             (if w__34 then (concat_vec el1 el2  :  32 words$word)
             else (concat_vec el2 el1  :  32 words$word)) in
           sail2_state_monad$returnS data)))
         else (aget_X (( 32 : int):ii) t  : ( 32 words$word) M)) (\ (data : 32 bits) . 
        let (status : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in sail2_state_monad$bindS
        (AArch64_ExclusiveMonitorsPass address dbytes) (\ (w__36 : bool) .  sail2_state_monad$bindS
        (if w__36 then sail2_state_monad$seqS
           (aset_Mem address dbytes acctype data) (ExclusiveMonitorsStatus ()   : ( 1 words$word) M)
         else sail2_state_monad$returnS status) (\ (status : 1 bits) .  sail2_state_monad$bindS
        (ZeroExtend__0 status ((make_the_value (( 32 : int):ii)  :  32 itself))  : ( 32 words$word) M) (\ (w__38 :
           32 words$word) . 
        aset_X s w__38))))
     | MemOp_LOAD => sail2_state_monad$seqS
        (AArch64_SetExclusiveMonitors address dbytes)
        (if pair then sail2_state_monad$seqS
          (sail2_state_monad$assert_expS T "datasize constraint")
          (if rt_unknown then sail2_state_monad$bindS
            (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (w__39 : 32 bits) . 
            aset_X t w__39)
          else sail2_state_monad$bindS (sail2_state_monad$seqS
            (if (((address <> ((Align__1 address dbytes  :  64 words$word))))) then
               let iswrite = F in
               let secondstage = F in sail2_state_monad$bindS
               (AArch64_AlignmentFault acctype F F) (\ (w__40 : FaultRecord) . 
               AArch64_Abort address w__40)
             else sail2_state_monad$returnS () )
            (aget_Mem ((add_vec_int address (( 0 : int):ii)  :  64 words$word)) (( 8 : int):ii) acctype  : ( 64 words$word) M)) (\ (w__41 :
               64 words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
            (aset_X t w__41)
            (aget_Mem ((add_vec_int address (( 8 : int):ii)  :  64 words$word)) (( 8 : int):ii) acctype  : ( 64 words$word) M)) (\ (w__42 :
               64 words$word) . 
            aset_X t2 w__42)))
        else sail2_state_monad$bindS
          (aget_Mem address dbytes acctype  : ( 32 words$word) M) (\ (w__43 : 32 bits) . 
          let data = w__43 in sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__44 :
             'regsize words$word) . 
          aset_X t w__44)))
     ))))))))
   else if (((((size_itself_int p_1)) = (( 64 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 64 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (data : 64 bits) . 
     let (rt_unknown : bool) = F in
     let (rn_unknown : bool) = F in sail2_state_monad$bindS (sail2_state_monad$seqS
     (if (((((((((memop = MemOp_LOAD))) /\ pair))) /\ (((t = t2)))))) then
        let (c : Constraint) = Constraint_UNDEF in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_UNDEF = Constraint_UNKNOWN))) \/ ((((((Constraint_UNDEF = Constraint_UNDEF))) \/ (((Constraint_UNDEF = Constraint_NOP))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP)))")
        (UnallocatedEncoding () )
      else sail2_state_monad$returnS () )
     (if (((memop = MemOp_STORE))) then sail2_state_monad$bindS
        (if ((((((s = t))) \/ (((pair /\ (((s = t2))))))))) then
           let (c : Constraint) = Constraint_NONE in sail2_state_monad$seqS
           (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
           (sail2_state_monad$returnS F)
         else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
        (if ((((((s = n))) /\ (((n <> (( 31 : int):ii))))))) then
           let (c : Constraint) = Constraint_NONE in sail2_state_monad$seqS
           (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
           (sail2_state_monad$returnS F)
         else sail2_state_monad$returnS rn_unknown) (\ (rn_unknown : bool) . 
        sail2_state_monad$returnS (rn_unknown, rt_unknown)))
      else sail2_state_monad$returnS (rn_unknown, rt_unknown))) (\ varstup .  let ((rn_unknown : bool), (rt_unknown :
       bool)) = varstup in sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else if rn_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (secondstage : bool) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (iswrite : bool) . 
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
         else if pair then
           let v = (ex_int (((( 64 : int):ii) / (( 2 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS
           (sail2_state_monad$assert_expS T "")
           (aget_X v t  : ( 32 words$word) M)) (\ el1 .  sail2_state_monad$bindS
           (aget_X ((int_of_num (words$word_len el1))) t2  : ( 32 words$word) M) (\ el2 .  sail2_state_monad$bindS
           (BigEndian () ) (\ (w__49 : bool) . 
           let (data : 64 bits) =
             (if w__49 then (concat_vec el1 el2  :  64 words$word)
             else (concat_vec el2 el1  :  64 words$word)) in
           sail2_state_monad$returnS data)))
         else (aget_X (( 64 : int):ii) t  : ( 64 words$word) M)) (\ (data : 64 bits) . 
        let (status : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in sail2_state_monad$bindS
        (AArch64_ExclusiveMonitorsPass address dbytes) (\ (w__51 : bool) .  sail2_state_monad$bindS
        (if w__51 then sail2_state_monad$seqS
           (aset_Mem address dbytes acctype data) (ExclusiveMonitorsStatus ()   : ( 1 words$word) M)
         else sail2_state_monad$returnS status) (\ (status : 1 bits) .  sail2_state_monad$bindS
        (ZeroExtend__0 status ((make_the_value (( 32 : int):ii)  :  32 itself))  : ( 32 words$word) M) (\ (w__53 :
           32 words$word) . 
        aset_X s w__53))))
     | MemOp_LOAD => sail2_state_monad$seqS
        (AArch64_SetExclusiveMonitors address dbytes)
        (if pair then sail2_state_monad$seqS
          (sail2_state_monad$assert_expS T "datasize constraint")
          (if rt_unknown then sail2_state_monad$bindS
            (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (w__54 : 32 bits) . 
            aset_X t w__54)
          else if (((elsize = (( 32 : int):ii)))) then sail2_state_monad$bindS
            (aget_Mem address dbytes acctype  : ( 64 words$word) M) (\ (w__55 : 64 bits) . 
            let data = w__55 in sail2_state_monad$bindS
            (BigEndian () ) (\ (w__56 : bool) . 
            if w__56 then sail2_state_monad$seqS
              (aset_X t
                ((slice data (( 32 : int):ii) ((((~ (( 32 : int):ii))) + (( 64 : int):ii)))  :  32 words$word)))
              (aset_X t2 ((slice data (( 0 : int):ii) (( 32 : int):ii)  :  32 words$word)))
            else sail2_state_monad$seqS
              (aset_X t ((slice data (( 0 : int):ii) (( 32 : int):ii)  :  32 words$word)))
              (aset_X t2
                ((slice data (( 32 : int):ii) ((((~ (( 32 : int):ii))) + (( 64 : int):ii)))  :  32 words$word)))))
          else sail2_state_monad$bindS (sail2_state_monad$seqS
            (if (((address <> ((Align__1 address dbytes  :  64 words$word))))) then
               let iswrite = F in
               let secondstage = F in sail2_state_monad$bindS
               (AArch64_AlignmentFault acctype F F) (\ (w__57 : FaultRecord) . 
               AArch64_Abort address w__57)
             else sail2_state_monad$returnS () )
            (aget_Mem ((add_vec_int address (( 0 : int):ii)  :  64 words$word)) (( 8 : int):ii) acctype  : ( 64 words$word) M)) (\ (w__58 :
               64 words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
            (aset_X t w__58)
            (aget_Mem ((add_vec_int address (( 8 : int):ii)  :  64 words$word)) (( 8 : int):ii) acctype  : ( 64 words$word) M)) (\ (w__59 :
               64 words$word) . 
            aset_X t2 w__59)))
        else sail2_state_monad$bindS
          (aget_Mem address dbytes acctype  : ( 64 words$word) M) (\ (w__60 : 64 bits) . 
          let data = w__60 in sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__61 :
             'regsize words$word) . 
          aset_X t w__61)))
     ))))))))
   else if (((((size_itself_int p_1)) = (( 128 : int):ii)))) then
     let regsize = (size_itself_int regsize) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int (((( 128 : int):ii) / (( 8 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "datasize constraint")
     (sail2_state_monad$assert_expS T "dbytes constraint"))
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M) (\ (data : 128 bits) . 
     let (rt_unknown : bool) = F in
     let (rn_unknown : bool) = F in sail2_state_monad$bindS (sail2_state_monad$seqS
     (if (((((((((memop = MemOp_LOAD))) /\ pair))) /\ (((t = t2)))))) then
        let (c : Constraint) = Constraint_UNDEF in sail2_state_monad$seqS
        (sail2_state_monad$assert_expS ((((((Constraint_UNDEF = Constraint_UNKNOWN))) \/ ((((((Constraint_UNDEF = Constraint_UNDEF))) \/ (((Constraint_UNDEF = Constraint_NOP))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP)))")
        (UnallocatedEncoding () )
      else sail2_state_monad$returnS () )
     (if (((memop = MemOp_STORE))) then sail2_state_monad$bindS
        (if ((((((s = t))) \/ (((pair /\ (((s = t2))))))))) then
           let (c : Constraint) = Constraint_NONE in sail2_state_monad$seqS
           (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
           (sail2_state_monad$returnS F)
         else sail2_state_monad$returnS rt_unknown) (\ (rt_unknown : bool) .  sail2_state_monad$bindS
        (if ((((((s = n))) /\ (((n <> (( 31 : int):ii))))))) then
           let (c : Constraint) = Constraint_NONE in sail2_state_monad$seqS
           (sail2_state_monad$assert_expS ((((((Constraint_NONE = Constraint_UNKNOWN))) \/ ((((((Constraint_NONE = Constraint_NONE))) \/ ((((((Constraint_NONE = Constraint_UNDEF))) \/ (((Constraint_NONE = Constraint_NOP)))))))))))) "((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))")
           (sail2_state_monad$returnS F)
         else sail2_state_monad$returnS rn_unknown) (\ (rn_unknown : bool) . 
        sail2_state_monad$returnS (rn_unknown, rt_unknown)))
      else sail2_state_monad$returnS (rn_unknown, rt_unknown))) (\ varstup .  let ((rn_unknown : bool), (rt_unknown :
       bool)) = varstup in sail2_state_monad$bindS
     (if (((n = (( 31 : int):ii)))) then sail2_state_monad$seqS (CheckSPAlignment () ) (aget_SP (( 64 : int):ii) ()   : ( 64 words$word) M)
      else if rn_unknown then (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)
      else (aget_X (( 64 : int):ii) n  : ( 64 words$word) M)) (\ (address : 64 bits) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (secondstage : bool) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (iswrite : bool) . 
     (case memop of
       MemOp_STORE => sail2_state_monad$bindS
        (if rt_unknown then (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M)
         else if pair then
           let v = (ex_int (((( 128 : int):ii) / (( 2 : int):ii)))) in sail2_state_monad$bindS (sail2_state_monad$seqS
           (sail2_state_monad$assert_expS T "")
           (aget_X ((int_of_num (words$word_len address))) t  : ( 64 words$word) M)) (\ el1 .  sail2_state_monad$bindS
           (aget_X ((int_of_num (words$word_len address))) t2  : ( 64 words$word) M) (\ el2 .  sail2_state_monad$bindS
           (BigEndian () ) (\ (w__66 : bool) . 
           let (data : 128 bits) =
             (if w__66 then (concat_vec el1 el2  :  128 words$word)
             else (concat_vec el2 el1  :  128 words$word)) in
           sail2_state_monad$returnS data)))
         else (aget_X (( 128 : int):ii) t  : ( 128 words$word) M)) (\ (data : 128 bits) . 
        let (status : 1 bits) = ((vec_of_bits [B1]  :  1 words$word)) in sail2_state_monad$bindS
        (AArch64_ExclusiveMonitorsPass address dbytes) (\ (w__68 : bool) .  sail2_state_monad$bindS
        (if w__68 then sail2_state_monad$seqS
           (aset_Mem address dbytes acctype data) (ExclusiveMonitorsStatus ()   : ( 1 words$word) M)
         else sail2_state_monad$returnS status) (\ (status : 1 bits) .  sail2_state_monad$bindS
        (ZeroExtend__0 status ((make_the_value (( 32 : int):ii)  :  32 itself))  : ( 32 words$word) M) (\ (w__70 :
           32 words$word) . 
        aset_X s w__70))))
     | MemOp_LOAD => sail2_state_monad$seqS
        (AArch64_SetExclusiveMonitors address dbytes)
        (if pair then sail2_state_monad$seqS
          (sail2_state_monad$assert_expS T "datasize constraint")
          (if rt_unknown then sail2_state_monad$bindS
            (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (w__71 : 32 bits) . 
            aset_X t w__71)
          else if (((elsize = (( 32 : int):ii)))) then sail2_state_monad$bindS
            (aget_Mem address dbytes acctype  : ( 128 words$word) M) (\ (w__72 : 128 bits) . 
            let data = w__72 in sail2_state_monad$bindS
            (BigEndian () ) (\ (w__73 : bool) . 
            if w__73 then sail2_state_monad$seqS
              (aset_X t
                ((slice data (( 32 : int):ii) ((((~ (( 32 : int):ii))) + (( 128 : int):ii)))  :  96 words$word)))
              (aset_X t2 ((slice data (( 0 : int):ii) (( 32 : int):ii)  :  32 words$word)))
            else sail2_state_monad$seqS
              (aset_X t ((slice data (( 0 : int):ii) (( 32 : int):ii)  :  32 words$word)))
              (aset_X t2
                ((slice data (( 32 : int):ii) ((((~ (( 32 : int):ii))) + (( 128 : int):ii)))  :  96 words$word)))))
          else sail2_state_monad$bindS (sail2_state_monad$seqS
            (if (((address <> ((Align__1 address dbytes  :  64 words$word))))) then
               let iswrite = F in
               let secondstage = F in sail2_state_monad$bindS
               (AArch64_AlignmentFault acctype F F) (\ (w__74 : FaultRecord) . 
               AArch64_Abort address w__74)
             else sail2_state_monad$returnS () )
            (aget_Mem ((add_vec_int address (( 0 : int):ii)  :  64 words$word)) (( 8 : int):ii) acctype  : ( 64 words$word) M)) (\ (w__75 :
               64 words$word) .  sail2_state_monad$bindS (sail2_state_monad$seqS
            (aset_X t w__75)
            (aget_Mem ((add_vec_int address (( 8 : int):ii)  :  64 words$word)) (( 8 : int):ii) acctype  : ( 64 words$word) M)) (\ (w__76 :
               64 words$word) . 
            aset_X t2 w__76)))
        else sail2_state_monad$bindS
          (aget_Mem address dbytes acctype  : ( 128 words$word) M) (\ (w__77 : 128 bits) . 
          let data = w__77 in sail2_state_monad$bindS
          (ZeroExtend__0 data ((make_the_value regsize  :  'regsize itself))  : ( 'regsize words$word) M) (\ (w__78 :
             'regsize words$word) . 
          aset_X t w__78)))
     ))))))))
   else
     let regsize = (size_itself_int regsize) in
     let datasize = (size_itself_int p_1) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "regsize constraint")
     (let dbytes = (ex_int ((datasize / (( 8 : int):ii)))) in
     sail2_state_monad$assert_expS T "datasize constraint")))`;


(*val memory_exclusive_pair_decode : mword ty1 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_exclusive_pair_decode:(1)words$word ->(1)words$word ->(1)words$word ->(1)words$word ->(5)words$word ->(1)words$word ->(5)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 o2 L o1 Rs o0 Rt2 Rn Rt=
    (if (((b__0 = (vec_of_bits [B0]  :  1 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (s : ii) = (lem$w2ui Rs) in
     let (acctype : AccType) =
       (if (((o0 = (vec_of_bits [B1]  :  1 words$word)))) then AccType_ORDERED
       else AccType_ATOMIC) in
     let (pair : bool) = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (elsize : ii) = ((( 32 : int):ii)) in
     let (regsize : ii) = ((( 32 : int):ii)) in
     let (datasize : ii) = ((( 64 : int):ii)) in
     aarch64_memory_exclusive_pair acctype ((make_the_value (( 64 : int):ii)  :  64 itself)) (( 32 : int):ii) memop n
       T ((make_the_value (( 32 : int):ii)  :  32 itself)) s t t2)
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (s : ii) = (lem$w2ui Rs) in
     let (acctype : AccType) =
       (if (((o0 = (vec_of_bits [B1]  :  1 words$word)))) then AccType_ORDERED
       else AccType_ATOMIC) in
     let (pair : bool) = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (elsize : ii) = ((( 64 : int):ii)) in
     let (regsize : ii) = ((( 64 : int):ii)) in
     let (datasize : ii) = ((( 128 : int):ii)) in
     aarch64_memory_exclusive_pair acctype ((make_the_value (( 128 : int):ii)  :  128 itself)) (( 64 : int):ii) memop
       n T ((make_the_value (( 64 : int):ii)  :  64 itself)) s t t2)))`;


(*val aarch64_integer_crc : bool -> ii -> ii -> ii -> integer -> M unit*)

val _ = Define `
 ((aarch64_integer_crc:bool -> int -> int -> int -> int ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) crc32c d m n l__16=
    (if (((l__16 = (( 8 : int):ii)))) then sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (if ((~ ((HaveCRCExt () )))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (aget_X (( 32 : int):ii) n  : ( 32 words$word) M)) (\ (acc : 32 bits) .  sail2_state_monad$bindS
     (aget_X (( 8 : int):ii) m  : ( 8 words$word) M) (\ (val_name : 8 bits) . 
     let (poly : 32 bits) =
       ((GetSlice_int ((make_the_value (( 32 : int):ii)  :  32 itself))
          (if crc32c then (( 517762881 : int):ii)
           else (( 79764919 : int):ii)) (( 0 : int):ii)
         :  32 words$word)) in sail2_state_monad$bindS
     (BitReverse acc  : ( 32 words$word) M) (\ (w__0 :  32 words$word) . 
     let (tempacc : 40 bits) =
       ((concat_vec w__0 ((Zeros__0 ((make_the_value (( 8 : int):ii)  :  8 itself))  :  8 words$word))
         :  40 words$word)) in sail2_state_monad$bindS
     (BitReverse val_name  : ( 8 words$word) M) (\ (w__1 :  8 words$word) . 
     let (tempval : 40 bits) =
       ((concat_vec w__1 ((Zeros__0 ((make_the_value (( 32 : int):ii)  :  32 itself))  :  32 words$word))
         :  40 words$word)) in sail2_state_monad$bindS
     (Poly32Mod2 ((xor_vec tempacc tempval  :  40 words$word)) poly  : ( 32 words$word) M) (\ (w__2 :
        32 words$word) .  sail2_state_monad$bindS
     (BitReverse w__2  : ( 32 words$word) M) (\ (w__3 :  32 words$word) .  aset_X d w__3))))))
   else if (((l__16 = (( 16 : int):ii)))) then sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (if ((~ ((HaveCRCExt () )))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (aget_X (( 32 : int):ii) n  : ( 32 words$word) M)) (\ (acc : 32 bits) .  sail2_state_monad$bindS
     (aget_X (( 16 : int):ii) m  : ( 16 words$word) M) (\ (val_name : 16 bits) . 
     let (poly : 32 bits) =
       ((GetSlice_int ((make_the_value (( 32 : int):ii)  :  32 itself))
          (if crc32c then (( 517762881 : int):ii)
           else (( 79764919 : int):ii)) (( 0 : int):ii)
         :  32 words$word)) in sail2_state_monad$bindS
     (BitReverse acc  : ( 32 words$word) M) (\ (w__4 :  32 words$word) . 
     let (tempacc : 48 bits) =
       ((concat_vec w__4 ((Zeros__0 ((make_the_value (( 16 : int):ii)  :  16 itself))  :  16 words$word))
         :  48 words$word)) in sail2_state_monad$bindS
     (BitReverse val_name  : ( 16 words$word) M) (\ (w__5 :  16 words$word) . 
     let (tempval : 48 bits) =
       ((concat_vec w__5 ((Zeros__0 ((make_the_value (( 32 : int):ii)  :  32 itself))  :  32 words$word))
         :  48 words$word)) in sail2_state_monad$bindS
     (Poly32Mod2 ((xor_vec tempacc tempval  :  48 words$word)) poly  : ( 32 words$word) M) (\ (w__6 :
        32 words$word) .  sail2_state_monad$bindS
     (BitReverse w__6  : ( 32 words$word) M) (\ (w__7 :  32 words$word) .  aset_X d w__7))))))
   else if (((l__16 = (( 32 : int):ii)))) then sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (if ((~ ((HaveCRCExt () )))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (aget_X (( 32 : int):ii) n  : ( 32 words$word) M)) (\ (acc : 32 bits) .  sail2_state_monad$bindS
     (aget_X (( 32 : int):ii) m  : ( 32 words$word) M) (\ (val_name : 32 bits) . 
     let (poly : 32 bits) =
       ((GetSlice_int ((make_the_value (( 32 : int):ii)  :  32 itself))
          (if crc32c then (( 517762881 : int):ii)
           else (( 79764919 : int):ii)) (( 0 : int):ii)
         :  32 words$word)) in sail2_state_monad$bindS
     (BitReverse acc  : ( 32 words$word) M) (\ (w__8 :  32 words$word) . 
     let (tempacc : 64 bits) =
       ((concat_vec w__8 ((Zeros__0 ((make_the_value (( 32 : int):ii)  :  32 itself))  :  32 words$word))
         :  64 words$word)) in sail2_state_monad$bindS
     (BitReverse val_name  : ( 32 words$word) M) (\ (w__9 :  32 words$word) . 
     let (tempval : 64 bits) =
       ((concat_vec w__9 ((Zeros__0 ((make_the_value (( 32 : int):ii)  :  32 itself))  :  32 words$word))
         :  64 words$word)) in sail2_state_monad$bindS
     (Poly32Mod2 ((xor_vec tempacc tempval  :  64 words$word)) poly  : ( 32 words$word) M) (\ (w__10 :
        32 words$word) .  sail2_state_monad$bindS
     (BitReverse w__10  : ( 32 words$word) M) (\ (w__11 :  32 words$word) .  aset_X d w__11))))))
   else if (((l__16 = (( 64 : int):ii)))) then sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (if ((~ ((HaveCRCExt () )))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (aget_X (( 32 : int):ii) n  : ( 32 words$word) M)) (\ (acc : 32 bits) .  sail2_state_monad$bindS
     (aget_X (( 64 : int):ii) m  : ( 64 words$word) M) (\ (val_name : 64 bits) . 
     let (poly : 32 bits) =
       ((GetSlice_int ((make_the_value (( 32 : int):ii)  :  32 itself))
          (if crc32c then (( 517762881 : int):ii)
           else (( 79764919 : int):ii)) (( 0 : int):ii)
         :  32 words$word)) in sail2_state_monad$bindS
     (BitReverse acc  : ( 32 words$word) M) (\ (w__12 :  32 words$word) . 
     let (tempacc : 96 bits) =
       ((concat_vec w__12 ((Zeros__0 ((make_the_value (( 64 : int):ii)  :  64 itself))  :  64 words$word))
         :  96 words$word)) in sail2_state_monad$bindS
     (BitReverse val_name  : ( 64 words$word) M) (\ (w__13 :  64 words$word) . 
     let (tempval : 96 bits) =
       ((concat_vec w__13 ((Zeros__0 ((make_the_value (( 32 : int):ii)  :  32 itself))  :  32 words$word))
         :  96 words$word)) in sail2_state_monad$bindS
     (Poly32Mod2 ((xor_vec tempacc tempval  :  96 words$word)) poly  : ( 32 words$word) M) (\ (w__14 :
        32 words$word) .  sail2_state_monad$bindS
     (BitReverse w__14  : ( 32 words$word) M) (\ (w__15 :  32 words$word) .  aset_X d w__15))))))
   else sail2_state_monad$assert_expS T ""))`;


(*val system_exceptions_debug_exception_decode : mword ty3 -> mword ty16 -> mword ty3 -> mword ty2 -> M unit*)

val _ = Define `
 ((system_exceptions_debug_exception_decode:(3)words$word ->(16)words$word ->(3)words$word ->(2)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) opc imm16 op2 LL=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (target_level : 2 bits) = LL in sail2_state_monad$bindS (sail2_state_monad$seqS
   (if (((LL = (vec_of_bits [B0;B0]  :  2 words$word)))) then UnallocatedEncoding () 
    else sail2_state_monad$returnS () )
   (Halted () )) (\ (w__0 : bool) .  sail2_state_monad$seqS
   (if ((~ w__0)) then AArch64_UndefinedFault () 
    else sail2_state_monad$returnS () )
   (aarch64_system_exceptions_debug_exception target_level)))))`;


(*val system_barriers_decode : mword ty1 -> mword ty2 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty5 -> M unit*)

val _ = Define `
 ((system_barriers_decode:(1)words$word ->(2)words$word ->(3)words$word ->(4)words$word ->(4)words$word ->(2)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) L op0 op1 CRn CRm opc Rt=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (undefined_MemBarrierOp () )) (\ (op : MemBarrierOp) .  sail2_state_monad$bindS
   (undefined_MBReqDomain () ) (\ (domain1 : MBReqDomain) .  sail2_state_monad$bindS
   (undefined_MBReqTypes () ) (\ (types : MBReqTypes) . 
   let b__0 = opc in sail2_state_monad$bindS
   (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$returnS MemBarrierOp_DSB
    else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$returnS MemBarrierOp_DMB
    else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$returnS MemBarrierOp_ISB
    else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS op)) (\ (op : MemBarrierOp) . 
   let b__3 = ((slice CRm (( 2 : int):ii) (( 2 : int):ii)  :  2 words$word)) in
   let (domain1 : MBReqDomain) =
     (if (((b__3 = (vec_of_bits [B0;B0]  :  2 words$word)))) then MBReqDomain_OuterShareable
     else if (((b__3 = (vec_of_bits [B0;B1]  :  2 words$word)))) then MBReqDomain_Nonshareable
     else if (((b__3 = (vec_of_bits [B1;B0]  :  2 words$word)))) then MBReqDomain_InnerShareable
     else MBReqDomain_FullSystem) in
   let b__7 = ((slice CRm (( 0 : int):ii) (( 2 : int):ii)  :  2 words$word)) in
   let ((domain1 : MBReqDomain), (types : MBReqTypes)) =
     (if (((b__7 = (vec_of_bits [B0;B1]  :  2 words$word)))) then
       let (types : MBReqTypes) = MBReqTypes_Reads in
       (domain1, types)
     else
       let ((domain1 : MBReqDomain), (types : MBReqTypes)) =
         (if (((b__7 = (vec_of_bits [B1;B0]  :  2 words$word)))) then
           let (types : MBReqTypes) = MBReqTypes_Writes in
           (domain1, types)
         else
           let ((domain1 : MBReqDomain), (types : MBReqTypes)) =
             (if (((b__7 = (vec_of_bits [B1;B1]  :  2 words$word)))) then
               let (types : MBReqTypes) = MBReqTypes_All in
               (domain1, types)
             else
               let (types : MBReqTypes) = MBReqTypes_All in
               let (domain1 : MBReqDomain) = MBReqDomain_FullSystem in
               (domain1, types)) in
           (domain1, types)) in
       (domain1, types)) in
   sail2_state_monad$returnS ((aarch64_system_barriers domain1 op types))))))))`;


(*val memory_vector_single_postinc_aarch64_memory_vector_single_nowb__decode : mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty3 -> mword ty1 -> mword ty2 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_vector_single_postinc_aarch64_memory_vector_single_nowb__decode:(1)words$word ->(1)words$word ->(1)words$word ->(5)words$word ->(3)words$word ->(1)words$word ->(2)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 L R1 Rm b__1 S1 b__2 Rn Rt=
    (if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0;B0]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index m memop n F ((ex_int selem)) t T))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0;B1]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index m memop n F ((ex_int selem)) t T))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1;B0]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index m memop n F ((ex_int selem)) t T))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1;B1]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index m memop n F ((ex_int selem)) t T))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0;B0]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index m memop n F ((ex_int selem)) t T))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0;B1]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index m memop n F ((ex_int selem)) t T))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1;B0]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index m memop n F ((ex_int selem)) t T))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1;B1]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index m memop n F ((ex_int selem)) t T))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index m memop n F ((ex_int selem)) t T))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index m memop n F ((ex_int selem)) t T)))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index m memop n F ((ex_int selem)) t T))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index m memop n F ((ex_int selem)) t T)))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index m memop n F ((ex_int selem)) t T))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index m memop n F ((ex_int selem)) t T)))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index m memop n F ((ex_int selem)) t T))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index m memop n F ((ex_int selem)) t T)))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index = (lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 32 : int):ii)  :  32 itself)) index m memop n F ((ex_int selem)) t T))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let index = ((( 0 : int):ii)) in
     let scale = ((( 3 : int):ii)) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 64 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 64 : int):ii)  :  64 itself)) (( 0 : int):ii) m memop n F ((ex_int selem)) t T)))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let index = (lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 32 : int):ii)  :  32 itself)) index m memop n F ((ex_int selem)) t T)))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS (sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (let index = ((( 0 : int):ii)) in
     let scale = ((( 3 : int):ii)) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 64 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 64 : int):ii)  :  64 itself)) (( 0 : int):ii) m memop n F ((ex_int selem)) t T)))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index = (lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 32 : int):ii)  :  32 itself)) index m memop n F ((ex_int selem)) t T))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let index = ((( 0 : int):ii)) in
     let scale = ((( 3 : int):ii)) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 64 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 64 : int):ii)  :  64 itself)) (( 0 : int):ii) m memop n F ((ex_int selem)) t T)))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let index = (lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 32 : int):ii)  :  32 itself)) index m memop n F ((ex_int selem)) t T)))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS (sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (let index = ((( 0 : int):ii)) in
     let scale = ((( 3 : int):ii)) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 64 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 64 : int):ii)  :  64 itself)) (( 0 : int):ii) m memop n F ((ex_int selem)) t T)))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 0 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__0 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) w__0 m memop n T ((ex_int selem)) t T))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 1 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__1 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) w__1 m memop n T ((ex_int selem)) t T))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 2 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__2 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 32 : int):ii)  :  32 itself)) w__2 m memop n T ((ex_int selem)) t T))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 3 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__3 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 64 : int):ii)  :  64 itself)) w__3 m memop n T ((ex_int selem)) t T))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 0 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__4 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) w__4 m memop n T ((ex_int selem)) t T))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 1 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__5 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) w__5 m memop n T ((ex_int selem)) t T))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 2 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__6 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 32 : int):ii)  :  32 itself)) w__6 m memop n T ((ex_int selem)) t T))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 3 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__7 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 64 : int):ii)  :  64 itself)) w__7 m memop n T ((ex_int selem)) t T))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0;B0]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index m memop n F ((ex_int selem)) t T))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0;B1]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index m memop n F ((ex_int selem)) t T))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1;B0]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index m memop n F ((ex_int selem)) t T))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1;B1]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index m memop n F ((ex_int selem)) t T))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0;B0]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index m memop n F ((ex_int selem)) t T))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0;B1]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index m memop n F ((ex_int selem)) t T))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1;B0]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index m memop n F ((ex_int selem)) t T))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1;B1]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index m memop n F ((ex_int selem)) t T))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index m memop n F ((ex_int selem)) t T))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index m memop n F ((ex_int selem)) t T)))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index m memop n F ((ex_int selem)) t T))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index m memop n F ((ex_int selem)) t T)))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index m memop n F ((ex_int selem)) t T))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index m memop n F ((ex_int selem)) t T)))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index m memop n F ((ex_int selem)) t T))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index m memop n F ((ex_int selem)) t T)))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index = (lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 32 : int):ii)  :  32 itself)) index m memop n F ((ex_int selem)) t T))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let index = ((( 1 : int):ii)) in
     let scale = ((( 3 : int):ii)) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 64 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 64 : int):ii)  :  64 itself)) (( 1 : int):ii) m memop n F ((ex_int selem)) t T)))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let index = (lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 32 : int):ii)  :  32 itself)) index m memop n F ((ex_int selem)) t T)))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS (sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (let index = ((( 1 : int):ii)) in
     let scale = ((( 3 : int):ii)) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 64 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 64 : int):ii)  :  64 itself)) (( 1 : int):ii) m memop n F ((ex_int selem)) t T)))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index = (lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 32 : int):ii)  :  32 itself)) index m memop n F ((ex_int selem)) t T))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let index = ((( 1 : int):ii)) in
     let scale = ((( 3 : int):ii)) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 64 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 64 : int):ii)  :  64 itself)) (( 1 : int):ii) m memop n F ((ex_int selem)) t T)))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let index = (lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 32 : int):ii)  :  32 itself)) index m memop n F ((ex_int selem)) t T)))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS (sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (let index = ((( 1 : int):ii)) in
     let scale = ((( 3 : int):ii)) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 64 : int):ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 64 : int):ii)  :  64 itself)) (( 1 : int):ii) m memop n F ((ex_int selem)) t T)))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 0 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__8 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) w__8 m memop n T ((ex_int selem)) t T))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 1 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__9 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) w__9 m memop n T ((ex_int selem)) t T))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 2 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__10 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 32 : int):ii)  :  32 itself)) w__10 m memop n T ((ex_int selem)) t T))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 3 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__11 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 64 : int):ii)  :  64 itself)) w__11 m memop n T ((ex_int selem)) t T))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 0 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__12 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) w__12 m memop n T ((ex_int selem)) t T))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 1 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__13 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) w__13 m memop n T ((ex_int selem)) t T))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 2 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__14 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 32 : int):ii)  :  32 itself)) w__14 m memop n T ((ex_int selem)) t T))))
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 3 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__15 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 64 : int):ii)  :  64 itself)) w__15 m memop n T ((ex_int selem)) t T))))))`;


(*val memory_vector_single_nowb_aarch64_memory_vector_single_nowb__decode : mword ty1 -> mword ty1 -> mword ty1 -> mword ty3 -> mword ty1 -> mword ty2 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_vector_single_nowb_aarch64_memory_vector_single_nowb__decode:(1)words$word ->(1)words$word ->(1)words$word ->(3)words$word ->(1)words$word ->(2)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 L R1 b__1 S1 b__2 Rn Rt=
    (if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0;B0]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__0 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index w__0 memop n F ((ex_int selem)) t F))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0;B1]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__1 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index w__1 memop n F ((ex_int selem)) t F))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1;B0]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__2 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index w__2 memop n F ((ex_int selem)) t F))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1;B1]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__3 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index w__3 memop n F ((ex_int selem)) t F))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0;B0]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__4 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index w__4 memop n F ((ex_int selem)) t F))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0;B1]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__5 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index w__5 memop n F ((ex_int selem)) t F))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1;B0]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__6 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index w__6 memop n F ((ex_int selem)) t F))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1;B1]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__7 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index w__7 memop n F ((ex_int selem)) t F))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__8 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index w__8 memop n F ((ex_int selem)) t F))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__9 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index w__9 memop n F ((ex_int selem)) t F)))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__10 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index w__10 memop n F ((ex_int selem)) t F))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__11 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index w__11 memop n F ((ex_int selem)) t F)))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__12 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index w__12 memop n F ((ex_int selem)) t F))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__13 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index w__13 memop n F ((ex_int selem)) t F)))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__14 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index w__14 memop n F ((ex_int selem)) t F))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__15 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index w__15 memop n F ((ex_int selem)) t F)))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index = (lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__16 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 32 : int):ii)  :  32 itself)) index w__16 memop n F ((ex_int selem)) t F))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let index = ((( 0 : int):ii)) in
     let scale = ((( 3 : int):ii)) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__17 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 64 : int):ii)  :  64 itself)) (( 0 : int):ii) w__17 memop n F ((ex_int selem)) t F)))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let index = (lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__18 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 32 : int):ii)  :  32 itself)) index w__18 memop n F ((ex_int selem)) t F)))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS (sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (let index = ((( 0 : int):ii)) in
     let scale = ((( 3 : int):ii)) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__19 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 64 : int):ii)  :  64 itself)) (( 0 : int):ii) w__19 memop n F ((ex_int selem)) t F)))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index = (lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__20 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 32 : int):ii)  :  32 itself)) index w__20 memop n F ((ex_int selem)) t F))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let index = ((( 0 : int):ii)) in
     let scale = ((( 3 : int):ii)) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__21 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 64 : int):ii)  :  64 itself)) (( 0 : int):ii) w__21 memop n F ((ex_int selem)) t F)))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let index = (lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) S1  :  2 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__22 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 32 : int):ii)  :  32 itself)) index w__22 memop n F ((ex_int selem)) t F)))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS (sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (let index = ((( 0 : int):ii)) in
     let scale = ((( 3 : int):ii)) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__23 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 64 : int):ii)  :  64 itself)) (( 0 : int):ii) w__23 memop n F ((ex_int selem)) t F)))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 0 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__24 : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (w__25 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) w__24 w__25 memop n T ((ex_int selem)) t F))))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 1 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__26 : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (w__27 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) w__26 w__27 memop n T ((ex_int selem)) t F))))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 2 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__28 : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (w__29 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 32 : int):ii)  :  32 itself)) w__28 w__29 memop n T ((ex_int selem)) t F))))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 3 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__30 : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (w__31 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 64 : int):ii)  :  64 itself)) w__30 w__31 memop n T ((ex_int selem)) t F))))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 0 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__32 : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (w__33 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) w__32 w__33 memop n T ((ex_int selem)) t F))))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 1 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__34 : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (w__35 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) w__34 w__35 memop n T ((ex_int selem)) t F))))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 2 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__36 : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (w__37 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 32 : int):ii)  :  32 itself)) w__36 w__37 memop n T ((ex_int selem)) t F))))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 3 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__38 : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (w__39 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 64 : int):ii)  :  64 itself)) w__38 w__39 memop n T ((ex_int selem)) t F))))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0;B0]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__40 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index w__40 memop n F ((ex_int selem)) t F))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0;B1]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__41 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index w__41 memop n F ((ex_int selem)) t F))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1;B0]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__42 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index w__42 memop n F ((ex_int selem)) t F))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1;B1]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__43 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index w__43 memop n F ((ex_int selem)) t F))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0;B0]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__44 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index w__44 memop n F ((ex_int selem)) t F))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0;B1]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__45 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index w__45 memop n F ((ex_int selem)) t F))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1;B0]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__46 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index w__46 memop n F ((ex_int selem)) t F))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1;B1]  :  2 words$word)
            :  4 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__47 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) index w__47 memop n F ((ex_int selem)) t F))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__48 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index w__48 memop n F ((ex_int selem)) t F))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__49 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index w__49 memop n F ((ex_int selem)) t F)))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__50 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index w__50 memop n F ((ex_int selem)) t F))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__51 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index w__51 memop n F ((ex_int selem)) t F)))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__52 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index w__52 memop n F ((ex_int selem)) t F))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B0]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__53 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index w__53 memop n F ((ex_int selem)) t F)))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__54 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index w__54 memop n F ((ex_int selem)) t F))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let index =
       (lem$w2ui ((concat_vec ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))
             (vec_of_bits [B1]  :  1 words$word)
            :  3 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__55 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) index w__55 memop n F ((ex_int selem)) t F)))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index = (lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__56 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 32 : int):ii)  :  32 itself)) index w__56 memop n F ((ex_int selem)) t F))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let index = ((( 1 : int):ii)) in
     let scale = ((( 3 : int):ii)) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__57 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 64 : int):ii)  :  64 itself)) (( 1 : int):ii) w__57 memop n F ((ex_int selem)) t F)))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let index = (lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__58 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 32 : int):ii)  :  32 itself)) index w__58 memop n F ((ex_int selem)) t F)))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS (sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (let index = ((( 1 : int):ii)) in
     let scale = ((( 3 : int):ii)) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__59 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 64 : int):ii)  :  64 itself)) (( 1 : int):ii) w__59 memop n F ((ex_int selem)) t F)))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) . 
     let index = (lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__60 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 32 : int):ii)  :  32 itself)) index w__60 memop n F ((ex_int selem)) t F))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let index = ((( 1 : int):ii)) in
     let scale = ((( 3 : int):ii)) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__61 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 64 : int):ii)  :  64 itself)) (( 1 : int):ii) w__61 memop n F ((ex_int selem)) t F)))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let index = (lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) S1  :  2 words$word))) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__62 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 32 : int):ii)  :  32 itself)) index w__62 memop n F ((ex_int selem)) t F)))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS (sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (let index = ((( 1 : int):ii)) in
     let scale = ((( 3 : int):ii)) in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__63 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 64 : int):ii)  :  64 itself)) (( 1 : int):ii) w__63 memop n F ((ex_int selem)) t F)))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 0 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__64 : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (w__65 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) w__64 w__65 memop n T ((ex_int selem)) t F))))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 1 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__66 : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (w__67 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) w__66 w__67 memop n T ((ex_int selem)) t F))))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 2 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__68 : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (w__69 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 32 : int):ii)  :  32 itself)) w__68 w__69 memop n T ((ex_int selem)) t F))))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B0]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 3 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__70 : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (w__71 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 64 : int):ii)  :  64 itself)) w__70 w__71 memop n T ((ex_int selem)) t F))))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 0 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__72 : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (w__73 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 8 : int):ii)  :  8 itself)) w__72 w__73 memop n T ((ex_int selem)) t F))))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 1 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__74 : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (w__75 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 16 : int):ii)  :  16 itself)) w__74 w__75 memop n T ((ex_int selem)) t F))))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((b__1 = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((b__2 = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 2 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__76 : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (w__77 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 32 : int):ii)  :  32 itself)) w__76 w__77 memop n T ((ex_int selem)) t F))))))
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (selem : ii) =
       (((lem$w2ui ((concat_vec (vec_of_bits [B1]  :  1 words$word) R1  :  2 words$word)))) + (( 1 : int):ii)) in
     let (replicate : bool) = F in sail2_state_monad$bindS
     (undefined_int () ) (\ (index : ii) .  sail2_state_monad$seqS
     (if ((((((L = (vec_of_bits [B0]  :  1 words$word)))) \/ (((S1 = (vec_of_bits [B1]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let scale = ((( 3 : int):ii)) in
     let replicate = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (w__78 : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (w__79 : ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 64 : int):ii)  :  64 itself)) w__78 w__79 memop n T ((ex_int selem)) t F))))))))`;


(*val memory_single_simdfp_register_aarch64_memory_single_simdfp_register__decode : mword ty2 -> mword ty1 -> mword ty2 -> mword ty5 -> mword ty3 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_single_simdfp_register_aarch64_memory_single_simdfp_register__decode:(2)words$word ->(1)words$word ->(2)words$word ->(5)words$word ->(3)words$word ->(1)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) size1 V1 opc Rm option_name S1 Rn Rt=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (wback : bool) = F in
   let (postindex : bool) = F in
   let (scale : ii) =
     (lem$w2ui ((concat_vec (vec_of_bits [access_vec_dec opc (( 1 : int):ii)]  :  1 words$word) size1  :  3 words$word))) in sail2_state_monad$seqS (sail2_state_monad$seqS
   (if ((((ex_int scale)) > (( 4 : int):ii))) then UnallocatedEncoding () 
    else sail2_state_monad$returnS () )
   (if ((((vec_of_bits [access_vec_dec option_name (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))) then
      UnallocatedEncoding () 
    else sail2_state_monad$returnS () ))
   (let (extend_type : ExtendType) = (DecodeRegExtend option_name) in
   let (shift : ii) = (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then scale else (( 0 : int):ii)) in
   let (n : ii) = (lem$w2ui Rn) in
   let (t : ii) = (lem$w2ui Rt) in
   let (m : ii) = (lem$w2ui Rm) in
   let (acctype : AccType) = AccType_VEC in
   let (memop : MemOp) =
     (if ((((vec_of_bits [access_vec_dec opc (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
       MemOp_LOAD
     else MemOp_STORE) in
   let (datasize : ii) = (shl_int (( 8 : int):ii) scale) in
   aarch64_memory_single_simdfp_register acctype datasize extend_type m memop n postindex shift t
     wback))))`;


(*val memory_single_simdfp_immediate_unsigned_aarch64_memory_single_simdfp_immediate_signed_postidx__decode : mword ty2 -> mword ty1 -> mword ty2 -> mword ty12 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_single_simdfp_immediate_unsigned_aarch64_memory_single_simdfp_immediate_signed_postidx__decode:(2)words$word ->(1)words$word ->(2)words$word ->(12)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) size1 V1 opc imm12 Rn Rt=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (wback : bool) = F in
   let (postindex : bool) = F in
   let (scale : ii) =
     (lem$w2ui ((concat_vec (vec_of_bits [access_vec_dec opc (( 1 : int):ii)]  :  1 words$word) size1  :  3 words$word))) in sail2_state_monad$bindS (sail2_state_monad$seqS
   (if ((((ex_int scale)) > (( 4 : int):ii))) then UnallocatedEncoding () 
    else sail2_state_monad$returnS () )
   (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M)) (\ (w__0 :
      64 words$word) .  sail2_state_monad$bindS
   (LSL w__0 scale  : ( 64 words$word) M) (\ (offset : 64 bits) . 
   let (n : ii) = (lem$w2ui Rn) in
   let (t : ii) = (lem$w2ui Rt) in
   let (acctype : AccType) = AccType_VEC in
   let (memop : MemOp) =
     (if ((((vec_of_bits [access_vec_dec opc (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
       MemOp_LOAD
     else MemOp_STORE) in
   let (datasize : ii) = (shl_int (( 8 : int):ii) scale) in
   aarch64_memory_single_simdfp_immediate_signed_postidx acctype datasize memop n offset postindex t
     wback)))))`;


(*val memory_single_simdfp_immediate_signed_preidx_aarch64_memory_single_simdfp_immediate_signed_postidx__decode : mword ty2 -> mword ty1 -> mword ty2 -> mword ty9 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_single_simdfp_immediate_signed_preidx_aarch64_memory_single_simdfp_immediate_signed_postidx__decode:(2)words$word ->(1)words$word ->(2)words$word ->(9)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) size1 V1 opc imm9 Rn Rt=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (wback : bool) = T in
   let (postindex : bool) = F in
   let (scale : ii) =
     (lem$w2ui ((concat_vec (vec_of_bits [access_vec_dec opc (( 1 : int):ii)]  :  1 words$word) size1  :  3 words$word))) in sail2_state_monad$bindS (sail2_state_monad$seqS
   (if ((((ex_int scale)) > (( 4 : int):ii))) then UnallocatedEncoding () 
    else sail2_state_monad$returnS () )
   (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M)) (\ (offset : 64
     bits) . 
   let (n : ii) = (lem$w2ui Rn) in
   let (t : ii) = (lem$w2ui Rt) in
   let (acctype : AccType) = AccType_VEC in
   let (memop : MemOp) =
     (if ((((vec_of_bits [access_vec_dec opc (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
       MemOp_LOAD
     else MemOp_STORE) in
   let (datasize : ii) = (shl_int (( 8 : int):ii) scale) in
   aarch64_memory_single_simdfp_immediate_signed_postidx acctype datasize memop n offset postindex t
     wback))))`;


(*val memory_single_simdfp_immediate_signed_postidx_aarch64_memory_single_simdfp_immediate_signed_postidx__decode : mword ty2 -> mword ty1 -> mword ty2 -> mword ty9 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_single_simdfp_immediate_signed_postidx_aarch64_memory_single_simdfp_immediate_signed_postidx__decode:(2)words$word ->(1)words$word ->(2)words$word ->(9)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) size1 V1 opc imm9 Rn Rt=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (wback : bool) = T in
   let (postindex : bool) = T in
   let (scale : ii) =
     (lem$w2ui ((concat_vec (vec_of_bits [access_vec_dec opc (( 1 : int):ii)]  :  1 words$word) size1  :  3 words$word))) in sail2_state_monad$bindS (sail2_state_monad$seqS
   (if ((((ex_int scale)) > (( 4 : int):ii))) then UnallocatedEncoding () 
    else sail2_state_monad$returnS () )
   (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M)) (\ (offset : 64
     bits) . 
   let (n : ii) = (lem$w2ui Rn) in
   let (t : ii) = (lem$w2ui Rt) in
   let (acctype : AccType) = AccType_VEC in
   let (memop : MemOp) =
     (if ((((vec_of_bits [access_vec_dec opc (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
       MemOp_LOAD
     else MemOp_STORE) in
   let (datasize : ii) = (shl_int (( 8 : int):ii) scale) in
   aarch64_memory_single_simdfp_immediate_signed_postidx acctype datasize memop n offset postindex t
     wback))))`;


(*val memory_single_simdfp_immediate_signed_offset_normal_aarch64_memory_single_simdfp_immediate_signed_offset_normal__decode : mword ty2 -> mword ty1 -> mword ty2 -> mword ty9 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_single_simdfp_immediate_signed_offset_normal_aarch64_memory_single_simdfp_immediate_signed_offset_normal__decode:(2)words$word ->(1)words$word ->(2)words$word ->(9)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) size1 V1 opc imm9 Rn Rt=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (wback : bool) = F in
   let (postindex : bool) = F in
   let (scale : ii) =
     (lem$w2ui ((concat_vec (vec_of_bits [access_vec_dec opc (( 1 : int):ii)]  :  1 words$word) size1  :  3 words$word))) in sail2_state_monad$bindS (sail2_state_monad$seqS
   (if ((((ex_int scale)) > (( 4 : int):ii))) then UnallocatedEncoding () 
    else sail2_state_monad$returnS () )
   (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M)) (\ (offset : 64
     bits) . 
   let (n : ii) = (lem$w2ui Rn) in
   let (t : ii) = (lem$w2ui Rt) in
   let (acctype : AccType) = AccType_VEC in
   let (memop : MemOp) =
     (if ((((vec_of_bits [access_vec_dec opc (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
       MemOp_LOAD
     else MemOp_STORE) in
   let (datasize : ii) = (shl_int (( 8 : int):ii) scale) in
   aarch64_memory_single_simdfp_immediate_signed_offset_normal acctype datasize memop n offset
     postindex t wback))))`;


(*val memory_single_general_register_aarch64_memory_single_general_register__decode : mword ty2 -> mword ty1 -> mword ty2 -> mword ty5 -> mword ty3 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_single_general_register_aarch64_memory_single_general_register__decode:(2)words$word ->(1)words$word ->(2)words$word ->(5)words$word ->(3)words$word ->(1)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 V1 b__1 Rm option_name S1 Rn Rt=
    (if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in sail2_state_monad$seqS
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (extend_type : ExtendType) = (DecodeRegExtend option_name) in
     let (shift : ii) = (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then (( 0 : int):ii) else (( 0 : int):ii)) in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (m : ii) = (lem$w2ui Rm) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_STORE in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_single_general_register AccType_NORMAL (( 8 : int):ii) extend_type m MemOp_STORE n F
       ((make_the_value (( 32 : int):ii)  :  32 itself)) shift F t F)))))
   else if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in sail2_state_monad$seqS
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (extend_type : ExtendType) = (DecodeRegExtend option_name) in
     let (shift : ii) = (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then (( 0 : int):ii) else (( 0 : int):ii)) in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (m : ii) = (lem$w2ui Rm) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_single_general_register AccType_NORMAL (( 8 : int):ii) extend_type m MemOp_LOAD n F
       ((make_the_value (( 32 : int):ii)  :  32 itself)) shift F t F)))))
   else if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in sail2_state_monad$seqS
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (extend_type : ExtendType) = (DecodeRegExtend option_name) in
     let (shift : ii) = (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then (( 0 : int):ii) else (( 0 : int):ii)) in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (m : ii) = (lem$w2ui Rm) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((F /\ F))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 64 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_single_general_register AccType_NORMAL (( 8 : int):ii) extend_type m MemOp_LOAD n F
       ((make_the_value (( 64 : int):ii)  :  64 itself)) shift T t F))))))
   else if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in sail2_state_monad$seqS
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (extend_type : ExtendType) = (DecodeRegExtend option_name) in
     let (shift : ii) = (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then (( 0 : int):ii) else (( 0 : int):ii)) in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (m : ii) = (lem$w2ui Rm) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((F /\ T))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 32 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_single_general_register AccType_NORMAL (( 8 : int):ii) extend_type m MemOp_LOAD n F
       ((make_the_value (( 32 : int):ii)  :  32 itself)) shift T t F))))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in sail2_state_monad$seqS
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (extend_type : ExtendType) = (DecodeRegExtend option_name) in
     let (shift : ii) = (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then (( 1 : int):ii) else (( 0 : int):ii)) in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (m : ii) = (lem$w2ui Rm) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_STORE in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_single_general_register AccType_NORMAL (( 16 : int):ii) extend_type m MemOp_STORE n F
       ((make_the_value (( 32 : int):ii)  :  32 itself)) shift F t F)))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in sail2_state_monad$seqS
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (extend_type : ExtendType) = (DecodeRegExtend option_name) in
     let (shift : ii) = (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then (( 1 : int):ii) else (( 0 : int):ii)) in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (m : ii) = (lem$w2ui Rm) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_single_general_register AccType_NORMAL (( 16 : int):ii) extend_type m MemOp_LOAD n F
       ((make_the_value (( 32 : int):ii)  :  32 itself)) shift F t F)))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in sail2_state_monad$seqS
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (extend_type : ExtendType) = (DecodeRegExtend option_name) in
     let (shift : ii) = (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then (( 1 : int):ii) else (( 0 : int):ii)) in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (m : ii) = (lem$w2ui Rm) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((F /\ F))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 64 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_single_general_register AccType_NORMAL (( 16 : int):ii) extend_type m MemOp_LOAD n F
       ((make_the_value (( 64 : int):ii)  :  64 itself)) shift T t F))))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in sail2_state_monad$seqS
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (extend_type : ExtendType) = (DecodeRegExtend option_name) in
     let (shift : ii) = (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then (( 1 : int):ii) else (( 0 : int):ii)) in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (m : ii) = (lem$w2ui Rm) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((F /\ T))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 32 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_single_general_register AccType_NORMAL (( 16 : int):ii) extend_type m MemOp_LOAD n F
       ((make_the_value (( 32 : int):ii)  :  32 itself)) shift T t F))))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in sail2_state_monad$seqS
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (extend_type : ExtendType) = (DecodeRegExtend option_name) in
     let (shift : ii) = (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then (( 2 : int):ii) else (( 0 : int):ii)) in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (m : ii) = (lem$w2ui Rm) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_STORE in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_single_general_register AccType_NORMAL (( 32 : int):ii) extend_type m MemOp_STORE n F
       ((make_the_value (( 32 : int):ii)  :  32 itself)) shift F t F)))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in sail2_state_monad$seqS
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (extend_type : ExtendType) = (DecodeRegExtend option_name) in
     let (shift : ii) = (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then (( 2 : int):ii) else (( 0 : int):ii)) in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (m : ii) = (lem$w2ui Rm) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_single_general_register AccType_NORMAL (( 32 : int):ii) extend_type m MemOp_LOAD n F
       ((make_the_value (( 32 : int):ii)  :  32 itself)) shift F t F)))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in sail2_state_monad$seqS
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (extend_type : ExtendType) = (DecodeRegExtend option_name) in
     let (shift : ii) = (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then (( 2 : int):ii) else (( 0 : int):ii)) in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (m : ii) = (lem$w2ui Rm) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((T /\ F))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 64 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_single_general_register AccType_NORMAL (( 32 : int):ii) extend_type m MemOp_LOAD n F
       ((make_the_value (( 64 : int):ii)  :  64 itself)) shift T t F))))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in sail2_state_monad$seqS
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (extend_type : ExtendType) = (DecodeRegExtend option_name) in
     let (shift : ii) = (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then (( 2 : int):ii) else (( 0 : int):ii)) in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (m : ii) = (lem$w2ui Rm) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((T /\ T))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 32 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_single_general_register AccType_NORMAL (( 32 : int):ii) extend_type m MemOp_LOAD n F
       ((make_the_value (( 32 : int):ii)  :  32 itself)) shift T t F))))))
   else if ((((((b__0 = (vec_of_bits [B1;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in sail2_state_monad$seqS
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (extend_type : ExtendType) = (DecodeRegExtend option_name) in
     let (shift : ii) = (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then (( 3 : int):ii) else (( 0 : int):ii)) in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (m : ii) = (lem$w2ui Rm) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_STORE in
     let regsize = ((( 64 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 64 : int):ii)) in
     aarch64_memory_single_general_register AccType_NORMAL (( 64 : int):ii) extend_type m MemOp_STORE n F
       ((make_the_value (( 64 : int):ii)  :  64 itself)) shift F t F)))))
   else if ((((((b__0 = (vec_of_bits [B1;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in sail2_state_monad$seqS
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (extend_type : ExtendType) = (DecodeRegExtend option_name) in
     let (shift : ii) = (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then (( 3 : int):ii) else (( 0 : int):ii)) in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (m : ii) = (lem$w2ui Rm) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in
     let regsize = ((( 64 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 64 : int):ii)) in
     aarch64_memory_single_general_register AccType_NORMAL (( 64 : int):ii) extend_type m MemOp_LOAD n F
       ((make_the_value (( 64 : int):ii)  :  64 itself)) shift F t F)))))
   else if ((((((b__0 = (vec_of_bits [B1;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in sail2_state_monad$seqS
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (extend_type : ExtendType) = (DecodeRegExtend option_name) in
     let (shift : ii) = (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then (( 3 : int):ii) else (( 0 : int):ii)) in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (m : ii) = (lem$w2ui Rm) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_PREFETCH in
     let (datasize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (w__0 : bool) . 
     aarch64_memory_single_general_register AccType_NORMAL (( 64 : int):ii) extend_type m MemOp_PREFETCH n
       F ((make_the_value (( 32 : int):ii)  :  32 itself)) shift w__0 t F))))))
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in sail2_state_monad$seqS
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (extend_type : ExtendType) = (DecodeRegExtend option_name) in
     let (shift : ii) = (if (((S1 = (vec_of_bits [B1]  :  1 words$word)))) then (( 3 : int):ii) else (( 0 : int):ii)) in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (m : ii) = (lem$w2ui Rm) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_PREFETCH in sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let (datasize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (w__1 : bool) . 
     aarch64_memory_single_general_register AccType_NORMAL (( 64 : int):ii) extend_type m MemOp_PREFETCH n
       F ((make_the_value (( 32 : int):ii)  :  32 itself)) shift w__1 t F)))))))))`;


(*val memory_single_general_immediate_unsigned_aarch64_memory_single_general_immediate_unsigned__decode : mword ty2 -> mword ty1 -> mword ty2 -> mword ty12 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_single_general_immediate_unsigned_aarch64_memory_single_general_immediate_unsigned__decode:(2)words$word ->(1)words$word ->(2)words$word ->(12)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 V1 b__1 imm12 Rn Rt=
    (if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__0 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__0 (( 0 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_STORE in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 8 : int):ii) MemOp_STORE n offset
       F ((make_the_value (( 32 : int):ii)  :  32 itself)) F t F))))))
   else if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__1 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__1 (( 0 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 8 : int):ii) MemOp_LOAD n offset
       F ((make_the_value (( 32 : int):ii)  :  32 itself)) F t F))))))
   else if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__2 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__2 (( 0 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((F /\ F))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 64 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 8 : int):ii) MemOp_LOAD n offset
       F ((make_the_value (( 64 : int):ii)  :  64 itself)) T t F)))))))
   else if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__3 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__3 (( 0 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((F /\ T))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 32 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 8 : int):ii) MemOp_LOAD n offset
       F ((make_the_value (( 32 : int):ii)  :  32 itself)) T t F)))))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__4 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__4 (( 1 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_STORE in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 16 : int):ii) MemOp_STORE n offset
       F ((make_the_value (( 32 : int):ii)  :  32 itself)) F t F))))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__5 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__5 (( 1 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 16 : int):ii) MemOp_LOAD n offset
       F ((make_the_value (( 32 : int):ii)  :  32 itself)) F t F))))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__6 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__6 (( 1 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((F /\ F))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 64 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 16 : int):ii) MemOp_LOAD n offset
       F ((make_the_value (( 64 : int):ii)  :  64 itself)) T t F)))))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__7 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__7 (( 1 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((F /\ T))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 32 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 16 : int):ii) MemOp_LOAD n offset
       F ((make_the_value (( 32 : int):ii)  :  32 itself)) T t F)))))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__8 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__8 (( 2 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_STORE in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 32 : int):ii) MemOp_STORE n offset
       F ((make_the_value (( 32 : int):ii)  :  32 itself)) F t F))))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__9 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__9 (( 2 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 32 : int):ii) MemOp_LOAD n offset
       F ((make_the_value (( 32 : int):ii)  :  32 itself)) F t F))))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__10 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__10 (( 2 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((T /\ F))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 64 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 32 : int):ii) MemOp_LOAD n offset
       F ((make_the_value (( 64 : int):ii)  :  64 itself)) T t F)))))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__11 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__11 (( 2 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((T /\ T))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 32 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 32 : int):ii) MemOp_LOAD n offset
       F ((make_the_value (( 32 : int):ii)  :  32 itself)) T t F)))))))
   else if ((((((b__0 = (vec_of_bits [B1;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__12 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__12 (( 3 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_STORE in
     let regsize = ((( 64 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 64 : int):ii)) in
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 64 : int):ii) MemOp_STORE n offset
       F ((make_the_value (( 64 : int):ii)  :  64 itself)) F t F))))))
   else if ((((((b__0 = (vec_of_bits [B1;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__13 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__13 (( 3 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in
     let regsize = ((( 64 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 64 : int):ii)) in
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 64 : int):ii) MemOp_LOAD n offset
       F ((make_the_value (( 64 : int):ii)  :  64 itself)) F t F))))))
   else if ((((((b__0 = (vec_of_bits [B1;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__14 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__14 (( 3 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_PREFETCH in
     let (datasize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (w__15 : bool) . 
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 64 : int):ii) MemOp_PREFETCH n offset
       F ((make_the_value (( 32 : int):ii)  :  32 itself)) w__15 t F)))))))
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__16 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__16 (( 3 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_PREFETCH in sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let (datasize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (w__17 : bool) . 
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 64 : int):ii) MemOp_PREFETCH n offset
       F ((make_the_value (( 32 : int):ii)  :  32 itself)) w__17 t F))))))))))`;


(*val memory_single_general_immediate_unsigned_aarch64_memory_single_general_immediate_signed_postidx__decode : mword ty2 -> mword ty1 -> mword ty2 -> mword ty12 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_single_general_immediate_unsigned_aarch64_memory_single_general_immediate_signed_postidx__decode:(2)words$word ->(1)words$word ->(2)words$word ->(12)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 V1 b__1 imm12 Rn Rt=
    (if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__0 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__0 (( 0 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_STORE in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 8 : int):ii) MemOp_STORE n
       offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) F t F))))))
   else if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__1 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__1 (( 0 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 8 : int):ii) MemOp_LOAD n
       offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) F t F))))))
   else if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__2 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__2 (( 0 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((F /\ F))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 64 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 8 : int):ii) MemOp_LOAD n
       offset F ((make_the_value (( 64 : int):ii)  :  64 itself)) T t F)))))))
   else if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__3 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__3 (( 0 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((F /\ T))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 32 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 8 : int):ii) MemOp_LOAD n
       offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) T t F)))))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__4 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__4 (( 1 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_STORE in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 16 : int):ii) MemOp_STORE n
       offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) F t F))))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__5 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__5 (( 1 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 16 : int):ii) MemOp_LOAD n
       offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) F t F))))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__6 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__6 (( 1 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((F /\ F))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 64 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 16 : int):ii) MemOp_LOAD n
       offset F ((make_the_value (( 64 : int):ii)  :  64 itself)) T t F)))))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__7 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__7 (( 1 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((F /\ T))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 32 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 16 : int):ii) MemOp_LOAD n
       offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) T t F)))))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__8 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__8 (( 2 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_STORE in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 32 : int):ii) MemOp_STORE n
       offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) F t F))))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__9 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__9 (( 2 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 32 : int):ii) MemOp_LOAD n
       offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) F t F))))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__10 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__10 (( 2 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((T /\ F))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 64 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 32 : int):ii) MemOp_LOAD n
       offset F ((make_the_value (( 64 : int):ii)  :  64 itself)) T t F)))))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__11 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__11 (( 2 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((T /\ T))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 32 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 32 : int):ii) MemOp_LOAD n
       offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) T t F)))))))
   else if ((((((b__0 = (vec_of_bits [B1;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__12 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__12 (( 3 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_STORE in
     let regsize = ((( 64 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 64 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 64 : int):ii) MemOp_STORE n
       offset F ((make_the_value (( 64 : int):ii)  :  64 itself)) F t F))))))
   else if ((((((b__0 = (vec_of_bits [B1;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__13 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__13 (( 3 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in
     let regsize = ((( 64 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 64 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 64 : int):ii) MemOp_LOAD n
       offset F ((make_the_value (( 64 : int):ii)  :  64 itself)) F t F))))))
   else if ((((((b__0 = (vec_of_bits [B1;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__14 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__14 (( 3 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let (datasize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (w__15 : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (w__16 : bool) . 
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 64 : int):ii) w__15 n offset
       F ((make_the_value (( 32 : int):ii)  :  32 itself)) w__16 t F)))))))))
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in sail2_state_monad$bindS
     (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__17 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__17 (( 3 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let (datasize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (w__18 : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (w__19 : bool) . 
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 64 : int):ii) w__18 n offset
       F ((make_the_value (( 32 : int):ii)  :  32 itself)) w__19 t F)))))))))))`;


(*val memory_single_general_immediate_signed_preidx_aarch64_memory_single_general_immediate_signed_postidx__decode : mword ty2 -> mword ty1 -> mword ty2 -> mword ty9 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_single_general_immediate_signed_preidx_aarch64_memory_single_general_immediate_signed_postidx__decode:(2)words$word ->(1)words$word ->(2)words$word ->(9)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 V1 b__1 imm9 Rn Rt=
    (if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_STORE in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 8 : int):ii) MemOp_STORE n
       offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) F t T)))))
   else if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 8 : int):ii) MemOp_LOAD n
       offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) F t T)))))
   else if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((F /\ F))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 64 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 8 : int):ii) MemOp_LOAD n
       offset F ((make_the_value (( 64 : int):ii)  :  64 itself)) T t T))))))
   else if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((F /\ T))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 32 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 8 : int):ii) MemOp_LOAD n
       offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) T t T))))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_STORE in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 16 : int):ii) MemOp_STORE n
       offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) F t T)))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 16 : int):ii) MemOp_LOAD n
       offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) F t T)))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((F /\ F))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 64 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 16 : int):ii) MemOp_LOAD n
       offset F ((make_the_value (( 64 : int):ii)  :  64 itself)) T t T))))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((F /\ T))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 32 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 16 : int):ii) MemOp_LOAD n
       offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) T t T))))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_STORE in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 32 : int):ii) MemOp_STORE n
       offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) F t T)))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 32 : int):ii) MemOp_LOAD n
       offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) F t T)))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((T /\ F))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 64 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 32 : int):ii) MemOp_LOAD n
       offset F ((make_the_value (( 64 : int):ii)  :  64 itself)) T t T))))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((T /\ T))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 32 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 32 : int):ii) MemOp_LOAD n
       offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) T t T))))))
   else if ((((((b__0 = (vec_of_bits [B1;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_STORE in
     let regsize = ((( 64 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 64 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 64 : int):ii) MemOp_STORE n
       offset F ((make_the_value (( 64 : int):ii)  :  64 itself)) F t T)))))
   else if ((((((b__0 = (vec_of_bits [B1;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in
     let regsize = ((( 64 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 64 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 64 : int):ii) MemOp_LOAD n
       offset F ((make_the_value (( 64 : int):ii)  :  64 itself)) F t T)))))
   else if ((((((b__0 = (vec_of_bits [B1;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let (datasize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (w__0 : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (w__1 : bool) . 
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 64 : int):ii) w__0 n offset
       F ((make_the_value (( 32 : int):ii)  :  32 itself)) w__1 t T))))))))
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let (datasize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (w__2 : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (w__3 : bool) . 
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 64 : int):ii) w__2 n offset
       F ((make_the_value (( 32 : int):ii)  :  32 itself)) w__3 t T))))))))))`;


(*val memory_single_general_immediate_signed_postidx_aarch64_memory_single_general_immediate_signed_postidx__decode : mword ty2 -> mword ty1 -> mword ty2 -> mword ty9 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_single_general_immediate_signed_postidx_aarch64_memory_single_general_immediate_signed_postidx__decode:(2)words$word ->(1)words$word ->(2)words$word ->(9)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 V1 b__1 imm9 Rn Rt=
    (if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = T in
     let (scale : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_STORE in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 8 : int):ii) MemOp_STORE n
       offset T ((make_the_value (( 32 : int):ii)  :  32 itself)) F t T)))))
   else if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = T in
     let (scale : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 8 : int):ii) MemOp_LOAD n
       offset T ((make_the_value (( 32 : int):ii)  :  32 itself)) F t T)))))
   else if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = T in
     let (scale : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((F /\ F))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 64 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 8 : int):ii) MemOp_LOAD n
       offset T ((make_the_value (( 64 : int):ii)  :  64 itself)) T t T))))))
   else if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = T in
     let (scale : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((F /\ T))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 32 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 8 : int):ii) MemOp_LOAD n
       offset T ((make_the_value (( 32 : int):ii)  :  32 itself)) T t T))))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = T in
     let (scale : ii) = ((( 1 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_STORE in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 16 : int):ii) MemOp_STORE n
       offset T ((make_the_value (( 32 : int):ii)  :  32 itself)) F t T)))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = T in
     let (scale : ii) = ((( 1 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 16 : int):ii) MemOp_LOAD n
       offset T ((make_the_value (( 32 : int):ii)  :  32 itself)) F t T)))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = T in
     let (scale : ii) = ((( 1 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((F /\ F))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 64 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 16 : int):ii) MemOp_LOAD n
       offset T ((make_the_value (( 64 : int):ii)  :  64 itself)) T t T))))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = T in
     let (scale : ii) = ((( 1 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((F /\ T))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 32 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 16 : int):ii) MemOp_LOAD n
       offset T ((make_the_value (( 32 : int):ii)  :  32 itself)) T t T))))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = T in
     let (scale : ii) = ((( 2 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_STORE in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 32 : int):ii) MemOp_STORE n
       offset T ((make_the_value (( 32 : int):ii)  :  32 itself)) F t T)))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = T in
     let (scale : ii) = ((( 2 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 32 : int):ii) MemOp_LOAD n
       offset T ((make_the_value (( 32 : int):ii)  :  32 itself)) F t T)))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = T in
     let (scale : ii) = ((( 2 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((T /\ F))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 64 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 32 : int):ii) MemOp_LOAD n
       offset T ((make_the_value (( 64 : int):ii)  :  64 itself)) T t T))))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = T in
     let (scale : ii) = ((( 2 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((T /\ T))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 32 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 32 : int):ii) MemOp_LOAD n
       offset T ((make_the_value (( 32 : int):ii)  :  32 itself)) T t T))))))
   else if ((((((b__0 = (vec_of_bits [B1;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = T in
     let (scale : ii) = ((( 3 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_STORE in
     let regsize = ((( 64 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 64 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 64 : int):ii) MemOp_STORE n
       offset T ((make_the_value (( 64 : int):ii)  :  64 itself)) F t T)))))
   else if ((((((b__0 = (vec_of_bits [B1;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = T in
     let (scale : ii) = ((( 3 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in
     let regsize = ((( 64 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 64 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 64 : int):ii) MemOp_LOAD n
       offset T ((make_the_value (( 64 : int):ii)  :  64 itself)) F t T)))))
   else if ((((((b__0 = (vec_of_bits [B1;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = T in
     let (scale : ii) = ((( 3 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let (datasize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (w__0 : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (w__1 : bool) . 
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 64 : int):ii) w__0 n offset
       T ((make_the_value (( 32 : int):ii)  :  32 itself)) w__1 t T))))))))
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = T in
     let (scale : ii) = ((( 3 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let (datasize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (w__2 : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (w__3 : bool) . 
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 64 : int):ii) w__2 n offset
       T ((make_the_value (( 32 : int):ii)  :  32 itself)) w__3 t T))))))))))`;


(*val memory_single_general_immediate_signed_pac_decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty9 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_single_general_immediate_signed_pac_decode:(2)words$word ->(1)words$word ->(1)words$word ->(1)words$word ->(9)words$word ->(1)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) size1 V1 M S1 imm9 W1 Rn Rt=  (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (if (((((~ ((HavePACExt () )))) \/ (((size1 <> (vec_of_bits [B1;B1]  :  2 words$word)))))))
    then
      UnallocatedEncoding () 
    else sail2_state_monad$returnS () ))
   (let (t : ii) = (lem$w2ui Rt) in
   let (n : ii) = (lem$w2ui Rn) in
   let (wback : bool) = (W1 = (vec_of_bits [B1]  :  1 words$word)) in
   let (use_key_a : bool) = (M = (vec_of_bits [B0]  :  1 words$word)) in
   let (S10 : 10 bits) = ((concat_vec S1 imm9  :  10 words$word)) in
   let (scale : ii) = ((( 3 : int):ii)) in sail2_state_monad$bindS
   (SignExtend__0 S10 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__0 :
      64 words$word) .  sail2_state_monad$bindS
   (LSL w__0 scale  : ( 64 words$word) M) (\ (offset : 64 bits) . 
   aarch64_memory_single_general_immediate_signed_pac n offset t use_key_a wback)))))`;


(*val memory_single_general_immediate_signed_offset_unpriv_aarch64_memory_single_general_immediate_signed_offset_unpriv__decode : mword ty2 -> mword ty1 -> mword ty2 -> mword ty9 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_single_general_immediate_signed_offset_unpriv_aarch64_memory_single_general_immediate_signed_offset_unpriv__decode:(2)words$word ->(1)words$word ->(2)words$word ->(9)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 V1 b__1 imm9 Rn Rt=
    (if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_UNPRIV in sail2_state_monad$bindS
     (sail2_state$and_boolS
       (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveNVExt () )) /\ ((HaveEL EL2))))))
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__0 : 64 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__0 (( 42 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
       ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__2 : 64 bits) . 
        sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__2 (( 43 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__3 : bool) . 
     let (acctype : AccType) = (if w__3 then AccType_NORMAL else acctype) in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_STORE in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 8 : int):ii) MemOp_STORE n
       offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) F t F))))))
   else if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_UNPRIV in sail2_state_monad$bindS
     (sail2_state$and_boolS
       (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveNVExt () )) /\ ((HaveEL EL2))))))
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__4 : 64 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__4 (( 42 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
       ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__6 : 64 bits) . 
        sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__6 (( 43 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__7 : bool) . 
     let (acctype : AccType) = (if w__7 then AccType_NORMAL else acctype) in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 8 : int):ii) MemOp_LOAD n offset
       F ((make_the_value (( 32 : int):ii)  :  32 itself)) F t F))))))
   else if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_UNPRIV in sail2_state_monad$bindS
     (sail2_state$and_boolS
       (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveNVExt () )) /\ ((HaveEL EL2))))))
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__8 : 64 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__8 (( 42 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
       ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__10 : 64 bits) . 
        sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__10 (( 43 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__11 : bool) . 
     let (acctype : AccType) = (if w__11 then AccType_NORMAL else acctype) in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((F /\ F))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 64 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 8 : int):ii) MemOp_LOAD n offset
       F ((make_the_value (( 64 : int):ii)  :  64 itself)) T t F)))))))
   else if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_UNPRIV in sail2_state_monad$bindS
     (sail2_state$and_boolS
       (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveNVExt () )) /\ ((HaveEL EL2))))))
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__12 : 64 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__12 (( 42 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
       ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__14 : 64 bits) . 
        sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__14 (( 43 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__15 : bool) . 
     let (acctype : AccType) = (if w__15 then AccType_NORMAL else acctype) in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((F /\ T))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 32 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 8 : int):ii) MemOp_LOAD n offset
       F ((make_the_value (( 32 : int):ii)  :  32 itself)) T t F)))))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_UNPRIV in sail2_state_monad$bindS
     (sail2_state$and_boolS
       (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveNVExt () )) /\ ((HaveEL EL2))))))
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__16 : 64 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__16 (( 42 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
       ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__18 : 64 bits) . 
        sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__18 (( 43 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__19 : bool) . 
     let (acctype : AccType) = (if w__19 then AccType_NORMAL else acctype) in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_STORE in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 16 : int):ii) MemOp_STORE n
       offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) F t F))))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_UNPRIV in sail2_state_monad$bindS
     (sail2_state$and_boolS
       (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveNVExt () )) /\ ((HaveEL EL2))))))
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__20 : 64 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__20 (( 42 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
       ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__22 : 64 bits) . 
        sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__22 (( 43 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__23 : bool) . 
     let (acctype : AccType) = (if w__23 then AccType_NORMAL else acctype) in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 16 : int):ii) MemOp_LOAD n
       offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) F t F))))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_UNPRIV in sail2_state_monad$bindS
     (sail2_state$and_boolS
       (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveNVExt () )) /\ ((HaveEL EL2))))))
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__24 : 64 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__24 (( 42 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
       ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__26 : 64 bits) . 
        sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__26 (( 43 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__27 : bool) . 
     let (acctype : AccType) = (if w__27 then AccType_NORMAL else acctype) in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((F /\ F))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 64 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 16 : int):ii) MemOp_LOAD n
       offset F ((make_the_value (( 64 : int):ii)  :  64 itself)) T t F)))))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_UNPRIV in sail2_state_monad$bindS
     (sail2_state$and_boolS
       (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveNVExt () )) /\ ((HaveEL EL2))))))
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__28 : 64 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__28 (( 42 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
       ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__30 : 64 bits) . 
        sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__30 (( 43 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__31 : bool) . 
     let (acctype : AccType) = (if w__31 then AccType_NORMAL else acctype) in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((F /\ T))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 32 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 16 : int):ii) MemOp_LOAD n
       offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) T t F)))))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_UNPRIV in sail2_state_monad$bindS
     (sail2_state$and_boolS
       (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveNVExt () )) /\ ((HaveEL EL2))))))
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__32 : 64 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__32 (( 42 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
       ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__34 : 64 bits) . 
        sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__34 (( 43 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__35 : bool) . 
     let (acctype : AccType) = (if w__35 then AccType_NORMAL else acctype) in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_STORE in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 32 : int):ii) MemOp_STORE n
       offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) F t F))))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_UNPRIV in sail2_state_monad$bindS
     (sail2_state$and_boolS
       (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveNVExt () )) /\ ((HaveEL EL2))))))
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__36 : 64 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__36 (( 42 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
       ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__38 : 64 bits) . 
        sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__38 (( 43 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__39 : bool) . 
     let (acctype : AccType) = (if w__39 then AccType_NORMAL else acctype) in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 32 : int):ii) MemOp_LOAD n
       offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) F t F))))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_UNPRIV in sail2_state_monad$bindS
     (sail2_state$and_boolS
       (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveNVExt () )) /\ ((HaveEL EL2))))))
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__40 : 64 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__40 (( 42 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
       ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__42 : 64 bits) . 
        sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__42 (( 43 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__43 : bool) . 
     let (acctype : AccType) = (if w__43 then AccType_NORMAL else acctype) in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((T /\ F))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 64 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 32 : int):ii) MemOp_LOAD n
       offset F ((make_the_value (( 64 : int):ii)  :  64 itself)) T t F)))))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_UNPRIV in sail2_state_monad$bindS
     (sail2_state$and_boolS
       (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveNVExt () )) /\ ((HaveEL EL2))))))
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__44 : 64 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__44 (( 42 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
       ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__46 : 64 bits) . 
        sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__46 (( 43 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__47 : bool) . 
     let (acctype : AccType) = (if w__47 then AccType_NORMAL else acctype) in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((T /\ T))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 32 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 32 : int):ii) MemOp_LOAD n
       offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) T t F)))))))
   else if ((((((b__0 = (vec_of_bits [B1;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_UNPRIV in sail2_state_monad$bindS
     (sail2_state$and_boolS
       (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveNVExt () )) /\ ((HaveEL EL2))))))
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__48 : 64 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__48 (( 42 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
       ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__50 : 64 bits) . 
        sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__50 (( 43 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__51 : bool) . 
     let (acctype : AccType) = (if w__51 then AccType_NORMAL else acctype) in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_STORE in
     let regsize = ((( 64 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 64 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 64 : int):ii) MemOp_STORE n
       offset F ((make_the_value (( 64 : int):ii)  :  64 itself)) F t F))))))
   else if ((((((b__0 = (vec_of_bits [B1;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_UNPRIV in sail2_state_monad$bindS
     (sail2_state$and_boolS
       (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveNVExt () )) /\ ((HaveEL EL2))))))
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__52 : 64 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__52 (( 42 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
       ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__54 : 64 bits) . 
        sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__54 (( 43 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__55 : bool) . 
     let (acctype : AccType) = (if w__55 then AccType_NORMAL else acctype) in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in
     let regsize = ((( 64 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 64 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 64 : int):ii) MemOp_LOAD n
       offset F ((make_the_value (( 64 : int):ii)  :  64 itself)) F t F))))))
   else if ((((((b__0 = (vec_of_bits [B1;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_UNPRIV in sail2_state_monad$bindS
     (sail2_state$and_boolS
       (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveNVExt () )) /\ ((HaveEL EL2))))))
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__56 : 64 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__56 (( 42 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
       ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__58 : 64 bits) . 
        sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__58 (( 43 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__59 : bool) . 
     let (acctype : AccType) = (if w__59 then AccType_NORMAL else acctype) in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let (datasize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (w__60 : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (w__61 : bool) . 
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 64 : int):ii) w__60 n offset
       F ((make_the_value (( 32 : int):ii)  :  32 itself)) w__61 t F)))))))))
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_UNPRIV in sail2_state_monad$bindS
     (sail2_state$and_boolS
       (sail2_state$and_boolS (sail2_state_monad$returnS (((((HaveNVExt () )) /\ ((HaveEL EL2))))))
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__62 : 64 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__62 (( 42 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
       ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__64 : 64 bits) . 
        sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__64 (( 43 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__65 : bool) . 
     let (acctype : AccType) = (if w__65 then AccType_NORMAL else acctype) in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) .  sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let (datasize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (w__66 : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (w__67 : bool) . 
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 64 : int):ii) w__66 n offset
       F ((make_the_value (( 32 : int):ii)  :  32 itself)) w__67 t F)))))))))))`;


(*val memory_single_general_immediate_signed_offset_normal_aarch64_memory_single_general_immediate_signed_offset_normal__decode : mword ty2 -> mword ty1 -> mword ty2 -> mword ty9 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_single_general_immediate_signed_offset_normal_aarch64_memory_single_general_immediate_signed_offset_normal__decode:(2)words$word ->(1)words$word ->(2)words$word ->(9)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 V1 b__1 imm9 Rn Rt=
    (if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_STORE in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 8 : int):ii) MemOp_STORE
       n offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) F t F)))))
   else if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 8 : int):ii) MemOp_LOAD n
       offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) F t F)))))
   else if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((F /\ F))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 64 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 8 : int):ii) MemOp_LOAD n
       offset F ((make_the_value (( 64 : int):ii)  :  64 itself)) T t F))))))
   else if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((F /\ T))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 32 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 8 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 8 : int):ii) MemOp_LOAD n
       offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) T t F))))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_STORE in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 16 : int):ii) MemOp_STORE
       n offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) F t F)))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 16 : int):ii) MemOp_LOAD
       n offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) F t F)))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((F /\ F))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 64 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 16 : int):ii) MemOp_LOAD
       n offset F ((make_the_value (( 64 : int):ii)  :  64 itself)) T t F))))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 1 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((F /\ T))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 32 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 16 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 16 : int):ii) MemOp_LOAD
       n offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) T t F))))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_STORE in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 32 : int):ii) MemOp_STORE
       n offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) F t F)))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in
     let regsize = ((( 32 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 32 : int):ii) MemOp_LOAD
       n offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) F t F)))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((T /\ F))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 64 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 32 : int):ii) MemOp_LOAD
       n offset F ((make_the_value (( 64 : int):ii)  :  64 itself)) T t F))))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in sail2_state_monad$seqS
     (if (((T /\ T))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let regsize = ((( 32 : int):ii)) in
     let signed = T in
     let (datasize : ii) = ((( 32 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 32 : int):ii) MemOp_LOAD
       n offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) T t F))))))
   else if ((((((b__0 = (vec_of_bits [B1;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_STORE in
     let regsize = ((( 64 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 64 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 64 : int):ii) MemOp_STORE
       n offset F ((make_the_value (( 64 : int):ii)  :  64 itself)) F t F)))))
   else if ((((((b__0 = (vec_of_bits [B1;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_LOAD in
     let regsize = ((( 64 : int):ii)) in
     let signed = F in
     let (datasize : ii) = ((( 64 : int):ii)) in
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 64 : int):ii) MemOp_LOAD
       n offset F ((make_the_value (( 64 : int):ii)  :  64 itself)) F t F)))))
   else if ((((((b__0 = (vec_of_bits [B1;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_PREFETCH in
     let (datasize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (w__0 : bool) . 
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 64 : int):ii)
       MemOp_PREFETCH n offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) w__0 t F))))))
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm9 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (offset : 64
       bits) . 
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (acctype : AccType) = AccType_NORMAL in sail2_state_monad$bindS
     (undefined_MemOp () ) (\ (memop : MemOp) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (signed : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (regsize : ii) . 
     let memop = MemOp_PREFETCH in sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let (datasize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (w__1 : bool) . 
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 64 : int):ii)
       MemOp_PREFETCH n offset F ((make_the_value (( 32 : int):ii)  :  32 itself)) w__1 t F)))))))))`;


(*val memory_pair_simdfp_preidx_aarch64_memory_pair_simdfp_postidx__decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty7 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_pair_simdfp_preidx_aarch64_memory_pair_simdfp_postidx__decode:(2)words$word ->(1)words$word ->(1)words$word ->(7)words$word ->(5)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 V1 L imm7 Rt2 Rn Rt=
    (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = F in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_VEC in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (datasize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__0 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__0 (( 2 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_simdfp_postidx AccType_VEC ((make_the_value (( 32 : int):ii)  :  32 itself)) memop
       n offset F t t2 T)))
   else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = F in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_VEC in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (datasize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__1 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__1 (( 3 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_simdfp_postidx AccType_VEC ((make_the_value (( 64 : int):ii)  :  64 itself)) memop
       n offset F t t2 T)))
   else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = F in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_VEC in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (scale : ii) = ((( 4 : int):ii)) in
     let (datasize : ii) = ((( 128 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__2 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__2 (( 4 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_simdfp_postidx AccType_VEC ((make_the_value (( 128 : int):ii)  :  128 itself))
       memop n offset F t t2 T)))
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = F in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_VEC in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let (scale : ii) = ((( 5 : int):ii)) in
     let (datasize : ii) = ((( 256 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__3 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__3 (( 5 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_simdfp_postidx AccType_VEC ((make_the_value (( 256 : int):ii)  :  256 itself))
       memop n offset F t t2 T))))))`;


(*val memory_pair_simdfp_postidx_aarch64_memory_pair_simdfp_postidx__decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty7 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_pair_simdfp_postidx_aarch64_memory_pair_simdfp_postidx__decode:(2)words$word ->(1)words$word ->(1)words$word ->(7)words$word ->(5)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 V1 L imm7 Rt2 Rn Rt=
    (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = T in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_VEC in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (datasize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__0 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__0 (( 2 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_simdfp_postidx AccType_VEC ((make_the_value (( 32 : int):ii)  :  32 itself)) memop
       n offset T t t2 T)))
   else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = T in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_VEC in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (datasize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__1 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__1 (( 3 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_simdfp_postidx AccType_VEC ((make_the_value (( 64 : int):ii)  :  64 itself)) memop
       n offset T t t2 T)))
   else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = T in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_VEC in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (scale : ii) = ((( 4 : int):ii)) in
     let (datasize : ii) = ((( 128 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__2 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__2 (( 4 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_simdfp_postidx AccType_VEC ((make_the_value (( 128 : int):ii)  :  128 itself))
       memop n offset T t t2 T)))
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = T in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_VEC in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let (scale : ii) = ((( 5 : int):ii)) in
     let (datasize : ii) = ((( 256 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__3 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__3 (( 5 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_simdfp_postidx AccType_VEC ((make_the_value (( 256 : int):ii)  :  256 itself))
       memop n offset T t t2 T))))))`;


(*val memory_pair_simdfp_offset_aarch64_memory_pair_simdfp_postidx__decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty7 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_pair_simdfp_offset_aarch64_memory_pair_simdfp_postidx__decode:(2)words$word ->(1)words$word ->(1)words$word ->(7)words$word ->(5)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 V1 L imm7 Rt2 Rn Rt=
    (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_VEC in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (datasize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__0 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__0 (( 2 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_simdfp_postidx AccType_VEC ((make_the_value (( 32 : int):ii)  :  32 itself)) memop
       n offset F t t2 F)))
   else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_VEC in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (datasize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__1 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__1 (( 3 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_simdfp_postidx AccType_VEC ((make_the_value (( 64 : int):ii)  :  64 itself)) memop
       n offset F t t2 F)))
   else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_VEC in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (scale : ii) = ((( 4 : int):ii)) in
     let (datasize : ii) = ((( 128 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__2 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__2 (( 4 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_simdfp_postidx AccType_VEC ((make_the_value (( 128 : int):ii)  :  128 itself))
       memop n offset F t t2 F)))
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_VEC in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let (scale : ii) = ((( 5 : int):ii)) in
     let (datasize : ii) = ((( 256 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__3 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__3 (( 5 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_simdfp_postidx AccType_VEC ((make_the_value (( 256 : int):ii)  :  256 itself))
       memop n offset F t t2 F))))))`;


(*val memory_pair_simdfp_noalloc_aarch64_memory_pair_simdfp_noalloc__decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty7 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_pair_simdfp_noalloc_aarch64_memory_pair_simdfp_noalloc__decode:(2)words$word ->(1)words$word ->(1)words$word ->(7)words$word ->(5)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 V1 L imm7 Rt2 Rn Rt=
    (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_VECSTREAM in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (datasize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__0 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__0 (( 2 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_simdfp_noalloc AccType_VECSTREAM ((make_the_value (( 32 : int):ii)  :  32 itself))
       memop n offset F t t2 F)))
   else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_VECSTREAM in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (datasize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__1 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__1 (( 3 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_simdfp_noalloc AccType_VECSTREAM ((make_the_value (( 64 : int):ii)  :  64 itself))
       memop n offset F t t2 F)))
   else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_VECSTREAM in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (scale : ii) = ((( 4 : int):ii)) in
     let (datasize : ii) = ((( 128 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__2 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__2 (( 4 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_simdfp_noalloc AccType_VECSTREAM
       ((make_the_value (( 128 : int):ii)  :  128 itself)) memop n offset F t t2 F)))
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_VECSTREAM in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let (scale : ii) = ((( 5 : int):ii)) in
     let (datasize : ii) = ((( 256 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__3 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__3 (( 5 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_simdfp_noalloc AccType_VECSTREAM
       ((make_the_value (( 256 : int):ii)  :  256 itself)) memop n offset F t t2 F))))))`;


(*val memory_pair_general_preidx_aarch64_memory_pair_general_postidx__decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty7 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_pair_general_preidx_aarch64_memory_pair_general_postidx__decode:(2)words$word ->(1)words$word ->(1)words$word ->(7)words$word ->(5)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 V1 L imm7 Rt2 Rn Rt=
    (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = F in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_NORMAL in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in sail2_state_monad$seqS
     (if ((((((((concat_vec L (vec_of_bits [B0]  :  1 words$word)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))) \/ F))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (signed : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (datasize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__0 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__0 (( 2 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_general_postidx AccType_NORMAL ((make_the_value (( 32 : int):ii)  :  32 itself))
       memop n offset F F t t2 T))))
   else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = F in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_NORMAL in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in sail2_state_monad$seqS
     (if ((((((((concat_vec L (vec_of_bits [B1]  :  1 words$word)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))) \/ F))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (signed : bool) = T in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (datasize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__1 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__1 (( 2 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_general_postidx AccType_NORMAL ((make_the_value (( 32 : int):ii)  :  32 itself))
       memop n offset F T t t2 T))))
   else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = F in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_NORMAL in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in sail2_state_monad$seqS
     (if ((((((((concat_vec L (vec_of_bits [B0]  :  1 words$word)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))) \/ F))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (signed : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (datasize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__2 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__2 (( 3 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_general_postidx AccType_NORMAL ((make_the_value (( 64 : int):ii)  :  64 itself))
       memop n offset F F t t2 T))))
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = F in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_NORMAL in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in sail2_state_monad$seqS
     (if ((((((((concat_vec L (vec_of_bits [B1]  :  1 words$word)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))) \/ T))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (signed : bool) = T in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (datasize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__3 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__3 (( 3 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_general_postidx AccType_NORMAL ((make_the_value (( 64 : int):ii)  :  64 itself))
       memop n offset F T t t2 T))))))`;


(*val memory_pair_general_postidx_aarch64_memory_pair_general_postidx__decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty7 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_pair_general_postidx_aarch64_memory_pair_general_postidx__decode:(2)words$word ->(1)words$word ->(1)words$word ->(7)words$word ->(5)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 V1 L imm7 Rt2 Rn Rt=
    (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = T in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_NORMAL in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in sail2_state_monad$seqS
     (if ((((((((concat_vec L (vec_of_bits [B0]  :  1 words$word)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))) \/ F))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (signed : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (datasize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__0 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__0 (( 2 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_general_postidx AccType_NORMAL ((make_the_value (( 32 : int):ii)  :  32 itself))
       memop n offset T F t t2 T))))
   else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = T in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_NORMAL in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in sail2_state_monad$seqS
     (if ((((((((concat_vec L (vec_of_bits [B1]  :  1 words$word)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))) \/ F))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (signed : bool) = T in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (datasize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__1 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__1 (( 2 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_general_postidx AccType_NORMAL ((make_the_value (( 32 : int):ii)  :  32 itself))
       memop n offset T T t t2 T))))
   else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = T in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_NORMAL in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in sail2_state_monad$seqS
     (if ((((((((concat_vec L (vec_of_bits [B0]  :  1 words$word)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))) \/ F))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (signed : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (datasize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__2 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__2 (( 3 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_general_postidx AccType_NORMAL ((make_the_value (( 64 : int):ii)  :  64 itself))
       memop n offset T F t t2 T))))
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = T in
     let (postindex : bool) = T in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_NORMAL in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in sail2_state_monad$seqS
     (if ((((((((concat_vec L (vec_of_bits [B1]  :  1 words$word)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))) \/ T))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (signed : bool) = T in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (datasize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__3 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__3 (( 3 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_general_postidx AccType_NORMAL ((make_the_value (( 64 : int):ii)  :  64 itself))
       memop n offset T T t t2 T))))))`;


(*val memory_pair_general_offset_aarch64_memory_pair_general_postidx__decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty7 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_pair_general_offset_aarch64_memory_pair_general_postidx__decode:(2)words$word ->(1)words$word ->(1)words$word ->(7)words$word ->(5)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 V1 L imm7 Rt2 Rn Rt=
    (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_NORMAL in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in sail2_state_monad$seqS
     (if ((((((((concat_vec L (vec_of_bits [B0]  :  1 words$word)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))) \/ F))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (signed : bool) = F in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (datasize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__0 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__0 (( 2 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_general_postidx AccType_NORMAL ((make_the_value (( 32 : int):ii)  :  32 itself))
       memop n offset F F t t2 F))))
   else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_NORMAL in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in sail2_state_monad$seqS
     (if ((((((((concat_vec L (vec_of_bits [B1]  :  1 words$word)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))) \/ F))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (signed : bool) = T in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (datasize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__1 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__1 (( 2 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_general_postidx AccType_NORMAL ((make_the_value (( 32 : int):ii)  :  32 itself))
       memop n offset F T t t2 F))))
   else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_NORMAL in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in sail2_state_monad$seqS
     (if ((((((((concat_vec L (vec_of_bits [B0]  :  1 words$word)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))) \/ F))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (signed : bool) = F in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (datasize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__2 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__2 (( 3 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_general_postidx AccType_NORMAL ((make_the_value (( 64 : int):ii)  :  64 itself))
       memop n offset F F t t2 F))))
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_NORMAL in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in sail2_state_monad$seqS
     (if ((((((((concat_vec L (vec_of_bits [B1]  :  1 words$word)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))) \/ T))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (signed : bool) = T in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (datasize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__3 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__3 (( 3 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_general_postidx AccType_NORMAL ((make_the_value (( 64 : int):ii)  :  64 itself))
       memop n offset F T t t2 F))))))`;


(*val memory_pair_general_noalloc_aarch64_memory_pair_general_noalloc__decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty7 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_pair_general_noalloc_aarch64_memory_pair_general_noalloc__decode:(2)words$word ->(1)words$word ->(1)words$word ->(7)words$word ->(5)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 V1 L imm7 Rt2 Rn Rt=
    (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_STREAM in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (scale : ii) = ((( 2 : int):ii)) in
     let (datasize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__0 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__0 (( 2 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_general_noalloc AccType_STREAM ((make_the_value (( 32 : int):ii)  :  32 itself))
       memop n offset F t t2 F)))
   else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_STREAM in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let (scale : ii) = ((( 2 : int):ii)) in
     let (datasize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__1 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__1 (( 2 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_general_noalloc AccType_STREAM ((make_the_value (( 32 : int):ii)  :  32 itself))
       memop n offset F t t2 F))))
   else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_STREAM in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (scale : ii) = ((( 3 : int):ii)) in
     let (datasize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__2 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__2 (( 3 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_general_noalloc AccType_STREAM ((make_the_value (( 64 : int):ii)  :  64 itself))
       memop n offset F t t2 F)))
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (wback : bool) = F in
     let (postindex : bool) = F in
     let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (t2 : ii) = (lem$w2ui Rt2) in
     let (acctype : AccType) = AccType_STREAM in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (let (scale : ii) = ((( 3 : int):ii)) in
     let (datasize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (SignExtend__0 imm7 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M) (\ (w__3 :
        64 words$word) .  sail2_state_monad$bindS
     (LSL w__3 (( 3 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
     aarch64_memory_pair_general_noalloc AccType_STREAM ((make_the_value (( 64 : int):ii)  :  64 itself))
       memop n offset F t t2 F))))))`;


(*val memory_literal_simdfp_decode : mword ty2 -> mword ty1 -> mword ty19 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_literal_simdfp_decode:(2)words$word ->(1)words$word ->(19)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) opc V1 imm19 Rt=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (t : ii) = (lem$w2ui Rt) in sail2_state_monad$bindS
   (undefined_int () ) (\ (size1 : ii) .  sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (offset : 64 bits) . 
   let b__0 = opc in sail2_state_monad$bindS
   (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$returnS (( 4 : int):ii)
    else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$returnS (( 8 : int):ii)
    else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$returnS (( 16 : int):ii)
    else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS size1)) (\ (size1 : ii) .  sail2_state_monad$bindS
   (SignExtend__0 ((concat_vec imm19 (vec_of_bits [B0;B0]  :  2 words$word)  :  21 words$word))
      ((make_the_value (( 64 : int):ii)  :  64 itself))
     : ( 64 words$word) M) (\ (w__0 : 64 bits) . 
   let offset = w__0 in
   aarch64_memory_literal_simdfp offset ((ex_int size1)) t)))))))`;


(*val memory_atomicops_swp_decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty3 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_atomicops_swp_decode:(2)words$word ->(1)words$word ->(1)words$word ->(1)words$word ->(5)words$word ->(1)words$word ->(3)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 V1 A R1 Rs o3 opc Rn Rt=
    (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (if ((~ ((HaveAtomicExt () )))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (s : ii) = (lem$w2ui Rs) in
     let (datasize : ii) = ((( 8 : int):ii)) in
     let (regsize : ii) = ((( 32 : int):ii)) in
     let (ldacctype : AccType) =
       (if ((((((A = (vec_of_bits [B1]  :  1 words$word)))) /\ (((Rt <> (vec_of_bits [B1;B1;B1;B1;B1]  :  5 words$word))))))) then
         AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     let (stacctype : AccType) =
       (if (((R1 = (vec_of_bits [B1]  :  1 words$word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     aarch64_memory_atomicops_swp (( 8 : int):ii) ldacctype n ((make_the_value (( 32 : int):ii)  :  32 itself)) s
       stacctype t)
   else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (if ((~ ((HaveAtomicExt () )))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (s : ii) = (lem$w2ui Rs) in
     let (datasize : ii) = ((( 16 : int):ii)) in
     let (regsize : ii) = ((( 32 : int):ii)) in
     let (ldacctype : AccType) =
       (if ((((((A = (vec_of_bits [B1]  :  1 words$word)))) /\ (((Rt <> (vec_of_bits [B1;B1;B1;B1;B1]  :  5 words$word))))))) then
         AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     let (stacctype : AccType) =
       (if (((R1 = (vec_of_bits [B1]  :  1 words$word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     aarch64_memory_atomicops_swp (( 16 : int):ii) ldacctype n ((make_the_value (( 32 : int):ii)  :  32 itself)) s
       stacctype t)
   else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (if ((~ ((HaveAtomicExt () )))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (s : ii) = (lem$w2ui Rs) in
     let (datasize : ii) = ((( 32 : int):ii)) in
     let (regsize : ii) = ((( 32 : int):ii)) in
     let (ldacctype : AccType) =
       (if ((((((A = (vec_of_bits [B1]  :  1 words$word)))) /\ (((Rt <> (vec_of_bits [B1;B1;B1;B1;B1]  :  5 words$word))))))) then
         AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     let (stacctype : AccType) =
       (if (((R1 = (vec_of_bits [B1]  :  1 words$word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     aarch64_memory_atomicops_swp (( 32 : int):ii) ldacctype n ((make_the_value (( 32 : int):ii)  :  32 itself)) s
       stacctype t)
   else sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (if ((~ ((HaveAtomicExt () )))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (s : ii) = (lem$w2ui Rs) in
     let (datasize : ii) = ((( 64 : int):ii)) in
     let (regsize : ii) = ((( 64 : int):ii)) in
     let (ldacctype : AccType) =
       (if ((((((A = (vec_of_bits [B1]  :  1 words$word)))) /\ (((Rt <> (vec_of_bits [B1;B1;B1;B1;B1]  :  5 words$word))))))) then
         AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     let (stacctype : AccType) =
       (if (((R1 = (vec_of_bits [B1]  :  1 words$word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     aarch64_memory_atomicops_swp (( 64 : int):ii) ldacctype n ((make_the_value (( 64 : int):ii)  :  64 itself)) s
       stacctype t)))`;


(*val memory_atomicops_st_decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty3 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_atomicops_st_decode:(2)words$word ->(1)words$word ->(1)words$word ->(1)words$word ->(5)words$word ->(1)words$word ->(3)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) size1 V1 A R1 Rs o3 opc Rn Rt=  (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (if ((~ ((HaveAtomicExt () )))) then UnallocatedEncoding () 
    else sail2_state_monad$returnS () ))
   (let (n : ii) = (lem$w2ui Rn) in
   let (s : ii) = (lem$w2ui Rs) in
   let (datasize : ii) = (shl_int (( 8 : int):ii) ((lem$w2ui size1))) in
   let (regsize : ii) = (if (((((ex_int datasize)) = (( 64 : int):ii)))) then (( 64 : int):ii) else (( 32 : int):ii)) in
   let (ldacctype : AccType) = AccType_ATOMICRW in
   let (stacctype : AccType) =
     (if (((R1 = (vec_of_bits [B1]  :  1 words$word)))) then AccType_ORDEREDRW
     else AccType_ATOMICRW) in sail2_state_monad$bindS
   (undefined_MemAtomicOp () ) (\ (op : MemAtomicOp) . 
   let b__0 = opc in
   let (op : MemAtomicOp) =
     (if (((b__0 = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) then MemAtomicOp_ADD
     else if (((b__0 = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) then MemAtomicOp_BIC
     else if (((b__0 = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) then MemAtomicOp_EOR
     else if (((b__0 = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) then MemAtomicOp_ORR
     else if (((b__0 = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) then MemAtomicOp_SMAX
     else if (((b__0 = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) then MemAtomicOp_SMIN
     else if (((b__0 = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) then MemAtomicOp_UMAX
     else MemAtomicOp_UMIN) in
   aarch64_memory_atomicops_st datasize ldacctype n op s stacctype))))`;


(*val memory_atomicops_ld_decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty3 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_atomicops_ld_decode:(2)words$word ->(1)words$word ->(1)words$word ->(1)words$word ->(5)words$word ->(1)words$word ->(3)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 V1 A R1 Rs o3 opc Rn Rt=
    (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (if ((~ ((HaveAtomicExt () )))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (s : ii) = (lem$w2ui Rs) in
     let (datasize : ii) = ((( 8 : int):ii)) in
     let (regsize : ii) = ((( 32 : int):ii)) in
     let (ldacctype : AccType) =
       (if ((((((A = (vec_of_bits [B1]  :  1 words$word)))) /\ (((Rt <> (vec_of_bits [B1;B1;B1;B1;B1]  :  5 words$word))))))) then
         AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     let (stacctype : AccType) =
       (if (((R1 = (vec_of_bits [B1]  :  1 words$word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in sail2_state_monad$bindS
     (undefined_MemAtomicOp () ) (\ (op : MemAtomicOp) . 
     let b__1 = opc in
     let (op : MemAtomicOp) =
       (if (((b__1 = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) then MemAtomicOp_ADD
       else if (((b__1 = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) then MemAtomicOp_BIC
       else if (((b__1 = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) then MemAtomicOp_EOR
       else if (((b__1 = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) then MemAtomicOp_ORR
       else if (((b__1 = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) then MemAtomicOp_SMAX
       else if (((b__1 = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) then MemAtomicOp_SMIN
       else if (((b__1 = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) then MemAtomicOp_UMAX
       else MemAtomicOp_UMIN) in
     aarch64_memory_atomicops_ld (( 8 : int):ii) ldacctype n op ((make_the_value (( 32 : int):ii)  :  32 itself)) s
       stacctype t))
   else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (if ((~ ((HaveAtomicExt () )))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (s : ii) = (lem$w2ui Rs) in
     let (datasize : ii) = ((( 16 : int):ii)) in
     let (regsize : ii) = ((( 32 : int):ii)) in
     let (ldacctype : AccType) =
       (if ((((((A = (vec_of_bits [B1]  :  1 words$word)))) /\ (((Rt <> (vec_of_bits [B1;B1;B1;B1;B1]  :  5 words$word))))))) then
         AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     let (stacctype : AccType) =
       (if (((R1 = (vec_of_bits [B1]  :  1 words$word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in sail2_state_monad$bindS
     (undefined_MemAtomicOp () ) (\ (op : MemAtomicOp) . 
     let b__10 = opc in
     let (op : MemAtomicOp) =
       (if (((b__10 = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) then MemAtomicOp_ADD
       else if (((b__10 = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) then MemAtomicOp_BIC
       else if (((b__10 = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) then MemAtomicOp_EOR
       else if (((b__10 = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) then MemAtomicOp_ORR
       else if (((b__10 = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) then MemAtomicOp_SMAX
       else if (((b__10 = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) then MemAtomicOp_SMIN
       else if (((b__10 = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) then MemAtomicOp_UMAX
       else MemAtomicOp_UMIN) in
     aarch64_memory_atomicops_ld (( 16 : int):ii) ldacctype n op ((make_the_value (( 32 : int):ii)  :  32 itself)) s
       stacctype t))
   else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (if ((~ ((HaveAtomicExt () )))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (s : ii) = (lem$w2ui Rs) in
     let (datasize : ii) = ((( 32 : int):ii)) in
     let (regsize : ii) = ((( 32 : int):ii)) in
     let (ldacctype : AccType) =
       (if ((((((A = (vec_of_bits [B1]  :  1 words$word)))) /\ (((Rt <> (vec_of_bits [B1;B1;B1;B1;B1]  :  5 words$word))))))) then
         AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     let (stacctype : AccType) =
       (if (((R1 = (vec_of_bits [B1]  :  1 words$word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in sail2_state_monad$bindS
     (undefined_MemAtomicOp () ) (\ (op : MemAtomicOp) . 
     let b__19 = opc in
     let (op : MemAtomicOp) =
       (if (((b__19 = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) then MemAtomicOp_ADD
       else if (((b__19 = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) then MemAtomicOp_BIC
       else if (((b__19 = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) then MemAtomicOp_EOR
       else if (((b__19 = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) then MemAtomicOp_ORR
       else if (((b__19 = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) then MemAtomicOp_SMAX
       else if (((b__19 = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) then MemAtomicOp_SMIN
       else if (((b__19 = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) then MemAtomicOp_UMAX
       else MemAtomicOp_UMIN) in
     aarch64_memory_atomicops_ld (( 32 : int):ii) ldacctype n op ((make_the_value (( 32 : int):ii)  :  32 itself)) s
       stacctype t))
   else sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (if ((~ ((HaveAtomicExt () )))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (s : ii) = (lem$w2ui Rs) in
     let (datasize : ii) = ((( 64 : int):ii)) in
     let (regsize : ii) = ((( 64 : int):ii)) in
     let (ldacctype : AccType) =
       (if ((((((A = (vec_of_bits [B1]  :  1 words$word)))) /\ (((Rt <> (vec_of_bits [B1;B1;B1;B1;B1]  :  5 words$word))))))) then
         AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     let (stacctype : AccType) =
       (if (((R1 = (vec_of_bits [B1]  :  1 words$word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in sail2_state_monad$bindS
     (undefined_MemAtomicOp () ) (\ (op : MemAtomicOp) . 
     let b__28 = opc in
     let (op : MemAtomicOp) =
       (if (((b__28 = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) then MemAtomicOp_ADD
       else if (((b__28 = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) then MemAtomicOp_BIC
       else if (((b__28 = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) then MemAtomicOp_EOR
       else if (((b__28 = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) then MemAtomicOp_ORR
       else if (((b__28 = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) then MemAtomicOp_SMAX
       else if (((b__28 = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) then MemAtomicOp_SMIN
       else if (((b__28 = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) then MemAtomicOp_UMAX
       else MemAtomicOp_UMIN) in
     aarch64_memory_atomicops_ld (( 64 : int):ii) ldacctype n op ((make_the_value (( 64 : int):ii)  :  64 itself)) s
       stacctype t))))`;


(*val memory_atomicops_cas_single_decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_atomicops_cas_single_decode:(2)words$word ->(1)words$word ->(1)words$word ->(1)words$word ->(5)words$word ->(1)words$word ->(5)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 o2 L o1 Rs o0 Rt2 Rn Rt=
    (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (if ((~ ((HaveAtomicExt () )))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (s : ii) = (lem$w2ui Rs) in
     let (datasize : ii) = ((( 8 : int):ii)) in
     let (regsize : ii) = ((( 32 : int):ii)) in
     let (ldacctype : AccType) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     let (stacctype : AccType) =
       (if (((o0 = (vec_of_bits [B1]  :  1 words$word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     aarch64_memory_atomicops_cas_single (( 8 : int):ii) ldacctype n
       ((make_the_value (( 32 : int):ii)  :  32 itself)) s stacctype t)
   else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (if ((~ ((HaveAtomicExt () )))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (s : ii) = (lem$w2ui Rs) in
     let (datasize : ii) = ((( 16 : int):ii)) in
     let (regsize : ii) = ((( 32 : int):ii)) in
     let (ldacctype : AccType) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     let (stacctype : AccType) =
       (if (((o0 = (vec_of_bits [B1]  :  1 words$word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     aarch64_memory_atomicops_cas_single (( 16 : int):ii) ldacctype n
       ((make_the_value (( 32 : int):ii)  :  32 itself)) s stacctype t)
   else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (if ((~ ((HaveAtomicExt () )))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (s : ii) = (lem$w2ui Rs) in
     let (datasize : ii) = ((( 32 : int):ii)) in
     let (regsize : ii) = ((( 32 : int):ii)) in
     let (ldacctype : AccType) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     let (stacctype : AccType) =
       (if (((o0 = (vec_of_bits [B1]  :  1 words$word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     aarch64_memory_atomicops_cas_single (( 32 : int):ii) ldacctype n
       ((make_the_value (( 32 : int):ii)  :  32 itself)) s stacctype t)
   else sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (if ((~ ((HaveAtomicExt () )))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (s : ii) = (lem$w2ui Rs) in
     let (datasize : ii) = ((( 64 : int):ii)) in
     let (regsize : ii) = ((( 64 : int):ii)) in
     let (ldacctype : AccType) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     let (stacctype : AccType) =
       (if (((o0 = (vec_of_bits [B1]  :  1 words$word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     aarch64_memory_atomicops_cas_single (( 64 : int):ii) ldacctype n
       ((make_the_value (( 64 : int):ii)  :  64 itself)) s stacctype t)))`;


(*val memory_atomicops_cas_pair_decode : mword ty1 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_atomicops_cas_pair_decode:(1)words$word ->(1)words$word ->(1)words$word ->(1)words$word ->(5)words$word ->(1)words$word ->(5)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 o2 L o1 Rs o0 Rt2 Rn Rt=
    (if (((b__0 = (vec_of_bits [B0]  :  1 words$word)))) then sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (if ((~ ((HaveAtomicExt () )))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (if ((((vec_of_bits [access_vec_dec Rs (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (if ((((vec_of_bits [access_vec_dec Rt (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (s : ii) = (lem$w2ui Rs) in
     let (datasize : ii) = ((( 32 : int):ii)) in
     let (regsize : ii) = ((( 32 : int):ii)) in
     let (ldacctype : AccType) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     let (stacctype : AccType) =
       (if (((o0 = (vec_of_bits [B1]  :  1 words$word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     aarch64_memory_atomicops_cas_pair (( 32 : int):ii) ldacctype n ((make_the_value (( 32 : int):ii)  :  32 itself))
       s stacctype t)
   else sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (if ((~ ((HaveAtomicExt () )))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (if ((((vec_of_bits [access_vec_dec Rs (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (if ((((vec_of_bits [access_vec_dec Rt (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (let (n : ii) = (lem$w2ui Rn) in
     let (t : ii) = (lem$w2ui Rt) in
     let (s : ii) = (lem$w2ui Rs) in
     let (datasize : ii) = ((( 64 : int):ii)) in
     let (regsize : ii) = ((( 64 : int):ii)) in
     let (ldacctype : AccType) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     let (stacctype : AccType) =
       (if (((o0 = (vec_of_bits [B1]  :  1 words$word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     aarch64_memory_atomicops_cas_pair (( 64 : int):ii) ldacctype n ((make_the_value (( 64 : int):ii)  :  64 itself))
       s stacctype t)))`;


(*val integer_pac_strip_dp_1src_decode : mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_pac_strip_dp_1src_decode:(1)words$word ->(1)words$word ->(5)words$word ->(1)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) sf S1 opcode2 D Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (data : bool) = (D = (vec_of_bits [B1]  :  1 words$word)) in
   let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$seqS (sail2_state_monad$seqS
   (if ((~ ((HavePACExt () )))) then UnallocatedEncoding () 
    else sail2_state_monad$returnS () )
   (if (((((ex_int n)) <> (( 31 : int):ii)))) then UnallocatedEncoding () 
    else sail2_state_monad$returnS () ))
   (aarch64_integer_pac_strip_dp_1src d data))))`;


(*val integer_pac_pacib_dp_1src_decode : mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_pac_pacib_dp_1src_decode:(1)words$word ->(1)words$word ->(5)words$word ->(1)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) sf S1 opcode2 Z Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (source_is_sp : bool) = F in
   let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS (sail2_state_monad$seqS
   (if ((~ ((HavePACExt () )))) then UnallocatedEncoding () 
    else sail2_state_monad$returnS () )
   (if (((Z = (vec_of_bits [B0]  :  1 words$word)))) then
      let (source_is_sp : bool) = (if (((((ex_int n)) = (( 31 : int):ii)))) then T else source_is_sp) in
      sail2_state_monad$returnS source_is_sp
    else sail2_state_monad$seqS
      (if (((((ex_int n)) <> (( 31 : int):ii)))) then UnallocatedEncoding () 
       else sail2_state_monad$returnS () )
      (sail2_state_monad$returnS source_is_sp))) (\ (source_is_sp : bool) . 
   aarch64_integer_pac_pacib_dp_1src d n source_is_sp))))`;


(*val integer_pac_pacia_dp_1src_decode : mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_pac_pacia_dp_1src_decode:(1)words$word ->(1)words$word ->(5)words$word ->(1)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) sf S1 opcode2 Z Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (source_is_sp : bool) = F in
   let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS (sail2_state_monad$seqS
   (if ((~ ((HavePACExt () )))) then UnallocatedEncoding () 
    else sail2_state_monad$returnS () )
   (if (((Z = (vec_of_bits [B0]  :  1 words$word)))) then
      let (source_is_sp : bool) = (if (((((ex_int n)) = (( 31 : int):ii)))) then T else source_is_sp) in
      sail2_state_monad$returnS source_is_sp
    else sail2_state_monad$seqS
      (if (((((ex_int n)) <> (( 31 : int):ii)))) then UnallocatedEncoding () 
       else sail2_state_monad$returnS () )
      (sail2_state_monad$returnS source_is_sp))) (\ (source_is_sp : bool) . 
   aarch64_integer_pac_pacia_dp_1src d n source_is_sp))))`;


(*val integer_pac_pacga_dp_2src_decode : mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty6 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_pac_pacga_dp_2src_decode:(1)words$word ->(1)words$word ->(1)words$word ->(5)words$word ->(6)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) sf op S1 Rm opcode2 Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (source_is_sp : bool) = F in
   let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in
   let (m : ii) = (lem$w2ui Rm) in sail2_state_monad$seqS
   (if ((~ ((HavePACExt () )))) then UnallocatedEncoding () 
    else sail2_state_monad$returnS () )
   (let (source_is_sp : bool) = (if (((((ex_int m)) = (( 31 : int):ii)))) then T else source_is_sp) in
   aarch64_integer_pac_pacga_dp_2src d m n source_is_sp))))`;


(*val integer_pac_pacdb_dp_1src_decode : mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_pac_pacdb_dp_1src_decode:(1)words$word ->(1)words$word ->(5)words$word ->(1)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) sf S1 opcode2 Z Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (source_is_sp : bool) = F in
   let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS (sail2_state_monad$seqS
   (if ((~ ((HavePACExt () )))) then UnallocatedEncoding () 
    else sail2_state_monad$returnS () )
   (if (((Z = (vec_of_bits [B0]  :  1 words$word)))) then
      let (source_is_sp : bool) = (if (((((ex_int n)) = (( 31 : int):ii)))) then T else source_is_sp) in
      sail2_state_monad$returnS source_is_sp
    else sail2_state_monad$seqS
      (if (((((ex_int n)) <> (( 31 : int):ii)))) then UnallocatedEncoding () 
       else sail2_state_monad$returnS () )
      (sail2_state_monad$returnS source_is_sp))) (\ (source_is_sp : bool) . 
   aarch64_integer_pac_pacdb_dp_1src d n source_is_sp))))`;


(*val integer_pac_pacda_dp_1src_decode : mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_pac_pacda_dp_1src_decode:(1)words$word ->(1)words$word ->(5)words$word ->(1)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) sf S1 opcode2 Z Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (source_is_sp : bool) = F in
   let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS (sail2_state_monad$seqS
   (if ((~ ((HavePACExt () )))) then UnallocatedEncoding () 
    else sail2_state_monad$returnS () )
   (if (((Z = (vec_of_bits [B0]  :  1 words$word)))) then
      let (source_is_sp : bool) = (if (((((ex_int n)) = (( 31 : int):ii)))) then T else source_is_sp) in
      sail2_state_monad$returnS source_is_sp
    else sail2_state_monad$seqS
      (if (((((ex_int n)) <> (( 31 : int):ii)))) then UnallocatedEncoding () 
       else sail2_state_monad$returnS () )
      (sail2_state_monad$returnS source_is_sp))) (\ (source_is_sp : bool) . 
   aarch64_integer_pac_pacda_dp_1src d n source_is_sp))))`;


(*val integer_pac_autib_dp_1src_decode : mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_pac_autib_dp_1src_decode:(1)words$word ->(1)words$word ->(5)words$word ->(1)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) sf S1 opcode2 Z Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (source_is_sp : bool) = F in
   let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS (sail2_state_monad$seqS
   (if ((~ ((HavePACExt () )))) then UnallocatedEncoding () 
    else sail2_state_monad$returnS () )
   (if (((Z = (vec_of_bits [B0]  :  1 words$word)))) then
      let (source_is_sp : bool) = (if (((((ex_int n)) = (( 31 : int):ii)))) then T else source_is_sp) in
      sail2_state_monad$returnS source_is_sp
    else sail2_state_monad$seqS
      (if (((((ex_int n)) <> (( 31 : int):ii)))) then UnallocatedEncoding () 
       else sail2_state_monad$returnS () )
      (sail2_state_monad$returnS source_is_sp))) (\ (source_is_sp : bool) . 
   aarch64_integer_pac_autib_dp_1src d n source_is_sp))))`;


(*val integer_pac_autia_dp_1src_decode : mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_pac_autia_dp_1src_decode:(1)words$word ->(1)words$word ->(5)words$word ->(1)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) sf S1 opcode2 Z Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (source_is_sp : bool) = F in
   let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS (sail2_state_monad$seqS
   (if ((~ ((HavePACExt () )))) then UnallocatedEncoding () 
    else sail2_state_monad$returnS () )
   (if (((Z = (vec_of_bits [B0]  :  1 words$word)))) then
      let (source_is_sp : bool) = (if (((((ex_int n)) = (( 31 : int):ii)))) then T else source_is_sp) in
      sail2_state_monad$returnS source_is_sp
    else sail2_state_monad$seqS
      (if (((((ex_int n)) <> (( 31 : int):ii)))) then UnallocatedEncoding () 
       else sail2_state_monad$returnS () )
      (sail2_state_monad$returnS source_is_sp))) (\ (source_is_sp : bool) . 
   aarch64_integer_pac_autia_dp_1src d n source_is_sp))))`;


(*val integer_pac_autdb_dp_1src_decode : mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_pac_autdb_dp_1src_decode:(1)words$word ->(1)words$word ->(5)words$word ->(1)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) sf S1 opcode2 Z Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (source_is_sp : bool) = F in
   let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS (sail2_state_monad$seqS
   (if ((~ ((HavePACExt () )))) then UnallocatedEncoding () 
    else sail2_state_monad$returnS () )
   (if (((Z = (vec_of_bits [B0]  :  1 words$word)))) then
      let (source_is_sp : bool) = (if (((((ex_int n)) = (( 31 : int):ii)))) then T else source_is_sp) in
      sail2_state_monad$returnS source_is_sp
    else sail2_state_monad$seqS
      (if (((((ex_int n)) <> (( 31 : int):ii)))) then UnallocatedEncoding () 
       else sail2_state_monad$returnS () )
      (sail2_state_monad$returnS source_is_sp))) (\ (source_is_sp : bool) . 
   aarch64_integer_pac_autdb_dp_1src d n source_is_sp))))`;


(*val integer_pac_autda_dp_1src_decode : mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_pac_autda_dp_1src_decode:(1)words$word ->(1)words$word ->(5)words$word ->(1)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) sf S1 opcode2 Z Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (source_is_sp : bool) = F in
   let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS (sail2_state_monad$seqS
   (if ((~ ((HavePACExt () )))) then UnallocatedEncoding () 
    else sail2_state_monad$returnS () )
   (if (((Z = (vec_of_bits [B0]  :  1 words$word)))) then
      let (source_is_sp : bool) = (if (((((ex_int n)) = (( 31 : int):ii)))) then T else source_is_sp) in
      sail2_state_monad$returnS source_is_sp
    else sail2_state_monad$seqS
      (if (((((ex_int n)) <> (( 31 : int):ii)))) then UnallocatedEncoding () 
       else sail2_state_monad$returnS () )
      (sail2_state_monad$returnS source_is_sp))) (\ (source_is_sp : bool) . 
   aarch64_integer_pac_autda_dp_1src d n source_is_sp))))`;


(*val integer_insext_insert_movewide_decode : mword ty1 -> mword ty2 -> mword ty2 -> mword ty16 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_insext_insert_movewide_decode:(1)words$word ->(2)words$word ->(2)words$word ->(16)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) sf opc hw imm16 Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (d : ii) = (lem$w2ui Rd) in
   let (datasize : int) =
     (if (((sf = (vec_of_bits [B1]  :  1 words$word)))) then (( 64 : int):ii)
     else (( 32 : int):ii)) in
   let (imm : 16 bits) = imm16 in sail2_state_monad$bindS
   (undefined_int () ) (\ (pos : ii) .  sail2_state_monad$bindS
   (undefined_MoveWideOp () ) (\ (opcode : MoveWideOp) . 
   let b__0 = opc in sail2_state_monad$bindS
   (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$returnS MoveWideOp_N
    else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$returnS MoveWideOp_Z
    else if (((b__0 = (vec_of_bits [B1;B1]  :  2 words$word)))) then sail2_state_monad$returnS MoveWideOp_K
    else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS opcode)) (\ (opcode : MoveWideOp) .  sail2_state_monad$seqS
   (if ((((((sf = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((vec_of_bits [access_vec_dec hw (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) then
      UnallocatedEncoding () 
    else sail2_state_monad$returnS () )
   (let pos = (lem$w2ui ((concat_vec hw (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)  :  6 words$word))) in
   aarch64_integer_insext_insert_movewide d datasize imm opcode pos)))))))`;


(*val integer_crc_decode : mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty3 -> mword ty1 -> mword ty2 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_crc_decode:(1)words$word ->(1)words$word ->(1)words$word ->(5)words$word ->(3)words$word ->(1)words$word ->(2)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) sf op S1 Rm opcode2 C b__0 Rn Rd=
    (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (if ((((((sf = (vec_of_bits [B1]  :  1 words$word)))) /\ T))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (if ((((((sf = (vec_of_bits [B0]  :  1 words$word)))) /\ F))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (let (size1 : ii) = ((( 8 : int):ii)) in
     let (crc32c : bool) = (C = (vec_of_bits [B1]  :  1 words$word)) in
     aarch64_integer_crc crc32c d m n (( 8 : int):ii)))
   else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (if ((((((sf = (vec_of_bits [B1]  :  1 words$word)))) /\ T))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (if ((((((sf = (vec_of_bits [B0]  :  1 words$word)))) /\ F))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (let (size1 : ii) = ((( 16 : int):ii)) in
     let (crc32c : bool) = (C = (vec_of_bits [B1]  :  1 words$word)) in
     aarch64_integer_crc crc32c d m n (( 16 : int):ii)))
   else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (if ((((((sf = (vec_of_bits [B1]  :  1 words$word)))) /\ T))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (if ((((((sf = (vec_of_bits [B0]  :  1 words$word)))) /\ F))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (let (size1 : ii) = ((( 32 : int):ii)) in
     let (crc32c : bool) = (C = (vec_of_bits [B1]  :  1 words$word)) in
     aarch64_integer_crc crc32c d m n (( 32 : int):ii)))
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in sail2_state_monad$seqS (sail2_state_monad$seqS
     (if ((((((sf = (vec_of_bits [B1]  :  1 words$word)))) /\ F))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (if ((((((sf = (vec_of_bits [B0]  :  1 words$word)))) /\ T))) then UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (let (size1 : ii) = ((( 64 : int):ii)) in
     let (crc32c : bool) = (C = (vec_of_bits [B1]  :  1 words$word)) in
     aarch64_integer_crc crc32c d m n (( 64 : int):ii)))))`;


(*val integer_arithmetic_rev_decode : mword ty1 -> mword ty1 -> mword ty5 -> mword ty2 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_arithmetic_rev_decode:(1)words$word ->(1)words$word ->(5)words$word ->(2)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) sf S1 opcode2 opc Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in
   let (datasize : int) =
     (if (((sf = (vec_of_bits [B1]  :  1 words$word)))) then (( 64 : int):ii)
     else (( 32 : int):ii)) in sail2_state_monad$bindS
   (undefined_int () ) (\ (container_size : ii) . 
   let b__0 = opc in sail2_state_monad$bindS
   (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$seqS
      (Unreachable () ) (sail2_state_monad$returnS container_size)
    else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$returnS (( 16 : int):ii)
    else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$returnS (( 32 : int):ii)
    else sail2_state_monad$seqS
      (if (((sf = (vec_of_bits [B0]  :  1 words$word)))) then UnallocatedEncoding () 
       else sail2_state_monad$returnS () )
      (sail2_state_monad$returnS (( 64 : int):ii))) (\ (container_size : ii) . 
   aarch64_integer_arithmetic_rev container_size d datasize n)))))`;


(*val float_move_fp_select_decode : mword ty1 -> mword ty1 -> mword ty2 -> mword ty5 -> mword ty4 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((float_move_fp_select_decode:(1)words$word ->(1)words$word ->(2)words$word ->(5)words$word ->(4)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) M S1 typ Rm cond Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in
   let (m : ii) = (lem$w2ui Rm) in sail2_state_monad$bindS
   (undefined_int () ) (\ (datasize : ii) . 
   let b__0 = typ in sail2_state_monad$bindS
   (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$returnS (( 32 : int):ii)
    else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$returnS (( 64 : int):ii)
    else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$seqS
      (UnallocatedEncoding () ) (sail2_state_monad$returnS datasize)
    else if ((HaveFP16Ext () )) then sail2_state_monad$returnS (( 16 : int):ii)
    else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS datasize)) (\ (datasize : ii) . 
   let (condition : 4 bits) = cond in
   aarch64_float_move_fp_select condition d datasize m n)))))`;


(*val float_move_fp_imm_decode : mword ty1 -> mword ty1 -> mword ty2 -> mword ty8 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((float_move_fp_imm_decode:(1)words$word ->(1)words$word ->(2)words$word ->(8)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) M S1 b__0 imm8 imm5 Rd=
    (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in sail2_state_monad$bindS
     (undefined_int () ) (\ (datasize : ii) . 
     let datasize = ((( 32 : int):ii)) in sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (VFPExpandImm (( 32 : int):ii) imm8  : ( 32 words$word) M)) (\ (imm : 32 bits) . 
     aarch64_float_move_fp_imm d ((make_the_value (( 32 : int):ii)  :  32 itself)) imm)))
   else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in sail2_state_monad$bindS
     (undefined_int () ) (\ (datasize : ii) . 
     let datasize = ((( 64 : int):ii)) in sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (VFPExpandImm (( 64 : int):ii) imm8  : ( 64 words$word) M)) (\ (imm : 64 bits) . 
     aarch64_float_move_fp_imm d ((make_the_value (( 64 : int):ii)  :  64 itself)) imm)))
   else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in sail2_state_monad$bindS
     (undefined_int () ) (\ (datasize : ii) .  sail2_state_monad$bindS (sail2_state_monad$seqS (sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (sail2_state_monad$assert_expS T ""))
     (VFPExpandImm (( 32 : int):ii) imm8  : ( 32 words$word) M)) (\ (imm : 32 bits) . 
     aarch64_float_move_fp_imm d ((make_the_value (( 32 : int):ii)  :  32 itself)) imm)))
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in sail2_state_monad$bindS
     (undefined_int () ) (\ (datasize : ii) . 
     let datasize = ((( 16 : int):ii)) in sail2_state_monad$bindS (sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (VFPExpandImm (( 16 : int):ii) imm8  : ( 16 words$word) M)) (\ (imm : 16 bits) . 
     aarch64_float_move_fp_imm d ((make_the_value (( 16 : int):ii)  :  16 itself)) imm)))))`;


(*val aarch64_float_convert_int_split : ii -> ii -> ii -> ii -> FPConvOp -> ii -> FPRounding -> bool -> M unit*)

val _ = Define `
 ((aarch64_float_convert_int_split:int -> int -> int -> int -> FPConvOp -> int -> FPRounding -> bool ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) d l__0 l__1 n op part rounding unsigned=
    (if ((((((l__0 = (( 16 : int):ii)))) /\ (((l__1 = (( 32 : int):ii))))))) then
     aarch64_float_convert_int d ((make_the_value (( 16 : int):ii)  :  16 itself))
       ((make_the_value (( 32 : int):ii)  :  32 itself)) n op part rounding unsigned
   else if ((((((l__0 = (( 16 : int):ii)))) /\ (((l__1 = (( 64 : int):ii))))))) then
     aarch64_float_convert_int d ((make_the_value (( 16 : int):ii)  :  16 itself))
       ((make_the_value (( 64 : int):ii)  :  64 itself)) n op part rounding unsigned
   else if ((((((l__0 = (( 32 : int):ii)))) /\ (((l__1 = (( 32 : int):ii))))))) then
     aarch64_float_convert_int d ((make_the_value (( 32 : int):ii)  :  32 itself))
       ((make_the_value (( 32 : int):ii)  :  32 itself)) n op part rounding unsigned
   else if ((((((l__0 = (( 32 : int):ii)))) /\ (((l__1 = (( 64 : int):ii))))))) then
     aarch64_float_convert_int d ((make_the_value (( 32 : int):ii)  :  32 itself))
       ((make_the_value (( 64 : int):ii)  :  64 itself)) n op part rounding unsigned
   else if ((((((l__0 = (( 64 : int):ii)))) /\ (((l__1 = (( 32 : int):ii))))))) then
     aarch64_float_convert_int d ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 32 : int):ii)  :  32 itself)) n op part rounding unsigned
   else if ((((((l__0 = (( 64 : int):ii)))) /\ (((l__1 = (( 64 : int):ii))))))) then
     aarch64_float_convert_int d ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((make_the_value (( 64 : int):ii)  :  64 itself)) n op part rounding unsigned
   else if ((((((l__0 = (( 128 : int):ii)))) /\ (((l__1 = (( 32 : int):ii))))))) then
     aarch64_float_convert_int d ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 32 : int):ii)  :  32 itself)) n op part rounding unsigned
   else
     aarch64_float_convert_int d ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((make_the_value (( 64 : int):ii)  :  64 itself)) n op part rounding unsigned))`;


(*val float_convert_int_decode : mword ty1 -> mword ty1 -> mword ty2 -> mword ty2 -> mword ty3 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((float_convert_int_decode:(1)words$word ->(1)words$word ->(2)words$word ->(2)words$word ->(3)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) sf S1 typ rmode opcode Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in
   let (intsize : int) =
     (if (((sf = (vec_of_bits [B1]  :  1 words$word)))) then (( 64 : int):ii)
     else (( 32 : int):ii)) in sail2_state_monad$bindS
   (undefined_int () ) (\ (fltsize : ii) .  sail2_state_monad$bindS
   (undefined_FPConvOp () ) (\ (op : FPConvOp) .  sail2_state_monad$bindS
   (undefined_FPRounding () ) (\ (rounding : FPRounding) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (unsigned : bool) .  sail2_state_monad$bindS
   (undefined_int () ) (\ (part : ii) . 
   let b__0 = typ in sail2_state_monad$bindS
   (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$returnS (( 32 : int):ii)
    else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$returnS (( 64 : int):ii)
    else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$seqS
      (if (((((concat_vec ((slice opcode (( 1 : int):ii) (( 2 : int):ii)  :  2 words$word)) rmode  :  4 words$word)) <> (vec_of_bits [B1;B1;B0;B1]  :  4 words$word)))) then
         UnallocatedEncoding () 
       else sail2_state_monad$returnS () )
      (sail2_state_monad$returnS (( 128 : int):ii))
    else if ((HaveFP16Ext () )) then sail2_state_monad$returnS (( 16 : int):ii)
    else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS fltsize)) (\ (fltsize : ii) . 
   let v__98 = ((concat_vec ((slice opcode (( 1 : int):ii) (( 2 : int):ii)  :  2 words$word)) rmode  :  4 words$word)) in sail2_state_monad$bindS
   (if (((((subrange_vec_dec v__98 (( 3 : int):ii) (( 2 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B0]  :  2 words$word)))) then
      let (rounding : FPRounding) = (FPDecodeRounding rmode) in
      let (unsigned : bool) =
        ((vec_of_bits [access_vec_dec opcode (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
      let (op : FPConvOp) = FPConvOp_CVT_FtoI in
      sail2_state_monad$returnS (fltsize, op, part, rounding, unsigned)
    else if (((v__98 = (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)))) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__0 :  32 words$word) . 
      let (rounding : FPRounding) = (FPRoundingMode w__0) in
      let (unsigned : bool) =
        ((vec_of_bits [access_vec_dec opcode (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
      let (op : FPConvOp) = FPConvOp_CVT_ItoF in
      sail2_state_monad$returnS (fltsize, op, part, rounding, unsigned))
    else if (((v__98 = (vec_of_bits [B1;B0;B0;B0]  :  4 words$word)))) then
      let (rounding : FPRounding) = FPRounding_TIEAWAY in
      let (unsigned : bool) =
        ((vec_of_bits [access_vec_dec opcode (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
      let (op : FPConvOp) = FPConvOp_CVT_FtoI in
      sail2_state_monad$returnS (fltsize, op, part, rounding, unsigned)
    else if (((v__98 = (vec_of_bits [B1;B1;B0;B0]  :  4 words$word)))) then sail2_state_monad$seqS
      (if ((((((((ex_int fltsize)) <> (( 16 : int):ii)))) /\ (((((ex_int fltsize)) <> intsize)))))) then
         UnallocatedEncoding () 
       else sail2_state_monad$returnS () )
      (let (op : FPConvOp) =
        (if ((((vec_of_bits [access_vec_dec opcode (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
          FPConvOp_MOV_ItoF
        else FPConvOp_MOV_FtoI) in
      let (part : ii) = ((( 0 : int):ii)) in
      sail2_state_monad$returnS (fltsize, op, part, rounding, unsigned))
    else if (((v__98 = (vec_of_bits [B1;B1;B0;B1]  :  4 words$word)))) then sail2_state_monad$seqS
      (if ((((((((ex_int intsize)) <> (( 64 : int):ii)))) \/ (((((ex_int fltsize)) <> (( 128 : int):ii))))))) then
         UnallocatedEncoding () 
       else sail2_state_monad$returnS () )
      (let (op : FPConvOp) =
        (if ((((vec_of_bits [access_vec_dec opcode (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
          FPConvOp_MOV_ItoF
        else FPConvOp_MOV_FtoI) in
      let (part : ii) = ((( 1 : int):ii)) in
      let (fltsize : ii) = ((( 64 : int):ii)) in
      sail2_state_monad$returnS (fltsize, op, part, rounding, unsigned))
    else sail2_state_monad$bindS
      (if (((v__98 = (vec_of_bits [B1;B1;B1;B1]  :  4 words$word)))) then sail2_state_monad$seqS
         (if ((~ ((HaveFJCVTZSExt () )))) then UnallocatedEncoding () 
          else sail2_state_monad$returnS () )
         (let (rounding : FPRounding) = FPRounding_ZERO in
         let (unsigned : bool) =
           ((vec_of_bits [access_vec_dec opcode (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
         let (op : FPConvOp) = FPConvOp_CVT_FtoI_JS in
         sail2_state_monad$returnS (op, rounding, unsigned))
       else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS (op, rounding, unsigned))) (\ varstup .  let ((op :
        FPConvOp), (rounding : FPRounding), (unsigned : bool)) = varstup in
      sail2_state_monad$returnS (fltsize, op, part, rounding, unsigned))) (\ varstup .  let ((fltsize : ii), (op :
     FPConvOp), (part : ii), (rounding : FPRounding), (unsigned : bool)) = varstup in
   let fltsize2 = (ex_int fltsize) in sail2_state_monad$seqS
   (sail2_state_monad$assert_expS T "")
   (aarch64_float_convert_int_split d fltsize2 intsize n op part rounding unsigned)))))))))))`;


(*val float_convert_fp_decode : mword ty1 -> mword ty1 -> mword ty2 -> mword ty2 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((float_convert_fp_decode:(1)words$word ->(1)words$word ->(2)words$word ->(2)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) M S1 b__0 b__1 Rn Rd=
    (if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS (sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (undefined_int () )) (\ (srcsize : ii) . 
     let srcsize = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (dstsize : ii) . 
     let dstsize = ((( 32 : int):ii)) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (aarch64_float_convert_fp d ((make_the_value (( 32 : int):ii)  :  32 itself)) n
       ((make_the_value (( 32 : int):ii)  :  32 itself))))))
   else if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (srcsize : ii) . 
     let srcsize = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (dstsize : ii) . 
     let dstsize = ((( 64 : int):ii)) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (aarch64_float_convert_fp d ((make_the_value (( 64 : int):ii)  :  64 itself)) n
       ((make_the_value (( 32 : int):ii)  :  32 itself))))))
   else if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (srcsize : ii) . 
     let srcsize = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (dstsize : ii) .  sail2_state_monad$seqS (sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (sail2_state_monad$assert_expS T ""))
     (aarch64_float_convert_fp d ((make_the_value (( 32 : int):ii)  :  32 itself)) n
       ((make_the_value (( 32 : int):ii)  :  32 itself))))))
   else if ((((((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (srcsize : ii) . 
     let srcsize = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (dstsize : ii) . 
     let dstsize = ((( 16 : int):ii)) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (aarch64_float_convert_fp d ((make_the_value (( 16 : int):ii)  :  16 itself)) n
       ((make_the_value (( 32 : int):ii)  :  32 itself))))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (srcsize : ii) . 
     let srcsize = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (dstsize : ii) . 
     let dstsize = ((( 32 : int):ii)) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (aarch64_float_convert_fp d ((make_the_value (( 32 : int):ii)  :  32 itself)) n
       ((make_the_value (( 64 : int):ii)  :  64 itself))))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS (sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (undefined_int () )) (\ (srcsize : ii) . 
     let srcsize = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (dstsize : ii) . 
     let dstsize = ((( 64 : int):ii)) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (aarch64_float_convert_fp d ((make_the_value (( 64 : int):ii)  :  64 itself)) n
       ((make_the_value (( 64 : int):ii)  :  64 itself))))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (srcsize : ii) . 
     let srcsize = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (dstsize : ii) .  sail2_state_monad$seqS (sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (sail2_state_monad$assert_expS T ""))
     (aarch64_float_convert_fp d ((make_the_value (( 32 : int):ii)  :  32 itself)) n
       ((make_the_value (( 64 : int):ii)  :  64 itself))))))
   else if ((((((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (srcsize : ii) . 
     let srcsize = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (dstsize : ii) . 
     let dstsize = ((( 16 : int):ii)) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (aarch64_float_convert_fp d ((make_the_value (( 16 : int):ii)  :  16 itself)) n
       ((make_the_value (( 64 : int):ii)  :  64 itself))))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (srcsize : ii) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (undefined_int () )) (\ (dstsize : ii) . 
     let dstsize = ((( 32 : int):ii)) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (aarch64_float_convert_fp d ((make_the_value (( 32 : int):ii)  :  32 itself)) n
       ((make_the_value (( 32 : int):ii)  :  32 itself))))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (srcsize : ii) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (undefined_int () )) (\ (dstsize : ii) . 
     let dstsize = ((( 64 : int):ii)) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (aarch64_float_convert_fp d ((make_the_value (( 64 : int):ii)  :  64 itself)) n
       ((make_the_value (( 32 : int):ii)  :  32 itself))))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS (sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (undefined_int () )) (\ (srcsize : ii) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (undefined_int () )) (\ (dstsize : ii) .  sail2_state_monad$seqS (sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (sail2_state_monad$assert_expS T ""))
     (aarch64_float_convert_fp d ((make_the_value (( 32 : int):ii)  :  32 itself)) n
       ((make_the_value (( 32 : int):ii)  :  32 itself))))))
   else if ((((((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (srcsize : ii) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (undefined_int () )) (\ (dstsize : ii) . 
     let dstsize = ((( 16 : int):ii)) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (aarch64_float_convert_fp d ((make_the_value (( 16 : int):ii)  :  16 itself)) n
       ((make_the_value (( 32 : int):ii)  :  32 itself))))))
   else if ((((((b__0 = (vec_of_bits [B1;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (srcsize : ii) . 
     let srcsize = ((( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (dstsize : ii) . 
     let dstsize = ((( 32 : int):ii)) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (aarch64_float_convert_fp d ((make_the_value (( 32 : int):ii)  :  32 itself)) n
       ((make_the_value (( 16 : int):ii)  :  16 itself))))))
   else if ((((((b__0 = (vec_of_bits [B1;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (srcsize : ii) . 
     let srcsize = ((( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (dstsize : ii) . 
     let dstsize = ((( 64 : int):ii)) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (aarch64_float_convert_fp d ((make_the_value (( 64 : int):ii)  :  64 itself)) n
       ((make_the_value (( 16 : int):ii)  :  16 itself))))))
   else if ((((((b__0 = (vec_of_bits [B1;B1]  :  2 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (srcsize : ii) . 
     let srcsize = ((( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (dstsize : ii) .  sail2_state_monad$seqS (sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (sail2_state_monad$assert_expS T ""))
     (aarch64_float_convert_fp d ((make_the_value (( 32 : int):ii)  :  32 itself)) n
       ((make_the_value (( 16 : int):ii)  :  16 itself))))))
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS (sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (undefined_int () )) (\ (srcsize : ii) . 
     let srcsize = ((( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (dstsize : ii) . 
     let dstsize = ((( 16 : int):ii)) in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (aarch64_float_convert_fp d ((make_the_value (( 16 : int):ii)  :  16 itself)) n
       ((make_the_value (( 16 : int):ii)  :  16 itself))))))))`;


(*val float_convert_fix_decode : mword ty1 -> mword ty1 -> mword ty2 -> mword ty2 -> mword ty3 -> mword ty6 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((float_convert_fix_decode:(1)words$word ->(1)words$word ->(2)words$word ->(2)words$word ->(3)words$word ->(6)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 S1 b__1 rmode opcode scale Rn Rd=
    (if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in
     let (intsize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (fltsize : ii) .  sail2_state_monad$bindS
     (undefined_FPConvOp () ) (\ (op : FPConvOp) .  sail2_state_monad$bindS
     (undefined_FPRounding () ) (\ (rounding : FPRounding) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (unsigned : bool) . 
     let fltsize = ((( 32 : int):ii)) in sail2_state_monad$seqS
     (if (((T /\ ((((vec_of_bits [access_vec_dec scale (( 5 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (fracbits : ii) = ((( 64 : int):ii) - ((lem$w2ui scale))) in
     let b__2 = ((concat_vec ((slice opcode (( 1 : int):ii) (( 2 : int):ii)  :  2 words$word)) rmode  :  4 words$word)) in sail2_state_monad$bindS
     (if (((b__2 = (vec_of_bits [B0;B0;B1;B1]  :  4 words$word)))) then
        let (rounding : FPRounding) = FPRounding_ZERO in
        let (unsigned : bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
        let (op : FPConvOp) = FPConvOp_CVT_FtoI in
        sail2_state_monad$returnS (op, rounding, unsigned)
      else if (((b__2 = (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)))) then sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__0 :  32 words$word) . 
        let (rounding : FPRounding) = (FPRoundingMode w__0) in
        let (unsigned : bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
        let (op : FPConvOp) = FPConvOp_CVT_ItoF in
        sail2_state_monad$returnS (op, rounding, unsigned))
      else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS (op, rounding, unsigned))) (\ varstup .  let ((op :
       FPConvOp), (rounding : FPRounding), (unsigned : bool)) = varstup in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (aarch64_float_convert_fix d ((make_the_value (( 32 : int):ii)  :  32 itself)) fracbits
       ((make_the_value (( 32 : int):ii)  :  32 itself)) n op rounding unsigned))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in
     let (intsize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (fltsize : ii) .  sail2_state_monad$bindS
     (undefined_FPConvOp () ) (\ (op : FPConvOp) .  sail2_state_monad$bindS
     (undefined_FPRounding () ) (\ (rounding : FPRounding) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (unsigned : bool) . 
     let fltsize = ((( 64 : int):ii)) in sail2_state_monad$seqS
     (if (((T /\ ((((vec_of_bits [access_vec_dec scale (( 5 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (fracbits : ii) = ((( 64 : int):ii) - ((lem$w2ui scale))) in
     let b__6 = ((concat_vec ((slice opcode (( 1 : int):ii) (( 2 : int):ii)  :  2 words$word)) rmode  :  4 words$word)) in sail2_state_monad$bindS
     (if (((b__6 = (vec_of_bits [B0;B0;B1;B1]  :  4 words$word)))) then
        let (rounding : FPRounding) = FPRounding_ZERO in
        let (unsigned : bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
        let (op : FPConvOp) = FPConvOp_CVT_FtoI in
        sail2_state_monad$returnS (op, rounding, unsigned)
      else if (((b__6 = (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)))) then sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__1 :  32 words$word) . 
        let (rounding : FPRounding) = (FPRoundingMode w__1) in
        let (unsigned : bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
        let (op : FPConvOp) = FPConvOp_CVT_ItoF in
        sail2_state_monad$returnS (op, rounding, unsigned))
      else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS (op, rounding, unsigned))) (\ varstup .  let ((op :
       FPConvOp), (rounding : FPRounding), (unsigned : bool)) = varstup in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (aarch64_float_convert_fix d ((make_the_value (( 64 : int):ii)  :  64 itself)) fracbits
       ((make_the_value (( 32 : int):ii)  :  32 itself)) n op rounding unsigned))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in
     let (intsize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (fltsize : ii) .  sail2_state_monad$bindS
     (undefined_FPConvOp () ) (\ (op : FPConvOp) .  sail2_state_monad$bindS
     (undefined_FPRounding () ) (\ (rounding : FPRounding) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (unsigned : bool) .  sail2_state_monad$seqS (sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (if (((T /\ ((((vec_of_bits [access_vec_dec scale (( 5 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (let (fracbits : ii) = ((( 64 : int):ii) - ((lem$w2ui scale))) in
     let b__10 = ((concat_vec ((slice opcode (( 1 : int):ii) (( 2 : int):ii)  :  2 words$word)) rmode  :  4 words$word)) in sail2_state_monad$bindS
     (if (((b__10 = (vec_of_bits [B0;B0;B1;B1]  :  4 words$word)))) then
        let (rounding : FPRounding) = FPRounding_ZERO in
        let (unsigned : bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
        let (op : FPConvOp) = FPConvOp_CVT_FtoI in
        sail2_state_monad$returnS (op, rounding, unsigned)
      else if (((b__10 = (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)))) then sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__2 :  32 words$word) . 
        let (rounding : FPRounding) = (FPRoundingMode w__2) in
        let (unsigned : bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
        let (op : FPConvOp) = FPConvOp_CVT_ItoF in
        sail2_state_monad$returnS (op, rounding, unsigned))
      else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS (op, rounding, unsigned))) (\ varstup .  let ((op :
       FPConvOp), (rounding : FPRounding), (unsigned : bool)) = varstup in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (aarch64_float_convert_fix d ((make_the_value (( 32 : int):ii)  :  32 itself)) fracbits
       ((make_the_value (( 32 : int):ii)  :  32 itself)) n op rounding unsigned))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in
     let (intsize : ii) = ((( 32 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (fltsize : ii) .  sail2_state_monad$bindS
     (undefined_FPConvOp () ) (\ (op : FPConvOp) .  sail2_state_monad$bindS
     (undefined_FPRounding () ) (\ (rounding : FPRounding) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (unsigned : bool) . 
     let fltsize = ((( 16 : int):ii)) in sail2_state_monad$seqS
     (if (((T /\ ((((vec_of_bits [access_vec_dec scale (( 5 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (fracbits : ii) = ((( 64 : int):ii) - ((lem$w2ui scale))) in
     let b__14 = ((concat_vec ((slice opcode (( 1 : int):ii) (( 2 : int):ii)  :  2 words$word)) rmode  :  4 words$word)) in sail2_state_monad$bindS
     (if (((b__14 = (vec_of_bits [B0;B0;B1;B1]  :  4 words$word)))) then
        let (rounding : FPRounding) = FPRounding_ZERO in
        let (unsigned : bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
        let (op : FPConvOp) = FPConvOp_CVT_FtoI in
        sail2_state_monad$returnS (op, rounding, unsigned)
      else if (((b__14 = (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)))) then sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__3 :  32 words$word) . 
        let (rounding : FPRounding) = (FPRoundingMode w__3) in
        let (unsigned : bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
        let (op : FPConvOp) = FPConvOp_CVT_ItoF in
        sail2_state_monad$returnS (op, rounding, unsigned))
      else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS (op, rounding, unsigned))) (\ varstup .  let ((op :
       FPConvOp), (rounding : FPRounding), (unsigned : bool)) = varstup in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (aarch64_float_convert_fix d ((make_the_value (( 16 : int):ii)  :  16 itself)) fracbits
       ((make_the_value (( 32 : int):ii)  :  32 itself)) n op rounding unsigned))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in
     let (intsize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (fltsize : ii) .  sail2_state_monad$bindS
     (undefined_FPConvOp () ) (\ (op : FPConvOp) .  sail2_state_monad$bindS
     (undefined_FPRounding () ) (\ (rounding : FPRounding) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (unsigned : bool) . 
     let fltsize = ((( 32 : int):ii)) in sail2_state_monad$seqS
     (if (((F /\ ((((vec_of_bits [access_vec_dec scale (( 5 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (fracbits : ii) = ((( 64 : int):ii) - ((lem$w2ui scale))) in
     let b__18 = ((concat_vec ((slice opcode (( 1 : int):ii) (( 2 : int):ii)  :  2 words$word)) rmode  :  4 words$word)) in sail2_state_monad$bindS
     (if (((b__18 = (vec_of_bits [B0;B0;B1;B1]  :  4 words$word)))) then
        let (rounding : FPRounding) = FPRounding_ZERO in
        let (unsigned : bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
        let (op : FPConvOp) = FPConvOp_CVT_FtoI in
        sail2_state_monad$returnS (op, rounding, unsigned)
      else if (((b__18 = (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)))) then sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__4 :  32 words$word) . 
        let (rounding : FPRounding) = (FPRoundingMode w__4) in
        let (unsigned : bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
        let (op : FPConvOp) = FPConvOp_CVT_ItoF in
        sail2_state_monad$returnS (op, rounding, unsigned))
      else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS (op, rounding, unsigned))) (\ varstup .  let ((op :
       FPConvOp), (rounding : FPRounding), (unsigned : bool)) = varstup in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (aarch64_float_convert_fix d ((make_the_value (( 32 : int):ii)  :  32 itself)) fracbits
       ((make_the_value (( 64 : int):ii)  :  64 itself)) n op rounding unsigned))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in
     let (intsize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (fltsize : ii) .  sail2_state_monad$bindS
     (undefined_FPConvOp () ) (\ (op : FPConvOp) .  sail2_state_monad$bindS
     (undefined_FPRounding () ) (\ (rounding : FPRounding) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (unsigned : bool) . 
     let fltsize = ((( 64 : int):ii)) in sail2_state_monad$seqS
     (if (((F /\ ((((vec_of_bits [access_vec_dec scale (( 5 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (fracbits : ii) = ((( 64 : int):ii) - ((lem$w2ui scale))) in
     let b__22 = ((concat_vec ((slice opcode (( 1 : int):ii) (( 2 : int):ii)  :  2 words$word)) rmode  :  4 words$word)) in sail2_state_monad$bindS
     (if (((b__22 = (vec_of_bits [B0;B0;B1;B1]  :  4 words$word)))) then
        let (rounding : FPRounding) = FPRounding_ZERO in
        let (unsigned : bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
        let (op : FPConvOp) = FPConvOp_CVT_FtoI in
        sail2_state_monad$returnS (op, rounding, unsigned)
      else if (((b__22 = (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)))) then sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__5 :  32 words$word) . 
        let (rounding : FPRounding) = (FPRoundingMode w__5) in
        let (unsigned : bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
        let (op : FPConvOp) = FPConvOp_CVT_ItoF in
        sail2_state_monad$returnS (op, rounding, unsigned))
      else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS (op, rounding, unsigned))) (\ varstup .  let ((op :
       FPConvOp), (rounding : FPRounding), (unsigned : bool)) = varstup in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (aarch64_float_convert_fix d ((make_the_value (( 64 : int):ii)  :  64 itself)) fracbits
       ((make_the_value (( 64 : int):ii)  :  64 itself)) n op rounding unsigned))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in
     let (intsize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (fltsize : ii) .  sail2_state_monad$bindS
     (undefined_FPConvOp () ) (\ (op : FPConvOp) .  sail2_state_monad$bindS
     (undefined_FPRounding () ) (\ (rounding : FPRounding) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (unsigned : bool) .  sail2_state_monad$seqS (sail2_state_monad$seqS
     (UnallocatedEncoding () )
     (if (((F /\ ((((vec_of_bits [access_vec_dec scale (( 5 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () ))
     (let (fracbits : ii) = ((( 64 : int):ii) - ((lem$w2ui scale))) in
     let b__26 = ((concat_vec ((slice opcode (( 1 : int):ii) (( 2 : int):ii)  :  2 words$word)) rmode  :  4 words$word)) in sail2_state_monad$bindS
     (if (((b__26 = (vec_of_bits [B0;B0;B1;B1]  :  4 words$word)))) then
        let (rounding : FPRounding) = FPRounding_ZERO in
        let (unsigned : bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
        let (op : FPConvOp) = FPConvOp_CVT_FtoI in
        sail2_state_monad$returnS (op, rounding, unsigned)
      else if (((b__26 = (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)))) then sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__6 :  32 words$word) . 
        let (rounding : FPRounding) = (FPRoundingMode w__6) in
        let (unsigned : bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
        let (op : FPConvOp) = FPConvOp_CVT_ItoF in
        sail2_state_monad$returnS (op, rounding, unsigned))
      else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS (op, rounding, unsigned))) (\ varstup .  let ((op :
       FPConvOp), (rounding : FPRounding), (unsigned : bool)) = varstup in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (aarch64_float_convert_fix d ((make_the_value (( 32 : int):ii)  :  32 itself)) fracbits
       ((make_the_value (( 64 : int):ii)  :  64 itself)) n op rounding unsigned))))))))
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in
     let (intsize : ii) = ((( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (fltsize : ii) .  sail2_state_monad$bindS
     (undefined_FPConvOp () ) (\ (op : FPConvOp) .  sail2_state_monad$bindS
     (undefined_FPRounding () ) (\ (rounding : FPRounding) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (unsigned : bool) . 
     let fltsize = ((( 16 : int):ii)) in sail2_state_monad$seqS
     (if (((F /\ ((((vec_of_bits [access_vec_dec scale (( 5 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word))))))) then
        UnallocatedEncoding () 
      else sail2_state_monad$returnS () )
     (let (fracbits : ii) = ((( 64 : int):ii) - ((lem$w2ui scale))) in
     let b__30 = ((concat_vec ((slice opcode (( 1 : int):ii) (( 2 : int):ii)  :  2 words$word)) rmode  :  4 words$word)) in sail2_state_monad$bindS
     (if (((b__30 = (vec_of_bits [B0;B0;B1;B1]  :  4 words$word)))) then
        let (rounding : FPRounding) = FPRounding_ZERO in
        let (unsigned : bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
        let (op : FPConvOp) = FPConvOp_CVT_FtoI in
        sail2_state_monad$returnS (op, rounding, unsigned)
      else if (((b__30 = (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)))) then sail2_state_monad$bindS
        (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__7 :  32 words$word) . 
        let (rounding : FPRounding) = (FPRoundingMode w__7) in
        let (unsigned : bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
        let (op : FPConvOp) = FPConvOp_CVT_ItoF in
        sail2_state_monad$returnS (op, rounding, unsigned))
      else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS (op, rounding, unsigned))) (\ varstup .  let ((op :
       FPConvOp), (rounding : FPRounding), (unsigned : bool)) = varstup in sail2_state_monad$seqS
     (sail2_state_monad$assert_expS T "")
     (aarch64_float_convert_fix d ((make_the_value (( 16 : int):ii)  :  16 itself)) fracbits
       ((make_the_value (( 64 : int):ii)  :  64 itself)) n op rounding unsigned))))))))))`;


(*val float_compare_uncond_decode : mword ty1 -> mword ty1 -> mword ty2 -> mword ty5 -> mword ty2 -> mword ty5 -> mword ty2 -> M unit*)

val _ = Define `
 ((float_compare_uncond_decode:(1)words$word ->(1)words$word ->(2)words$word ->(5)words$word ->(2)words$word ->(5)words$word ->(2)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) M S1 typ Rm op Rn opc=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (n : ii) = (lem$w2ui Rn) in
   let (m : ii) = (lem$w2ui Rm) in sail2_state_monad$bindS
   (undefined_int () ) (\ (datasize : ii) . 
   let b__0 = typ in sail2_state_monad$bindS
   (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$returnS (( 32 : int):ii)
    else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$returnS (( 64 : int):ii)
    else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$seqS
      (UnallocatedEncoding () ) (sail2_state_monad$returnS datasize)
    else if ((HaveFP16Ext () )) then sail2_state_monad$returnS (( 16 : int):ii)
    else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS datasize)) (\ (datasize : ii) . 
   let (signal_all_nans : bool) =
     ((vec_of_bits [access_vec_dec opc (( 1 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
   let (cmp_with_zero : bool) =
     ((vec_of_bits [access_vec_dec opc (( 0 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)) in
   aarch64_float_compare_uncond cmp_with_zero datasize m n signal_all_nans)))))`;


(*val float_compare_cond_decode : mword ty1 -> mword ty1 -> mword ty2 -> mword ty5 -> mword ty4 -> mword ty5 -> mword ty1 -> mword ty4 -> M unit*)

val _ = Define `
 ((float_compare_cond_decode:(1)words$word ->(1)words$word ->(2)words$word ->(5)words$word ->(4)words$word ->(5)words$word ->(1)words$word ->(4)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) M S1 typ Rm cond Rn op nzcv1=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (n : ii) = (lem$w2ui Rn) in
   let (m : ii) = (lem$w2ui Rm) in sail2_state_monad$bindS
   (undefined_int () ) (\ (datasize : ii) . 
   let b__0 = typ in sail2_state_monad$bindS
   (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$returnS (( 32 : int):ii)
    else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$returnS (( 64 : int):ii)
    else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$seqS
      (UnallocatedEncoding () ) (sail2_state_monad$returnS datasize)
    else if ((HaveFP16Ext () )) then sail2_state_monad$returnS (( 16 : int):ii)
    else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS datasize)) (\ (datasize : ii) . 
   let (signal_all_nans : bool) = (op = (vec_of_bits [B1]  :  1 words$word)) in
   let (condition : 4 bits) = cond in
   let (flags : 4 bits) = nzcv1 in
   aarch64_float_compare_cond condition datasize flags m n signal_all_nans)))))`;


(*val float_arithmetic_unary_decode : mword ty1 -> mword ty1 -> mword ty2 -> mword ty2 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((float_arithmetic_unary_decode:(1)words$word ->(1)words$word ->(2)words$word ->(2)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) M S1 typ opc Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
   (undefined_int () ) (\ (datasize : ii) . 
   let b__0 = typ in sail2_state_monad$bindS
   (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$returnS (( 32 : int):ii)
    else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$returnS (( 64 : int):ii)
    else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$seqS
      (UnallocatedEncoding () ) (sail2_state_monad$returnS datasize)
    else if ((HaveFP16Ext () )) then sail2_state_monad$returnS (( 16 : int):ii)
    else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS datasize)) (\ (datasize : ii) .  sail2_state_monad$bindS
   (undefined_FPUnaryOp () ) (\ (fpop : FPUnaryOp) . 
   let b__4 = opc in
   let (fpop : FPUnaryOp) =
     (if (((b__4 = (vec_of_bits [B0;B0]  :  2 words$word)))) then FPUnaryOp_MOV
     else if (((b__4 = (vec_of_bits [B0;B1]  :  2 words$word)))) then FPUnaryOp_ABS
     else if (((b__4 = (vec_of_bits [B1;B0]  :  2 words$word)))) then FPUnaryOp_NEG
     else FPUnaryOp_SQRT) in
   aarch64_float_arithmetic_unary d datasize fpop n))))))`;


(*val float_arithmetic_round_decode : mword ty1 -> mword ty1 -> mword ty2 -> mword ty3 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((float_arithmetic_round_decode:(1)words$word ->(1)words$word ->(2)words$word ->(3)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) M S1 typ rmode Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
   (undefined_int () ) (\ (datasize : ii) . 
   let b__0 = typ in sail2_state_monad$bindS
   (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$returnS (( 32 : int):ii)
    else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$returnS (( 64 : int):ii)
    else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$seqS
      (UnallocatedEncoding () ) (sail2_state_monad$returnS datasize)
    else if ((HaveFP16Ext () )) then sail2_state_monad$returnS (( 16 : int):ii)
    else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS datasize)) (\ (datasize : ii) . 
   let (exact : bool) = F in sail2_state_monad$bindS
   (undefined_FPRounding () ) (\ (rounding : FPRounding) . 
   let v__101 = rmode in sail2_state_monad$bindS
   (if (((((subrange_vec_dec v__101 (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word)) = (vec_of_bits [B0]  :  1 words$word)))) then
      let (rounding : FPRounding) = (FPDecodeRounding ((slice rmode (( 0 : int):ii) (( 2 : int):ii)  :  2 words$word))) in
      sail2_state_monad$returnS (exact, rounding)
    else if (((v__101 = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) then
      let (rounding : FPRounding) = FPRounding_TIEAWAY in
      sail2_state_monad$returnS (exact, rounding)
    else if (((v__101 = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) then sail2_state_monad$seqS
      (UnallocatedEncoding () ) (sail2_state_monad$returnS (exact, rounding))
    else if (((v__101 = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) then sail2_state_monad$bindS
      (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__0 :  32 words$word) . 
      let (rounding : FPRounding) = (FPRoundingMode w__0) in
      let (exact : bool) = T in
      sail2_state_monad$returnS (exact, rounding))
    else sail2_state_monad$bindS
      (sail2_state_monad$read_regS FPCR_ref  : ( 32 words$word) M) (\ (w__1 :  32 words$word) . 
      let (rounding : FPRounding) = (FPRoundingMode w__1) in
      sail2_state_monad$returnS (exact, rounding))) (\ varstup .  let ((exact : bool), (rounding : FPRounding)) = varstup in
   aarch64_float_arithmetic_round d datasize exact n rounding)))))))`;


(*val float_arithmetic_mul_product_decode : mword ty1 -> mword ty1 -> mword ty2 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((float_arithmetic_mul_product_decode:(1)words$word ->(1)words$word ->(2)words$word ->(5)words$word ->(1)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) M S1 typ Rm op Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in
   let (m : ii) = (lem$w2ui Rm) in sail2_state_monad$bindS
   (undefined_int () ) (\ (datasize : ii) . 
   let b__0 = typ in sail2_state_monad$bindS
   (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$returnS (( 32 : int):ii)
    else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$returnS (( 64 : int):ii)
    else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$seqS
      (UnallocatedEncoding () ) (sail2_state_monad$returnS datasize)
    else if ((HaveFP16Ext () )) then sail2_state_monad$returnS (( 16 : int):ii)
    else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS datasize)) (\ (datasize : ii) . 
   let (negated : bool) = (op = (vec_of_bits [B1]  :  1 words$word)) in
   aarch64_float_arithmetic_mul_product d datasize m n negated)))))`;


(*val float_arithmetic_mul_addsub_decode : mword ty1 -> mword ty1 -> mword ty2 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((float_arithmetic_mul_addsub_decode:(1)words$word ->(1)words$word ->(2)words$word ->(1)words$word ->(5)words$word ->(1)words$word ->(5)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) M S1 typ o1 Rm o0 Ra Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (d : ii) = (lem$w2ui Rd) in
   let (a : ii) = (lem$w2ui Ra) in
   let (n : ii) = (lem$w2ui Rn) in
   let (m : ii) = (lem$w2ui Rm) in sail2_state_monad$bindS
   (undefined_int () ) (\ (datasize : ii) . 
   let b__0 = typ in sail2_state_monad$bindS
   (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$returnS (( 32 : int):ii)
    else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$returnS (( 64 : int):ii)
    else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$seqS
      (UnallocatedEncoding () ) (sail2_state_monad$returnS datasize)
    else if ((HaveFP16Ext () )) then sail2_state_monad$returnS (( 16 : int):ii)
    else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS datasize)) (\ (datasize : ii) . 
   let (opa_neg : bool) = (o1 = (vec_of_bits [B1]  :  1 words$word)) in
   let (op1_neg : bool) = (o0 <> o1) in
   aarch64_float_arithmetic_mul_addsub a d datasize m n op1_neg opa_neg)))))`;


(*val float_arithmetic_maxmin_decode : mword ty1 -> mword ty1 -> mword ty2 -> mword ty5 -> mword ty2 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((float_arithmetic_maxmin_decode:(1)words$word ->(1)words$word ->(2)words$word ->(5)words$word ->(2)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) M S1 typ Rm op Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in
   let (m : ii) = (lem$w2ui Rm) in sail2_state_monad$bindS
   (undefined_int () ) (\ (datasize : ii) . 
   let b__0 = typ in sail2_state_monad$bindS
   (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$returnS (( 32 : int):ii)
    else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$returnS (( 64 : int):ii)
    else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$seqS
      (UnallocatedEncoding () ) (sail2_state_monad$returnS datasize)
    else if ((HaveFP16Ext () )) then sail2_state_monad$returnS (( 16 : int):ii)
    else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS datasize)) (\ (datasize : ii) .  sail2_state_monad$bindS
   (undefined_FPMaxMinOp () ) (\ (operation : FPMaxMinOp) . 
   let b__4 = op in
   let (operation : FPMaxMinOp) =
     (if (((b__4 = (vec_of_bits [B0;B0]  :  2 words$word)))) then FPMaxMinOp_MAX
     else if (((b__4 = (vec_of_bits [B0;B1]  :  2 words$word)))) then FPMaxMinOp_MIN
     else if (((b__4 = (vec_of_bits [B1;B0]  :  2 words$word)))) then FPMaxMinOp_MAXNUM
     else FPMaxMinOp_MINNUM) in
   aarch64_float_arithmetic_maxmin d datasize m n operation))))))`;


(*val float_arithmetic_div_decode : mword ty1 -> mword ty1 -> mword ty2 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((float_arithmetic_div_decode:(1)words$word ->(1)words$word ->(2)words$word ->(5)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) M S1 typ Rm Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in
   let (m : ii) = (lem$w2ui Rm) in sail2_state_monad$bindS
   (undefined_int () ) (\ (datasize : ii) . 
   let b__0 = typ in sail2_state_monad$bindS
   (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$returnS (( 32 : int):ii)
    else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$returnS (( 64 : int):ii)
    else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$seqS
      (UnallocatedEncoding () ) (sail2_state_monad$returnS datasize)
    else if ((HaveFP16Ext () )) then sail2_state_monad$returnS (( 16 : int):ii)
    else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS datasize)) (\ (datasize : ii) . 
   aarch64_float_arithmetic_div d datasize m n)))))`;


(*val float_arithmetic_addsub_decode : mword ty1 -> mword ty1 -> mword ty2 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((float_arithmetic_addsub_decode:(1)words$word ->(1)words$word ->(2)words$word ->(5)words$word ->(1)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) M S1 typ Rm op Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in
   let (m : ii) = (lem$w2ui Rm) in sail2_state_monad$bindS
   (undefined_int () ) (\ (datasize : ii) . 
   let b__0 = typ in sail2_state_monad$bindS
   (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$returnS (( 32 : int):ii)
    else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$returnS (( 64 : int):ii)
    else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$seqS
      (UnallocatedEncoding () ) (sail2_state_monad$returnS datasize)
    else if ((HaveFP16Ext () )) then sail2_state_monad$returnS (( 16 : int):ii)
    else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS datasize)) (\ (datasize : ii) . 
   let (sub_op : bool) = (op = (vec_of_bits [B1]  :  1 words$word)) in
   aarch64_float_arithmetic_addsub d datasize m n sub_op)))))`;


(*val branch_unconditional_register_decode : mword ty1 -> mword ty1 -> mword ty2 -> mword ty5 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((branch_unconditional_register_decode:(1)words$word ->(1)words$word ->(2)words$word ->(5)words$word ->(4)words$word ->(1)words$word ->(1)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) Z opc op op2 op3 A M Rn Rm=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
   (undefined_BranchType () ) (\ (branch_type : BranchType) . 
   let (m : ii) = (lem$w2ui Rm) in
   let (pac : bool) = (A = (vec_of_bits [B1]  :  1 words$word)) in
   let (use_key_a : bool) = (M = (vec_of_bits [B0]  :  1 words$word)) in
   let (source_is_sp : bool) =
     ((((Z = (vec_of_bits [B1]  :  1 words$word)))) /\ (((((ex_int m)) = (( 31 : int):ii))))) in sail2_state_monad$seqS
   (if (((((~ pac)) /\ (((((ex_int m)) <> (( 0 : int):ii))))))) then UnallocatedEncoding () 
    else if (((pac /\ ((~ ((HavePACExt () ))))))) then UnallocatedEncoding () 
    else sail2_state_monad$returnS () )
   (let b__0 = op in sail2_state_monad$bindS
   (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then sail2_state_monad$returnS BranchType_JMP
    else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then sail2_state_monad$returnS BranchType_CALL
    else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then sail2_state_monad$returnS BranchType_RET
    else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS branch_type)) (\ (branch_type : BranchType) .  sail2_state_monad$bindS
   (if pac then sail2_state_monad$seqS
      (if ((((((Z = (vec_of_bits [B0]  :  1 words$word)))) /\ (((((ex_int m)) <> (( 31 : int):ii)))))))
       then
         UnallocatedEncoding () 
       else sail2_state_monad$returnS () )
      (if (((branch_type = BranchType_RET))) then sail2_state_monad$seqS
        (if (((((ex_int n)) <> (( 31 : int):ii)))) then UnallocatedEncoding () 
         else sail2_state_monad$returnS () )
        (let (n : ii) = ((( 30 : int):ii)) in
        let (source_is_sp : bool) = T in
        sail2_state_monad$returnS (n, source_is_sp))
      else sail2_state_monad$returnS (n, source_is_sp))
    else sail2_state_monad$returnS (n, source_is_sp)) (\ varstup .  let ((n : ii), (source_is_sp : bool)) = varstup in
   aarch64_branch_unconditional_register branch_type m n pac source_is_sp use_key_a)))))))`;


(*val branch_unconditional_eret_decode : mword ty4 -> mword ty5 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((branch_unconditional_eret_decode:(4)words$word ->(5)words$word ->(4)words$word ->(1)words$word ->(1)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) opc op2 op3 A M Rn op4=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (sail2_state_monad$read_regS PSTATE_ref)) (\ (w__0 : ProcState) .  sail2_state_monad$seqS
   (if (((w__0.ProcState_EL = EL0))) then UnallocatedEncoding () 
    else sail2_state_monad$returnS () )
   (let (pac : bool) = (A = (vec_of_bits [B1]  :  1 words$word)) in
   let (use_key_a : bool) = (M = (vec_of_bits [B0]  :  1 words$word)) in sail2_state_monad$seqS (sail2_state_monad$seqS
   (if (((((~ pac)) /\ (((op4 <> (vec_of_bits [B0;B0;B0;B0;B0]  :  5 words$word))))))) then
      UnallocatedEncoding () 
    else if (((pac /\ (((((~ ((HavePACExt () )))) \/ (((op4 <> (vec_of_bits [B1;B1;B1;B1;B1]  :  5 words$word)))))))))) then
      UnallocatedEncoding () 
    else sail2_state_monad$returnS () )
   (if (((Rn <> (vec_of_bits [B1;B1;B1;B1;B1]  :  5 words$word)))) then UnallocatedEncoding () 
    else sail2_state_monad$returnS () ))
   (aarch64_branch_unconditional_eret pac use_key_a)))))`;


(*val branch_unconditional_dret_decode : mword ty4 -> mword ty5 -> mword ty6 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((branch_unconditional_dret_decode:(4)words$word ->(5)words$word ->(6)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) opc op2 op3 Rt op4=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (sail2_state$or_boolS ( sail2_state_monad$bindS(Halted () ) (\ (w__0 : bool) .  sail2_state_monad$returnS ((~ w__0))))
     ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__1 : ProcState) .  sail2_state_monad$returnS (((w__1.ProcState_EL = EL0))))))) (\ (w__2 :
     bool) .  sail2_state_monad$seqS
   (if w__2 then UnallocatedEncoding ()  else sail2_state_monad$returnS () ) (aarch64_branch_unconditional_dret () ))))`;


(*val AArch64_CheckSystemAccess : mword ty2 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty3 -> mword ty5 -> mword ty1 -> M unit*)

val _ = Define `
 ((AArch64_CheckSystemAccess:(2)words$word ->(3)words$word ->(4)words$word ->(4)words$word ->(3)words$word ->(5)words$word ->(1)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) op0 op1 crn crm op2 rt read=
    (let (unallocated : bool) = F in
   let (need_secure : bool) = F in sail2_state_monad$bindS
   (undefined_bitvector (( 2 : int):ii)  : ( 2 words$word) M) (\ (min_EL : 2 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (rcs_el0_trap : bool) .  sail2_state_monad$bindS
   (sail2_state$and_boolS
     (sail2_state$and_boolS
        (sail2_state$and_boolS
           (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
              ( sail2_state_monad$bindS(IsSecure () ) (\ (w__0 : bool) .  sail2_state_monad$returnS ((~ w__0)))))
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__2 : 64 bits) . 
            sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__2 (( 20 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
        (sail2_state_monad$returnS (((((and_vec op0 (vec_of_bits [B0;B1]  :  2 words$word)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word))))))
     (sail2_state_monad$returnS (((((and_vec crn (vec_of_bits [B1;B0;B1;B1]  :  4 words$word)  :  4 words$word)) = (vec_of_bits [B1;B0;B1;B1]  :  4 words$word)))))) (\ (w__5 : bool) .  sail2_state_monad$seqS
   (if w__5 then sail2_state_monad$bindS
      (sail2_state_monad$undefined_boolS () ) (\ (w__6 : bool) . 
      let rcs_el0_trap = w__6 in sail2_state_monad$bindS
      (sail2_state$and_boolS
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__7 : ProcState) .  sail2_state_monad$returnS (((w__7.ProcState_EL = EL0)))))
        (sail2_state_monad$returnS rcs_el0_trap)) (\ (w__8 : bool) . 
      if w__8 then AArch64_SystemRegisterTrap EL2 op0 op2 op1 crn rt crm read
      else sail2_state_monad$bindS
        (sail2_state_monad$read_regS PSTATE_ref) (\ (w__9 : ProcState) . 
        if (((w__9.ProcState_EL = EL1))) then
          AArch64_SystemRegisterTrap EL2 op0 op2 op1 crn rt crm read
        else sail2_state_monad$returnS () )))
    else sail2_state_monad$returnS () )
   (let v__103 = op1 in sail2_state_monad$bindS
   (if (((((subrange_vec_dec v__103 (( 2 : int):ii) (( 1 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B0]  :  2 words$word)))) then
      let (min_EL : 2 bits) = EL1 in
      sail2_state_monad$returnS (min_EL, need_secure)
    else if (((v__103 = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) then
      let (min_EL : 2 bits) = EL1 in
      sail2_state_monad$returnS (min_EL, need_secure)
    else if (((v__103 = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) then
      let (min_EL : 2 bits) = EL0 in
      sail2_state_monad$returnS (min_EL, need_secure)
    else if (((v__103 = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) then
      let (min_EL : 2 bits) = EL2 in
      sail2_state_monad$returnS (min_EL, need_secure)
    else if (((v__103 = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) then sail2_state_monad$seqS
      (if ((~ ((HaveVirtHostExt () )))) then UnallocatedEncoding () 
       else sail2_state_monad$returnS () )
      (let (min_EL : 2 bits) = EL2 in
      sail2_state_monad$returnS (min_EL, need_secure))
    else
      let ((min_EL : 2 bits), (need_secure : bool)) =
        (if (((v__103 = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) then
          let (min_EL : 2 bits) = EL3 in
          (min_EL, need_secure)
        else
          let (min_EL : 2 bits) = EL1 in
          let (need_secure : bool) = T in
          (min_EL, need_secure)) in
      sail2_state_monad$returnS (min_EL, need_secure)) (\ varstup .  let ((min_EL : 2 bits), (need_secure : bool)) = varstup in sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__10 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (if ((((lem$w2ui w__10.ProcState_EL)) < ((lem$w2ui min_EL)))) then sail2_state_monad$bindS
      (sail2_state$and_boolS
        (sail2_state$and_boolS
           (sail2_state$and_boolS
              (sail2_state$and_boolS
                 (sail2_state$and_boolS
                    ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__11 : ProcState) . 
                     sail2_state_monad$returnS (((w__11.ProcState_EL = EL1))))) (sail2_state_monad$returnS (((min_EL = EL2)))))
                 (sail2_state_monad$returnS ((HaveNVExt () ))))
              ( sail2_state_monad$bindS(IsSecure () ) (\ (w__14 : bool) .  sail2_state_monad$returnS ((~ w__14))))) (sail2_state_monad$returnS ((HaveEL EL2))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__17 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__17 (( 42 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__18 : bool) . 
      if w__18 then AArch64_SystemRegisterTrap EL2 op0 op2 op1 crn rt crm read
      else UnallocatedEncoding () )
    else sail2_state_monad$bindS
      (sail2_state$and_boolS (sail2_state_monad$returnS need_secure) ( sail2_state_monad$bindS(IsSecure () ) (\ (w__19 : bool) .  sail2_state_monad$returnS ((~ w__19))))) (\ (w__20 :
        bool) . 
      if w__20 then UnallocatedEncoding () 
      else sail2_state_monad$bindS
        (AArch64_CheckUnallocatedSystemAccess op0 op1 crn crm op2 read) (\ (w__21 : bool) . 
        if w__21 then UnallocatedEncoding () 
        else sail2_state_monad$returnS () )))
   (undefined_bitvector (( 2 : int):ii)  : ( 2 words$word) M)) (\ (target_el : 2 bits) .  sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (take_trap : bool) .  sail2_state_monad$bindS
   (AArch64_CheckAdvSIMDFPSystemRegisterTraps op0 op1 crn crm op2 read  : ((bool #  2 words$word)) M) (\ varstup .  let (tup__0, tup__1) = varstup in
   let take_trap = tup__0 in
   let target_el = tup__1 in sail2_state_monad$bindS (sail2_state_monad$seqS
   (if take_trap then AArch64_AdvSIMDFPAccessTrap target_el
    else sail2_state_monad$returnS () )
   (AArch64_CheckSystemRegisterTraps op0 op1 crn crm op2 read  : ((bool #  2 words$word)) M)) (\ varstup .  let (tup__0, tup__1) = varstup in
   let take_trap = tup__0 in
   let target_el = tup__1 in
   if take_trap then AArch64_SystemRegisterTrap target_el op0 op2 op1 crn rt crm read
   else sail2_state_monad$returnS () ))))))))))))`;


(*val system_sysops_decode : mword ty1 -> mword ty2 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty3 -> mword ty5 -> M unit*)

val _ = Define `
 ((system_sysops_decode:(1)words$word ->(2)words$word ->(3)words$word ->(4)words$word ->(4)words$word ->(3)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) L op0 op1 CRn CRm op2 Rt=  (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (AArch64_CheckSystemAccess (vec_of_bits [B0;B1]  :  2 words$word) op1 CRn CRm op2 Rt L))
   (let (t : ii) = (lem$w2ui Rt) in
   let (sys_op0 : ii) = ((( 1 : int):ii)) in
   let (sys_op1 : ii) = (lem$w2ui op1) in
   let (sys_op2 : ii) = (lem$w2ui op2) in
   let (sys_crn : ii) = (lem$w2ui CRn) in
   let (sys_crm : ii) = (lem$w2ui CRm) in
   let (has_result : bool) = (L = (vec_of_bits [B1]  :  1 words$word)) in
   aarch64_system_sysops has_result sys_crm sys_crn sys_op0 sys_op1 sys_op2 t)))`;


(*val system_register_system_decode : mword ty1 -> mword ty1 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty3 -> mword ty5 -> M unit*)

val _ = Define `
 ((system_register_system_decode:(1)words$word ->(1)words$word ->(3)words$word ->(4)words$word ->(4)words$word ->(3)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) L o0 op1 CRn CRm op2 Rt=  (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (AArch64_CheckSystemAccess ((concat_vec (vec_of_bits [B1]  :  1 words$word) o0  :  2 words$word)) op1 CRn
     CRm op2 Rt L))
   (let (t : ii) = (lem$w2ui Rt) in
   let (sys_op0 : ii) = ((( 2 : int):ii) + ((lem$w2ui o0))) in
   let (sys_op1 : ii) = (lem$w2ui op1) in
   let (sys_op2 : ii) = (lem$w2ui op2) in
   let (sys_crn : ii) = (lem$w2ui CRn) in
   let (sys_crm : ii) = (lem$w2ui CRm) in
   let (read : bool) = (L = (vec_of_bits [B1]  :  1 words$word)) in
   aarch64_system_register_system read sys_crm sys_crn sys_op0 sys_op1 sys_op2 t)))`;


(*val system_register_cpsr_decode : mword ty1 -> mword ty2 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty3 -> mword ty5 -> M unit*)

val _ = Define `
 ((system_register_cpsr_decode:(1)words$word ->(2)words$word ->(3)words$word ->(4)words$word ->(4)words$word ->(3)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) L op0 op1 CRn CRm op2 Rt=  (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (AArch64_CheckSystemAccess (vec_of_bits [B0;B0]  :  2 words$word) op1
     (vec_of_bits [B0;B1;B0;B0]  :  4 words$word) CRm op2 (vec_of_bits [B1;B1;B1;B1;B1]  :  5 words$word)
     (vec_of_bits [B0]  :  1 words$word)))
   (let (operand : 4 bits) = CRm in sail2_state_monad$bindS
   (undefined_PSTATEField () ) (\ (field' : PSTATEField) . 
   let b__0 = ((concat_vec op1 op2  :  6 words$word)) in sail2_state_monad$bindS
   (if (((b__0 = (vec_of_bits [B0;B0;B0;B0;B1;B1]  :  6 words$word)))) then sail2_state_monad$seqS
      (if ((~ ((HaveUAOExt () )))) then UnallocatedEncoding () 
       else sail2_state_monad$returnS () )
      (sail2_state_monad$returnS PSTATEField_UAO)
    else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0]  :  6 words$word)))) then sail2_state_monad$seqS
      (if ((~ ((HavePANExt () )))) then UnallocatedEncoding () 
       else sail2_state_monad$returnS () )
      (sail2_state_monad$returnS PSTATEField_PAN)
    else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1]  :  6 words$word)))) then
      sail2_state_monad$returnS PSTATEField_SP
    else if (((b__0 = (vec_of_bits [B0;B1;B1;B1;B1;B0]  :  6 words$word)))) then
      sail2_state_monad$returnS PSTATEField_DAIFSet
    else if (((b__0 = (vec_of_bits [B0;B1;B1;B1;B1;B1]  :  6 words$word)))) then
      sail2_state_monad$returnS PSTATEField_DAIFClr
    else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS field')) (\ (field' : PSTATEField) .  sail2_state_monad$bindS
   (sail2_state$and_boolS
     (sail2_state$and_boolS (sail2_state_monad$returnS (((op1 = (vec_of_bits [B0;B1;B1]  :  3 words$word)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) .  sail2_state_monad$returnS (((w__0.ProcState_EL = EL0))))))
     (sail2_state$or_boolS ((IsInHost () ))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS SCTLR_EL1_ref  : ( 32 words$word) M) (\ (w__3 : 32 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__3 (( 9 : int):ii)]  :  1 words$word) = (vec_of_bits [B0]  :  1 words$word)))))))) (\ (w__5 : bool) .  sail2_state_monad$seqS
   (if w__5 then
      AArch64_SystemRegisterTrap EL1 (vec_of_bits [B0;B0]  :  2 words$word) op2 op1
        (vec_of_bits [B0;B1;B0;B0]  :  4 words$word) (vec_of_bits [B1;B1;B1;B1;B1]  :  5 words$word) CRm
        (vec_of_bits [B0]  :  1 words$word)
    else sail2_state_monad$returnS () )
   (aarch64_system_register_cpsr field' operand)))))))`;


(*val AArch64_CheckForSMCUndefOrTrap : mword ty16 -> M unit*)

val _ = Define `
 ((AArch64_CheckForSMCUndefOrTrap:(16)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) imm=  (sail2_state_monad$bindS
   (sail2_state_monad$read_regS PSTATE_ref) (\ (w__0 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (if (((w__0.ProcState_EL = EL0))) then UnallocatedEncoding () 
    else sail2_state_monad$returnS () )
   (sail2_state_monad$undefined_boolS () )) (\ (route_to_el2 : bool) .  sail2_state_monad$bindS
   (if ((~ ((HaveEL EL3)))) then sail2_state_monad$bindS
      (sail2_state$and_boolS
        (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
           ( sail2_state_monad$bindS(IsSecure () ) (\ (w__1 : bool) .  sail2_state_monad$returnS ((~ w__1)))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__3 : ProcState) .  sail2_state_monad$returnS (((w__3.ProcState_EL = EL1)))))) (\ (w__4 :
        bool) . 
      if w__4 then sail2_state_monad$bindS
        (sail2_state$and_boolS
          (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveNVExt () )))
             ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__5 : 64 bits) . 
              sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__5 (( 42 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))))))
          ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__7 : 64 bits) . 
           sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__7 (( 19 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (w__8 : bool) . 
        if w__8 then sail2_state_monad$returnS T
        else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS route_to_el2))
      else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS route_to_el2))
    else
      sail2_state$and_boolS
        (sail2_state$and_boolS
           (sail2_state$and_boolS (sail2_state_monad$returnS ((HaveEL EL2)))
              ( sail2_state_monad$bindS(IsSecure () ) (\ (w__9 : bool) .  sail2_state_monad$returnS ((~ w__9)))))
           ( sail2_state_monad$bindS(sail2_state_monad$read_regS PSTATE_ref) (\ (w__11 : ProcState) . 
            sail2_state_monad$returnS (((w__11.ProcState_EL = EL1))))))
        ( sail2_state_monad$bindS(sail2_state_monad$read_regS HCR_EL2_ref  : ( 64 words$word) M) (\ (w__13 : 64 bits) . 
         sail2_state_monad$returnS ((((vec_of_bits [access_vec_dec w__13 (( 19 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) (\ (route_to_el2 : bool) .  sail2_state_monad$bindS
   (undefined_ExceptionRecord () ) (\ (exception : ExceptionRecord) .  sail2_state_monad$bindS
   (undefined_int () ) (\ (vect_offset : ii) . 
   if route_to_el2 then sail2_state_monad$bindS
     (ThisInstrAddr (( 64 : int):ii) ()   : ( 64 words$word) M) (\ (preferred_exception_return : 64 bits) . 
     let vect_offset = ((( 0 : int):ii)) in sail2_state_monad$bindS
     (ExceptionSyndrome Exception_MonitorCall) (\ (w__15 : ExceptionRecord) . 
     let exception = w__15 in
     let (tmp_40 : 25 bits) = (exception.ExceptionRecord_syndrome) in
     let tmp_40 = ((set_slice (( 25 : int):ii) (( 16 : int):ii) tmp_40 (( 0 : int):ii) imm  :  25 words$word)) in
     let exception = ((exception with<| ExceptionRecord_syndrome := tmp_40|>)) in
     AArch64_TakeException EL2 exception preferred_exception_return vect_offset))
   else sail2_state_monad$returnS () )))))))`;


(*val aarch64_system_exceptions_runtime_smc : mword ty16 -> M unit*)

val _ = Define `
 ((aarch64_system_exceptions_runtime_smc:(16)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) imm=  (sail2_state_monad$bindS (sail2_state_monad$seqS
   (AArch64_CheckForSMCUndefOrTrap imm)
   (sail2_state_monad$read_regS SCR_EL3_ref  : ( 32 words$word) M)) (\ (w__0 : 32 bits) . 
   if ((((vec_of_bits [access_vec_dec w__0 (( 7 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word)))) then
     AArch64_UndefinedFault () 
   else AArch64_CallSecureMonitor imm)))`;


(*val system_exceptions_runtime_smc_decode : mword ty3 -> mword ty16 -> mword ty3 -> mword ty2 -> M unit*)

val _ = Define `
 ((system_exceptions_runtime_smc_decode:(3)words$word ->(16)words$word ->(3)words$word ->(2)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) opc imm16 op2 LL=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (imm : 16 bits) = imm16 in
   aarch64_system_exceptions_runtime_smc imm)))`;


(*val ReservedValue : unit -> M unit*)

val _ = Define `
 ((ReservedValue:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (sail2_state$and_boolS ((UsingAArch32 () ))
     ( sail2_state_monad$bindS(AArch32_GeneralExceptionsToAArch64 () ) (\ (w__1 : bool) .  sail2_state_monad$returnS ((~ w__1))))) (\ (w__2 :
     bool) . 
   if w__2 then AArch32_TakeUndefInstrException__0 () 
   else AArch64_UndefinedFault () )))`;


(*val memory_vector_multiple_postinc_aarch64_memory_vector_multiple_nowb__decode : mword ty1 -> mword ty1 -> mword ty5 -> mword ty4 -> mword ty2 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_vector_multiple_postinc_aarch64_memory_vector_multiple_nowb__decode:(1)words$word ->(1)words$word ->(5)words$word ->(4)words$word ->(2)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 L Rm opcode b__1 Rn Rt=
    (if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in
     let (elements : ii) = ((( 64 : int):ii) / (( 8 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (rpt : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (selem : ii) . 
     let b__2 = opcode in sail2_state_monad$bindS
     (if (((b__2 = (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 4 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__2 = (vec_of_bits [B0;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 4 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__2 = (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 3 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__2 = (vec_of_bits [B0;B1;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 3 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__2 = (vec_of_bits [B0;B1;B1;B1]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__2 = (vec_of_bits [B1;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 2 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__2 = (vec_of_bits [B1;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 2 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS (rpt, selem))) (\ varstup .  let ((rpt : ii), (selem :
       ii)) = varstup in sail2_state_monad$seqS
     (if (((F /\ (((((ex_int selem)) <> (( 1 : int):ii))))))) then ReservedValue () 
      else sail2_state_monad$returnS () )
     (aarch64_memory_vector_multiple_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((ex_int elements)) ((make_the_value (( 8 : int):ii)  :  8 itself)) m memop n ((ex_int rpt))
       ((ex_int selem)) t T)))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in
     let (elements : ii) = ((( 64 : int):ii) / (( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (rpt : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (selem : ii) . 
     let b__11 = opcode in sail2_state_monad$bindS
     (if (((b__11 = (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 4 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__11 = (vec_of_bits [B0;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 4 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__11 = (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 3 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__11 = (vec_of_bits [B0;B1;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 3 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__11 = (vec_of_bits [B0;B1;B1;B1]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__11 = (vec_of_bits [B1;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 2 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__11 = (vec_of_bits [B1;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 2 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS (rpt, selem))) (\ varstup .  let ((rpt : ii), (selem :
       ii)) = varstup in sail2_state_monad$seqS
     (if (((F /\ (((((ex_int selem)) <> (( 1 : int):ii))))))) then ReservedValue () 
      else sail2_state_monad$returnS () )
     (aarch64_memory_vector_multiple_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((ex_int elements)) ((make_the_value (( 16 : int):ii)  :  16 itself)) m memop n ((ex_int rpt))
       ((ex_int selem)) t T)))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 32 : int):ii)) in
     let (elements : ii) = ((( 64 : int):ii) / (( 32 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (rpt : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (selem : ii) . 
     let b__20 = opcode in sail2_state_monad$bindS
     (if (((b__20 = (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 4 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__20 = (vec_of_bits [B0;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 4 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__20 = (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 3 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__20 = (vec_of_bits [B0;B1;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 3 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__20 = (vec_of_bits [B0;B1;B1;B1]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__20 = (vec_of_bits [B1;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 2 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__20 = (vec_of_bits [B1;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 2 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS (rpt, selem))) (\ varstup .  let ((rpt : ii), (selem :
       ii)) = varstup in sail2_state_monad$seqS
     (if (((F /\ (((((ex_int selem)) <> (( 1 : int):ii))))))) then ReservedValue () 
      else sail2_state_monad$returnS () )
     (aarch64_memory_vector_multiple_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((ex_int elements)) ((make_the_value (( 32 : int):ii)  :  32 itself)) m memop n ((ex_int rpt))
       ((ex_int selem)) t T)))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 64 : int):ii)) in
     let (elements : ii) = ((( 64 : int):ii) / (( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (rpt : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (selem : ii) . 
     let b__29 = opcode in sail2_state_monad$bindS
     (if (((b__29 = (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 4 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__29 = (vec_of_bits [B0;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 4 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__29 = (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 3 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__29 = (vec_of_bits [B0;B1;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 3 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__29 = (vec_of_bits [B0;B1;B1;B1]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__29 = (vec_of_bits [B1;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 2 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__29 = (vec_of_bits [B1;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 2 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS (rpt, selem))) (\ varstup .  let ((rpt : ii), (selem :
       ii)) = varstup in sail2_state_monad$seqS
     (if (((T /\ (((((ex_int selem)) <> (( 1 : int):ii))))))) then ReservedValue () 
      else sail2_state_monad$returnS () )
     (aarch64_memory_vector_multiple_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((ex_int elements)) ((make_the_value (( 64 : int):ii)  :  64 itself)) m memop n ((ex_int rpt))
       ((ex_int selem)) t T)))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in
     let (elements : ii) = ((( 128 : int):ii) / (( 8 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (rpt : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (selem : ii) . 
     let b__38 = opcode in sail2_state_monad$bindS
     (if (((b__38 = (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 4 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__38 = (vec_of_bits [B0;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 4 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__38 = (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 3 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__38 = (vec_of_bits [B0;B1;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 3 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__38 = (vec_of_bits [B0;B1;B1;B1]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__38 = (vec_of_bits [B1;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 2 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__38 = (vec_of_bits [B1;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 2 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS (rpt, selem))) (\ varstup .  let ((rpt : ii), (selem :
       ii)) = varstup in sail2_state_monad$seqS
     (if (((F /\ (((((ex_int selem)) <> (( 1 : int):ii))))))) then ReservedValue () 
      else sail2_state_monad$returnS () )
     (aarch64_memory_vector_multiple_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((ex_int elements)) ((make_the_value (( 8 : int):ii)  :  8 itself)) m memop n ((ex_int rpt))
       ((ex_int selem)) t T)))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in
     let (elements : ii) = ((( 128 : int):ii) / (( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (rpt : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (selem : ii) . 
     let b__47 = opcode in sail2_state_monad$bindS
     (if (((b__47 = (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 4 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__47 = (vec_of_bits [B0;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 4 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__47 = (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 3 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__47 = (vec_of_bits [B0;B1;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 3 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__47 = (vec_of_bits [B0;B1;B1;B1]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__47 = (vec_of_bits [B1;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 2 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__47 = (vec_of_bits [B1;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 2 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS (rpt, selem))) (\ varstup .  let ((rpt : ii), (selem :
       ii)) = varstup in sail2_state_monad$seqS
     (if (((F /\ (((((ex_int selem)) <> (( 1 : int):ii))))))) then ReservedValue () 
      else sail2_state_monad$returnS () )
     (aarch64_memory_vector_multiple_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((ex_int elements)) ((make_the_value (( 16 : int):ii)  :  16 itself)) m memop n ((ex_int rpt))
       ((ex_int selem)) t T)))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 32 : int):ii)) in
     let (elements : ii) = ((( 128 : int):ii) / (( 32 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (rpt : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (selem : ii) . 
     let b__56 = opcode in sail2_state_monad$bindS
     (if (((b__56 = (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 4 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__56 = (vec_of_bits [B0;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 4 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__56 = (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 3 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__56 = (vec_of_bits [B0;B1;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 3 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__56 = (vec_of_bits [B0;B1;B1;B1]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__56 = (vec_of_bits [B1;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 2 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__56 = (vec_of_bits [B1;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 2 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS (rpt, selem))) (\ varstup .  let ((rpt : ii), (selem :
       ii)) = varstup in sail2_state_monad$seqS
     (if (((F /\ (((((ex_int selem)) <> (( 1 : int):ii))))))) then ReservedValue () 
      else sail2_state_monad$returnS () )
     (aarch64_memory_vector_multiple_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((ex_int elements)) ((make_the_value (( 32 : int):ii)  :  32 itself)) m memop n ((ex_int rpt))
       ((ex_int selem)) t T)))))
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in
     let (m : ii) = (lem$w2ui Rm) in
     let (wback : bool) = T in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 64 : int):ii)) in
     let (elements : ii) = ((( 128 : int):ii) / (( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (rpt : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (selem : ii) . 
     let b__65 = opcode in sail2_state_monad$bindS
     (if (((b__65 = (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 4 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__65 = (vec_of_bits [B0;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 4 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__65 = (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 3 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__65 = (vec_of_bits [B0;B1;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 3 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__65 = (vec_of_bits [B0;B1;B1;B1]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__65 = (vec_of_bits [B1;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 2 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__65 = (vec_of_bits [B1;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 2 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS (rpt, selem))) (\ varstup .  let ((rpt : ii), (selem :
       ii)) = varstup in sail2_state_monad$seqS
     (if (((F /\ (((((ex_int selem)) <> (( 1 : int):ii))))))) then ReservedValue () 
      else sail2_state_monad$returnS () )
     (aarch64_memory_vector_multiple_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((ex_int elements)) ((make_the_value (( 64 : int):ii)  :  64 itself)) m memop n ((ex_int rpt))
       ((ex_int selem)) t T)))))))`;


(*val memory_vector_multiple_nowb_aarch64_memory_vector_multiple_nowb__decode : mword ty1 -> mword ty1 -> mword ty4 -> mword ty2 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((memory_vector_multiple_nowb_aarch64_memory_vector_multiple_nowb__decode:(1)words$word ->(1)words$word ->(4)words$word ->(2)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 L opcode b__1 Rn Rt=
    (if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in
     let (elements : ii) = ((( 64 : int):ii) / (( 8 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (rpt : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (selem : ii) . 
     let b__2 = opcode in sail2_state_monad$bindS
     (if (((b__2 = (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 4 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__2 = (vec_of_bits [B0;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 4 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__2 = (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 3 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__2 = (vec_of_bits [B0;B1;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 3 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__2 = (vec_of_bits [B0;B1;B1;B1]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__2 = (vec_of_bits [B1;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 2 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__2 = (vec_of_bits [B1;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 2 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS (rpt, selem))) (\ varstup .  let ((rpt : ii), (selem :
       ii)) = varstup in sail2_state_monad$bindS (sail2_state_monad$seqS
     (if (((F /\ (((((ex_int selem)) <> (( 1 : int):ii))))))) then ReservedValue () 
      else sail2_state_monad$returnS () )
     (undefined_int () )) (\ (w__0 : ii) . 
     aarch64_memory_vector_multiple_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((ex_int elements)) ((make_the_value (( 8 : int):ii)  :  8 itself)) w__0 memop n ((ex_int rpt))
       ((ex_int selem)) t F))))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in
     let (elements : ii) = ((( 64 : int):ii) / (( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (rpt : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (selem : ii) . 
     let b__11 = opcode in sail2_state_monad$bindS
     (if (((b__11 = (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 4 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__11 = (vec_of_bits [B0;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 4 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__11 = (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 3 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__11 = (vec_of_bits [B0;B1;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 3 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__11 = (vec_of_bits [B0;B1;B1;B1]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__11 = (vec_of_bits [B1;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 2 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__11 = (vec_of_bits [B1;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 2 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS (rpt, selem))) (\ varstup .  let ((rpt : ii), (selem :
       ii)) = varstup in sail2_state_monad$bindS (sail2_state_monad$seqS
     (if (((F /\ (((((ex_int selem)) <> (( 1 : int):ii))))))) then ReservedValue () 
      else sail2_state_monad$returnS () )
     (undefined_int () )) (\ (w__1 : ii) . 
     aarch64_memory_vector_multiple_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((ex_int elements)) ((make_the_value (( 16 : int):ii)  :  16 itself)) w__1 memop n ((ex_int rpt))
       ((ex_int selem)) t F))))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 32 : int):ii)) in
     let (elements : ii) = ((( 64 : int):ii) / (( 32 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (rpt : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (selem : ii) . 
     let b__20 = opcode in sail2_state_monad$bindS
     (if (((b__20 = (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 4 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__20 = (vec_of_bits [B0;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 4 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__20 = (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 3 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__20 = (vec_of_bits [B0;B1;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 3 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__20 = (vec_of_bits [B0;B1;B1;B1]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__20 = (vec_of_bits [B1;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 2 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__20 = (vec_of_bits [B1;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 2 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS (rpt, selem))) (\ varstup .  let ((rpt : ii), (selem :
       ii)) = varstup in sail2_state_monad$bindS (sail2_state_monad$seqS
     (if (((F /\ (((((ex_int selem)) <> (( 1 : int):ii))))))) then ReservedValue () 
      else sail2_state_monad$returnS () )
     (undefined_int () )) (\ (w__2 : ii) . 
     aarch64_memory_vector_multiple_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((ex_int elements)) ((make_the_value (( 32 : int):ii)  :  32 itself)) w__2 memop n ((ex_int rpt))
       ((ex_int selem)) t F))))))
   else if ((((((b__0 = (vec_of_bits [B0]  :  1 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 64 : int):ii)) in
     let (elements : ii) = ((( 64 : int):ii) / (( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (rpt : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (selem : ii) . 
     let b__29 = opcode in sail2_state_monad$bindS
     (if (((b__29 = (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 4 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__29 = (vec_of_bits [B0;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 4 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__29 = (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 3 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__29 = (vec_of_bits [B0;B1;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 3 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__29 = (vec_of_bits [B0;B1;B1;B1]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__29 = (vec_of_bits [B1;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 2 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__29 = (vec_of_bits [B1;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 2 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS (rpt, selem))) (\ varstup .  let ((rpt : ii), (selem :
       ii)) = varstup in sail2_state_monad$bindS (sail2_state_monad$seqS
     (if (((T /\ (((((ex_int selem)) <> (( 1 : int):ii))))))) then ReservedValue () 
      else sail2_state_monad$returnS () )
     (undefined_int () )) (\ (w__3 : ii) . 
     aarch64_memory_vector_multiple_nowb ((make_the_value (( 64 : int):ii)  :  64 itself))
       ((ex_int elements)) ((make_the_value (( 64 : int):ii)  :  64 itself)) w__3 memop n ((ex_int rpt))
       ((ex_int selem)) t F))))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 8 : int):ii)) in
     let (elements : ii) = ((( 128 : int):ii) / (( 8 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (rpt : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (selem : ii) . 
     let b__38 = opcode in sail2_state_monad$bindS
     (if (((b__38 = (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 4 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__38 = (vec_of_bits [B0;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 4 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__38 = (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 3 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__38 = (vec_of_bits [B0;B1;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 3 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__38 = (vec_of_bits [B0;B1;B1;B1]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__38 = (vec_of_bits [B1;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 2 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__38 = (vec_of_bits [B1;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 2 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS (rpt, selem))) (\ varstup .  let ((rpt : ii), (selem :
       ii)) = varstup in sail2_state_monad$bindS (sail2_state_monad$seqS
     (if (((F /\ (((((ex_int selem)) <> (( 1 : int):ii))))))) then ReservedValue () 
      else sail2_state_monad$returnS () )
     (undefined_int () )) (\ (w__4 : ii) . 
     aarch64_memory_vector_multiple_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((ex_int elements)) ((make_the_value (( 8 : int):ii)  :  8 itself)) w__4 memop n ((ex_int rpt))
       ((ex_int selem)) t F))))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 16 : int):ii)) in
     let (elements : ii) = ((( 128 : int):ii) / (( 16 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (rpt : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (selem : ii) . 
     let b__47 = opcode in sail2_state_monad$bindS
     (if (((b__47 = (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 4 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__47 = (vec_of_bits [B0;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 4 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__47 = (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 3 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__47 = (vec_of_bits [B0;B1;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 3 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__47 = (vec_of_bits [B0;B1;B1;B1]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__47 = (vec_of_bits [B1;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 2 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__47 = (vec_of_bits [B1;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 2 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS (rpt, selem))) (\ varstup .  let ((rpt : ii), (selem :
       ii)) = varstup in sail2_state_monad$bindS (sail2_state_monad$seqS
     (if (((F /\ (((((ex_int selem)) <> (( 1 : int):ii))))))) then ReservedValue () 
      else sail2_state_monad$returnS () )
     (undefined_int () )) (\ (w__5 : ii) . 
     aarch64_memory_vector_multiple_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((ex_int elements)) ((make_the_value (( 16 : int):ii)  :  16 itself)) w__5 memop n ((ex_int rpt))
       ((ex_int selem)) t F))))))
   else if ((((((b__0 = (vec_of_bits [B1]  :  1 words$word)))) /\ (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word))))))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 32 : int):ii)) in
     let (elements : ii) = ((( 128 : int):ii) / (( 32 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (rpt : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (selem : ii) . 
     let b__56 = opcode in sail2_state_monad$bindS
     (if (((b__56 = (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 4 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__56 = (vec_of_bits [B0;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 4 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__56 = (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 3 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__56 = (vec_of_bits [B0;B1;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 3 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__56 = (vec_of_bits [B0;B1;B1;B1]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__56 = (vec_of_bits [B1;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 2 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__56 = (vec_of_bits [B1;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 2 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS (rpt, selem))) (\ varstup .  let ((rpt : ii), (selem :
       ii)) = varstup in sail2_state_monad$bindS (sail2_state_monad$seqS
     (if (((F /\ (((((ex_int selem)) <> (( 1 : int):ii))))))) then ReservedValue () 
      else sail2_state_monad$returnS () )
     (undefined_int () )) (\ (w__6 : ii) . 
     aarch64_memory_vector_multiple_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((ex_int elements)) ((make_the_value (( 32 : int):ii)  :  32 itself)) w__6 memop n ((ex_int rpt))
       ((ex_int selem)) t F))))))
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (t : ii) = (lem$w2ui Rt) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (undefined_int () ) (\ (m : ii) . 
     let (wback : bool) = F in
     let (memop : MemOp) =
       (if (((L = (vec_of_bits [B1]  :  1 words$word)))) then MemOp_LOAD
       else MemOp_STORE) in
     let (esize : ii) = ((( 64 : int):ii)) in
     let (elements : ii) = ((( 128 : int):ii) / (( 64 : int):ii)) in sail2_state_monad$bindS
     (undefined_int () ) (\ (rpt : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (selem : ii) . 
     let b__65 = opcode in sail2_state_monad$bindS
     (if (((b__65 = (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 4 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__65 = (vec_of_bits [B0;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 4 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__65 = (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 3 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__65 = (vec_of_bits [B0;B1;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 3 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__65 = (vec_of_bits [B0;B1;B1;B1]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__65 = (vec_of_bits [B1;B0;B0;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 1 : int):ii)) in
        let (selem : ii) = ((( 2 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else if (((b__65 = (vec_of_bits [B1;B0;B1;B0]  :  4 words$word)))) then
        let (rpt : ii) = ((( 2 : int):ii)) in
        let (selem : ii) = ((( 1 : int):ii)) in
        sail2_state_monad$returnS (rpt, selem)
      else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS (rpt, selem))) (\ varstup .  let ((rpt : ii), (selem :
       ii)) = varstup in sail2_state_monad$bindS (sail2_state_monad$seqS
     (if (((F /\ (((((ex_int selem)) <> (( 1 : int):ii))))))) then ReservedValue () 
      else sail2_state_monad$returnS () )
     (undefined_int () )) (\ (w__7 : ii) . 
     aarch64_memory_vector_multiple_nowb ((make_the_value (( 128 : int):ii)  :  128 itself))
       ((ex_int elements)) ((make_the_value (( 64 : int):ii)  :  64 itself)) w__7 memop n ((ex_int rpt))
       ((ex_int selem)) t F))))))))`;


(*val integer_logical_shiftedreg_decode : mword ty1 -> mword ty2 -> mword ty2 -> mword ty1 -> mword ty5 -> mword ty6 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_logical_shiftedreg_decode:(1)words$word ->(2)words$word ->(2)words$word ->(1)words$word ->(5)words$word ->(6)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) sf opc shift N Rm imm6 Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in
   let (m : ii) = (lem$w2ui Rm) in
   let (datasize : int) =
     (if (((sf = (vec_of_bits [B1]  :  1 words$word)))) then (( 64 : int):ii)
     else (( 32 : int):ii)) in sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (setflags : bool) .  sail2_state_monad$bindS
   (undefined_LogicalOp () ) (\ (op : LogicalOp) . 
   let b__0 = opc in
   let ((op : LogicalOp), (setflags : bool)) =
     (if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then
       let (op : LogicalOp) = LogicalOp_AND in
       let (setflags : bool) = F in
       (op, setflags)
     else
       let ((op : LogicalOp), (setflags : bool)) =
         (if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then
           let (op : LogicalOp) = LogicalOp_ORR in
           let (setflags : bool) = F in
           (op, setflags)
         else
           let ((op : LogicalOp), (setflags : bool)) =
             (if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then
               let (op : LogicalOp) = LogicalOp_EOR in
               let (setflags : bool) = F in
               (op, setflags)
             else
               let (op : LogicalOp) = LogicalOp_AND in
               let (setflags : bool) = T in
               (op, setflags)) in
           (op, setflags)) in
       (op, setflags)) in sail2_state_monad$seqS
   (if ((((((sf = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((vec_of_bits [access_vec_dec imm6 (( 5 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) then
      ReservedValue () 
    else sail2_state_monad$returnS () )
   (let (shift_type : ShiftType) = (DecodeShift shift) in
   let (shift_amount : ii) = (lem$w2ui imm6) in
   let (invert : bool) = (N = (vec_of_bits [B1]  :  1 words$word)) in
   aarch64_integer_logical_shiftedreg d datasize invert m n op setflags shift_amount shift_type))))))`;


(*val integer_insext_extract_immediate_decode : mword ty1 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty6 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_insext_extract_immediate_decode:(1)words$word ->(2)words$word ->(1)words$word ->(1)words$word ->(5)words$word ->(6)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) sf op21 N o0 Rm imms Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in
   let (m : ii) = (lem$w2ui Rm) in
   let (datasize : int) =
     (if (((sf = (vec_of_bits [B1]  :  1 words$word)))) then (( 64 : int):ii)
     else (( 32 : int):ii)) in sail2_state_monad$bindS
   (undefined_int () ) (\ (lsb : ii) .  sail2_state_monad$seqS (sail2_state_monad$seqS
   (if (((N <> sf))) then UnallocatedEncoding () 
    else sail2_state_monad$returnS () )
   (if ((((((sf = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((vec_of_bits [access_vec_dec imms (( 5 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) then
      ReservedValue () 
    else sail2_state_monad$returnS () ))
   (let lsb = (lem$w2ui imms) in
   aarch64_integer_insext_extract_immediate d datasize lsb m n)))))`;


(*val integer_arithmetic_addsub_shiftedreg_decode : mword ty1 -> mword ty1 -> mword ty1 -> mword ty2 -> mword ty5 -> mword ty6 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_arithmetic_addsub_shiftedreg_decode:(1)words$word ->(1)words$word ->(1)words$word ->(2)words$word ->(5)words$word ->(6)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) sf op S1 shift Rm imm6 Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in
   let (m : ii) = (lem$w2ui Rm) in
   let (datasize : int) =
     (if (((sf = (vec_of_bits [B1]  :  1 words$word)))) then (( 64 : int):ii)
     else (( 32 : int):ii)) in
   let (sub_op : bool) = (op = (vec_of_bits [B1]  :  1 words$word)) in
   let (setflags : bool) = (S1 = (vec_of_bits [B1]  :  1 words$word)) in sail2_state_monad$seqS (sail2_state_monad$seqS
   (if (((shift = (vec_of_bits [B1;B1]  :  2 words$word)))) then ReservedValue () 
    else sail2_state_monad$returnS () )
   (if ((((((sf = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((vec_of_bits [access_vec_dec imm6 (( 5 : int):ii)]  :  1 words$word) = (vec_of_bits [B1]  :  1 words$word))))))) then
      ReservedValue () 
    else sail2_state_monad$returnS () ))
   (let (shift_type : ShiftType) = (DecodeShift shift) in
   let (shift_amount : ii) = (lem$w2ui imm6) in
   aarch64_integer_arithmetic_addsub_shiftedreg d datasize m n setflags shift_amount shift_type
     sub_op))))`;


(*val integer_arithmetic_addsub_immediate_decode : mword ty1 -> mword ty1 -> mword ty1 -> mword ty2 -> mword ty12 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_arithmetic_addsub_immediate_decode:(1)words$word ->(1)words$word ->(1)words$word ->(2)words$word ->(12)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 op S1 shift imm12 Rn Rd=
    (if (((b__0 = (vec_of_bits [B0]  :  1 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in
     let (sub_op : bool) = (op = (vec_of_bits [B1]  :  1 words$word)) in
     let (setflags : bool) = (S1 = (vec_of_bits [B1]  :  1 words$word)) in sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (imm : 32 bits) . 
     let b__1 = shift in sail2_state_monad$bindS
     (if (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word)))) then
        (ZeroExtend__0 imm12 ((make_the_value (( 32 : int):ii)  :  32 itself))  : ( 32 words$word) M)
      else if (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word)))) then
        (ZeroExtend__0
           ((concat_vec imm12 ((Zeros__0 ((make_the_value (( 12 : int):ii)  :  12 itself))  :  12 words$word))
              :  24 words$word)) ((make_the_value (( 32 : int):ii)  :  32 itself))
          : ( 32 words$word) M)
      else sail2_state_monad$seqS (ReservedValue () ) (sail2_state_monad$returnS imm)) (\ (imm : 32 bits) . 
     aarch64_integer_arithmetic_addsub_immediate d ((make_the_value (( 32 : int):ii)  :  32 itself)) imm n
       setflags sub_op)))
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in
     let (sub_op : bool) = (op = (vec_of_bits [B1]  :  1 words$word)) in
     let (setflags : bool) = (S1 = (vec_of_bits [B1]  :  1 words$word)) in sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (imm : 64 bits) . 
     let b__4 = shift in sail2_state_monad$bindS
     (if (((b__4 = (vec_of_bits [B0;B0]  :  2 words$word)))) then
        (ZeroExtend__0 imm12 ((make_the_value (( 64 : int):ii)  :  64 itself))  : ( 64 words$word) M)
      else if (((b__4 = (vec_of_bits [B0;B1]  :  2 words$word)))) then
        (ZeroExtend__0
           ((concat_vec imm12 ((Zeros__0 ((make_the_value (( 12 : int):ii)  :  12 itself))  :  12 words$word))
              :  24 words$word)) ((make_the_value (( 64 : int):ii)  :  64 itself))
          : ( 64 words$word) M)
      else sail2_state_monad$seqS (ReservedValue () ) (sail2_state_monad$returnS imm)) (\ (imm : 64 bits) . 
     aarch64_integer_arithmetic_addsub_immediate d ((make_the_value (( 64 : int):ii)  :  64 itself)) imm n
       setflags sub_op)))))`;


(*val integer_arithmetic_addsub_extendedreg_decode : mword ty1 -> mword ty1 -> mword ty1 -> mword ty2 -> mword ty5 -> mword ty3 -> mword ty3 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_arithmetic_addsub_extendedreg_decode:(1)words$word ->(1)words$word ->(1)words$word ->(2)words$word ->(5)words$word ->(3)words$word ->(3)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) sf op S1 opt Rm option_name imm3 Rn Rd=  (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref T)
   (let (d : ii) = (lem$w2ui Rd) in
   let (n : ii) = (lem$w2ui Rn) in
   let (m : ii) = (lem$w2ui Rm) in
   let (datasize : int) =
     (if (((sf = (vec_of_bits [B1]  :  1 words$word)))) then (( 64 : int):ii)
     else (( 32 : int):ii)) in
   let (sub_op : bool) = (op = (vec_of_bits [B1]  :  1 words$word)) in
   let (setflags : bool) = (S1 = (vec_of_bits [B1]  :  1 words$word)) in
   let (extend_type : ExtendType) = (DecodeRegExtend option_name) in
   let (shift : ii) = (lem$w2ui imm3) in sail2_state_monad$seqS
   (if ((((ex_int shift)) > (( 4 : int):ii))) then ReservedValue () 
    else sail2_state_monad$returnS () )
   (aarch64_integer_arithmetic_addsub_extendedreg d datasize extend_type m n setflags shift sub_op))))`;


(*val DecodeBitMasks : forall 'M . Size 'M => integer -> mword ty1 -> mword ty6 -> mword ty6 -> bool -> M (mword 'M * mword 'M)*)

val _ = Define `
 ((DecodeBitMasks:int ->(1)words$word ->(6)words$word ->(6)words$word -> bool ->(regstate)sail2_state_monad$sequential_state ->((('M words$word#'M words$word),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) (M__tv : int) immN imms immr immediate=  (sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (tmask : 64 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (wmask : 64 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 6 : int):ii)  : ( 6 words$word) M) (\ (tmask_and : 6 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 6 : int):ii)  : ( 6 words$word) M) (\ (wmask_and : 6 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 6 : int):ii)  : ( 6 words$word) M) (\ (tmask_or : 6 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 6 : int):ii)  : ( 6 words$word) M) (\ (wmask_or : 6 bits) .  sail2_state_monad$bindS
   (undefined_bitvector (( 6 : int):ii)  : ( 6 words$word) M) (\ (levels : 6 bits) .  sail2_state_monad$bindS
   (HighestSetBit ((concat_vec immN ((not_vec imms  :  6 words$word))  :  7 words$word))) (\ len .  sail2_state_monad$seqS (sail2_state_monad$seqS (sail2_state_monad$seqS
   (sail2_state_monad$assert_expS ((len >= (( 0 : int):ii))) "")
   (if ((len < (( 1 : int):ii))) then ReservedValue () 
    else sail2_state_monad$returnS () ))
   (sail2_state_monad$assert_expS ((M__tv >= ((ex_int ((shl_int (( 1 : int):ii) len)))))) "(M >= (1 << len))"))
   (let levels = ((zext_ones (( 6 : int):ii) len  :  6 words$word)) in sail2_state_monad$seqS
   (if (((immediate /\ (((((and_vec imms levels  :  6 words$word)) = levels)))))) then
      ReservedValue () 
    else sail2_state_monad$returnS () )
   (let (S1 : ii) = (lem$w2ui ((and_vec imms levels  :  6 words$word))) in
   let (R1 : ii) = (lem$w2ui ((and_vec immr levels  :  6 words$word))) in
   let (diff : ii) = (((ex_int S1)) - ((ex_int R1))) in
   let (tmask_and : 6 bits) =
     ((or_vec ((GetSlice_int ((make_the_value (( 6 : int):ii)  :  6 itself)) diff (( 0 : int):ii)  :  6 words$word))
        ((not_vec levels  :  6 words$word))
       :  6 words$word)) in
   let (tmask_or : 6 bits) =
     ((and_vec ((GetSlice_int ((make_the_value (( 6 : int):ii)  :  6 itself)) diff (( 0 : int):ii)  :  6 words$word))
        levels
       :  6 words$word)) in
   let (tmask : 64 bits) = ((Ones__0 ((make_the_value (( 64 : int):ii)  :  64 itself))  :  64 words$word)) in
   let (tmask : 64 bits) =
     ((or_vec
        ((and_vec tmask
            ((replicate_bits
                ((concat_vec
                    ((replicate_bits (vec_of_bits [access_vec_dec tmask_and (( 0 : int):ii)]  :  1 words$word)
                        (( 1 : int):ii)
                       :  1 words$word))
                    ((Ones__0 ((make_the_value (( 1 : int):ii)  :  1 itself))  :  1 words$word))
                   :  2 words$word)) (( 32 : int):ii)
               :  64 words$word))
           :  64 words$word))
        ((replicate_bits
            ((concat_vec ((Zeros__0 ((make_the_value (( 1 : int):ii)  :  1 itself))  :  1 words$word))
                ((replicate_bits (vec_of_bits [access_vec_dec tmask_or (( 0 : int):ii)]  :  1 words$word) (( 1 : int):ii)
                   :  1 words$word))
               :  2 words$word)) (( 32 : int):ii)
           :  64 words$word))
       :  64 words$word)) in
   let (tmask : 64 bits) =
     ((or_vec
        ((and_vec tmask
            ((replicate_bits
                ((concat_vec
                    ((replicate_bits (vec_of_bits [access_vec_dec tmask_and (( 1 : int):ii)]  :  1 words$word)
                        (( 2 : int):ii)
                       :  2 words$word))
                    ((Ones__0 ((make_the_value (( 2 : int):ii)  :  2 itself))  :  2 words$word))
                   :  4 words$word)) (( 16 : int):ii)
               :  64 words$word))
           :  64 words$word))
        ((replicate_bits
            ((concat_vec ((Zeros__0 ((make_the_value (( 2 : int):ii)  :  2 itself))  :  2 words$word))
                ((replicate_bits (vec_of_bits [access_vec_dec tmask_or (( 1 : int):ii)]  :  1 words$word) (( 2 : int):ii)
                   :  2 words$word))
               :  4 words$word)) (( 16 : int):ii)
           :  64 words$word))
       :  64 words$word)) in
   let (tmask : 64 bits) =
     ((or_vec
        ((and_vec tmask
            ((replicate_bits
                ((concat_vec
                    ((replicate_bits (vec_of_bits [access_vec_dec tmask_and (( 2 : int):ii)]  :  1 words$word)
                        (( 4 : int):ii)
                       :  4 words$word))
                    ((Ones__0 ((make_the_value (( 4 : int):ii)  :  4 itself))  :  4 words$word))
                   :  8 words$word)) (( 8 : int):ii)
               :  64 words$word))
           :  64 words$word))
        ((replicate_bits
            ((concat_vec ((Zeros__0 ((make_the_value (( 4 : int):ii)  :  4 itself))  :  4 words$word))
                ((replicate_bits (vec_of_bits [access_vec_dec tmask_or (( 2 : int):ii)]  :  1 words$word) (( 4 : int):ii)
                   :  4 words$word))
               :  8 words$word)) (( 8 : int):ii)
           :  64 words$word))
       :  64 words$word)) in
   let (tmask : 64 bits) =
     ((or_vec
        ((and_vec tmask
            ((replicate_bits
                ((concat_vec
                    ((replicate_bits (vec_of_bits [access_vec_dec tmask_and (( 3 : int):ii)]  :  1 words$word)
                        (( 8 : int):ii)
                       :  8 words$word))
                    ((Ones__0 ((make_the_value (( 8 : int):ii)  :  8 itself))  :  8 words$word))
                   :  16 words$word)) (( 4 : int):ii)
               :  64 words$word))
           :  64 words$word))
        ((replicate_bits
            ((concat_vec ((Zeros__0 ((make_the_value (( 8 : int):ii)  :  8 itself))  :  8 words$word))
                ((replicate_bits (vec_of_bits [access_vec_dec tmask_or (( 3 : int):ii)]  :  1 words$word) (( 8 : int):ii)
                   :  8 words$word))
               :  16 words$word)) (( 4 : int):ii)
           :  64 words$word))
       :  64 words$word)) in
   let (tmask : 64 bits) =
     ((or_vec
        ((and_vec tmask
            ((replicate_bits
                ((concat_vec
                    ((replicate_bits (vec_of_bits [access_vec_dec tmask_and (( 4 : int):ii)]  :  1 words$word)
                        (( 16 : int):ii)
                       :  16 words$word))
                    ((Ones__0 ((make_the_value (( 16 : int):ii)  :  16 itself))  :  16 words$word))
                   :  32 words$word)) (( 2 : int):ii)
               :  64 words$word))
           :  64 words$word))
        ((replicate_bits
            ((concat_vec ((Zeros__0 ((make_the_value (( 16 : int):ii)  :  16 itself))  :  16 words$word))
                ((replicate_bits (vec_of_bits [access_vec_dec tmask_or (( 4 : int):ii)]  :  1 words$word) (( 16 : int):ii)
                   :  16 words$word))
               :  32 words$word)) (( 2 : int):ii)
           :  64 words$word))
       :  64 words$word)) in
   let (tmask : 64 bits) =
     ((or_vec
        ((and_vec tmask
            ((replicate_bits
                ((concat_vec
                    ((replicate_bits (vec_of_bits [access_vec_dec tmask_and (( 5 : int):ii)]  :  1 words$word)
                        (( 32 : int):ii)
                       :  32 words$word))
                    ((Ones__0 ((make_the_value (( 32 : int):ii)  :  32 itself))  :  32 words$word))
                   :  64 words$word)) (( 1 : int):ii)
               :  64 words$word))
           :  64 words$word))
        ((replicate_bits
            ((concat_vec ((Zeros__0 ((make_the_value (( 32 : int):ii)  :  32 itself))  :  32 words$word))
                ((replicate_bits (vec_of_bits [access_vec_dec tmask_or (( 5 : int):ii)]  :  1 words$word) (( 32 : int):ii)
                   :  32 words$word))
               :  64 words$word)) (( 1 : int):ii)
           :  64 words$word))
       :  64 words$word)) in
   let (wmask_and : 6 bits) = ((or_vec immr ((not_vec levels  :  6 words$word))  :  6 words$word)) in
   let (wmask_or : 6 bits) = ((and_vec immr levels  :  6 words$word)) in
   let (wmask : 64 bits) = ((Zeros__0 ((make_the_value (( 64 : int):ii)  :  64 itself))  :  64 words$word)) in
   let (wmask : 64 bits) =
     ((or_vec
        ((and_vec wmask
            ((replicate_bits
                ((concat_vec ((Ones__0 ((make_the_value (( 1 : int):ii)  :  1 itself))  :  1 words$word))
                    ((replicate_bits (vec_of_bits [access_vec_dec wmask_and (( 0 : int):ii)]  :  1 words$word)
                        (( 1 : int):ii)
                       :  1 words$word))
                   :  2 words$word)) (( 32 : int):ii)
               :  64 words$word))
           :  64 words$word))
        ((replicate_bits
            ((concat_vec
                ((replicate_bits (vec_of_bits [access_vec_dec wmask_or (( 0 : int):ii)]  :  1 words$word) (( 1 : int):ii)
                   :  1 words$word)) ((Zeros__0 ((make_the_value (( 1 : int):ii)  :  1 itself))  :  1 words$word))
               :  2 words$word)) (( 32 : int):ii)
           :  64 words$word))
       :  64 words$word)) in
   let (wmask : 64 bits) =
     ((or_vec
        ((and_vec wmask
            ((replicate_bits
                ((concat_vec ((Ones__0 ((make_the_value (( 2 : int):ii)  :  2 itself))  :  2 words$word))
                    ((replicate_bits (vec_of_bits [access_vec_dec wmask_and (( 1 : int):ii)]  :  1 words$word)
                        (( 2 : int):ii)
                       :  2 words$word))
                   :  4 words$word)) (( 16 : int):ii)
               :  64 words$word))
           :  64 words$word))
        ((replicate_bits
            ((concat_vec
                ((replicate_bits (vec_of_bits [access_vec_dec wmask_or (( 1 : int):ii)]  :  1 words$word) (( 2 : int):ii)
                   :  2 words$word)) ((Zeros__0 ((make_the_value (( 2 : int):ii)  :  2 itself))  :  2 words$word))
               :  4 words$word)) (( 16 : int):ii)
           :  64 words$word))
       :  64 words$word)) in
   let (wmask : 64 bits) =
     ((or_vec
        ((and_vec wmask
            ((replicate_bits
                ((concat_vec ((Ones__0 ((make_the_value (( 4 : int):ii)  :  4 itself))  :  4 words$word))
                    ((replicate_bits (vec_of_bits [access_vec_dec wmask_and (( 2 : int):ii)]  :  1 words$word)
                        (( 4 : int):ii)
                       :  4 words$word))
                   :  8 words$word)) (( 8 : int):ii)
               :  64 words$word))
           :  64 words$word))
        ((replicate_bits
            ((concat_vec
                ((replicate_bits (vec_of_bits [access_vec_dec wmask_or (( 2 : int):ii)]  :  1 words$word) (( 4 : int):ii)
                   :  4 words$word)) ((Zeros__0 ((make_the_value (( 4 : int):ii)  :  4 itself))  :  4 words$word))
               :  8 words$word)) (( 8 : int):ii)
           :  64 words$word))
       :  64 words$word)) in
   let (wmask : 64 bits) =
     ((or_vec
        ((and_vec wmask
            ((replicate_bits
                ((concat_vec ((Ones__0 ((make_the_value (( 8 : int):ii)  :  8 itself))  :  8 words$word))
                    ((replicate_bits (vec_of_bits [access_vec_dec wmask_and (( 3 : int):ii)]  :  1 words$word)
                        (( 8 : int):ii)
                       :  8 words$word))
                   :  16 words$word)) (( 4 : int):ii)
               :  64 words$word))
           :  64 words$word))
        ((replicate_bits
            ((concat_vec
                ((replicate_bits (vec_of_bits [access_vec_dec wmask_or (( 3 : int):ii)]  :  1 words$word) (( 8 : int):ii)
                   :  8 words$word)) ((Zeros__0 ((make_the_value (( 8 : int):ii)  :  8 itself))  :  8 words$word))
               :  16 words$word)) (( 4 : int):ii)
           :  64 words$word))
       :  64 words$word)) in
   let (wmask : 64 bits) =
     ((or_vec
        ((and_vec wmask
            ((replicate_bits
                ((concat_vec ((Ones__0 ((make_the_value (( 16 : int):ii)  :  16 itself))  :  16 words$word))
                    ((replicate_bits (vec_of_bits [access_vec_dec wmask_and (( 4 : int):ii)]  :  1 words$word)
                        (( 16 : int):ii)
                       :  16 words$word))
                   :  32 words$word)) (( 2 : int):ii)
               :  64 words$word))
           :  64 words$word))
        ((replicate_bits
            ((concat_vec
                ((replicate_bits (vec_of_bits [access_vec_dec wmask_or (( 4 : int):ii)]  :  1 words$word) (( 16 : int):ii)
                   :  16 words$word))
                ((Zeros__0 ((make_the_value (( 16 : int):ii)  :  16 itself))  :  16 words$word))
               :  32 words$word)) (( 2 : int):ii)
           :  64 words$word))
       :  64 words$word)) in
   let (wmask : 64 bits) =
     ((or_vec
        ((and_vec wmask
            ((replicate_bits
                ((concat_vec ((Ones__0 ((make_the_value (( 32 : int):ii)  :  32 itself))  :  32 words$word))
                    ((replicate_bits (vec_of_bits [access_vec_dec wmask_and (( 5 : int):ii)]  :  1 words$word)
                        (( 32 : int):ii)
                       :  32 words$word))
                   :  64 words$word)) (( 1 : int):ii)
               :  64 words$word))
           :  64 words$word))
        ((replicate_bits
            ((concat_vec
                ((replicate_bits (vec_of_bits [access_vec_dec wmask_or (( 5 : int):ii)]  :  1 words$word) (( 32 : int):ii)
                   :  32 words$word))
                ((Zeros__0 ((make_the_value (( 32 : int):ii)  :  32 itself))  :  32 words$word))
               :  64 words$word)) (( 1 : int):ii)
           :  64 words$word))
       :  64 words$word)) in
   let (wmask : 64 bits) =
     (if (((((GetSlice_int ((make_the_value (( 1 : int):ii)  :  1 itself)) diff (( 6 : int):ii)  :  1 words$word)) <> (vec_of_bits [B0]  :  1 words$word)))) then
       (and_vec wmask tmask  :  64 words$word)
     else (or_vec wmask tmask  :  64 words$word)) in
   sail2_state_monad$returnS ((slice wmask (( 0 : int):ii) M__tv  :  'M words$word), (slice tmask (( 0 : int):ii) M__tv  :  'M words$word))))))))))))))`;


(*val integer_logical_immediate_decode : mword ty1 -> mword ty2 -> mword ty1 -> mword ty6 -> mword ty6 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_logical_immediate_decode:(1)words$word ->(2)words$word ->(1)words$word ->(6)words$word ->(6)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 opc N immr imms Rn Rd=
    (if (((b__0 = (vec_of_bits [B0]  :  1 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (setflags : bool) .  sail2_state_monad$bindS
     (undefined_LogicalOp () ) (\ (op : LogicalOp) . 
     let b__1 = opc in
     let ((op : LogicalOp), (setflags : bool)) =
       (if (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word)))) then
         let (op : LogicalOp) = LogicalOp_AND in
         let (setflags : bool) = F in
         (op, setflags)
       else
         let ((op : LogicalOp), (setflags : bool)) =
           (if (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word)))) then
             let (op : LogicalOp) = LogicalOp_ORR in
             let (setflags : bool) = F in
             (op, setflags)
           else
             let ((op : LogicalOp), (setflags : bool)) =
               (if (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word)))) then
                 let (op : LogicalOp) = LogicalOp_EOR in
                 let (setflags : bool) = F in
                 (op, setflags)
               else
                 let (op : LogicalOp) = LogicalOp_AND in
                 let (setflags : bool) = T in
                 (op, setflags)) in
             (op, setflags)) in
         (op, setflags)) in sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (imm : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (if (((T /\ (((N <> (vec_of_bits [B0]  :  1 words$word))))))) then ReservedValue () 
      else sail2_state_monad$returnS () )
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (anon10 : 32 bits) .  sail2_state_monad$bindS
     (DecodeBitMasks (( 32 : int):ii) N imms immr T  : (( 32 words$word #  32 words$word)) M) (\ (w__0 :
       ( 32 bits # 32 bits)) . 
     let (tup__0, tup__1) = w__0 in
     let imm = tup__0 in
     let anon10 = tup__1 in
     aarch64_integer_logical_immediate d ((make_the_value (( 32 : int):ii)  :  32 itself)) imm n op setflags))))))
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (setflags : bool) .  sail2_state_monad$bindS
     (undefined_LogicalOp () ) (\ (op : LogicalOp) . 
     let b__6 = opc in
     let ((op : LogicalOp), (setflags : bool)) =
       (if (((b__6 = (vec_of_bits [B0;B0]  :  2 words$word)))) then
         let (op : LogicalOp) = LogicalOp_AND in
         let (setflags : bool) = F in
         (op, setflags)
       else
         let ((op : LogicalOp), (setflags : bool)) =
           (if (((b__6 = (vec_of_bits [B0;B1]  :  2 words$word)))) then
             let (op : LogicalOp) = LogicalOp_ORR in
             let (setflags : bool) = F in
             (op, setflags)
           else
             let ((op : LogicalOp), (setflags : bool)) =
               (if (((b__6 = (vec_of_bits [B1;B0]  :  2 words$word)))) then
                 let (op : LogicalOp) = LogicalOp_EOR in
                 let (setflags : bool) = F in
                 (op, setflags)
               else
                 let (op : LogicalOp) = LogicalOp_AND in
                 let (setflags : bool) = T in
                 (op, setflags)) in
             (op, setflags)) in
         (op, setflags)) in sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (imm : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
     (if (((F /\ (((N <> (vec_of_bits [B0]  :  1 words$word))))))) then ReservedValue () 
      else sail2_state_monad$returnS () )
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (anon10 : 64 bits) .  sail2_state_monad$bindS
     (DecodeBitMasks (( 64 : int):ii) N imms immr T  : (( 64 words$word #  64 words$word)) M) (\ (w__1 :
       ( 64 bits # 64 bits)) . 
     let (tup__0, tup__1) = w__1 in
     let imm = tup__0 in
     let anon10 = tup__1 in
     aarch64_integer_logical_immediate d ((make_the_value (( 64 : int):ii)  :  64 itself)) imm n op setflags))))))))`;


(*val integer_bitfield_decode : mword ty1 -> mword ty2 -> mword ty1 -> mword ty6 -> mword ty6 -> mword ty5 -> mword ty5 -> M unit*)

val _ = Define `
 ((integer_bitfield_decode:(1)words$word ->(2)words$word ->(1)words$word ->(6)words$word ->(6)words$word ->(5)words$word ->(5)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) b__0 opc N immr imms Rn Rd=
    (if (((b__0 = (vec_of_bits [B0]  :  1 words$word)))) then sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (inzero : bool) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (extend : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (R1 : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (S1 : ii) .  sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (wmask : 32 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M) (\ (tmask : 32 bits) . 
     let b__1 = opc in sail2_state_monad$bindS
     (if (((b__1 = (vec_of_bits [B0;B0]  :  2 words$word)))) then
        let (inzero : bool) = T in
        let (extend : bool) = T in
        sail2_state_monad$returnS (extend, inzero)
      else if (((b__1 = (vec_of_bits [B0;B1]  :  2 words$word)))) then
        let (inzero : bool) = F in
        let (extend : bool) = F in
        sail2_state_monad$returnS (extend, inzero)
      else if (((b__1 = (vec_of_bits [B1;B0]  :  2 words$word)))) then
        let (inzero : bool) = T in
        let (extend : bool) = F in
        sail2_state_monad$returnS (extend, inzero)
      else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS (extend, inzero))) (\ varstup .  let ((extend : bool), (inzero :
       bool)) = varstup in sail2_state_monad$seqS (sail2_state_monad$seqS
     (if (((F /\ (((N <> (vec_of_bits [B1]  :  1 words$word))))))) then ReservedValue () 
      else sail2_state_monad$returnS () )
     (if (((T /\ (((((((((N <> (vec_of_bits [B0]  :  1 words$word)))) \/ ((((vec_of_bits [access_vec_dec immr (( 5 : int):ii)]  :  1 words$word) <> (vec_of_bits [B0]  :  1 words$word))))))) \/ ((((vec_of_bits [access_vec_dec imms (( 5 : int):ii)]  :  1 words$word) <> (vec_of_bits [B0]  :  1 words$word)))))))))) then
        ReservedValue () 
      else sail2_state_monad$returnS () ))
     (let R1 = (lem$w2ui immr) in
     let S1 = (lem$w2ui imms) in sail2_state_monad$bindS
     (DecodeBitMasks (( 32 : int):ii) N imms immr F  : (( 32 words$word #  32 words$word)) M) (\ (w__0 :
       ( 32 bits # 32 bits)) . 
     let (tup__0, tup__1) = w__0 in
     let wmask = tup__0 in
     let tmask = tup__1 in
     aarch64_integer_bitfield R1 S1 d ((make_the_value (( 32 : int):ii)  :  32 itself)) extend inzero n tmask
       wmask))))))))))
   else sail2_state_monad$seqS
     (sail2_state_monad$write_regS unconditional_ref T)
     (let (d : ii) = (lem$w2ui Rd) in
     let (n : ii) = (lem$w2ui Rn) in sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (inzero : bool) .  sail2_state_monad$bindS
     (sail2_state_monad$undefined_boolS () ) (\ (extend : bool) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (R1 : ii) .  sail2_state_monad$bindS
     (undefined_int () ) (\ (S1 : ii) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (wmask : 64 bits) .  sail2_state_monad$bindS
     (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M) (\ (tmask : 64 bits) . 
     let b__6 = opc in sail2_state_monad$bindS
     (if (((b__6 = (vec_of_bits [B0;B0]  :  2 words$word)))) then
        let (inzero : bool) = T in
        let (extend : bool) = T in
        sail2_state_monad$returnS (extend, inzero)
      else if (((b__6 = (vec_of_bits [B0;B1]  :  2 words$word)))) then
        let (inzero : bool) = F in
        let (extend : bool) = F in
        sail2_state_monad$returnS (extend, inzero)
      else if (((b__6 = (vec_of_bits [B1;B0]  :  2 words$word)))) then
        let (inzero : bool) = T in
        let (extend : bool) = F in
        sail2_state_monad$returnS (extend, inzero)
      else sail2_state_monad$seqS (UnallocatedEncoding () ) (sail2_state_monad$returnS (extend, inzero))) (\ varstup .  let ((extend : bool), (inzero :
       bool)) = varstup in sail2_state_monad$seqS (sail2_state_monad$seqS
     (if (((T /\ (((N <> (vec_of_bits [B1]  :  1 words$word))))))) then ReservedValue () 
      else sail2_state_monad$returnS () )
     (if (((F /\ (((((((((N <> (vec_of_bits [B0]  :  1 words$word)))) \/ ((((vec_of_bits [access_vec_dec immr (( 5 : int):ii)]  :  1 words$word) <> (vec_of_bits [B0]  :  1 words$word))))))) \/ ((((vec_of_bits [access_vec_dec imms (( 5 : int):ii)]  :  1 words$word) <> (vec_of_bits [B0]  :  1 words$word)))))))))) then
        ReservedValue () 
      else sail2_state_monad$returnS () ))
     (let R1 = (lem$w2ui immr) in
     let S1 = (lem$w2ui imms) in sail2_state_monad$bindS
     (DecodeBitMasks (( 64 : int):ii) N imms immr F  : (( 64 words$word #  64 words$word)) M) (\ (w__1 :
       ( 64 bits # 64 bits)) . 
     let (tup__0, tup__1) = w__1 in
     let wmask = tup__0 in
     let tmask = tup__1 in
     aarch64_integer_bitfield R1 S1 d ((make_the_value (( 64 : int):ii)  :  64 itself)) extend inzero n tmask
       wmask))))))))))))`;


(*val decode : mword ty32 -> M unit*)

val _ = Define `
 ((decode:(32)words$word ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) op_code=
    (if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 24 : int):ii)  :  8 words$word)) = (vec_of_bits [B1;B0;B0;B1;B1;B0;B1;B1]  :  8 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 22 : int):ii) (( 21 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((((subrange_vec_dec op_code (( 15 : int):ii) (( 15 : int):ii)  :  1 words$word)) = (vec_of_bits [B0]  :  1 words$word)))))))))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (op54 : 2 bits) = ((subrange_vec_dec op_code (( 30 : int):ii) (( 29 : int):ii)  :  2 words$word)) in
     let (U : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 23 : int):ii)]  :  1 words$word)) in
     let (Rm : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (o0 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 15 : int):ii)]  :  1 words$word)) in
     let (Ra : 5 bits) = ((subrange_vec_dec op_code (( 14 : int):ii) (( 10 : int):ii)  :  5 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_arithmetic_mul_widening_64128hi_decode sf op54 U Rm o0 Ra Rn Rd
   else if (((((subrange_vec_dec op_code (( 29 : int):ii) (( 23 : int):ii)  :  7 words$word)) = (vec_of_bits [B1;B0;B1;B0;B0;B0;B1]  :  7 words$word)))) then
     let (opc : 2 bits) = ((subrange_vec_dec op_code (( 31 : int):ii) (( 30 : int):ii)  :  2 words$word)) in
     let (V1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 : int):ii)]  :  1 words$word)) in
     let (L : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 : int):ii)]  :  1 words$word)) in
     let (imm7 : 7 bits) = ((subrange_vec_dec op_code (( 21 : int):ii) (( 15 : int):ii)  :  7 words$word)) in
     let (Rt2 : 5 bits) = ((subrange_vec_dec op_code (( 14 : int):ii) (( 10 : int):ii)  :  5 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_pair_general_postidx_aarch64_memory_pair_general_postidx__decode opc V1 L imm7 Rt2 Rn Rt
   else if (((((subrange_vec_dec op_code (( 29 : int):ii) (( 23 : int):ii)  :  7 words$word)) = (vec_of_bits [B1;B0;B1;B0;B0;B1;B1]  :  7 words$word)))) then
     let (opc : 2 bits) = ((subrange_vec_dec op_code (( 31 : int):ii) (( 30 : int):ii)  :  2 words$word)) in
     let (V1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 : int):ii)]  :  1 words$word)) in
     let (L : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 : int):ii)]  :  1 words$word)) in
     let (imm7 : 7 bits) = ((subrange_vec_dec op_code (( 21 : int):ii) (( 15 : int):ii)  :  7 words$word)) in
     let (Rt2 : 5 bits) = ((subrange_vec_dec op_code (( 14 : int):ii) (( 10 : int):ii)  :  5 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_pair_general_preidx_aarch64_memory_pair_general_postidx__decode opc V1 L imm7 Rt2 Rn Rt
   else if (((((subrange_vec_dec op_code (( 29 : int):ii) (( 23 : int):ii)  :  7 words$word)) = (vec_of_bits [B1;B0;B1;B0;B0;B1;B0]  :  7 words$word)))) then
     let (opc : 2 bits) = ((subrange_vec_dec op_code (( 31 : int):ii) (( 30 : int):ii)  :  2 words$word)) in
     let (V1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 : int):ii)]  :  1 words$word)) in
     let (L : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 : int):ii)]  :  1 words$word)) in
     let (imm7 : 7 bits) = ((subrange_vec_dec op_code (( 21 : int):ii) (( 15 : int):ii)  :  7 words$word)) in
     let (Rt2 : 5 bits) = ((subrange_vec_dec op_code (( 14 : int):ii) (( 10 : int):ii)  :  5 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_pair_general_offset_aarch64_memory_pair_general_postidx__decode opc V1 L imm7 Rt2 Rn Rt
   else if ((((((((subrange_vec_dec op_code (( 29 : int):ii) (( 24 : int):ii)  :  6 words$word)) = (vec_of_bits [B1;B1;B1;B1;B0;B0]  :  6 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)) = (vec_of_bits [B1]  :  1 words$word)))) /\ (((((subrange_vec_dec op_code (( 11 : int):ii) (( 10 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then
     let (size1 : 2 bits) = ((subrange_vec_dec op_code (( 31 : int):ii) (( 30 : int):ii)  :  2 words$word)) in
     let (V1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 : int):ii)]  :  1 words$word)) in
     let (opc : 2 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 22 : int):ii)  :  2 words$word)) in
     let (Rm : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (option_name : 3 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 13 : int):ii)  :  3 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 12 : int):ii)]  :  1 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_single_simdfp_register_aarch64_memory_single_simdfp_register__decode size1 V1 opc Rm
       option_name S1 Rn Rt
   else if (((((subrange_vec_dec op_code (( 31 : int):ii) (( 24 : int):ii)  :  8 words$word)) = (vec_of_bits [B0;B0;B0;B1;B1;B1;B1;B1]  :  8 words$word)))) then
     let (M : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (typ : 2 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 22 : int):ii)  :  2 words$word)) in
     let (o1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 : int):ii)]  :  1 words$word)) in
     let (Rm : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (o0 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 15 : int):ii)]  :  1 words$word)) in
     let (Ra : 5 bits) = ((subrange_vec_dec op_code (( 14 : int):ii) (( 10 : int):ii)  :  5 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     float_arithmetic_mul_addsub_decode M S1 typ o1 Rm o0 Ra Rn Rd
   else if ((((((((subrange_vec_dec op_code (( 29 : int):ii) (( 24 : int):ii)  :  6 words$word)) = (vec_of_bits [B1;B1;B1;B0;B0;B0]  :  6 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)) = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 15 : int):ii) (( 15 : int):ii)  :  1 words$word)) = (vec_of_bits [B0]  :  1 words$word)))) /\ (((((subrange_vec_dec op_code (( 11 : int):ii) (( 10 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B0]  :  2 words$word))))))))))))) then
     let (size1 : 2 bits) = ((subrange_vec_dec op_code (( 31 : int):ii) (( 30 : int):ii)  :  2 words$word)) in
     let (V1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 : int):ii)]  :  1 words$word)) in
     let (A : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 23 : int):ii)]  :  1 words$word)) in
     let (R1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 : int):ii)]  :  1 words$word)) in
     let (Rs : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (o3 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 15 : int):ii)]  :  1 words$word)) in
     let (opc : 3 bits) = ((subrange_vec_dec op_code (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_atomicops_ld_decode size1 V1 A R1 Rs o3 opc Rn Rt
   else if (((((subrange_vec_dec op_code (( 31 : int):ii) (( 11 : int):ii)  :  21 words$word)) = (vec_of_bits [B1;B1;B0;B1;B1;B0;B1;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B1;B0;B0;B0]
                 :  21 words$word)))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (opcode2 : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (D : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 10 : int):ii)]  :  1 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_pac_strip_dp_1src_decode sf S1 opcode2 D Rn Rd
   else if (((op_code = (vec_of_bits [B1;B1;B0;B1;B0;B1;B0;B1;B0;B0;B0;B0;B0;B0;B1;B1;B0;B0;B1;B0;B0;B0;B0;B0;
                             B1;B1;B1;B1;B1;B1;B1;B1]
                 :  32 words$word)))) then
     let (L : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 : int):ii)]  :  1 words$word)) in
     let (op0 : 2 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 19 : int):ii)  :  2 words$word)) in
     let (op1 : 3 bits) = ((subrange_vec_dec op_code (( 18 : int):ii) (( 16 : int):ii)  :  3 words$word)) in
     let (CRn : 4 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 12 : int):ii)  :  4 words$word)) in
     let (CRm : 4 bits) = ((subrange_vec_dec op_code (( 11 : int):ii) (( 8 : int):ii)  :  4 words$word)) in
     let (op2 : 3 bits) = ((subrange_vec_dec op_code (( 7 : int):ii) (( 5 : int):ii)  :  3 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_pac_strip_hint_decode L op0 op1 CRn CRm op2 Rt
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 14 : int):ii)  :  18 words$word)) = (vec_of_bits [B1;B1;B0;B1;B1;B0;B1;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B0]
                     :  18 words$word)))) /\ (((((subrange_vec_dec op_code (( 12 : int):ii) (( 10 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word))))))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (opcode2 : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (Z : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 13 : int):ii)]  :  1 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_pac_pacda_dp_1src_decode sf S1 opcode2 Z Rn Rd
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 12 : int):ii)  :  20 words$word)) = (vec_of_bits [B1;B1;B0;B1;B0;B1;B0;B1;B0;B0;B0;B0;B0;B0;B1;B1;B0;B0;B1;B1]
                     :  20 words$word)))) /\ (((((subrange_vec_dec op_code (( 7 : int):ii) (( 0 : int):ii)  :  8 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1;B1]  :  8 words$word))))))) then
     let (L : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 : int):ii)]  :  1 words$word)) in
     let (op0 : 2 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 19 : int):ii)  :  2 words$word)) in
     let (op1 : 3 bits) = ((subrange_vec_dec op_code (( 18 : int):ii) (( 16 : int):ii)  :  3 words$word)) in
     let (CRn : 4 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 12 : int):ii)  :  4 words$word)) in
     let (CRm : 4 bits) = ((subrange_vec_dec op_code (( 11 : int):ii) (( 8 : int):ii)  :  4 words$word)) in
     let (op2 : 3 bits) = ((subrange_vec_dec op_code (( 7 : int):ii) (( 5 : int):ii)  :  3 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     system_monitors_decode L op0 op1 CRn CRm op2 Rt
   else if ((((((((subrange_vec_dec op_code (( 29 : int):ii) (( 24 : int):ii)  :  6 words$word)) = (vec_of_bits [B1;B1;B1;B0;B0;B0]  :  6 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)) = (vec_of_bits [B0]  :  1 words$word)))) /\ (((((subrange_vec_dec op_code (( 11 : int):ii) (( 10 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then
     let (size1 : 2 bits) = ((subrange_vec_dec op_code (( 31 : int):ii) (( 30 : int):ii)  :  2 words$word)) in
     let (V1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 : int):ii)]  :  1 words$word)) in
     let (opc : 2 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 22 : int):ii)  :  2 words$word)) in
     let (imm9 : 9 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 12 : int):ii)  :  9 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_single_general_immediate_signed_offset_normal_aarch64_memory_single_general_immediate_signed_offset_normal__decode
       size1 V1 opc imm9 Rn Rt
   else if (((((subrange_vec_dec op_code (( 29 : int):ii) (( 23 : int):ii)  :  7 words$word)) = (vec_of_bits [B1;B0;B1;B0;B0;B0;B0]  :  7 words$word)))) then
     let (opc : 2 bits) = ((subrange_vec_dec op_code (( 31 : int):ii) (( 30 : int):ii)  :  2 words$word)) in
     let (V1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 : int):ii)]  :  1 words$word)) in
     let (L : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 : int):ii)]  :  1 words$word)) in
     let (imm7 : 7 bits) = ((subrange_vec_dec op_code (( 21 : int):ii) (( 15 : int):ii)  :  7 words$word)) in
     let (Rt2 : 5 bits) = ((subrange_vec_dec op_code (( 14 : int):ii) (( 10 : int):ii)  :  5 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_pair_general_noalloc_aarch64_memory_pair_general_noalloc__decode opc V1 L imm7 Rt2 Rn Rt
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 24 : int):ii)  :  8 words$word)) = (vec_of_bits [B0;B0;B0;B1;B1;B1;B1;B0]  :  8 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)) = (vec_of_bits [B1]  :  1 words$word)))) /\ (((((subrange_vec_dec op_code (( 14 : int):ii) (( 10 : int):ii)  :  5 words$word)) = (vec_of_bits [B0;B0;B0;B1;B0]  :  5 words$word)))))))))) then
     let (M : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (typ : 2 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 22 : int):ii)  :  2 words$word)) in
     let (Rm : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (op : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 15 : int):ii)]  :  1 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     float_arithmetic_mul_product_decode M S1 typ Rm op Rn Rd
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 21 : int):ii)  :  11 words$word)) = (vec_of_bits [B1;B0;B0;B1;B1;B0;B1;B0;B1;B1;B0]  :  11 words$word)))) /\ (((((subrange_vec_dec op_code (( 15 : int):ii) (( 10 : int):ii)  :  6 words$word)) = (vec_of_bits [B0;B0;B1;B1;B0;B0]  :  6 words$word))))))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (op : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (Rm : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (opcode2 : 6 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 10 : int):ii)  :  6 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_pac_pacga_dp_2src_decode sf op S1 Rm opcode2 Rn Rd
   else if ((((((((subrange_vec_dec op_code (( 29 : int):ii) (( 23 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B0;B0;B0;B1]  :  7 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)) = (vec_of_bits [B1]  :  1 words$word)))) /\ (((((subrange_vec_dec op_code (( 14 : int):ii) (( 10 : int):ii)  :  5 words$word)) = (vec_of_bits [B1;B1;B1;B1;B1]  :  5 words$word)))))))))) then
     let (size1 : 2 bits) = ((subrange_vec_dec op_code (( 31 : int):ii) (( 30 : int):ii)  :  2 words$word)) in
     let (o2 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 23 : int):ii)]  :  1 words$word)) in
     let (L : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 : int):ii)]  :  1 words$word)) in
     let (o1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 : int):ii)]  :  1 words$word)) in
     let (Rs : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (o0 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 15 : int):ii)]  :  1 words$word)) in
     let (Rt2 : 5 bits) = ((subrange_vec_dec op_code (( 14 : int):ii) (( 10 : int):ii)  :  5 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_atomicops_cas_single_decode size1 o2 L o1 Rs o0 Rt2 Rn Rt
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 19 : int):ii)  :  13 words$word)) = (vec_of_bits [B1;B1;B0;B1;B0;B1;B0;B1;B0;B0;B0;B0;B0]  :  13 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 15 : int):ii) (( 12 : int):ii)  :  4 words$word)) = (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)))) /\ (((((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) = (vec_of_bits [B1;B1;B1;B1;B1]  :  5 words$word)))))))))) then
     let (L : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 : int):ii)]  :  1 words$word)) in
     let (op0 : 2 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 19 : int):ii)  :  2 words$word)) in
     let (op1 : 3 bits) = ((subrange_vec_dec op_code (( 18 : int):ii) (( 16 : int):ii)  :  3 words$word)) in
     let (CRn : 4 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 12 : int):ii)  :  4 words$word)) in
     let (CRm : 4 bits) = ((subrange_vec_dec op_code (( 11 : int):ii) (( 8 : int):ii)  :  4 words$word)) in
     let (op2 : 3 bits) = ((subrange_vec_dec op_code (( 7 : int):ii) (( 5 : int):ii)  :  3 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     system_register_cpsr_decode L op0 op1 CRn CRm op2 Rt
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 24 : int):ii)  :  8 words$word)) = (vec_of_bits [B0;B1;B0;B1;B0;B1;B0;B0]  :  8 words$word)))) /\ (((((subrange_vec_dec op_code (( 4 : int):ii) (( 4 : int):ii)  :  1 words$word)) = (vec_of_bits [B0]  :  1 words$word))))))) then
     let (o1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 24 : int):ii)]  :  1 words$word)) in
     let (imm19 : 19 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 5 : int):ii)  :  19 words$word)) in
     let (o0 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 4 : int):ii)]  :  1 words$word)) in
     let (cond : 4 bits) = ((subrange_vec_dec op_code (( 3 : int):ii) (( 0 : int):ii)  :  4 words$word)) in
     branch_conditional_cond_decode o1 imm19 o0 cond
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 21 : int):ii)  :  11 words$word)) = (vec_of_bits [B1;B1;B0;B1;B0;B1;B0;B0;B0;B0;B0]  :  11 words$word)))) /\ (((((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) = (vec_of_bits [B0;B0;B0;B1;B0]  :  5 words$word))))))) then
     let (opc : 3 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 21 : int):ii)  :  3 words$word)) in
     let (imm16 : 16 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 5 : int):ii)  :  16 words$word)) in
     let (op2 : 3 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 2 : int):ii)  :  3 words$word)) in
     let (LL : 2 bits) = ((subrange_vec_dec op_code (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) in
     system_exceptions_runtime_hvc_decode opc imm16 op2 LL
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 31 : int):ii)  :  1 words$word)) = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 29 : int):ii) (( 23 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B0;B0;B0;B0]  :  7 words$word)))) /\ (((((subrange_vec_dec op_code (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)) = (vec_of_bits [B1]  :  1 words$word)))))))))) then
     let (sz : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 : int):ii)]  :  1 words$word)) in
     let (o2 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 23 : int):ii)]  :  1 words$word)) in
     let (L : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 : int):ii)]  :  1 words$word)) in
     let (o1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 : int):ii)]  :  1 words$word)) in
     let (Rs : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (o0 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 15 : int):ii)]  :  1 words$word)) in
     let (Rt2 : 5 bits) = ((subrange_vec_dec op_code (( 14 : int):ii) (( 10 : int):ii)  :  5 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_exclusive_pair_decode sz o2 L o1 Rs o0 Rt2 Rn Rt
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 14 : int):ii)  :  18 words$word)) = (vec_of_bits [B1;B1;B0;B1;B1;B0;B1;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B0]
                     :  18 words$word)))) /\ (((((subrange_vec_dec op_code (( 12 : int):ii) (( 10 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B1]  :  3 words$word))))))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (opcode2 : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (Z : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 13 : int):ii)]  :  1 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_pac_autdb_dp_1src_decode sf S1 opcode2 Z Rn Rd
   else if (((((subrange_vec_dec op_code (( 30 : int):ii) (( 10 : int):ii)  :  21 words$word)) = (vec_of_bits [B1;B0;B1;B1;B0;B1;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
                 :  21 words$word)))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (opcode2 : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_arithmetic_rbit_decode sf S1 opcode2 Rn Rd
   else if (((((subrange_vec_dec op_code (( 29 : int):ii) (( 24 : int):ii)  :  6 words$word)) = (vec_of_bits [B1;B1;B1;B0;B0;B1]  :  6 words$word)))) then
     let (size1 : 2 bits) = ((subrange_vec_dec op_code (( 31 : int):ii) (( 30 : int):ii)  :  2 words$word)) in
     let (V1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 : int):ii)]  :  1 words$word)) in
     let (opc : 2 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 22 : int):ii)  :  2 words$word)) in
     let (imm12 : 12 bits) = ((subrange_vec_dec op_code (( 21 : int):ii) (( 10 : int):ii)  :  12 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_single_general_immediate_unsigned_aarch64_memory_single_general_immediate_unsigned__decode
       size1 V1 opc imm12 Rn Rt
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 14 : int):ii)  :  18 words$word)) = (vec_of_bits [B1;B1;B0;B1;B1;B0;B1;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B0]
                     :  18 words$word)))) /\ (((((subrange_vec_dec op_code (( 12 : int):ii) (( 10 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B0]  :  3 words$word))))))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (opcode2 : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (Z : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 13 : int):ii)]  :  1 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_pac_autia_dp_1src_decode sf S1 opcode2 Z Rn Rd
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 12 : int):ii)  :  20 words$word)) = (vec_of_bits [B1;B1;B0;B1;B0;B1;B0;B1;B0;B0;B0;B0;B0;B0;B1;B1;B0;B0;B1;B0]
                     :  20 words$word)))) /\ (((((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) = (vec_of_bits [B1;B1;B1;B1;B1]  :  5 words$word))))))) then
     let (L : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 : int):ii)]  :  1 words$word)) in
     let (op0 : 2 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 19 : int):ii)  :  2 words$word)) in
     let (op1 : 3 bits) = ((subrange_vec_dec op_code (( 18 : int):ii) (( 16 : int):ii)  :  3 words$word)) in
     let (CRn : 4 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 12 : int):ii)  :  4 words$word)) in
     let (CRm : 4 bits) = ((subrange_vec_dec op_code (( 11 : int):ii) (( 8 : int):ii)  :  4 words$word)) in
     let (op2 : 3 bits) = ((subrange_vec_dec op_code (( 7 : int):ii) (( 5 : int):ii)  :  3 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_pac_autia_hint_decode L op0 op1 CRn CRm op2 Rt
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 21 : int):ii)  :  11 words$word)) = (vec_of_bits [B1;B1;B0;B1;B0;B1;B0;B0;B0;B0;B0]  :  11 words$word)))) /\ (((((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) = (vec_of_bits [B0;B0;B0;B0;B1]  :  5 words$word))))))) then
     let (opc : 3 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 21 : int):ii)  :  3 words$word)) in
     let (imm16 : 16 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 5 : int):ii)  :  16 words$word)) in
     let (op2 : 3 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 2 : int):ii)  :  3 words$word)) in
     let (LL : 2 bits) = ((subrange_vec_dec op_code (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) in
     system_exceptions_runtime_svc_decode opc imm16 op2 LL
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B1;B1;B0;B1;B0;B1;B1]  :  7 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 23 : int):ii) (( 23 : int):ii)  :  1 words$word)) = (vec_of_bits [B0]  :  1 words$word)))) /\ (((((subrange_vec_dec op_code (( 20 : int):ii) (( 12 : int):ii)  :  9 words$word)) = (vec_of_bits [B1;B1;B1;B1;B1;B0;B0;B0;B0]  :  9 words$word)))))))))) then
     let (Z : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 24 : int):ii)]  :  1 words$word)) in
     let (opc : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 23 : int):ii)]  :  1 words$word)) in
     let (op : 2 bits) = ((subrange_vec_dec op_code (( 22 : int):ii) (( 21 : int):ii)  :  2 words$word)) in
     let (op2 : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (op3 : 4 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 12 : int):ii)  :  4 words$word)) in
     let (A : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 11 : int):ii)]  :  1 words$word)) in
     let (M : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 10 : int):ii)]  :  1 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rm : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     branch_unconditional_register_decode Z opc op op2 op3 A M Rn Rm
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 24 : int):ii)  :  8 words$word)) = (vec_of_bits [B0;B0;B0;B1;B1;B1;B1;B0]  :  8 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)) = (vec_of_bits [B1]  :  1 words$word)))) /\ (((((subrange_vec_dec op_code (( 12 : int):ii) (( 5 : int):ii)  :  8 words$word)) = (vec_of_bits [B1;B0;B0;B0;B0;B0;B0;B0]  :  8 words$word)))))))))) then
     let (M : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (typ : 2 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 22 : int):ii)  :  2 words$word)) in
     let (imm8 : 8 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 13 : int):ii)  :  8 words$word)) in
     let (imm5 : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     float_move_fp_imm_decode M S1 typ imm8 imm5 Rd
   else if (((((subrange_vec_dec op_code (( 30 : int):ii) (( 25 : int):ii)  :  6 words$word)) = (vec_of_bits [B0;B1;B1;B0;B1;B1]  :  6 words$word)))) then
     let (b5 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (op : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 24 : int):ii)]  :  1 words$word)) in
     let (b40 : 5 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 19 : int):ii)  :  5 words$word)) in
     let (imm14 : 14 bits) = ((subrange_vec_dec op_code (( 18 : int):ii) (( 5 : int):ii)  :  14 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     branch_conditional_test_decode b5 op b40 imm14 Rt
   else if ((((((((subrange_vec_dec op_code (( 29 : int):ii) (( 24 : int):ii)  :  6 words$word)) = (vec_of_bits [B1;B1;B1;B0;B0;B0]  :  6 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)) = (vec_of_bits [B0]  :  1 words$word)))) /\ (((((subrange_vec_dec op_code (( 11 : int):ii) (( 10 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then
     let (size1 : 2 bits) = ((subrange_vec_dec op_code (( 31 : int):ii) (( 30 : int):ii)  :  2 words$word)) in
     let (V1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 : int):ii)]  :  1 words$word)) in
     let (opc : 2 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 22 : int):ii)  :  2 words$word)) in
     let (imm9 : 9 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 12 : int):ii)  :  9 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_single_general_immediate_signed_postidx_aarch64_memory_single_general_immediate_signed_postidx__decode
       size1 V1 opc imm9 Rn Rt
   else if ((((((((subrange_vec_dec op_code (( 29 : int):ii) (( 24 : int):ii)  :  6 words$word)) = (vec_of_bits [B1;B1;B1;B0;B0;B0]  :  6 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)) = (vec_of_bits [B0]  :  1 words$word)))) /\ (((((subrange_vec_dec op_code (( 11 : int):ii) (( 10 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then
     let (size1 : 2 bits) = ((subrange_vec_dec op_code (( 31 : int):ii) (( 30 : int):ii)  :  2 words$word)) in
     let (V1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 : int):ii)]  :  1 words$word)) in
     let (opc : 2 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 22 : int):ii)  :  2 words$word)) in
     let (imm9 : 9 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 12 : int):ii)  :  9 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_single_general_immediate_signed_preidx_aarch64_memory_single_general_immediate_signed_postidx__decode
       size1 V1 opc imm9 Rn Rt
   else if (((((subrange_vec_dec op_code (( 29 : int):ii) (( 24 : int):ii)  :  6 words$word)) = (vec_of_bits [B1;B1;B1;B0;B0;B1]  :  6 words$word)))) then
     let (size1 : 2 bits) = ((subrange_vec_dec op_code (( 31 : int):ii) (( 30 : int):ii)  :  2 words$word)) in
     let (V1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 : int):ii)]  :  1 words$word)) in
     let (opc : 2 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 22 : int):ii)  :  2 words$word)) in
     let (imm12 : 12 bits) = ((subrange_vec_dec op_code (( 21 : int):ii) (( 10 : int):ii)  :  12 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_single_general_immediate_unsigned_aarch64_memory_single_general_immediate_signed_postidx__decode
       size1 V1 opc imm12 Rn Rt
   else if (((((subrange_vec_dec op_code (( 29 : int):ii) (( 24 : int):ii)  :  6 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B0]  :  6 words$word)))) then
     let (opc : 2 bits) = ((subrange_vec_dec op_code (( 31 : int):ii) (( 30 : int):ii)  :  2 words$word)) in
     let (V1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 : int):ii)]  :  1 words$word)) in
     let (imm19 : 19 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 5 : int):ii)  :  19 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_literal_general_decode opc V1 imm19 Rt
   else if (((((subrange_vec_dec op_code (( 29 : int):ii) (( 23 : int):ii)  :  7 words$word)) = (vec_of_bits [B1;B0;B1;B1;B0;B0;B1]  :  7 words$word)))) then
     let (opc : 2 bits) = ((subrange_vec_dec op_code (( 31 : int):ii) (( 30 : int):ii)  :  2 words$word)) in
     let (V1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 : int):ii)]  :  1 words$word)) in
     let (L : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 : int):ii)]  :  1 words$word)) in
     let (imm7 : 7 bits) = ((subrange_vec_dec op_code (( 21 : int):ii) (( 15 : int):ii)  :  7 words$word)) in
     let (Rt2 : 5 bits) = ((subrange_vec_dec op_code (( 14 : int):ii) (( 10 : int):ii)  :  5 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_pair_simdfp_postidx_aarch64_memory_pair_simdfp_postidx__decode opc V1 L imm7 Rt2 Rn Rt
   else if (((((subrange_vec_dec op_code (( 29 : int):ii) (( 23 : int):ii)  :  7 words$word)) = (vec_of_bits [B1;B0;B1;B1;B0;B1;B1]  :  7 words$word)))) then
     let (opc : 2 bits) = ((subrange_vec_dec op_code (( 31 : int):ii) (( 30 : int):ii)  :  2 words$word)) in
     let (V1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 : int):ii)]  :  1 words$word)) in
     let (L : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 : int):ii)]  :  1 words$word)) in
     let (imm7 : 7 bits) = ((subrange_vec_dec op_code (( 21 : int):ii) (( 15 : int):ii)  :  7 words$word)) in
     let (Rt2 : 5 bits) = ((subrange_vec_dec op_code (( 14 : int):ii) (( 10 : int):ii)  :  5 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_pair_simdfp_preidx_aarch64_memory_pair_simdfp_postidx__decode opc V1 L imm7 Rt2 Rn Rt
   else if (((((subrange_vec_dec op_code (( 29 : int):ii) (( 23 : int):ii)  :  7 words$word)) = (vec_of_bits [B1;B0;B1;B1;B0;B1;B0]  :  7 words$word)))) then
     let (opc : 2 bits) = ((subrange_vec_dec op_code (( 31 : int):ii) (( 30 : int):ii)  :  2 words$word)) in
     let (V1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 : int):ii)]  :  1 words$word)) in
     let (L : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 : int):ii)]  :  1 words$word)) in
     let (imm7 : 7 bits) = ((subrange_vec_dec op_code (( 21 : int):ii) (( 15 : int):ii)  :  7 words$word)) in
     let (Rt2 : 5 bits) = ((subrange_vec_dec op_code (( 14 : int):ii) (( 10 : int):ii)  :  5 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_pair_simdfp_offset_aarch64_memory_pair_simdfp_postidx__decode opc V1 L imm7 Rt2 Rn Rt
   else if (((((subrange_vec_dec op_code (( 30 : int):ii) (( 25 : int):ii)  :  6 words$word)) = (vec_of_bits [B0;B1;B1;B0;B1;B0]  :  6 words$word)))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (op : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 24 : int):ii)]  :  1 words$word)) in
     let (imm19 : 19 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 5 : int):ii)  :  19 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     branch_conditional_compare_decode sf op imm19 Rt
   else if ((((((((subrange_vec_dec op_code (( 29 : int):ii) (( 24 : int):ii)  :  6 words$word)) = (vec_of_bits [B1;B1;B1;B1;B0;B0]  :  6 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)) = (vec_of_bits [B0]  :  1 words$word)))) /\ (((((subrange_vec_dec op_code (( 11 : int):ii) (( 10 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B0]  :  2 words$word)))))))))) then
     let (size1 : 2 bits) = ((subrange_vec_dec op_code (( 31 : int):ii) (( 30 : int):ii)  :  2 words$word)) in
     let (V1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 : int):ii)]  :  1 words$word)) in
     let (opc : 2 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 22 : int):ii)  :  2 words$word)) in
     let (imm9 : 9 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 12 : int):ii)  :  9 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_single_simdfp_immediate_signed_offset_normal_aarch64_memory_single_simdfp_immediate_signed_offset_normal__decode
       size1 V1 opc imm9 Rn Rt
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 14 : int):ii)  :  18 words$word)) = (vec_of_bits [B1;B1;B0;B1;B1;B0;B1;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B0]
                     :  18 words$word)))) /\ (((((subrange_vec_dec op_code (( 12 : int):ii) (( 10 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B1]  :  3 words$word))))))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (opcode2 : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (Z : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 13 : int):ii)]  :  1 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_pac_pacib_dp_1src_decode sf S1 opcode2 Z Rn Rd
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 12 : int):ii)  :  20 words$word)) = (vec_of_bits [B1;B1;B0;B1;B0;B1;B0;B1;B0;B0;B0;B0;B0;B0;B1;B1;B0;B0;B1;B0]
                     :  20 words$word)))) /\ (((((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) = (vec_of_bits [B1;B1;B1;B1;B1]  :  5 words$word))))))) then
     let (L : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 : int):ii)]  :  1 words$word)) in
     let (op0 : 2 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 19 : int):ii)  :  2 words$word)) in
     let (op1 : 3 bits) = ((subrange_vec_dec op_code (( 18 : int):ii) (( 16 : int):ii)  :  3 words$word)) in
     let (CRn : 4 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 12 : int):ii)  :  4 words$word)) in
     let (CRm : 4 bits) = ((subrange_vec_dec op_code (( 11 : int):ii) (( 8 : int):ii)  :  4 words$word)) in
     let (op2 : 3 bits) = ((subrange_vec_dec op_code (( 7 : int):ii) (( 5 : int):ii)  :  3 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_pac_pacib_hint_decode L op0 op1 CRn CRm op2 Rt
   else if ((((((((subrange_vec_dec op_code (( 29 : int):ii) (( 24 : int):ii)  :  6 words$word)) = (vec_of_bits [B1;B1;B1;B1;B0;B0]  :  6 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)) = (vec_of_bits [B0]  :  1 words$word)))) /\ (((((subrange_vec_dec op_code (( 11 : int):ii) (( 10 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then
     let (size1 : 2 bits) = ((subrange_vec_dec op_code (( 31 : int):ii) (( 30 : int):ii)  :  2 words$word)) in
     let (V1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 : int):ii)]  :  1 words$word)) in
     let (opc : 2 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 22 : int):ii)  :  2 words$word)) in
     let (imm9 : 9 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 12 : int):ii)  :  9 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_single_simdfp_immediate_signed_postidx_aarch64_memory_single_simdfp_immediate_signed_postidx__decode
       size1 V1 opc imm9 Rn Rt
   else if ((((((((subrange_vec_dec op_code (( 29 : int):ii) (( 24 : int):ii)  :  6 words$word)) = (vec_of_bits [B1;B1;B1;B1;B0;B0]  :  6 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)) = (vec_of_bits [B0]  :  1 words$word)))) /\ (((((subrange_vec_dec op_code (( 11 : int):ii) (( 10 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then
     let (size1 : 2 bits) = ((subrange_vec_dec op_code (( 31 : int):ii) (( 30 : int):ii)  :  2 words$word)) in
     let (V1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 : int):ii)]  :  1 words$word)) in
     let (opc : 2 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 22 : int):ii)  :  2 words$word)) in
     let (imm9 : 9 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 12 : int):ii)  :  9 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_single_simdfp_immediate_signed_preidx_aarch64_memory_single_simdfp_immediate_signed_postidx__decode
       size1 V1 opc imm9 Rn Rt
   else if (((((subrange_vec_dec op_code (( 29 : int):ii) (( 24 : int):ii)  :  6 words$word)) = (vec_of_bits [B1;B1;B1;B1;B0;B1]  :  6 words$word)))) then
     let (size1 : 2 bits) = ((subrange_vec_dec op_code (( 31 : int):ii) (( 30 : int):ii)  :  2 words$word)) in
     let (V1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 : int):ii)]  :  1 words$word)) in
     let (opc : 2 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 22 : int):ii)  :  2 words$word)) in
     let (imm12 : 12 bits) = ((subrange_vec_dec op_code (( 21 : int):ii) (( 10 : int):ii)  :  12 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_single_simdfp_immediate_unsigned_aarch64_memory_single_simdfp_immediate_signed_postidx__decode
       size1 V1 opc imm12 Rn Rt
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 31 : int):ii)  :  1 words$word)) = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 29 : int):ii) (( 23 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0]  :  7 words$word)))) /\ (((((subrange_vec_dec op_code (( 21 : int):ii) (( 16 : int):ii)  :  6 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0]  :  6 words$word)))))))))) then
     let (Q : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 : int):ii)]  :  1 words$word)) in
     let (L : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 : int):ii)]  :  1 words$word)) in
     let (opcode : 4 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 12 : int):ii)  :  4 words$word)) in
     let (size1 : 2 bits) = ((subrange_vec_dec op_code (( 11 : int):ii) (( 10 : int):ii)  :  2 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_vector_multiple_nowb_aarch64_memory_vector_multiple_nowb__decode Q L opcode size1 Rn Rt
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 31 : int):ii)  :  1 words$word)) = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 29 : int):ii) (( 23 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B1;B0;B0;B1]  :  7 words$word)))) /\ (((((subrange_vec_dec op_code (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)) = (vec_of_bits [B0]  :  1 words$word)))))))))) then
     let (Q : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 : int):ii)]  :  1 words$word)) in
     let (L : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 : int):ii)]  :  1 words$word)) in
     let (Rm : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (opcode : 4 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 12 : int):ii)  :  4 words$word)) in
     let (size1 : 2 bits) = ((subrange_vec_dec op_code (( 11 : int):ii) (( 10 : int):ii)  :  2 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_vector_multiple_postinc_aarch64_memory_vector_multiple_nowb__decode Q L Rm opcode size1
       Rn Rt
   else if (((((subrange_vec_dec op_code (( 31 : int):ii) (( 12 : int):ii)  :  20 words$word)) = (vec_of_bits [B1;B1;B0;B1;B0;B1;B1;B0;B1;B0;B0;B1;B1;B1;B1;B1;B0;B0;B0;B0]
                 :  20 words$word)))) then
     let (opc : 4 bits) = ((subrange_vec_dec op_code (( 24 : int):ii) (( 21 : int):ii)  :  4 words$word)) in
     let (op2 : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (op3 : 4 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 12 : int):ii)  :  4 words$word)) in
     let (A : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 11 : int):ii)]  :  1 words$word)) in
     let (M : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 10 : int):ii)]  :  1 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (op4 : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     branch_unconditional_eret_decode opc op2 op3 A M Rn op4
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 24 : int):ii)  :  8 words$word)) = (vec_of_bits [B0;B0;B0;B1;B1;B1;B1;B0]  :  8 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)) = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 15 : int):ii) (( 14 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((((subrange_vec_dec op_code (( 11 : int):ii) (( 10 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word))))))))))))) then
     let (M : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (typ : 2 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 22 : int):ii)  :  2 words$word)) in
     let (Rm : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (op : 2 bits) = ((subrange_vec_dec op_code (( 13 : int):ii) (( 12 : int):ii)  :  2 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     float_arithmetic_maxmin_decode M S1 typ Rm op Rn Rd
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 24 : int):ii)  :  8 words$word)) = (vec_of_bits [B0;B0;B0;B1;B1;B1;B1;B0]  :  8 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 21 : int):ii) (( 17 : int):ii)  :  5 words$word)) = (vec_of_bits [B1;B0;B0;B0;B0]  :  5 words$word)))) /\ (((((subrange_vec_dec op_code (( 14 : int):ii) (( 10 : int):ii)  :  5 words$word)) = (vec_of_bits [B1;B0;B0;B0;B0]  :  5 words$word)))))))))) then
     let (M : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (typ : 2 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 22 : int):ii)  :  2 words$word)) in
     let (opc : 2 bits) = ((subrange_vec_dec op_code (( 16 : int):ii) (( 15 : int):ii)  :  2 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     float_arithmetic_unary_decode M S1 typ opc Rn Rd
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 21 : int):ii)  :  11 words$word)) = (vec_of_bits [B1;B1;B0;B1;B0;B1;B0;B0;B0;B0;B0]  :  11 words$word)))) /\ (((((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) = (vec_of_bits [B0;B0;B0;B1;B1]  :  5 words$word))))))) then
     let (opc : 3 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 21 : int):ii)  :  3 words$word)) in
     let (imm16 : 16 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 5 : int):ii)  :  16 words$word)) in
     let (op2 : 3 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 2 : int):ii)  :  3 words$word)) in
     let (LL : 2 bits) = ((subrange_vec_dec op_code (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) in
     system_exceptions_runtime_smc_decode opc imm16 op2 LL
   else if ((((((((subrange_vec_dec op_code (( 29 : int):ii) (( 23 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B0;B0;B0;B1]  :  7 words$word)))) /\ (((((subrange_vec_dec op_code (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)) = (vec_of_bits [B0]  :  1 words$word))))))) then
     let (size1 : 2 bits) = ((subrange_vec_dec op_code (( 31 : int):ii) (( 30 : int):ii)  :  2 words$word)) in
     let (o2 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 23 : int):ii)]  :  1 words$word)) in
     let (L : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 : int):ii)]  :  1 words$word)) in
     let (o1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 : int):ii)]  :  1 words$word)) in
     let (Rs : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (o0 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 15 : int):ii)]  :  1 words$word)) in
     let (Rt2 : 5 bits) = ((subrange_vec_dec op_code (( 14 : int):ii) (( 10 : int):ii)  :  5 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_ordered_decode size1 o2 L o1 Rs o0 Rt2 Rn Rt
   else if ((((((((subrange_vec_dec op_code (( 29 : int):ii) (( 24 : int):ii)  :  6 words$word)) = (vec_of_bits [B1;B1;B1;B0;B0;B0]  :  6 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)) = (vec_of_bits [B1]  :  1 words$word)))) /\ (((((subrange_vec_dec op_code (( 11 : int):ii) (( 10 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then
     let (size1 : 2 bits) = ((subrange_vec_dec op_code (( 31 : int):ii) (( 30 : int):ii)  :  2 words$word)) in
     let (V1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 : int):ii)]  :  1 words$word)) in
     let (opc : 2 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 22 : int):ii)  :  2 words$word)) in
     let (Rm : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (option_name : 3 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 13 : int):ii)  :  3 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 12 : int):ii)]  :  1 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_single_general_register_aarch64_memory_single_general_register__decode size1 V1 opc Rm
       option_name S1 Rn Rt
   else if (((((subrange_vec_dec op_code (( 29 : int):ii) (( 23 : int):ii)  :  7 words$word)) = (vec_of_bits [B1;B0;B1;B1;B0;B0;B0]  :  7 words$word)))) then
     let (opc : 2 bits) = ((subrange_vec_dec op_code (( 31 : int):ii) (( 30 : int):ii)  :  2 words$word)) in
     let (V1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 : int):ii)]  :  1 words$word)) in
     let (L : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 : int):ii)]  :  1 words$word)) in
     let (imm7 : 7 bits) = ((subrange_vec_dec op_code (( 21 : int):ii) (( 15 : int):ii)  :  7 words$word)) in
     let (Rt2 : 5 bits) = ((subrange_vec_dec op_code (( 14 : int):ii) (( 10 : int):ii)  :  5 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_pair_simdfp_noalloc_aarch64_memory_pair_simdfp_noalloc__decode opc V1 L imm7 Rt2 Rn Rt
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 21 : int):ii)  :  11 words$word)) = (vec_of_bits [B1;B1;B0;B1;B0;B1;B0;B0;B0;B0;B1]  :  11 words$word)))) /\ (((((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0]  :  5 words$word))))))) then
     let (opc : 3 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 21 : int):ii)  :  3 words$word)) in
     let (imm16 : 16 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 5 : int):ii)  :  16 words$word)) in
     let (op2 : 3 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 2 : int):ii)  :  3 words$word)) in
     let (LL : 2 bits) = ((subrange_vec_dec op_code (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) in
     system_exceptions_debug_breakpoint_decode opc imm16 op2 LL
   else if (((((subrange_vec_dec op_code (( 30 : int):ii) (( 21 : int):ii)  :  10 words$word)) = (vec_of_bits [B0;B0;B1;B1;B0;B1;B1;B0;B0;B0]  :  10 words$word)))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (op54 : 2 bits) = ((subrange_vec_dec op_code (( 30 : int):ii) (( 29 : int):ii)  :  2 words$word)) in
     let (op31 : 3 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 21 : int):ii)  :  3 words$word)) in
     let (Rm : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (o0 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 15 : int):ii)]  :  1 words$word)) in
     let (Ra : 5 bits) = ((subrange_vec_dec op_code (( 14 : int):ii) (( 10 : int):ii)  :  5 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_arithmetic_mul_uniform_addsub_decode sf op54 op31 Rm o0 Ra Rn Rd
   else if (((((subrange_vec_dec op_code (( 29 : int):ii) (( 24 : int):ii)  :  6 words$word)) = (vec_of_bits [B0;B1;B1;B1;B0;B0]  :  6 words$word)))) then
     let (opc : 2 bits) = ((subrange_vec_dec op_code (( 31 : int):ii) (( 30 : int):ii)  :  2 words$word)) in
     let (V1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 : int):ii)]  :  1 words$word)) in
     let (imm19 : 19 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 5 : int):ii)  :  19 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_literal_simdfp_decode opc V1 imm19 Rt
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 22 : int):ii)  :  10 words$word)) = (vec_of_bits [B1;B1;B0;B1;B0;B1;B0;B1;B0;B0]  :  10 words$word)))) /\ (((((subrange_vec_dec op_code (( 20 : int):ii) (( 19 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word))))))) then
     let (L : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 : int):ii)]  :  1 words$word)) in
     let (op0 : 2 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 19 : int):ii)  :  2 words$word)) in
     let (op1 : 3 bits) = ((subrange_vec_dec op_code (( 18 : int):ii) (( 16 : int):ii)  :  3 words$word)) in
     let (CRn : 4 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 12 : int):ii)  :  4 words$word)) in
     let (CRm : 4 bits) = ((subrange_vec_dec op_code (( 11 : int):ii) (( 8 : int):ii)  :  4 words$word)) in
     let (op2 : 3 bits) = ((subrange_vec_dec op_code (( 7 : int):ii) (( 5 : int):ii)  :  3 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     system_sysops_decode L op0 op1 CRn CRm op2 Rt
   else if ((((((((subrange_vec_dec op_code (( 28 : int):ii) (( 24 : int):ii)  :  5 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1]  :  5 words$word)))) /\ (((((subrange_vec_dec op_code (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)) = (vec_of_bits [B0]  :  1 words$word))))))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (op : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (shift : 2 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 22 : int):ii)  :  2 words$word)) in
     let (Rm : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (imm6 : 6 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 10 : int):ii)  :  6 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_arithmetic_addsub_shiftedreg_decode sf op S1 shift Rm imm6 Rn Rd
   else if (((((subrange_vec_dec op_code (( 28 : int):ii) (( 23 : int):ii)  :  6 words$word)) = (vec_of_bits [B1;B0;B0;B1;B0;B0]  :  6 words$word)))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (opc : 2 bits) = ((subrange_vec_dec op_code (( 30 : int):ii) (( 29 : int):ii)  :  2 words$word)) in
     let (N : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 : int):ii)]  :  1 words$word)) in
     let (immr : 6 bits) = ((subrange_vec_dec op_code (( 21 : int):ii) (( 16 : int):ii)  :  6 words$word)) in
     let (imms : 6 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 10 : int):ii)  :  6 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_logical_immediate_decode sf opc N immr imms Rn Rd
   else if ((((((((subrange_vec_dec op_code (( 29 : int):ii) (( 21 : int):ii)  :  9 words$word)) = (vec_of_bits [B1;B1;B1;B0;B1;B0;B0;B1;B0]  :  9 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 11 : int):ii) (( 10 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((((subrange_vec_dec op_code (( 4 : int):ii) (( 4 : int):ii)  :  1 words$word)) = (vec_of_bits [B0]  :  1 words$word)))))))))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (op : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (Rm : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (cond : 4 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 12 : int):ii)  :  4 words$word)) in
     let (o2 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 10 : int):ii)]  :  1 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (o3 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 4 : int):ii)]  :  1 words$word)) in
     let (nzcv1 : 4 bits) = ((subrange_vec_dec op_code (( 3 : int):ii) (( 0 : int):ii)  :  4 words$word)) in
     integer_conditional_compare_register_decode sf op S1 Rm cond o2 Rn o3 nzcv1
   else if (((((subrange_vec_dec op_code (( 28 : int):ii) (( 23 : int):ii)  :  6 words$word)) = (vec_of_bits [B1;B0;B0;B1;B1;B0]  :  6 words$word)))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (opc : 2 bits) = ((subrange_vec_dec op_code (( 30 : int):ii) (( 29 : int):ii)  :  2 words$word)) in
     let (N : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 : int):ii)]  :  1 words$word)) in
     let (immr : 6 bits) = ((subrange_vec_dec op_code (( 21 : int):ii) (( 16 : int):ii)  :  6 words$word)) in
     let (imms : 6 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 10 : int):ii)  :  6 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_bitfield_decode sf opc N immr imms Rn Rd
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 22 : int):ii)  :  10 words$word)) = (vec_of_bits [B1;B1;B0;B1;B0;B1;B0;B1;B0;B0]  :  10 words$word)))) /\ (((((subrange_vec_dec op_code (( 20 : int):ii) (( 20 : int):ii)  :  1 words$word)) = (vec_of_bits [B1]  :  1 words$word))))))) then
     let (L : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 : int):ii)]  :  1 words$word)) in
     let (o0 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 19 : int):ii)]  :  1 words$word)) in
     let (op1 : 3 bits) = ((subrange_vec_dec op_code (( 18 : int):ii) (( 16 : int):ii)  :  3 words$word)) in
     let (CRn : 4 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 12 : int):ii)  :  4 words$word)) in
     let (CRm : 4 bits) = ((subrange_vec_dec op_code (( 11 : int):ii) (( 8 : int):ii)  :  4 words$word)) in
     let (op2 : 3 bits) = ((subrange_vec_dec op_code (( 7 : int):ii) (( 5 : int):ii)  :  3 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     system_register_system_decode L o0 op1 CRn CRm op2 Rt
   else if ((((((((subrange_vec_dec op_code (( 29 : int):ii) (( 21 : int):ii)  :  9 words$word)) = (vec_of_bits [B1;B1;B1;B0;B1;B0;B0;B1;B0]  :  9 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 11 : int):ii) (( 10 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((((subrange_vec_dec op_code (( 4 : int):ii) (( 4 : int):ii)  :  1 words$word)) = (vec_of_bits [B0]  :  1 words$word)))))))))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (op : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (imm5 : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (cond : 4 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 12 : int):ii)  :  4 words$word)) in
     let (o2 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 10 : int):ii)]  :  1 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (o3 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 4 : int):ii)]  :  1 words$word)) in
     let (nzcv1 : 4 bits) = ((subrange_vec_dec op_code (( 3 : int):ii) (( 0 : int):ii)  :  4 words$word)) in
     integer_conditional_compare_immediate_decode sf op S1 imm5 cond o2 Rn o3 nzcv1
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 24 : int):ii)  :  8 words$word)) = (vec_of_bits [B0;B0;B0;B1;B1;B1;B1;B0]  :  8 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)) = (vec_of_bits [B1]  :  1 words$word)))) /\ (((((subrange_vec_dec op_code (( 15 : int):ii) (( 10 : int):ii)  :  6 words$word)) = (vec_of_bits [B0;B0;B0;B1;B1;B0]  :  6 words$word)))))))))) then
     let (M : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (typ : 2 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 22 : int):ii)  :  2 words$word)) in
     let (Rm : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     float_arithmetic_div_decode M S1 typ Rm Rn Rd
   else if ((((((((subrange_vec_dec op_code (( 29 : int):ii) (( 24 : int):ii)  :  6 words$word)) = (vec_of_bits [B1;B1;B1;B0;B0;B0]  :  6 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)) = (vec_of_bits [B1]  :  1 words$word)))) /\ (((((subrange_vec_dec op_code (( 15 : int):ii) (( 10 : int):ii)  :  6 words$word)) = (vec_of_bits [B1;B0;B0;B0;B0;B0]  :  6 words$word)))))))))) then
     let (size1 : 2 bits) = ((subrange_vec_dec op_code (( 31 : int):ii) (( 30 : int):ii)  :  2 words$word)) in
     let (V1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 : int):ii)]  :  1 words$word)) in
     let (A : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 23 : int):ii)]  :  1 words$word)) in
     let (R1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 : int):ii)]  :  1 words$word)) in
     let (Rs : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (o3 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 15 : int):ii)]  :  1 words$word)) in
     let (opc : 3 bits) = ((subrange_vec_dec op_code (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_atomicops_swp_decode size1 V1 A R1 Rs o3 opc Rn Rt
   else if (((((subrange_vec_dec op_code (( 28 : int):ii) (( 24 : int):ii)  :  5 words$word)) = (vec_of_bits [B1;B0;B0;B0;B1]  :  5 words$word)))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (op : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (shift : 2 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 22 : int):ii)  :  2 words$word)) in
     let (imm12 : 12 bits) = ((subrange_vec_dec op_code (( 21 : int):ii) (( 10 : int):ii)  :  12 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_arithmetic_addsub_immediate_decode sf op S1 shift imm12 Rn Rd
   else if (((((subrange_vec_dec op_code (( 30 : int):ii) (( 26 : int):ii)  :  5 words$word)) = (vec_of_bits [B0;B0;B1;B0;B1]  :  5 words$word)))) then
     let (op : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (imm26 : 26 bits) = ((subrange_vec_dec op_code (( 25 : int):ii) (( 0 : int):ii)  :  26 words$word)) in
     branch_unconditional_immediate_decode op imm26
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 14 : int):ii)  :  18 words$word)) = (vec_of_bits [B1;B1;B0;B1;B1;B0;B1;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B0]
                     :  18 words$word)))) /\ (((((subrange_vec_dec op_code (( 12 : int):ii) (( 10 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B0]  :  3 words$word))))))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (opcode2 : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (Z : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 13 : int):ii)]  :  1 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_pac_autda_dp_1src_decode sf S1 opcode2 Z Rn Rd
   else if (((((subrange_vec_dec op_code (( 30 : int):ii) (( 11 : int):ii)  :  20 words$word)) = (vec_of_bits [B1;B0;B1;B1;B0;B1;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0]
                 :  20 words$word)))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (opcode2 : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (op : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 10 : int):ii)]  :  1 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_arithmetic_cnt_decode sf S1 opcode2 op Rn Rd
   else if ((((((((subrange_vec_dec op_code (( 29 : int):ii) (( 27 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 25 : int):ii) (( 24 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)) = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 11 : int):ii) (( 10 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) = (vec_of_bits [B1;B1;B1;B1;B1]  :  5 words$word)))))))))))))))) then
     let (size1 : 2 bits) = ((subrange_vec_dec op_code (( 31 : int):ii) (( 30 : int):ii)  :  2 words$word)) in
     let (V1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 : int):ii)]  :  1 words$word)) in
     let (A : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 23 : int):ii)]  :  1 words$word)) in
     let (R1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 : int):ii)]  :  1 words$word)) in
     let (Rs : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (o3 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 15 : int):ii)]  :  1 words$word)) in
     let (opc : 3 bits) = ((subrange_vec_dec op_code (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_atomicops_st_decode size1 V1 A R1 Rs o3 opc Rn Rt
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 12 : int):ii)  :  20 words$word)) = (vec_of_bits [B1;B1;B0;B1;B0;B1;B0;B1;B0;B0;B0;B0;B0;B0;B1;B1;B0;B0;B1;B1]
                     :  20 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 7 : int):ii) (( 7 : int):ii)  :  1 words$word)) = (vec_of_bits [B1]  :  1 words$word)))) /\ (((((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) = (vec_of_bits [B1;B1;B1;B1;B1]  :  5 words$word)))))))))) then
     let (L : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 : int):ii)]  :  1 words$word)) in
     let (op0 : 2 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 19 : int):ii)  :  2 words$word)) in
     let (op1 : 3 bits) = ((subrange_vec_dec op_code (( 18 : int):ii) (( 16 : int):ii)  :  3 words$word)) in
     let (CRn : 4 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 12 : int):ii)  :  4 words$word)) in
     let (CRm : 4 bits) = ((subrange_vec_dec op_code (( 11 : int):ii) (( 8 : int):ii)  :  4 words$word)) in
     let (opc : 2 bits) = ((subrange_vec_dec op_code (( 6 : int):ii) (( 5 : int):ii)  :  2 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     system_barriers_decode L op0 op1 CRn CRm opc Rt
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 31 : int):ii)  :  1 words$word)) = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 29 : int):ii) (( 23 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B0;B0;B0;B0]  :  7 words$word)))) /\ (((((subrange_vec_dec op_code (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)) = (vec_of_bits [B1]  :  1 words$word)))))))))) then
     let (sz : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 : int):ii)]  :  1 words$word)) in
     let (o2 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 23 : int):ii)]  :  1 words$word)) in
     let (L : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 : int):ii)]  :  1 words$word)) in
     let (o1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 : int):ii)]  :  1 words$word)) in
     let (Rs : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (o0 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 15 : int):ii)]  :  1 words$word)) in
     let (Rt2 : 5 bits) = ((subrange_vec_dec op_code (( 14 : int):ii) (( 10 : int):ii)  :  5 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_atomicops_cas_pair_decode sz o2 L o1 Rs o0 Rt2 Rn Rt
   else if (((((subrange_vec_dec op_code (( 28 : int):ii) (( 23 : int):ii)  :  6 words$word)) = (vec_of_bits [B1;B0;B0;B1;B0;B1]  :  6 words$word)))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (opc : 2 bits) = ((subrange_vec_dec op_code (( 30 : int):ii) (( 29 : int):ii)  :  2 words$word)) in
     let (hw : 2 bits) = ((subrange_vec_dec op_code (( 22 : int):ii) (( 21 : int):ii)  :  2 words$word)) in
     let (imm16 : 16 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 5 : int):ii)  :  16 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_insext_insert_movewide_decode sf opc hw imm16 Rd
   else if (((op_code = (vec_of_bits [B1;B1;B0;B1;B0;B1;B1;B0;B1;B0;B1;B1;B1;B1;B1;B1;B0;B0;B0;B0;B0;B0;B1;B1;
                             B1;B1;B1;B0;B0;B0;B0;B0]
                 :  32 words$word)))) then
     let (opc : 4 bits) = ((subrange_vec_dec op_code (( 24 : int):ii) (( 21 : int):ii)  :  4 words$word)) in
     let (op2 : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (op3 : 6 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 10 : int):ii)  :  6 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (op4 : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     branch_unconditional_dret_decode opc op2 op3 Rt op4
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 24 : int):ii)  :  8 words$word)) = (vec_of_bits [B0;B0;B0;B1;B1;B1;B1;B0]  :  8 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)) = (vec_of_bits [B1]  :  1 words$word)))) /\ (((((subrange_vec_dec op_code (( 11 : int):ii) (( 10 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B1]  :  2 words$word)))))))))) then
     let (M : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (typ : 2 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 22 : int):ii)  :  2 words$word)) in
     let (Rm : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (cond : 4 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 12 : int):ii)  :  4 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     float_move_fp_select_decode M S1 typ Rm cond Rn Rd
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 21 : int):ii)  :  11 words$word)) = (vec_of_bits [B1;B1;B0;B1;B0;B1;B0;B0;B1;B0;B1]  :  11 words$word)))) /\ (((((subrange_vec_dec op_code (( 4 : int):ii) (( 2 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word))))))) then
     let (opc : 3 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 21 : int):ii)  :  3 words$word)) in
     let (imm16 : 16 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 5 : int):ii)  :  16 words$word)) in
     let (op2 : 3 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 2 : int):ii)  :  3 words$word)) in
     let (LL : 2 bits) = ((subrange_vec_dec op_code (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) in
     system_exceptions_debug_exception_decode opc imm16 op2 LL
   else if (((((subrange_vec_dec op_code (( 30 : int):ii) (( 12 : int):ii)  :  19 words$word)) = (vec_of_bits [B1;B0;B1;B1;B0;B1;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  :  19 words$word))))
   then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (opcode2 : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (opc : 2 bits) = ((subrange_vec_dec op_code (( 11 : int):ii) (( 10 : int):ii)  :  2 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_arithmetic_rev_decode sf S1 opcode2 opc Rn Rd
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 24 : int):ii)  :  8 words$word)) = (vec_of_bits [B0;B0;B0;B1;B1;B1;B1;B0]  :  8 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 21 : int):ii) (( 17 : int):ii)  :  5 words$word)) = (vec_of_bits [B1;B0;B0;B0;B1]  :  5 words$word)))) /\ (((((subrange_vec_dec op_code (( 14 : int):ii) (( 10 : int):ii)  :  5 words$word)) = (vec_of_bits [B1;B0;B0;B0;B0]  :  5 words$word)))))))))) then
     let (M : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (typ : 2 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 22 : int):ii)  :  2 words$word)) in
     let (opc : 2 bits) = ((subrange_vec_dec op_code (( 16 : int):ii) (( 15 : int):ii)  :  2 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     float_convert_fp_decode M S1 typ opc Rn Rd
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 14 : int):ii)  :  18 words$word)) = (vec_of_bits [B1;B1;B0;B1;B1;B0;B1;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B0]
                     :  18 words$word)))) /\ (((((subrange_vec_dec op_code (( 12 : int):ii) (( 10 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word))))))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (opcode2 : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (Z : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 13 : int):ii)]  :  1 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_pac_pacia_dp_1src_decode sf S1 opcode2 Z Rn Rd
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 12 : int):ii)  :  20 words$word)) = (vec_of_bits [B1;B1;B0;B1;B0;B1;B0;B1;B0;B0;B0;B0;B0;B0;B1;B1;B0;B0;B1;B0]
                     :  20 words$word)))) /\ (((((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) = (vec_of_bits [B1;B1;B1;B1;B1]  :  5 words$word))))))) then
     let (L : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 : int):ii)]  :  1 words$word)) in
     let (op0 : 2 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 19 : int):ii)  :  2 words$word)) in
     let (op1 : 3 bits) = ((subrange_vec_dec op_code (( 18 : int):ii) (( 16 : int):ii)  :  3 words$word)) in
     let (CRn : 4 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 12 : int):ii)  :  4 words$word)) in
     let (CRm : 4 bits) = ((subrange_vec_dec op_code (( 11 : int):ii) (( 8 : int):ii)  :  4 words$word)) in
     let (op2 : 3 bits) = ((subrange_vec_dec op_code (( 7 : int):ii) (( 5 : int):ii)  :  3 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_pac_pacia_hint_decode L op0 op1 CRn CRm op2 Rt
   else if ((((((((subrange_vec_dec op_code (( 30 : int):ii) (( 24 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B1;B1;B1;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)) = (vec_of_bits [B1]  :  1 words$word)))) /\ (((((subrange_vec_dec op_code (( 15 : int):ii) (( 10 : int):ii)  :  6 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0]  :  6 words$word)))))))))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (typ : 2 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 22 : int):ii)  :  2 words$word)) in
     let (rmode : 2 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 19 : int):ii)  :  2 words$word)) in
     let (opcode : 3 bits) = ((subrange_vec_dec op_code (( 18 : int):ii) (( 16 : int):ii)  :  3 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     float_convert_int_decode sf S1 typ rmode opcode Rn Rd
   else if ((((((((subrange_vec_dec op_code (( 29 : int):ii) (( 21 : int):ii)  :  9 words$word)) = (vec_of_bits [B0;B1;B1;B0;B1;B0;B1;B0;B0]  :  9 words$word)))) /\ (((((subrange_vec_dec op_code (( 11 : int):ii) (( 11 : int):ii)  :  1 words$word)) = (vec_of_bits [B0]  :  1 words$word))))))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (op : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (Rm : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (cond : 4 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 12 : int):ii)  :  4 words$word)) in
     let (o2 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 10 : int):ii)]  :  1 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_conditional_select_decode sf op S1 Rm cond o2 Rn Rd
   else if ((((((((subrange_vec_dec op_code (( 29 : int):ii) (( 21 : int):ii)  :  9 words$word)) = (vec_of_bits [B1;B1;B1;B0;B0;B0;B1;B0;B1]  :  9 words$word)))) /\ (((((subrange_vec_dec op_code (( 15 : int):ii) (( 10 : int):ii)  :  6 words$word)) = (vec_of_bits [B1;B1;B0;B0;B0;B0]  :  6 words$word))))))) then
     let (size1 : 2 bits) = ((subrange_vec_dec op_code (( 31 : int):ii) (( 30 : int):ii)  :  2 words$word)) in
     let (V1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 : int):ii)]  :  1 words$word)) in
     let (A : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 23 : int):ii)]  :  1 words$word)) in
     let (R1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 : int):ii)]  :  1 words$word)) in
     let (Rs : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (o3 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 15 : int):ii)]  :  1 words$word)) in
     let (opc : 3 bits) = ((subrange_vec_dec op_code (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_orderedrcpc_decode size1 V1 A R1 Rs o3 opc Rn Rt
   else if (((((subrange_vec_dec op_code (( 28 : int):ii) (( 21 : int):ii)  :  8 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B0;B0;B1]  :  8 words$word)))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (op : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (opt : 2 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 22 : int):ii)  :  2 words$word)) in
     let (Rm : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (option_name : 3 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 13 : int):ii)  :  3 words$word)) in
     let (imm3 : 3 bits) = ((subrange_vec_dec op_code (( 12 : int):ii) (( 10 : int):ii)  :  3 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_arithmetic_addsub_extendedreg_decode sf op S1 opt Rm option_name imm3 Rn Rd
   else if (((((subrange_vec_dec op_code (( 28 : int):ii) (( 24 : int):ii)  :  5 words$word)) = (vec_of_bits [B1;B0;B0;B0;B0]  :  5 words$word)))) then
     let (op : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (immlo : 2 bits) = ((subrange_vec_dec op_code (( 30 : int):ii) (( 29 : int):ii)  :  2 words$word)) in
     let (immhi : 19 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 5 : int):ii)  :  19 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_arithmetic_address_pcrel_decode op immlo immhi Rd
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 31 : int):ii)  :  1 words$word)) = (vec_of_bits [B0]  :  1 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 29 : int):ii) (( 23 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0]  :  7 words$word)))) /\ (((((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0]  :  5 words$word)))))))))) then
     let (Q : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 : int):ii)]  :  1 words$word)) in
     let (L : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 : int):ii)]  :  1 words$word)) in
     let (R1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 : int):ii)]  :  1 words$word)) in
     let (opcode : 3 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 13 : int):ii)  :  3 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 12 : int):ii)]  :  1 words$word)) in
     let (size1 : 2 bits) = ((subrange_vec_dec op_code (( 11 : int):ii) (( 10 : int):ii)  :  2 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_vector_single_nowb_aarch64_memory_vector_single_nowb__decode Q L R1 opcode S1 size1 Rn Rt
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 31 : int):ii)  :  1 words$word)) = (vec_of_bits [B0]  :  1 words$word)))) /\ (((((subrange_vec_dec op_code (( 29 : int):ii) (( 23 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  :  7 words$word))))))) then
     let (Q : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 : int):ii)]  :  1 words$word)) in
     let (L : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 : int):ii)]  :  1 words$word)) in
     let (R1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 : int):ii)]  :  1 words$word)) in
     let (Rm : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (opcode : 3 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 13 : int):ii)  :  3 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 12 : int):ii)]  :  1 words$word)) in
     let (size1 : 2 bits) = ((subrange_vec_dec op_code (( 11 : int):ii) (( 10 : int):ii)  :  2 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_vector_single_postinc_aarch64_memory_vector_single_nowb__decode Q L R1 Rm opcode S1 size1
       Rn Rt
   else if ((((((((subrange_vec_dec op_code (( 29 : int):ii) (( 24 : int):ii)  :  6 words$word)) = (vec_of_bits [B1;B1;B1;B0;B0;B0]  :  6 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)) = (vec_of_bits [B1]  :  1 words$word)))) /\ (((((subrange_vec_dec op_code (( 10 : int):ii) (( 10 : int):ii)  :  1 words$word)) = (vec_of_bits [B1]  :  1 words$word)))))))))) then
     let (size1 : 2 bits) = ((subrange_vec_dec op_code (( 31 : int):ii) (( 30 : int):ii)  :  2 words$word)) in
     let (V1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 : int):ii)]  :  1 words$word)) in
     let (M : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 23 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 : int):ii)]  :  1 words$word)) in
     let (imm9 : 9 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 12 : int):ii)  :  9 words$word)) in
     let (W1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 11 : int):ii)]  :  1 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_single_general_immediate_signed_pac_decode size1 V1 M S1 imm9 W1 Rn Rt
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 14 : int):ii)  :  18 words$word)) = (vec_of_bits [B1;B1;B0;B1;B1;B0;B1;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B0]
                     :  18 words$word)))) /\ (((((subrange_vec_dec op_code (( 12 : int):ii) (( 10 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B1]  :  3 words$word))))))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (opcode2 : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (Z : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 13 : int):ii)]  :  1 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_pac_autib_dp_1src_decode sf S1 opcode2 Z Rn Rd
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 12 : int):ii)  :  20 words$word)) = (vec_of_bits [B1;B1;B0;B1;B0;B1;B0;B1;B0;B0;B0;B0;B0;B0;B1;B1;B0;B0;B1;B0]
                     :  20 words$word)))) /\ (((((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) = (vec_of_bits [B1;B1;B1;B1;B1]  :  5 words$word))))))) then
     let (L : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 : int):ii)]  :  1 words$word)) in
     let (op0 : 2 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 19 : int):ii)  :  2 words$word)) in
     let (op1 : 3 bits) = ((subrange_vec_dec op_code (( 18 : int):ii) (( 16 : int):ii)  :  3 words$word)) in
     let (CRn : 4 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 12 : int):ii)  :  4 words$word)) in
     let (CRm : 4 bits) = ((subrange_vec_dec op_code (( 11 : int):ii) (( 8 : int):ii)  :  4 words$word)) in
     let (op2 : 3 bits) = ((subrange_vec_dec op_code (( 7 : int):ii) (( 5 : int):ii)  :  3 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_pac_autib_hint_decode L op0 op1 CRn CRm op2 Rt
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 24 : int):ii)  :  8 words$word)) = (vec_of_bits [B0;B0;B0;B1;B1;B1;B1;B0]  :  8 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)) = (vec_of_bits [B1]  :  1 words$word)))) /\ (((((subrange_vec_dec op_code (( 11 : int):ii) (( 10 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then
     let (M : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (typ : 2 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 22 : int):ii)  :  2 words$word)) in
     let (Rm : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (cond : 4 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 12 : int):ii)  :  4 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (op : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 4 : int):ii)]  :  1 words$word)) in
     let (nzcv1 : 4 bits) = ((subrange_vec_dec op_code (( 3 : int):ii) (( 0 : int):ii)  :  4 words$word)) in
     float_compare_cond_decode M S1 typ Rm cond Rn op nzcv1
   else if ((((((((subrange_vec_dec op_code (( 29 : int):ii) (( 23 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B0;B0;B0;B0]  :  7 words$word)))) /\ (((((subrange_vec_dec op_code (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)) = (vec_of_bits [B0]  :  1 words$word))))))) then
     let (size1 : 2 bits) = ((subrange_vec_dec op_code (( 31 : int):ii) (( 30 : int):ii)  :  2 words$word)) in
     let (o2 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 23 : int):ii)]  :  1 words$word)) in
     let (L : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 : int):ii)]  :  1 words$word)) in
     let (o1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 : int):ii)]  :  1 words$word)) in
     let (Rs : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (o0 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 15 : int):ii)]  :  1 words$word)) in
     let (Rt2 : 5 bits) = ((subrange_vec_dec op_code (( 14 : int):ii) (( 10 : int):ii)  :  5 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_exclusive_single_decode size1 o2 L o1 Rs o0 Rt2 Rn Rt
   else if ((((((((subrange_vec_dec op_code (( 30 : int):ii) (( 24 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B1;B1;B1;B0]  :  7 words$word)))) /\ (((((subrange_vec_dec op_code (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)) = (vec_of_bits [B0]  :  1 words$word))))))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (typ : 2 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 22 : int):ii)  :  2 words$word)) in
     let (rmode : 2 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 19 : int):ii)  :  2 words$word)) in
     let (opcode : 3 bits) = ((subrange_vec_dec op_code (( 18 : int):ii) (( 16 : int):ii)  :  3 words$word)) in
     let (scale : 6 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 10 : int):ii)  :  6 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     float_convert_fix_decode sf S1 typ rmode opcode scale Rn Rd
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 24 : int):ii)  :  8 words$word)) = (vec_of_bits [B0;B0;B0;B1;B1;B1;B1;B0]  :  8 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 21 : int):ii) (( 18 : int):ii)  :  4 words$word)) = (vec_of_bits [B1;B0;B0;B1]  :  4 words$word)))) /\ (((((subrange_vec_dec op_code (( 14 : int):ii) (( 10 : int):ii)  :  5 words$word)) = (vec_of_bits [B1;B0;B0;B0;B0]  :  5 words$word)))))))))) then
     let (M : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (typ : 2 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 22 : int):ii)  :  2 words$word)) in
     let (rmode : 3 bits) = ((subrange_vec_dec op_code (( 17 : int):ii) (( 15 : int):ii)  :  3 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     float_arithmetic_round_decode M S1 typ rmode Rn Rd
   else if (((((subrange_vec_dec op_code (( 28 : int):ii) (( 24 : int):ii)  :  5 words$word)) = (vec_of_bits [B0;B1;B0;B1;B0]  :  5 words$word)))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (opc : 2 bits) = ((subrange_vec_dec op_code (( 30 : int):ii) (( 29 : int):ii)  :  2 words$word)) in
     let (shift : 2 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 22 : int):ii)  :  2 words$word)) in
     let (N : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 : int):ii)]  :  1 words$word)) in
     let (Rm : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (imm6 : 6 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 10 : int):ii)  :  6 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_logical_shiftedreg_decode sf opc shift N Rm imm6 Rn Rd
   else if ((((((((subrange_vec_dec op_code (( 30 : int):ii) (( 21 : int):ii)  :  10 words$word)) = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B1;B1;B0]  :  10 words$word)))) /\ (((((subrange_vec_dec op_code (( 15 : int):ii) (( 13 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word))))))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (op : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (Rm : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (opcode2 : 3 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 13 : int):ii)  :  3 words$word)) in
     let (C : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 12 : int):ii)]  :  1 words$word)) in
     let (sz : 2 bits) = ((subrange_vec_dec op_code (( 11 : int):ii) (( 10 : int):ii)  :  2 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_crc_decode sf op S1 Rm opcode2 C sz Rn Rd
   else if ((((((((subrange_vec_dec op_code (( 28 : int):ii) (( 21 : int):ii)  :  8 words$word)) = (vec_of_bits [B1;B1;B0;B1;B0;B0;B0;B0]  :  8 words$word)))) /\ (((((subrange_vec_dec op_code (( 15 : int):ii) (( 10 : int):ii)  :  6 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0]  :  6 words$word))))))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (op : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (Rm : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (opcode2 : 6 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 10 : int):ii)  :  6 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_arithmetic_addsub_carry_decode sf op S1 Rm opcode2 Rn Rd
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 24 : int):ii)  :  8 words$word)) = (vec_of_bits [B0;B0;B0;B1;B1;B1;B1;B0]  :  8 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)) = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 15 : int):ii) (( 10 : int):ii)  :  6 words$word)) = (vec_of_bits [B0;B0;B1;B0;B0;B0]  :  6 words$word)))) /\ (((((subrange_vec_dec op_code (( 2 : int):ii) (( 0 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word))))))))))))) then
     let (M : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (typ : 2 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 22 : int):ii)  :  2 words$word)) in
     let (Rm : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (op : 2 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 14 : int):ii)  :  2 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (opc : 2 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 3 : int):ii)  :  2 words$word)) in
     float_compare_uncond_decode M S1 typ Rm op Rn opc
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 12 : int):ii)  :  20 words$word)) = (vec_of_bits [B1;B1;B0;B1;B0;B1;B0;B1;B0;B0;B0;B0;B0;B0;B1;B1;B0;B0;B1;B0]
                     :  20 words$word)))) /\ (((((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) = (vec_of_bits [B1;B1;B1;B1;B1]  :  5 words$word))))))) then
     let (L : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 : int):ii)]  :  1 words$word)) in
     let (op0 : 2 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 19 : int):ii)  :  2 words$word)) in
     let (op1 : 3 bits) = ((subrange_vec_dec op_code (( 18 : int):ii) (( 16 : int):ii)  :  3 words$word)) in
     let (CRn : 4 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 12 : int):ii)  :  4 words$word)) in
     let (CRm : 4 bits) = ((subrange_vec_dec op_code (( 11 : int):ii) (( 8 : int):ii)  :  4 words$word)) in
     let (op2 : 3 bits) = ((subrange_vec_dec op_code (( 7 : int):ii) (( 5 : int):ii)  :  3 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     system_hints_decode L op0 op1 CRn CRm op2 Rt
   else if ((((((((subrange_vec_dec op_code (( 30 : int):ii) (( 21 : int):ii)  :  10 words$word)) = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B1;B1;B0]  :  10 words$word)))) /\ (((((subrange_vec_dec op_code (( 15 : int):ii) (( 12 : int):ii)  :  4 words$word)) = (vec_of_bits [B0;B0;B1;B0]  :  4 words$word))))))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (op : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (Rm : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (opcode2 : 4 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 12 : int):ii)  :  4 words$word)) in
     let (op2 : 2 bits) = ((subrange_vec_dec op_code (( 11 : int):ii) (( 10 : int):ii)  :  2 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_shift_variable_decode sf op S1 Rm opcode2 op2 Rn Rd
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 14 : int):ii)  :  18 words$word)) = (vec_of_bits [B1;B1;B0;B1;B1;B0;B1;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B0]
                     :  18 words$word)))) /\ (((((subrange_vec_dec op_code (( 12 : int):ii) (( 10 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word))))))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (opcode2 : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (Z : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 13 : int):ii)]  :  1 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_pac_pacdb_dp_1src_decode sf S1 opcode2 Z Rn Rd
   else if ((((((((subrange_vec_dec op_code (( 29 : int):ii) (( 24 : int):ii)  :  6 words$word)) = (vec_of_bits [B1;B1;B1;B0;B0;B0]  :  6 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)) = (vec_of_bits [B0]  :  1 words$word)))) /\ (((((subrange_vec_dec op_code (( 11 : int):ii) (( 10 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word)))))))))) then
     let (size1 : 2 bits) = ((subrange_vec_dec op_code (( 31 : int):ii) (( 30 : int):ii)  :  2 words$word)) in
     let (V1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 : int):ii)]  :  1 words$word)) in
     let (opc : 2 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 22 : int):ii)  :  2 words$word)) in
     let (imm9 : 9 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 12 : int):ii)  :  9 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rt : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     memory_single_general_immediate_signed_offset_unpriv_aarch64_memory_single_general_immediate_signed_offset_unpriv__decode
       size1 V1 opc imm9 Rn Rt
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 24 : int):ii)  :  8 words$word)) = (vec_of_bits [B0;B0;B0;B1;B1;B1;B1;B0]  :  8 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)) = (vec_of_bits [B1]  :  1 words$word)))) /\ ((((((((subrange_vec_dec op_code (( 15 : int):ii) (( 13 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec op_code (( 11 : int):ii) (( 10 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word))))))))))))) then
     let (M : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (typ : 2 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 22 : int):ii)  :  2 words$word)) in
     let (Rm : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (op : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 12 : int):ii)]  :  1 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     float_arithmetic_addsub_decode M S1 typ Rm op Rn Rd
   else if ((((((((subrange_vec_dec op_code (( 30 : int):ii) (( 23 : int):ii)  :  8 words$word)) = (vec_of_bits [B0;B0;B1;B0;B0;B1;B1;B1]  :  8 words$word)))) /\ (((((subrange_vec_dec op_code (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)) = (vec_of_bits [B0]  :  1 words$word))))))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (op21 : 2 bits) = ((subrange_vec_dec op_code (( 30 : int):ii) (( 29 : int):ii)  :  2 words$word)) in
     let (N : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 : int):ii)]  :  1 words$word)) in
     let (o0 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 : int):ii)]  :  1 words$word)) in
     let (Rm : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (imms : 6 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 10 : int):ii)  :  6 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_insext_extract_immediate_decode sf op21 N o0 Rm imms Rn Rd
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 21 : int):ii)  :  11 words$word)) = (vec_of_bits [B1;B1;B0;B1;B0;B1;B0;B0;B0;B1;B0]  :  11 words$word)))) /\ (((((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0]  :  5 words$word))))))) then
     let (opc : 3 bits) = ((subrange_vec_dec op_code (( 23 : int):ii) (( 21 : int):ii)  :  3 words$word)) in
     let (imm16 : 16 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 5 : int):ii)  :  16 words$word)) in
     let (op2 : 3 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 2 : int):ii)  :  3 words$word)) in
     let (LL : 2 bits) = ((subrange_vec_dec op_code (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) in
     system_exceptions_debug_halt_decode opc imm16 op2 LL
   else if ((((((((subrange_vec_dec op_code (( 31 : int):ii) (( 24 : int):ii)  :  8 words$word)) = (vec_of_bits [B1;B0;B0;B1;B1;B0;B1;B1]  :  8 words$word)))) /\ (((((subrange_vec_dec op_code (( 22 : int):ii) (( 21 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word))))))) then
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (op54 : 2 bits) = ((subrange_vec_dec op_code (( 30 : int):ii) (( 29 : int):ii)  :  2 words$word)) in
     let (U : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 23 : int):ii)]  :  1 words$word)) in
     let (Rm : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (o0 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 15 : int):ii)]  :  1 words$word)) in
     let (Ra : 5 bits) = ((subrange_vec_dec op_code (( 14 : int):ii) (( 10 : int):ii)  :  5 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_arithmetic_mul_widening_3264_decode sf op54 U Rm o0 Ra Rn Rd
   else
     let (sf : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 : int):ii)]  :  1 words$word)) in
     let (op : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 : int):ii)]  :  1 words$word)) in
     let (S1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 : int):ii)]  :  1 words$word)) in
     let (Rm : 5 bits) = ((subrange_vec_dec op_code (( 20 : int):ii) (( 16 : int):ii)  :  5 words$word)) in
     let (opcode2 : 5 bits) = ((subrange_vec_dec op_code (( 15 : int):ii) (( 11 : int):ii)  :  5 words$word)) in
     let (o1 : 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 10 : int):ii)]  :  1 words$word)) in
     let (Rn : 5 bits) = ((subrange_vec_dec op_code (( 9 : int):ii) (( 5 : int):ii)  :  5 words$word)) in
     let (Rd : 5 bits) = ((subrange_vec_dec op_code (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word)) in
     integer_arithmetic_div_decode sf op S1 Rm opcode2 o1 Rn Rd))`;


(*val initialize_registers : unit -> M unit*)

val _ = Define `
 ((initialize_registers:unit ->(regstate)sail2_state_monad$sequential_state ->(((unit),(exception))sail2_state_monad$result#(regstate)sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$bindS
   (sail2_state_monad$undefined_boolS () ) (\ (w__0 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS unconditional_ref w__0)
   (undefined_bitvector (( 4 : int):ii)  : ( 4 words$word) M)) (\ (w__1 : 4 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS currentCond_ref w__1)
   (undefined___InstrEnc () )) (\ (w__2 : InstrEnc) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS ThisInstrEnc_ref w__2)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__3 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS ThisInstr_ref w__3)
   (sail2_state_monad$undefined_boolS () )) (\ (w__4 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS Sleeping_ref w__4)
   (sail2_state_monad$undefined_boolS () )) (\ (w__5 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PendingPhysicalSError_ref w__5)
   (sail2_state_monad$undefined_boolS () )) (\ (w__6 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PendingInterrupt_ref w__6)
   (undefined_bitvector (( 52 : int):ii)  : ( 52 words$word) M)) (\ (w__7 : 52 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS Memory_ref w__7)
   (sail2_state_monad$undefined_boolS () )) (\ (w__8 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS ExclusiveLocal_ref w__8)
   (sail2_state_monad$undefined_boolS () )) (\ (w__9 : bool) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS BranchTaken_ref w__9)
   (undefined_bitvector (( 128 : int):ii)  : ( 128 words$word) M)) (\ (w__10 :  128 words$word) .  sail2_state_monad$bindS
   (undefined_vector (( 32 : int):ii) w__10  : ( ( 128 words$word)list) M) (\ (w__11 : ( 128 bits) list) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS V_ref w__11)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__12 :  64 words$word) .  sail2_state_monad$bindS
   (undefined_vector (( 31 : int):ii) w__12  : ( ( 64 words$word)list) M) (\ (w__13 : ( 64 bits) list) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS R_ref w__13)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__14 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PC_ref w__14)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__15 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS VTTBR_EL2_ref w__15)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__16 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS VTCR_EL2_ref w__16)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__17 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS VSESR_EL2_ref w__17)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__18 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS VDFSR_ref w__18)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__19 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS VBAR_EL3_ref w__19)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__20 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS VBAR_EL2_ref w__20)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__21 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS VBAR_EL1_ref w__21)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__22 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS VBAR_ref w__22)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__23 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS TTBR1_EL2_ref w__23)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__24 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS TTBR1_EL1_ref w__24)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__25 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS TTBR0_EL3_ref w__25)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__26 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS TTBR0_EL2_ref w__26)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__27 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS TTBR0_EL1_ref w__27)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__28 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS TTBCR_ref w__28)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__29 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS TCR_EL3_ref w__29)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__30 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS TCR_EL2_ref w__30)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__31 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS TCR_EL1_ref w__31)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__32 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS SP_mon_ref w__32)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__33 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS SP_EL3_ref w__33)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__34 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS SP_EL2_ref w__34)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__35 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS SP_EL1_ref w__35)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__36 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS SP_EL0_ref w__36)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__37 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS SPSR_und_ref w__37)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__38 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS SPSR_svc_ref w__38)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__39 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS SPSR_mon_ref w__39)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__40 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS SPSR_irq_ref w__40)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__41 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS SPSR_hyp_ref w__41)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__42 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS SPSR_fiq_ref w__42)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__43 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS SPSR_abt_ref w__43)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__44 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS SPSR_EL3_ref w__44)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__45 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS SPSR_EL2_ref w__45)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__46 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS SPSR_EL1_ref w__46)
   (undefined_signal () )) (\ (w__47 : signal) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS SPIDEN_ref w__47)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__48 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS SDER_ref w__48)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__49 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS SDCR_ref w__49)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__50 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS SCTLR_EL3_ref w__50)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__51 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS SCTLR_EL2_ref w__51)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__52 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS SCTLR_EL1_ref w__52)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__53 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS SCTLR_ref w__53)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__54 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS SCR_EL3_ref w__54)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__55 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS SCR_ref w__55)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__56 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS RVBAR_EL3_ref w__56)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__57 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS RVBAR_EL2_ref w__57)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__58 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS RVBAR_EL1_ref w__58)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__59 :  64 words$word) .  sail2_state_monad$bindS
   (undefined_vector (( 5 : int):ii) w__59  : ( ( 64 words$word)list) M) (\ (w__60 : ( 64 bits) list) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS RC_ref w__60)
   (undefined_ProcState () )) (\ (w__61 : ProcState) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS PSTATE_ref w__61)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__62 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS OSLSR_EL1_ref w__62)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__63 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS OSDLR_EL1_ref w__63)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__64 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS MDSCR_EL1_ref w__64)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__65 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS MDCR_EL3_ref w__65)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__66 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS MDCR_EL2_ref w__66)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__67 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS MAIR_EL3_ref w__67)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__68 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS MAIR_EL2_ref w__68)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__69 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS MAIR_EL1_ref w__69)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__70 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS LR_mon_ref w__70)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__71 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS ID_AA64DFR0_EL1_ref w__71)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__72 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS HVBAR_ref w__72)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__73 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS HSR_ref w__73)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__74 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS HSCTLR_ref w__74)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__75 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS HPFAR_EL2_ref w__75)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__76 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS HPFAR_ref w__76)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__77 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS HIFAR_ref w__77)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__78 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS HDFAR_ref w__78)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__79 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS HDCR_ref w__79)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__80 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS HCR_EL2_ref w__80)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__81 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS HCR2_ref w__81)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__82 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS HCR_ref w__82)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__83 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS FPSR_ref w__83)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__84 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS FPSCR_ref w__84)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__85 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS FPEXC_ref w__85)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__86 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS FPCR_ref w__86)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__87 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS FAR_EL3_ref w__87)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__88 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS FAR_EL2_ref w__88)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__89 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS FAR_EL1_ref w__89)
   (undefined_bitvector (( 1 : int):ii)  : ( 1 words$word) M)) (\ (w__90 : 1 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS EventRegister_ref w__90)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__91 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS ESR_EL3_ref w__91)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__92 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS ESR_EL2_ref w__92)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__93 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS ESR_EL1_ref w__93)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__94 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS ELR_hyp_ref w__94)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__95 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS ELR_EL3_ref w__95)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__96 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS ELR_EL2_ref w__96)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__97 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS ELR_EL1_ref w__97)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__98 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS EDSCR_ref w__98)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__99 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS DSPSR_EL0_ref w__99)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__100 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS DSPSR_ref w__100)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__101 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS DLR_EL0_ref w__101)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__102 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS DLR_ref w__102)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__103 :  64 words$word) .  sail2_state_monad$bindS
   (undefined_vector (( 16 : int):ii) w__103  : ( ( 64 words$word)list) M) (\ (w__104 : ( 64 bits) list) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS DBGWVR_EL1_ref w__104)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__105 :  32 words$word) .  sail2_state_monad$bindS
   (undefined_vector (( 16 : int):ii) w__105  : ( ( 32 words$word)list) M) (\ (w__106 : ( 32 bits) list) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS DBGWCR_EL1_ref w__106)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__107 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS DBGPRCR_EL1_ref w__107)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__108 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS DBGPRCR_ref w__108)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__109 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS DBGOSLSR_ref w__109)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__110 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS DBGOSDLR_ref w__110)
   (undefined_signal () )) (\ (w__111 : signal) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS DBGEN_ref w__111)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__112 :  64 words$word) .  sail2_state_monad$bindS
   (undefined_vector (( 16 : int):ii) w__112  : ( ( 64 words$word)list) M) (\ (w__113 : ( 64 bits) list) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS DBGBVR_EL1_ref w__113)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__114 :  32 words$word) .  sail2_state_monad$bindS
   (undefined_vector (( 16 : int):ii) w__114  : ( ( 32 words$word)list) M) (\ (w__115 : ( 32 bits) list) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS DBGBCR_EL1_ref w__115)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__116 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS CPTR_EL3_ref w__116)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__117 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS CPTR_EL2_ref w__117)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__118 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS CPACR_EL1_ref w__118)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__119 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS CONTEXTIDR_EL2_ref w__119)
   (undefined_bitvector (( 32 : int):ii)  : ( 32 words$word) M)) (\ (w__120 : 32 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS CONTEXTIDR_EL1_ref w__120)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__121 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS APIBKeyLo_EL1_ref w__121)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__122 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS APIBKeyHi_EL1_ref w__122)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__123 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS APIAKeyLo_EL1_ref w__123)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__124 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS APIAKeyHi_EL1_ref w__124)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__125 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS APGAKeyLo_EL1_ref w__125)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__126 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS APGAKeyHi_EL1_ref w__126)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__127 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS APDBKeyLo_EL1_ref w__127)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__128 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS APDBKeyHi_EL1_ref w__128)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__129 : 64 bits) .  sail2_state_monad$bindS (sail2_state_monad$seqS
   (sail2_state_monad$write_regS APDAKeyLo_EL1_ref w__129)
   (undefined_bitvector (( 64 : int):ii)  : ( 64 words$word) M)) (\ (w__130 : 64 bits) . 
   sail2_state_monad$write_regS APDAKeyHi_EL1_ref w__130)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))`;


val _ = Define `
((initial_regstate:regstate)=
   (<| APDAKeyHi_EL1 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     APDAKeyLo_EL1 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     APDBKeyHi_EL1 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     APDBKeyLo_EL1 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     APGAKeyHi_EL1 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     APGAKeyLo_EL1 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     APIAKeyHi_EL1 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     APIAKeyLo_EL1 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     APIBKeyHi_EL1 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     APIBKeyLo_EL1 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     CONTEXTIDR_EL1 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     CONTEXTIDR_EL2 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     CPACR_EL1 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     CPTR_EL2 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     CPTR_EL3 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     DBGBCR_EL1 :=
       ([(vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word)]); 
     DBGBVR_EL1 :=
       ([(vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word)]); 
     DBGEN := LOW; 
     DBGOSDLR :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     DBGOSLSR :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     DBGPRCR :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     DBGPRCR_EL1 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     DBGWCR_EL1 :=
       ([(vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0]
           :  32 words$word)]); 
     DBGWVR_EL1 :=
       ([(vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word)]); 
     DLR :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     DLR_EL0 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     DSPSR :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     DSPSR_EL0 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     EDSCR :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     ELR_EL1 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     ELR_EL2 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     ELR_EL3 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     ELR_hyp :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     ESR_EL1 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     ESR_EL2 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     ESR_EL3 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     EventRegister := ((vec_of_bits [B0]  :  1 words$word)); 
     FAR_EL1 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     FAR_EL2 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     FAR_EL3 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     FPCR :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     FPEXC :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     FPSCR :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     FPSR :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     HCR :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     HCR2 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     HCR_EL2 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     HDCR :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     HDFAR :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     HIFAR :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     HPFAR :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     HPFAR_EL2 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     HSCTLR :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     HSR :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     HVBAR :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     ID_AA64DFR0_EL1 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     LR_mon :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     MAIR_EL1 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     MAIR_EL2 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     MAIR_EL3 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     MDCR_EL2 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     MDCR_EL3 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     MDSCR_EL1 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     OSDLR_EL1 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     OSLSR_EL1 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     PSTATE :=
       (<| ProcState_N := ((vec_of_bits [B0]  :  1 words$word)); 
           ProcState_Z := ((vec_of_bits [B0]  :  1 words$word)); 
           ProcState_C := ((vec_of_bits [B0]  :  1 words$word)); 
           ProcState_V := ((vec_of_bits [B0]  :  1 words$word)); 
           ProcState_D := ((vec_of_bits [B0]  :  1 words$word)); 
           ProcState_A := ((vec_of_bits [B0]  :  1 words$word)); 
           ProcState_I := ((vec_of_bits [B0]  :  1 words$word)); 
           ProcState_F := ((vec_of_bits [B0]  :  1 words$word)); 
           ProcState_PAN := ((vec_of_bits [B0]  :  1 words$word)); 
           ProcState_UAO := ((vec_of_bits [B0]  :  1 words$word)); 
           ProcState_SS := ((vec_of_bits [B0]  :  1 words$word)); 
           ProcState_IL := ((vec_of_bits [B0]  :  1 words$word)); 
           ProcState_EL := ((vec_of_bits [B0;B0]  :  2 words$word)); 
           ProcState_nRW := ((vec_of_bits [B0]  :  1 words$word)); 
           ProcState_SP := ((vec_of_bits [B0]  :  1 words$word)); 
           ProcState_Q := ((vec_of_bits [B0]  :  1 words$word)); 
           ProcState_GE := ((vec_of_bits [B0;B0;B0;B0]  :  4 words$word)); 
           ProcState_IT := ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0]  :  8 words$word)); 
           ProcState_J := ((vec_of_bits [B0]  :  1 words$word)); 
           ProcState_T := ((vec_of_bits [B0]  :  1 words$word)); 
           ProcState_E := ((vec_of_bits [B0]  :  1 words$word)); 
           ProcState_M := ((vec_of_bits [B0;B0;B0;B0;B0]  :  5 words$word)) |>); 
     RC0 :=
       ([(vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word)]); 
     RVBAR_EL1 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     RVBAR_EL2 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     RVBAR_EL3 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     SCR :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     SCR_EL3 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     SCTLR :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     SCTLR_EL1 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     SCTLR_EL2 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     SCTLR_EL3 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     SDCR :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     SDER :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     SPIDEN := LOW; 
     SPSR_EL1 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     SPSR_EL2 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     SPSR_EL3 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     SPSR_abt :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     SPSR_fiq :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     SPSR_hyp :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     SPSR_irq :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     SPSR_mon :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     SPSR_svc :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     SPSR_und :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     SP_EL0 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     SP_EL1 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     SP_EL2 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     SP_EL3 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     SP_mon :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     TCR_EL1 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     TCR_EL2 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     TCR_EL3 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     TTBCR :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     TTBR0_EL1 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     TTBR0_EL2 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     TTBR0_EL3 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     TTBR1_EL1 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     TTBR1_EL2 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     VBAR :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     VBAR_EL1 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     VBAR_EL2 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     VBAR_EL3 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     VDFSR :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     VSESR_EL2 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     VTCR_EL2 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     VTTBR_EL2 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     PC :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     R :=
       ([(vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word)]); 
     V :=
       ([(vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  128 words$word)]); 
     BranchTaken := F; 
     ExclusiveLocal := F; 
     Memory :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  52 words$word)); 
     PendingInterrupt := F; 
     PendingPhysicalSError := F; 
     Sleeping := F; 
     ThisInstr :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0]
         :  32 words$word)); 
     ThisInstrEnc := A64; 
     currentCond := ((vec_of_bits [B0;B0;B0;B0]  :  4 words$word)); 
     unconditional := F |>))`;



val _ = export_theory()


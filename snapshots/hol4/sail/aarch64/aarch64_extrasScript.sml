(*Generated by Lem from ../aarch64_extras.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasives_extraTheory sail2_instr_kindsTheory sail2_valuesTheory sail2_prompt_monadTheory sail2_operators_mwordsTheory sail2_promptTheory;

val _ = numLib.prefer_num();



val _ = new_theory "aarch64_extras"

(*open import Pervasives_extra*)
(*open import Sail2_instr_kinds*)
(*open import Sail2_values*)
(*open import Sail2_operators_mwords*)
(*open import Sail2_prompt_monad*)
(*open import Sail2_prompt*)

(*type ty512*)
(*type ty1024*)
(*type ty2048*)

val _ = Define `
 ((hexchar_to_bool_list:char ->((bool)list)option) c=
   (if c = #"0" then      SOME ([F;F;F;F])
  else if c = #"1" then SOME ([F;F;F;T ])
  else if c = #"2" then SOME ([F;F;T; F])
  else if c = #"3" then SOME ([F;F;T; T ])
  else if c = #"4" then SOME ([F;T; F;F])
  else if c = #"5" then SOME ([F;T; F;T ])
  else if c = #"6" then SOME ([F;T; T; F])
  else if c = #"7" then SOME ([F;T; T; T ])
  else if c = #"8" then SOME ([T; F;F;F])
  else if c = #"9" then SOME ([T; F;F;T ])
  else if c = #"A" then SOME ([T; F;T; F])
  else if c = #"a" then SOME ([T; F;T; F])
  else if c = #"B" then SOME ([T; F;T; T ])
  else if c = #"b" then SOME ([T; F;T; T ])
  else if c = #"C" then SOME ([T; T; F;F])
  else if c = #"c" then SOME ([T; T; F;F])
  else if c = #"D" then SOME ([T; T; F;T ])
  else if c = #"d" then SOME ([T; T; F;T ])
  else if c = #"E" then SOME ([T; T; T; F])
  else if c = #"e" then SOME ([T; T; T; F])
  else if c = #"F" then SOME ([T; T; T; T ])
  else if c = #"f" then SOME ([T; T; T; T ])
  else NONE))`;


val _ = Define `
 ((hexstring_to_bools:string ->((bool)list)option) s=
   ((case (EXPLODE s) of
      z :: x :: hs =>
       let str = (if ((z = #"0") /\ (x = #"x")) then hs else z :: (x :: hs)) in
       OPTION_MAP FLAT (just_list (MAP hexchar_to_bool_list str))
    | _ => NONE
  )))`;


(*val hex_slice : forall 'rv 'n 'e. Size 'n => string -> integer -> integer -> monad 'rv (mword 'n) 'e*)
val _ = Define `
 ((hex_slice:string -> int -> int -> 'rv sail2_state_monad$sequential_state ->((('n words$word),'e)sail2_state_monad$result#'rv sail2_state_monad$sequential_state)set) v len lo=  (sail2_state_monad$bindS
  (sail2_state_monad$maybe_failS "hex_slice" (hexstring_to_bools v)) (\ bs . 
   let hi = ((len + lo) -( 1 : int)) in
   let bs = (ext_list F (len + lo) bs) in
   sail2_state_monad$returnS (bitstring$v2w (subrange_list F bs hi lo)))))`;


(*val BigEndianReverse : forall 'rv 'n 'e. Size 'n => mword 'n -> monad 'rv (mword 'n) 'e*)
val _ = Define `
 ((BigEndianReverse:'n words$word -> 'rv sail2_state_monad$sequential_state ->((('n words$word),'e)sail2_state_monad$result#'rv sail2_state_monad$sequential_state)set) w=  (sail2_state_monad$returnS (reverse_endianness w)))`;


(* Use constants for some undefined values for now *)
val _ = Define `
 ((undefined_string:unit -> 'a sail2_state_monad$sequential_state ->(((string),'b)sail2_state_monad$result#'a sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$returnS ""))`;

val _ = Define `
 ((undefined_unit:unit -> 'a sail2_state_monad$sequential_state ->(((unit),'b)sail2_state_monad$result#'a sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$returnS () ))`;

val _ = Define `
 ((undefined_int:unit -> 'a sail2_state_monad$sequential_state ->(((int),'b)sail2_state_monad$result#'a sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$returnS (( 0 : int):ii)))`;

(*val undefined_vector : forall 'rv 'a 'e. integer -> 'a -> monad 'rv (list 'a) 'e*)
val _ = Define `
 ((undefined_vector:int -> 'a -> 'rv sail2_state_monad$sequential_state ->((('a list),'e)sail2_state_monad$result#'rv sail2_state_monad$sequential_state)set) len u=  (sail2_state_monad$returnS (repeat [u] len)))`;

(*val undefined_bitvector : forall 'rv 'a 'e. Size 'a => integer -> monad 'rv (mword 'a) 'e*)
val _ = Define `
 ((undefined_bitvector:int -> 'rv sail2_state_monad$sequential_state ->((('a words$word),'e)sail2_state_monad$result#'rv sail2_state_monad$sequential_state)set) len=  (sail2_state_monad$returnS (bitstring$v2w (repeat [F] len))))`;

(*val undefined_bits : forall 'rv 'a 'e. Size 'a => integer -> monad 'rv (mword 'a) 'e*)
val _ = Define `
 ((undefined_bits:int ->('rv,('a words$word),'e)monad)=  undefined_bitvector)`;

val _ = Define `
 ((undefined_bit:unit -> 'a sail2_state_monad$sequential_state ->(((bitU),'b)sail2_state_monad$result#'a sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$returnS B0))`;

val _ = Define `
 ((undefined_real:unit -> 'a sail2_state_monad$sequential_state ->(((real),'b)sail2_state_monad$result#'a sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$returnS (realFromFrac(( 0 : int))(( 1 : int)))))`;

val _ = Define `
 ((undefined_range:'a -> 'd -> 'b sail2_state_monad$sequential_state ->(('a,'c)sail2_state_monad$result#'b sail2_state_monad$sequential_state)set) i j=  (sail2_state_monad$returnS i))`;

val _ = Define `
 ((undefined_atom:'a -> 'b sail2_state_monad$sequential_state ->(('a,'c)sail2_state_monad$result#'b sail2_state_monad$sequential_state)set) i=  (sail2_state_monad$returnS i))`;

val _ = Define `
 ((undefined_nat:unit -> 'a sail2_state_monad$sequential_state ->(((int),'b)sail2_state_monad$result#'a sail2_state_monad$sequential_state)set) () =  (sail2_state_monad$returnS (( 0 : int):ii)))`;


(*val write_ram : forall 'rv 'a 'b 'c 'e. Size 'b, Size 'c =>
  integer -> integer -> mword 'a -> mword 'b -> mword 'c -> monad 'rv unit 'e*)
val _ = Define `
 ((write_ram:int -> int -> 'a words$word -> 'b words$word -> 'c words$word -> 'rv sail2_state_monad$sequential_state ->(((unit),'e)sail2_state_monad$result#'rv sail2_state_monad$sequential_state)set) addrsize size1 hexRAM address value=  (sail2_state_monad$bindS (sail2_state_monad$seqS
  (sail2_state_monad$write_mem_eaS 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict Write_plain address (nat_of_int size1))
  (sail2_state_monad$write_mem_valS 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict value)) (\b .  (case (b ) of ( _ ) => sail2_state_monad$returnS ()  ))))`;


(*val read_ram : forall 'rv 'a 'b 'c 'e. Size 'b, Size 'c =>
  integer -> integer -> mword 'a -> mword 'b -> monad 'rv (mword 'c) 'e*)
val _ = Define `
 ((read_ram:int -> int -> 'a words$word -> 'b words$word -> 'rv sail2_state_monad$sequential_state ->((('c words$word),'e)sail2_state_monad$result#'rv sail2_state_monad$sequential_state)set) addrsize size1 hexRAM address=
   (
  (*let _ = prerr_endline ("Reading " ^ (stringFromInteger size) ^ " bytes from address " ^ (stringFromInteger (unsigned address))) in*)sail2_state_monad$read_memS 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict Read_plain address size1))`;


(*val elf_entry : unit -> integer*)
val _ = Define `
 ((elf_entry:unit -> int) () = (( 0 : int)))`;

val _ = export_theory()


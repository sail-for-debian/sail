chapter \<open>Generated by Lem from \<open>riscv_duopod_types.lem\<close>.\<close>

theory "Riscv_duopod_types" 

imports
  Main
  "LEM.Lem_pervasives_extra"
  "Sail.Sail2_instr_kinds"
  "Sail.Sail2_values"
  "Sail.Sail2_operators_mwords"
  "Sail.Sail2_prompt_monad"
  "Sail.Sail2_prompt"
  "Sail.Sail2_string"

begin 

(*Generated by Sail from riscv_duopod.*)
(*open import Pervasives_extra*)
(*open import Sail2_instr_kinds*)
(*open import Sail2_values*)
(*open import Sail2_string*)
(*open import Sail2_operators_mwords*)
(*open import Sail2_prompt_monad*)
(*open import Sail2_prompt*)
type_synonym 'n bits =" ( 'n::len)Word.word "



type_synonym xlen  =" int "

type_synonym xlen_t  =" 64 bits "

type_synonym 'n regno  =" int "

type_synonym regbits  =" 5 bits "

datatype iop = RISCV_ADDI | RISCV_SLTI | RISCV_SLTIU | RISCV_XORI | RISCV_ORI | RISCV_ANDI



datatype ast  =
    ITYPE " (( 12 bits * regbits * regbits * iop))" | LOAD " (( 12 bits * regbits * regbits))"



datatype register_value  =
    Regval_vector " ((ii * bool * register_value list))"
  | Regval_list " ( register_value list)"
  | Regval_option " ( register_value option)"
  | Regval_vector_64_dec_bit " ( 64 Word.word)"



record regstate  = 
 Xs ::" ( 64 Word.word) list " 
 nextPC ::"  64 Word.word " 
 PC ::"  64 Word.word "  





(*val vector_64_dec_bit_of_regval : register_value -> maybe (mword ty64)*)

fun vector_64_dec_bit_of_regval  :: " register_value \<Rightarrow>((64)Word.word)option "  where 
     " vector_64_dec_bit_of_regval (Regval_vector_64_dec_bit (v)) = ( Some v )"
|" vector_64_dec_bit_of_regval g__1 = ( None )"


(*val regval_of_vector_64_dec_bit : mword ty64 -> register_value*)

definition regval_of_vector_64_dec_bit  :: "(64)Word.word \<Rightarrow> register_value "  where 
     " regval_of_vector_64_dec_bit v = ( Regval_vector_64_dec_bit v )"




(*val vector_of_regval : forall 'a. (register_value -> maybe 'a) -> register_value -> maybe (list 'a)*)
definition vector_of_regval  :: "(register_value \<Rightarrow> 'a option)\<Rightarrow> register_value \<Rightarrow>('a list)option "  where 
     " vector_of_regval of_regval1 = ( \<lambda>x .  
  (case  x of
        Regval_vector (_, _, v) => just_list (List.map of_regval1 v)
    | _ => None
  ) )"


(*val regval_of_vector : forall 'a. ('a -> register_value) -> integer -> bool -> list 'a -> register_value*)
definition regval_of_vector  :: "('a \<Rightarrow> register_value)\<Rightarrow> int \<Rightarrow> bool \<Rightarrow> 'a list \<Rightarrow> register_value "  where 
     " regval_of_vector regval_of1 size1 is_inc xs = ( Regval_vector (size1, is_inc, List.map regval_of1 xs))"


(*val list_of_regval : forall 'a. (register_value -> maybe 'a) -> register_value -> maybe (list 'a)*)
definition list_of_regval  :: "(register_value \<Rightarrow> 'a option)\<Rightarrow> register_value \<Rightarrow>('a list)option "  where 
     " list_of_regval of_regval1 = ( \<lambda>x .  
  (case  x of
        Regval_list v => just_list (List.map of_regval1 v)
    | _ => None
  ) )"


(*val regval_of_list : forall 'a. ('a -> register_value) -> list 'a -> register_value*)
definition regval_of_list  :: "('a \<Rightarrow> register_value)\<Rightarrow> 'a list \<Rightarrow> register_value "  where 
     " regval_of_list regval_of1 xs = ( Regval_list (List.map regval_of1 xs))"


(*val option_of_regval : forall 'a. (register_value -> maybe 'a) -> register_value -> maybe (maybe 'a)*)
definition option_of_regval  :: "(register_value \<Rightarrow> 'a option)\<Rightarrow> register_value \<Rightarrow>('a option)option "  where 
     " option_of_regval of_regval1 = ( \<lambda>x .  
  (case  x of
        Regval_option v => Some (Option.bind v of_regval1)
    | _ => None
  ) )"


(*val regval_of_option : forall 'a. ('a -> register_value) -> maybe 'a -> register_value*)
definition regval_of_option  :: "('a \<Rightarrow> register_value)\<Rightarrow> 'a option \<Rightarrow> register_value "  where 
     " regval_of_option regval_of1 v = ( Regval_option (map_option regval_of1 v))"



definition Xs_ref  :: "((regstate),(register_value),(((64)Word.word)list))register_ref "  where 
     " Xs_ref = ( (|
  name = (''Xs''),
  read_from = (\<lambda> s . (Xs   s)),
  write_to = (\<lambda> v s .  (( s (| Xs := v |)))),
  of_regval = (\<lambda> v .  vector_of_regval (\<lambda> v .  vector_64_dec_bit_of_regval v) v),
  regval_of = (\<lambda> v .  regval_of_vector (\<lambda> v .  regval_of_vector_64_dec_bit v)(( 32 :: int)) False v) |) )"


definition nextPC_ref  :: "((regstate),(register_value),((64)Word.word))register_ref "  where 
     " nextPC_ref = ( (|
  name = (''nextPC''),
  read_from = (\<lambda> s . (nextPC   s)),
  write_to = (\<lambda> v s .  (( s (| nextPC := v |)))),
  of_regval = (\<lambda> v .  vector_64_dec_bit_of_regval v),
  regval_of = (\<lambda> v .  regval_of_vector_64_dec_bit v) |) )"


definition PC_ref  :: "((regstate),(register_value),((64)Word.word))register_ref "  where 
     " PC_ref = ( (|
  name = (''PC''),
  read_from = (\<lambda> s . (PC   s)),
  write_to = (\<lambda> v s .  (( s (| PC := v |)))),
  of_regval = (\<lambda> v .  vector_64_dec_bit_of_regval v),
  regval_of = (\<lambda> v .  regval_of_vector_64_dec_bit v) |) )"


(*val get_regval : string -> regstate -> maybe register_value*)
definition get_regval  :: " string \<Rightarrow> regstate \<Rightarrow>(register_value)option "  where 
     " get_regval reg_name s = (
  if reg_name = (''Xs'') then Some ((regval_of   Xs_ref) ((read_from   Xs_ref) s)) else
  if reg_name = (''nextPC'') then Some ((regval_of   nextPC_ref) ((read_from   nextPC_ref) s)) else
  if reg_name = (''PC'') then Some ((regval_of   PC_ref) ((read_from   PC_ref) s)) else
  None )"


(*val set_regval : string -> register_value -> regstate -> maybe regstate*)
definition set_regval  :: " string \<Rightarrow> register_value \<Rightarrow> regstate \<Rightarrow>(regstate)option "  where 
     " set_regval reg_name v s = (
  if reg_name = (''Xs'') then map_option (\<lambda> v . (write_to   Xs_ref) v s) ((of_regval   Xs_ref) v) else
  if reg_name = (''nextPC'') then map_option (\<lambda> v . (write_to   nextPC_ref) v s) ((of_regval   nextPC_ref) v) else
  if reg_name = (''PC'') then map_option (\<lambda> v . (write_to   PC_ref) v s) ((of_regval   PC_ref) v) else
  None )"


definition register_accessors  :: "(string \<Rightarrow> regstate \<Rightarrow>(register_value)option)*(string \<Rightarrow> register_value \<Rightarrow> regstate \<Rightarrow>(regstate)option)"  where 
     " register_accessors = ( (get_regval, set_regval))"



type_synonym( 'a, 'r) MR =" (register_value, regstate, 'a, 'r, unit) base_monadR "
type_synonym 'a M =" (register_value, regstate, 'a, unit) base_monad "
end

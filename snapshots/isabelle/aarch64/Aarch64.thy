chapter \<open>Generated by Lem from \<open>aarch64.lem\<close>.\<close>

theory "Aarch64" 

imports
  Main
  "LEM.Lem_pervasives_extra"
  "Sail.Sail2_instr_kinds"
  "Sail.Sail2_values"
  "Sail.Sail2_operators_mwords"
  "Sail.Sail2_prompt_monad"
  "Sail.Sail2_prompt"
  "Sail.Sail2_string"
  "Aarch64_types"
  "Aarch64_extras"

begin 

(*Generated by Sail from aarch64.*)
(*open import Pervasives_extra*)
(*open import Sail2_instr_kinds*)
(*open import Sail2_values*)
(*open import Sail2_string*)
(*open import Sail2_operators_mwords*)
(*open import Sail2_prompt_monad*)
(*open import Sail2_prompt*)
(*open import Aarch64_types*)
(*open import Aarch64_extras*)

(*val eq_unit : unit -> unit -> bool*)

definition eq_unit  :: " unit \<Rightarrow> unit \<Rightarrow> bool "  where 
     " eq_unit g__306 g__307 = ( True )"








(*val neq_bool : bool -> bool -> bool*)

definition neq_bool  :: " bool \<Rightarrow> bool \<Rightarrow> bool "  where 
     " neq_bool x y = ( \<not> (((x = y))))"


(*val vcons : forall  'a. 'a -> list 'a -> list 'a*)





(*val builtin_and_vec : forall 'n. bits 'n -> bits 'n -> bits 'n*)



(*val builtin_or_vec : forall 'n. bits 'n -> bits 'n -> bits 'n*)



(*val __raw_SetSlice_int : forall 'w. integer -> ii -> ii -> bits 'w -> ii*)

(*val __GetSlice_int : forall 'n. Size 'n => itself 'n -> ii -> ii -> mword 'n*)

definition GetSlice_int  :: "('n::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('n::len)Word.word "  where 
     " GetSlice_int n m o1 = (
   (let n = (size_itself_int n) in
   (get_slice_int n m o1  :: ( 'n::len)Word.word)))"


(*val __raw_SetSlice_bits : forall 'n 'w. integer -> integer -> bits 'n -> ii -> bits 'w -> bits 'n*)

(*val __raw_GetSlice_bits : forall 'n 'w. integer -> integer -> bits 'n -> ii -> bits 'w*)

(*val cast_unit_vec : bitU -> mword ty1*)

fun cast_unit_vec0  :: " bitU \<Rightarrow>(1)Word.word "  where 
     " cast_unit_vec0 B0 = ( (vec_of_bits [B0]  ::  1 Word.word))"
|" cast_unit_vec0 B1 = ( (vec_of_bits [B1]  ::  1 Word.word))"


(*val BoolStr : bool -> string*)

definition BoolStr  :: " bool \<Rightarrow> string "  where 
     " BoolStr b = ( if b then (''true'') else (''false''))"


(*val ex_nat : ii -> integer*)

definition ex_nat  :: " int \<Rightarrow> int "  where 
     " ex_nat n = ( n )"


(*val ex_int : ii -> integer*)

definition ex_int  :: " int \<Rightarrow> int "  where 
     " ex_int n = ( n )"


(*val ex_range : integer -> integer*)

(*val coerce_int_nat : ii -> M ii*)

definition coerce_int_nat  :: " int \<Rightarrow>((register_value),(int),(exception))monad "  where 
     " coerce_int_nat x = ( assert_exp True (''Cannot coerce int to nat'') \<then> return x )"


(*val break : unit -> unit*)

definition break  :: " unit \<Rightarrow> unit "  where 
     " break _ = ( ()  )"


(*val undefined_exception : unit -> M exception*)

definition undefined_exception  :: " unit \<Rightarrow>((register_value),(exception),(exception))monad "  where 
     " undefined_exception _ = (
   undefined_string ()  \<bind> (\<lambda> (u_0 :: string) . 
   undefined_unit ()  \<bind> (\<lambda> (u_1 :: unit) . 
   internal_pick
     [Error_Undefined u_1,Error_See u_0,Error_Implementation_Defined u_0,Error_ReservedEncoding u_1,Error_ExceptionTaken u_1])))"


(*val __GetVerbosity : unit -> M (bits ty64)*)

(*val get_cycle_count : unit -> M ii*)

(*val __InitRAM : forall 'm. Size 'm => integer -> ii -> mword 'm -> mword ty8 -> unit*)

definition InitRAM  :: " int \<Rightarrow> int \<Rightarrow>('m::len)Word.word \<Rightarrow>(8)Word.word \<Rightarrow> unit "  where 
     " InitRAM g__302 g__303 g__304 g__305 = ( ()  )"


(*val __ReadRAM : forall  'm 'p8_times_n_ . Size 'm, Size 'p8_times_n_ => itself 'm -> integer -> mword 'm -> mword 'm -> M (mword 'p8_times_n_)*)

definition ReadRAM  :: "('m::len)itself \<Rightarrow> int \<Rightarrow>('m::len)Word.word \<Rightarrow>('m::len)Word.word \<Rightarrow>((register_value),(('p8_times_n_::len)Word.word),(exception))monad "  where 
     " ReadRAM addr_length bytes hex_ram addr = (
   (let addr_length = (size_itself_int addr_length) in
   (read_ram addr_length bytes hex_ram addr  :: (( 'p8_times_n_::len)Word.word) M)))"


(*val __TraceMemoryWrite : forall  'm 'p8_times_n_ . Size 'm, Size 'p8_times_n_ => integer -> mword 'm -> mword 'p8_times_n_ -> unit*)

(*val __WriteRAM : forall  'm 'p8_times_n_ . Size 'm, Size 'p8_times_n_ => itself 'm -> integer -> mword 'm -> mword 'm -> mword 'p8_times_n_ -> M unit*)

definition WriteRAM  :: "('m::len)itself \<Rightarrow> int \<Rightarrow>('m::len)Word.word \<Rightarrow>('m::len)Word.word \<Rightarrow>('p8_times_n_::len)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " WriteRAM addr_length bytes hex_ram addr data = (
   (let addr_length = (size_itself_int addr_length) in
   write_ram addr_length bytes hex_ram addr data \<then> return () ))"


definition TraceMemoryWrite  :: " int \<Rightarrow>('m::len)Word.word \<Rightarrow>('p8_times_n_::len)Word.word \<Rightarrow> unit "  where 
     " TraceMemoryWrite bytes addr data = ( ()  )"


(*val __TraceMemoryRead : forall  'm 'p8_times_n_ . Size 'm, Size 'p8_times_n_ => integer -> mword 'm -> mword 'p8_times_n_ -> unit*)

definition TraceMemoryRead  :: " int \<Rightarrow>('m::len)Word.word \<Rightarrow>('p8_times_n_::len)Word.word \<Rightarrow> unit "  where 
     " TraceMemoryRead bytes addr data = ( ()  )"


(*val extzv : forall 'n 'm. Size 'm, Size 'n => integer -> mword 'n -> mword 'm*)

definition extzv  :: " int \<Rightarrow>('n::len)Word.word \<Rightarrow>('m::len)Word.word "  where 
     " extzv (m__tv :: int) v = ( (extz_vec m__tv v  :: ( 'm::len)Word.word))"


(*val extsv : forall 'n 'm. Size 'm, Size 'n => integer -> mword 'n -> mword 'm*)

definition extsv  :: " int \<Rightarrow>('n::len)Word.word \<Rightarrow>('m::len)Word.word "  where 
     " extsv (m__tv :: int) v = ( (exts_vec m__tv v  :: ( 'm::len)Word.word))"


(*val slice_mask : forall 'n . Size 'n => integer -> ii -> ii -> mword 'n*)

definition slice_mask  :: " int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('n::len)Word.word "  where 
     " slice_mask (n__tv :: int) i l = (
   (let one = ((extzv n__tv (vec_of_bits [B1]  ::  1 Word.word)  :: ( 'n::len)Word.word)) in
   (shiftl ((sub_vec ((shiftl one l  :: ( 'n::len)Word.word)) one  :: ( 'n::len)Word.word)) i  :: ( 'n::len)Word.word)))"


(*val is_zero_subrange : forall 'n . Size 'n => mword 'n -> ii -> ii -> bool*)

definition is_zero_subrange  :: "('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool "  where 
     " is_zero_subrange xs i j = (
   (((and_vec xs
         ((slice_mask ((int (size xs))) j ((((i - j)) + (( 1 :: int)::ii)))  :: ( 'n::len)Word.word))
        :: ( 'n::len)Word.word)) = ((extzv ((int (size xs))) (vec_of_bits [B0]  ::  1 Word.word)  :: ( 'n::len)Word.word))))"


(*val is_ones_subrange : forall 'n . Size 'n => mword 'n -> ii -> ii -> bool*)

definition is_ones_subrange  :: "('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool "  where 
     " is_ones_subrange xs i j = (
   (let m = ((slice_mask ((int (size xs))) j ((((j - i)) + (( 1 :: int)::ii)))  :: ( 'n::len)Word.word)) in
   (((and_vec xs m  :: ( 'n::len)Word.word)) = m)))"


(*val slice_slice_concat : forall 'n 'm 'r . Size 'm, Size 'n, Size 'r => integer -> mword 'n -> ii -> ii -> mword 'm -> ii -> ii -> mword 'r*)

definition slice_slice_concat  :: " int \<Rightarrow>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('m::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('r::len)Word.word "  where 
     " slice_slice_concat (r__tv :: int) xs i l ys i' l' = (
   (let xs =
     ((shiftr ((and_vec xs ((slice_mask ((int (size xs))) i l  :: ( 'n::len)Word.word))  :: ( 'n::len)Word.word)) i  :: ( 'n::len)Word.word)) in
   (let ys =
     ((shiftr ((and_vec ys ((slice_mask ((int (size ys))) i' l'  :: ( 'm::len)Word.word))  :: ( 'm::len)Word.word)) i'
       :: ( 'm::len)Word.word)) in
   (or_vec ((shiftl ((extzv r__tv xs  :: ( 'r::len)Word.word)) l'  :: ( 'r::len)Word.word)) ((extzv r__tv ys  :: ( 'r::len)Word.word))
     :: ( 'r::len)Word.word))))"


(*val slice_zeros_concat : forall 'n   'r . Size 'n, Size 'r => integer -> mword 'n -> ii -> integer -> integer -> mword 'r*)

definition slice_zeros_concat  :: " int \<Rightarrow>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('r::len)Word.word "  where 
     " slice_zeros_concat (r__tv :: int) xs i l l' = (
   (let xs =
     ((shiftr ((and_vec xs ((slice_mask ((int (size xs))) i l  :: ( 'n::len)Word.word))  :: ( 'n::len)Word.word)) i  :: ( 'n::len)Word.word)) in
   (shiftl ((extzv r__tv xs  :: ( 'r::len)Word.word)) l'  :: ( 'r::len)Word.word)))"


(*val subrange_subrange_eq : forall 'n . Size 'n => mword 'n -> ii -> ii -> mword 'n -> ii -> ii -> bool*)

definition subrange_subrange_eq  :: "('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool "  where 
     " subrange_subrange_eq xs i j ys i' j' = (
   (let xs =
     ((shiftr
        ((and_vec xs
            ((slice_mask ((int (size xs))) j ((((i - j)) + (( 1 :: int)::ii)))  :: ( 'n::len)Word.word))
           :: ( 'n::len)Word.word)) j
       :: ( 'n::len)Word.word)) in
   (let ys =
     ((shiftr
        ((and_vec ys
            ((slice_mask ((int (size xs))) j' ((((i' - j')) + (( 1 :: int)::ii)))  :: ( 'n::len)Word.word))
           :: ( 'n::len)Word.word)) j'
       :: ( 'n::len)Word.word)) in
   (xs = ys))))"


(*val subrange_subrange_concat : forall 'n   'm   's . Size 'm, Size 'n, Size 's => integer -> mword 'n -> integer -> integer -> mword 'm -> integer -> integer -> mword 's*)

definition subrange_subrange_concat  :: " int \<Rightarrow>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('m::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('s::len)Word.word "  where 
     " subrange_subrange_concat (s__tv :: int) xs i j ys i' j' = (
   (let xs =
     ((shiftr
        ((and_vec xs
            ((slice_mask ((int (size xs))) j ((((i - j)) + (( 1 :: int)::ii)))  :: ( 'n::len)Word.word))
           :: ( 'n::len)Word.word)) j
       :: ( 'n::len)Word.word)) in
   (let ys =
     ((shiftr
        ((and_vec ys
            ((slice_mask ((int (size ys))) j' ((((i' - j')) + (( 1 :: int)::ii)))  :: ( 'm::len)Word.word))
           :: ( 'm::len)Word.word)) j'
       :: ( 'm::len)Word.word)) in
   (or_vec
      ((shiftl ((extzv s__tv xs  :: ( 's::len)Word.word)) ((((i' - j')) + (( 1 :: int)::ii)))
         :: ( 's::len)Word.word)) ((extzv s__tv ys  :: ( 's::len)Word.word))
     :: ( 's::len)Word.word))))"


(*val place_subrange : forall 'n 'm . Size 'm, Size 'n => integer -> mword 'n -> ii -> ii -> ii -> mword 'm*)

definition place_subrange  :: " int \<Rightarrow>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('m::len)Word.word "  where 
     " place_subrange (m__tv :: int) xs i j shift = (
   (let xs =
     ((shiftr
        ((and_vec xs
            ((slice_mask ((int (size xs))) j ((((i - j)) + (( 1 :: int)::ii)))  :: ( 'n::len)Word.word))
           :: ( 'n::len)Word.word)) j
       :: ( 'n::len)Word.word)) in
   (shiftl ((extzv m__tv xs  :: ( 'm::len)Word.word)) shift  :: ( 'm::len)Word.word)))"


(*val place_slice : forall 'n 'm . Size 'm, Size 'n => integer -> mword 'n -> ii -> ii -> ii -> mword 'm*)

definition place_slice  :: " int \<Rightarrow>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('m::len)Word.word "  where 
     " place_slice (m__tv :: int) xs i l shift = (
   (let xs =
     ((shiftr ((and_vec xs ((slice_mask ((int (size xs))) i l  :: ( 'n::len)Word.word))  :: ( 'n::len)Word.word)) i  :: ( 'n::len)Word.word)) in
   (shiftl ((extzv m__tv xs  :: ( 'm::len)Word.word)) shift  :: ( 'm::len)Word.word)))"


(*val zext_slice : forall 'n 'm . Size 'm, Size 'n => integer -> mword 'n -> ii -> ii -> mword 'm*)

definition zext_slice  :: " int \<Rightarrow>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('m::len)Word.word "  where 
     " zext_slice (m__tv :: int) xs i l = (
   (let xs =
     ((shiftr ((and_vec xs ((slice_mask ((int (size xs))) i l  :: ( 'n::len)Word.word))  :: ( 'n::len)Word.word)) i  :: ( 'n::len)Word.word)) in
   (extzv m__tv xs  :: ( 'm::len)Word.word)))"


(*val sext_slice : forall 'n 'm . Size 'm, Size 'n => integer -> mword 'n -> ii -> ii -> mword 'm*)

definition sext_slice  :: " int \<Rightarrow>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('m::len)Word.word "  where 
     " sext_slice (m__tv :: int) xs i l = (
   (let xs =
     ((arith_shiftr
        ((shiftl ((and_vec xs ((slice_mask ((int (size xs))) i l  :: ( 'n::len)Word.word))  :: ( 'n::len)Word.word))
            ((((((int (size xs))) - i)) - l))
           :: ( 'n::len)Word.word)) ((((int (size xs))) - l))
       :: ( 'n::len)Word.word)) in
   (extsv m__tv xs  :: ( 'm::len)Word.word)))"


(*val unsigned_slice : forall 'n . Size 'n => mword 'n -> ii -> ii -> ii*)

definition unsigned_slice  :: "('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int "  where 
     " unsigned_slice xs i l = (
   (let xs =
     ((shiftr ((and_vec xs ((slice_mask ((int (size xs))) i l  :: ( 'n::len)Word.word))  :: ( 'n::len)Word.word)) i  :: ( 'n::len)Word.word)) in
   Word.uint xs))"


(*val unsigned_subrange : forall 'n . Size 'n => mword 'n -> ii -> ii -> ii*)

definition unsigned_subrange  :: "('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int "  where 
     " unsigned_subrange xs i j = (
   (let xs =
     ((shiftr
        ((and_vec xs
            ((slice_mask ((int (size xs))) j ((((i - j)) + (( 1 :: int)::ii)))  :: ( 'n::len)Word.word))
           :: ( 'n::len)Word.word)) i
       :: ( 'n::len)Word.word)) in
   Word.uint xs))"


(*val zext_ones : forall 'n . Size 'n => integer -> ii -> mword 'n*)

definition zext_ones  :: " int \<Rightarrow> int \<Rightarrow>('n::len)Word.word "  where 
     " zext_ones (n__tv :: int) m = (
   (let v = ((extsv n__tv (vec_of_bits [B1]  ::  1 Word.word)  :: ( 'n::len)Word.word)) in
   (shiftr v ((((int (size v))) - m))  :: ( 'n::len)Word.word)))"


(*val boolean_of_num : integer -> boolean*)

definition boolean_of_num  :: " int \<Rightarrow> boolean "  where 
     " boolean_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then FALSE
   else TRUE))"


(*val num_of_boolean : boolean -> integer*)

fun num_of_boolean  :: " boolean \<Rightarrow> int "  where 
     " num_of_boolean FALSE = ( (( 0 :: int)::ii))"
|" num_of_boolean TRUE = ( (( 1 :: int)::ii))"


(*val undefined_boolean : unit -> M boolean*)

definition undefined_boolean  :: " unit \<Rightarrow>((register_value),(boolean),(exception))monad "  where 
     " undefined_boolean _ = ( internal_pick [FALSE,TRUE])"


(*val signal_of_num : integer -> signal*)

definition signal_of_num  :: " int \<Rightarrow> signal "  where 
     " signal_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then LOW
   else HIGH))"


(*val num_of_signal : signal -> integer*)

fun num_of_signal  :: " signal \<Rightarrow> int "  where 
     " num_of_signal LOW = ( (( 0 :: int)::ii))"
|" num_of_signal HIGH = ( (( 1 :: int)::ii))"


(*val undefined_signal : unit -> M signal*)

definition undefined_signal  :: " unit \<Rightarrow>((register_value),(signal),(exception))monad "  where 
     " undefined_signal _ = ( internal_pick [LOW,HIGH])"


(*val __RetCode_of_num : integer -> __RetCode*)

definition RetCode_of_num  :: " int \<Rightarrow> RetCode "  where 
     " RetCode_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then RC_OK
   else if (((p00 = (( 1 :: int)::ii)))) then RC_UNDEFINED
   else if (((p00 = (( 2 :: int)::ii)))) then RC_UNPREDICTABLE
   else if (((p00 = (( 3 :: int)::ii)))) then RC_SEE
   else if (((p00 = (( 4 :: int)::ii)))) then RC_IMPLEMENTATION_DEFINED
   else if (((p00 = (( 5 :: int)::ii)))) then RC_SUBARCHITECTURE_DEFINED
   else if (((p00 = (( 6 :: int)::ii)))) then RC_EXCEPTION_TAKEN
   else if (((p00 = (( 7 :: int)::ii)))) then RC_ASSERT_FAILED
   else RC_UNMATCHED_CASE))"


(*val num_of___RetCode : __RetCode -> integer*)

fun num_of___RetCode  :: " RetCode \<Rightarrow> int "  where 
     " num_of___RetCode RC_OK = ( (( 0 :: int)::ii))"
|" num_of___RetCode RC_UNDEFINED = ( (( 1 :: int)::ii))"
|" num_of___RetCode RC_UNPREDICTABLE = ( (( 2 :: int)::ii))"
|" num_of___RetCode RC_SEE = ( (( 3 :: int)::ii))"
|" num_of___RetCode RC_IMPLEMENTATION_DEFINED = ( (( 4 :: int)::ii))"
|" num_of___RetCode RC_SUBARCHITECTURE_DEFINED = ( (( 5 :: int)::ii))"
|" num_of___RetCode RC_EXCEPTION_TAKEN = ( (( 6 :: int)::ii))"
|" num_of___RetCode RC_ASSERT_FAILED = ( (( 7 :: int)::ii))"
|" num_of___RetCode RC_UNMATCHED_CASE = ( (( 8 :: int)::ii))"


(*val undefined___RetCode : unit -> M __RetCode*)

definition undefined___RetCode  :: " unit \<Rightarrow>((register_value),(RetCode),(exception))monad "  where 
     " undefined___RetCode _ = (
   internal_pick
     [RC_OK,RC_UNDEFINED,RC_UNPREDICTABLE,RC_SEE,RC_IMPLEMENTATION_DEFINED,RC_SUBARCHITECTURE_DEFINED,RC_EXCEPTION_TAKEN,RC_ASSERT_FAILED,RC_UNMATCHED_CASE])"


(*val FPConvOp_of_num : integer -> FPConvOp*)

definition FPConvOp_of_num  :: " int \<Rightarrow> FPConvOp "  where 
     " FPConvOp_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then FPConvOp_CVT_FtoI
   else if (((p00 = (( 1 :: int)::ii)))) then FPConvOp_CVT_ItoF
   else if (((p00 = (( 2 :: int)::ii)))) then FPConvOp_MOV_FtoI
   else if (((p00 = (( 3 :: int)::ii)))) then FPConvOp_MOV_ItoF
   else FPConvOp_CVT_FtoI_JS))"


(*val num_of_FPConvOp : FPConvOp -> integer*)

fun num_of_FPConvOp  :: " FPConvOp \<Rightarrow> int "  where 
     " num_of_FPConvOp FPConvOp_CVT_FtoI = ( (( 0 :: int)::ii))"
|" num_of_FPConvOp FPConvOp_CVT_ItoF = ( (( 1 :: int)::ii))"
|" num_of_FPConvOp FPConvOp_MOV_FtoI = ( (( 2 :: int)::ii))"
|" num_of_FPConvOp FPConvOp_MOV_ItoF = ( (( 3 :: int)::ii))"
|" num_of_FPConvOp FPConvOp_CVT_FtoI_JS = ( (( 4 :: int)::ii))"


(*val undefined_FPConvOp : unit -> M FPConvOp*)

definition undefined_FPConvOp  :: " unit \<Rightarrow>((register_value),(FPConvOp),(exception))monad "  where 
     " undefined_FPConvOp _ = (
   internal_pick
     [FPConvOp_CVT_FtoI,FPConvOp_CVT_ItoF,FPConvOp_MOV_FtoI,FPConvOp_MOV_ItoF,FPConvOp_CVT_FtoI_JS])"


(*val Exception_of_num : integer -> Exception*)

definition Exception_of_num  :: " int \<Rightarrow> Exception "  where 
     " Exception_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then Exception_Uncategorized
   else if (((p00 = (( 1 :: int)::ii)))) then Exception_WFxTrap
   else if (((p00 = (( 2 :: int)::ii)))) then Exception_CP15RTTrap
   else if (((p00 = (( 3 :: int)::ii)))) then Exception_CP15RRTTrap
   else if (((p00 = (( 4 :: int)::ii)))) then Exception_CP14RTTrap
   else if (((p00 = (( 5 :: int)::ii)))) then Exception_CP14DTTrap
   else if (((p00 = (( 6 :: int)::ii)))) then Exception_AdvSIMDFPAccessTrap
   else if (((p00 = (( 7 :: int)::ii)))) then Exception_FPIDTrap
   else if (((p00 = (( 8 :: int)::ii)))) then Exception_PACTrap
   else if (((p00 = (( 9 :: int)::ii)))) then Exception_CP14RRTTrap
   else if (((p00 = (( 10 :: int)::ii)))) then Exception_IllegalState
   else if (((p00 = (( 11 :: int)::ii)))) then Exception_SupervisorCall
   else if (((p00 = (( 12 :: int)::ii)))) then Exception_HypervisorCall
   else if (((p00 = (( 13 :: int)::ii)))) then Exception_MonitorCall
   else if (((p00 = (( 14 :: int)::ii)))) then Exception_SystemRegisterTrap
   else if (((p00 = (( 15 :: int)::ii)))) then Exception_ERetTrap
   else if (((p00 = (( 16 :: int)::ii)))) then Exception_InstructionAbort
   else if (((p00 = (( 17 :: int)::ii)))) then Exception_PCAlignment
   else if (((p00 = (( 18 :: int)::ii)))) then Exception_DataAbort
   else if (((p00 = (( 19 :: int)::ii)))) then Exception_SPAlignment
   else if (((p00 = (( 20 :: int)::ii)))) then Exception_FPTrappedException
   else if (((p00 = (( 21 :: int)::ii)))) then Exception_SError
   else if (((p00 = (( 22 :: int)::ii)))) then Exception_Breakpoint
   else if (((p00 = (( 23 :: int)::ii)))) then Exception_SoftwareStep
   else if (((p00 = (( 24 :: int)::ii)))) then Exception_Watchpoint
   else if (((p00 = (( 25 :: int)::ii)))) then Exception_SoftwareBreakpoint
   else if (((p00 = (( 26 :: int)::ii)))) then Exception_VectorCatch
   else if (((p00 = (( 27 :: int)::ii)))) then Exception_IRQ
   else Exception_FIQ))"


(*val num_of_Exception : Exception -> integer*)

fun num_of_Exception  :: " Exception \<Rightarrow> int "  where 
     " num_of_Exception Exception_Uncategorized = ( (( 0 :: int)::ii))"
|" num_of_Exception Exception_WFxTrap = ( (( 1 :: int)::ii))"
|" num_of_Exception Exception_CP15RTTrap = ( (( 2 :: int)::ii))"
|" num_of_Exception Exception_CP15RRTTrap = ( (( 3 :: int)::ii))"
|" num_of_Exception Exception_CP14RTTrap = ( (( 4 :: int)::ii))"
|" num_of_Exception Exception_CP14DTTrap = ( (( 5 :: int)::ii))"
|" num_of_Exception Exception_AdvSIMDFPAccessTrap = ( (( 6 :: int)::ii))"
|" num_of_Exception Exception_FPIDTrap = ( (( 7 :: int)::ii))"
|" num_of_Exception Exception_PACTrap = ( (( 8 :: int)::ii))"
|" num_of_Exception Exception_CP14RRTTrap = ( (( 9 :: int)::ii))"
|" num_of_Exception Exception_IllegalState = ( (( 10 :: int)::ii))"
|" num_of_Exception Exception_SupervisorCall = ( (( 11 :: int)::ii))"
|" num_of_Exception Exception_HypervisorCall = ( (( 12 :: int)::ii))"
|" num_of_Exception Exception_MonitorCall = ( (( 13 :: int)::ii))"
|" num_of_Exception Exception_SystemRegisterTrap = ( (( 14 :: int)::ii))"
|" num_of_Exception Exception_ERetTrap = ( (( 15 :: int)::ii))"
|" num_of_Exception Exception_InstructionAbort = ( (( 16 :: int)::ii))"
|" num_of_Exception Exception_PCAlignment = ( (( 17 :: int)::ii))"
|" num_of_Exception Exception_DataAbort = ( (( 18 :: int)::ii))"
|" num_of_Exception Exception_SPAlignment = ( (( 19 :: int)::ii))"
|" num_of_Exception Exception_FPTrappedException = ( (( 20 :: int)::ii))"
|" num_of_Exception Exception_SError = ( (( 21 :: int)::ii))"
|" num_of_Exception Exception_Breakpoint = ( (( 22 :: int)::ii))"
|" num_of_Exception Exception_SoftwareStep = ( (( 23 :: int)::ii))"
|" num_of_Exception Exception_Watchpoint = ( (( 24 :: int)::ii))"
|" num_of_Exception Exception_SoftwareBreakpoint = ( (( 25 :: int)::ii))"
|" num_of_Exception Exception_VectorCatch = ( (( 26 :: int)::ii))"
|" num_of_Exception Exception_IRQ = ( (( 27 :: int)::ii))"
|" num_of_Exception Exception_FIQ = ( (( 28 :: int)::ii))"


(*val undefined_Exception : unit -> M Exception*)

definition undefined_Exception  :: " unit \<Rightarrow>((register_value),(Exception),(exception))monad "  where 
     " undefined_Exception _ = (
   internal_pick
     [Exception_Uncategorized,Exception_WFxTrap,Exception_CP15RTTrap,Exception_CP15RRTTrap,Exception_CP14RTTrap,Exception_CP14DTTrap,Exception_AdvSIMDFPAccessTrap,Exception_FPIDTrap,Exception_PACTrap,Exception_CP14RRTTrap,Exception_IllegalState,Exception_SupervisorCall,Exception_HypervisorCall,Exception_MonitorCall,Exception_SystemRegisterTrap,Exception_ERetTrap,Exception_InstructionAbort,Exception_PCAlignment,Exception_DataAbort,Exception_SPAlignment,Exception_FPTrappedException,Exception_SError,Exception_Breakpoint,Exception_SoftwareStep,Exception_Watchpoint,Exception_SoftwareBreakpoint,Exception_VectorCatch,Exception_IRQ,Exception_FIQ])"


(*val ArchVersion_of_num : integer -> ArchVersion*)

definition ArchVersion_of_num  :: " int \<Rightarrow> ArchVersion "  where 
     " ArchVersion_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then ARMv8p0
   else if (((p00 = (( 1 :: int)::ii)))) then ARMv8p1
   else if (((p00 = (( 2 :: int)::ii)))) then ARMv8p2
   else ARMv8p3))"


(*val num_of_ArchVersion : ArchVersion -> integer*)

fun num_of_ArchVersion  :: " ArchVersion \<Rightarrow> int "  where 
     " num_of_ArchVersion ARMv8p0 = ( (( 0 :: int)::ii))"
|" num_of_ArchVersion ARMv8p1 = ( (( 1 :: int)::ii))"
|" num_of_ArchVersion ARMv8p2 = ( (( 2 :: int)::ii))"
|" num_of_ArchVersion ARMv8p3 = ( (( 3 :: int)::ii))"


(*val undefined_ArchVersion : unit -> M ArchVersion*)

definition undefined_ArchVersion  :: " unit \<Rightarrow>((register_value),(ArchVersion),(exception))monad "  where 
     " undefined_ArchVersion _ = ( internal_pick [ARMv8p0,ARMv8p1,ARMv8p2,ARMv8p3])"


(*val Unpredictable_of_num : integer -> Unpredictable*)

definition Unpredictable_of_num  :: " int \<Rightarrow> Unpredictable "  where 
     " Unpredictable_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then Unpredictable_WBOVERLAPLD
   else if (((p00 = (( 1 :: int)::ii)))) then Unpredictable_WBOVERLAPST
   else if (((p00 = (( 2 :: int)::ii)))) then Unpredictable_LDPOVERLAP
   else if (((p00 = (( 3 :: int)::ii)))) then Unpredictable_BASEOVERLAP
   else if (((p00 = (( 4 :: int)::ii)))) then Unpredictable_DATAOVERLAP
   else if (((p00 = (( 5 :: int)::ii)))) then Unpredictable_DEVPAGE2
   else if (((p00 = (( 6 :: int)::ii)))) then Unpredictable_INSTRDEVICE
   else if (((p00 = (( 7 :: int)::ii)))) then Unpredictable_RESCPACR
   else if (((p00 = (( 8 :: int)::ii)))) then Unpredictable_RESMAIR
   else if (((p00 = (( 9 :: int)::ii)))) then Unpredictable_RESTEXCB
   else if (((p00 = (( 10 :: int)::ii)))) then Unpredictable_RESPRRR
   else if (((p00 = (( 11 :: int)::ii)))) then Unpredictable_RESDACR
   else if (((p00 = (( 12 :: int)::ii)))) then Unpredictable_RESVTCRS
   else if (((p00 = (( 13 :: int)::ii)))) then Unpredictable_RESTnSZ
   else if (((p00 = (( 14 :: int)::ii)))) then Unpredictable_OORTnSZ
   else if (((p00 = (( 15 :: int)::ii)))) then Unpredictable_LARGEIPA
   else if (((p00 = (( 16 :: int)::ii)))) then Unpredictable_ESRCONDPASS
   else if (((p00 = (( 17 :: int)::ii)))) then Unpredictable_ILZEROIT
   else if (((p00 = (( 18 :: int)::ii)))) then Unpredictable_ILZEROT
   else if (((p00 = (( 19 :: int)::ii)))) then Unpredictable_BPVECTORCATCHPRI
   else if (((p00 = (( 20 :: int)::ii)))) then Unpredictable_VCMATCHHALF
   else if (((p00 = (( 21 :: int)::ii)))) then Unpredictable_VCMATCHDAPA
   else if (((p00 = (( 22 :: int)::ii)))) then Unpredictable_WPMASKANDBAS
   else if (((p00 = (( 23 :: int)::ii)))) then Unpredictable_WPBASCONTIGUOUS
   else if (((p00 = (( 24 :: int)::ii)))) then Unpredictable_RESWPMASK
   else if (((p00 = (( 25 :: int)::ii)))) then Unpredictable_WPMASKEDBITS
   else if (((p00 = (( 26 :: int)::ii)))) then Unpredictable_RESBPWPCTRL
   else if (((p00 = (( 27 :: int)::ii)))) then Unpredictable_BPNOTIMPL
   else if (((p00 = (( 28 :: int)::ii)))) then Unpredictable_RESBPTYPE
   else if (((p00 = (( 29 :: int)::ii)))) then Unpredictable_BPNOTCTXCMP
   else if (((p00 = (( 30 :: int)::ii)))) then Unpredictable_BPMATCHHALF
   else if (((p00 = (( 31 :: int)::ii)))) then Unpredictable_BPMISMATCHHALF
   else if (((p00 = (( 32 :: int)::ii)))) then Unpredictable_RESTARTALIGNPC
   else if (((p00 = (( 33 :: int)::ii)))) then Unpredictable_RESTARTZEROUPPERPC
   else if (((p00 = (( 34 :: int)::ii)))) then Unpredictable_ZEROUPPER
   else if (((p00 = (( 35 :: int)::ii)))) then Unpredictable_ERETZEROUPPERPC
   else if (((p00 = (( 36 :: int)::ii)))) then Unpredictable_A32FORCEALIGNPC
   else if (((p00 = (( 37 :: int)::ii)))) then Unpredictable_SMD
   else if (((p00 = (( 38 :: int)::ii)))) then Unpredictable_AFUPDATE
   else if (((p00 = (( 39 :: int)::ii)))) then Unpredictable_IESBinDebug
   else if (((p00 = (( 40 :: int)::ii)))) then Unpredictable_ZEROPMSEVFR
   else if (((p00 = (( 41 :: int)::ii)))) then Unpredictable_NOOPTYPES
   else if (((p00 = (( 42 :: int)::ii)))) then Unpredictable_ZEROMINLATENCY
   else if (((p00 = (( 43 :: int)::ii)))) then Unpredictable_CLEARERRITEZERO
   else Unpredictable_TBD))"


(*val num_of_Unpredictable : Unpredictable -> integer*)

fun num_of_Unpredictable  :: " Unpredictable \<Rightarrow> int "  where 
     " num_of_Unpredictable Unpredictable_WBOVERLAPLD = ( (( 0 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_WBOVERLAPST = ( (( 1 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_LDPOVERLAP = ( (( 2 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_BASEOVERLAP = ( (( 3 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_DATAOVERLAP = ( (( 4 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_DEVPAGE2 = ( (( 5 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_INSTRDEVICE = ( (( 6 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_RESCPACR = ( (( 7 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_RESMAIR = ( (( 8 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_RESTEXCB = ( (( 9 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_RESPRRR = ( (( 10 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_RESDACR = ( (( 11 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_RESVTCRS = ( (( 12 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_RESTnSZ = ( (( 13 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_OORTnSZ = ( (( 14 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_LARGEIPA = ( (( 15 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_ESRCONDPASS = ( (( 16 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_ILZEROIT = ( (( 17 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_ILZEROT = ( (( 18 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_BPVECTORCATCHPRI = ( (( 19 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_VCMATCHHALF = ( (( 20 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_VCMATCHDAPA = ( (( 21 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_WPMASKANDBAS = ( (( 22 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_WPBASCONTIGUOUS = ( (( 23 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_RESWPMASK = ( (( 24 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_WPMASKEDBITS = ( (( 25 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_RESBPWPCTRL = ( (( 26 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_BPNOTIMPL = ( (( 27 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_RESBPTYPE = ( (( 28 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_BPNOTCTXCMP = ( (( 29 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_BPMATCHHALF = ( (( 30 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_BPMISMATCHHALF = ( (( 31 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_RESTARTALIGNPC = ( (( 32 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_RESTARTZEROUPPERPC = ( (( 33 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_ZEROUPPER = ( (( 34 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_ERETZEROUPPERPC = ( (( 35 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_A32FORCEALIGNPC = ( (( 36 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_SMD = ( (( 37 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_AFUPDATE = ( (( 38 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_IESBinDebug = ( (( 39 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_ZEROPMSEVFR = ( (( 40 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_NOOPTYPES = ( (( 41 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_ZEROMINLATENCY = ( (( 42 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_CLEARERRITEZERO = ( (( 43 :: int)::ii))"
|" num_of_Unpredictable Unpredictable_TBD = ( (( 44 :: int)::ii))"


(*val undefined_Unpredictable : unit -> M Unpredictable*)

definition undefined_Unpredictable  :: " unit \<Rightarrow>((register_value),(Unpredictable),(exception))monad "  where 
     " undefined_Unpredictable _ = (
   internal_pick
     [Unpredictable_WBOVERLAPLD,Unpredictable_WBOVERLAPST,Unpredictable_LDPOVERLAP,Unpredictable_BASEOVERLAP,Unpredictable_DATAOVERLAP,Unpredictable_DEVPAGE2,Unpredictable_INSTRDEVICE,Unpredictable_RESCPACR,Unpredictable_RESMAIR,Unpredictable_RESTEXCB,Unpredictable_RESPRRR,Unpredictable_RESDACR,Unpredictable_RESVTCRS,Unpredictable_RESTnSZ,Unpredictable_OORTnSZ,Unpredictable_LARGEIPA,Unpredictable_ESRCONDPASS,Unpredictable_ILZEROIT,Unpredictable_ILZEROT,Unpredictable_BPVECTORCATCHPRI,Unpredictable_VCMATCHHALF,Unpredictable_VCMATCHDAPA,Unpredictable_WPMASKANDBAS,Unpredictable_WPBASCONTIGUOUS,Unpredictable_RESWPMASK,Unpredictable_WPMASKEDBITS,Unpredictable_RESBPWPCTRL,Unpredictable_BPNOTIMPL,Unpredictable_RESBPTYPE,Unpredictable_BPNOTCTXCMP,Unpredictable_BPMATCHHALF,Unpredictable_BPMISMATCHHALF,Unpredictable_RESTARTALIGNPC,Unpredictable_RESTARTZEROUPPERPC,Unpredictable_ZEROUPPER,Unpredictable_ERETZEROUPPERPC,Unpredictable_A32FORCEALIGNPC,Unpredictable_SMD,Unpredictable_AFUPDATE,Unpredictable_IESBinDebug,Unpredictable_ZEROPMSEVFR,Unpredictable_NOOPTYPES,Unpredictable_ZEROMINLATENCY,Unpredictable_CLEARERRITEZERO,Unpredictable_TBD])"


(*val Constraint_of_num : integer -> Constraint*)

definition Constraint_of_num  :: " int \<Rightarrow> Constraint "  where 
     " Constraint_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then Constraint_NONE
   else if (((p00 = (( 1 :: int)::ii)))) then Constraint_UNKNOWN
   else if (((p00 = (( 2 :: int)::ii)))) then Constraint_UNDEF
   else if (((p00 = (( 3 :: int)::ii)))) then Constraint_UNDEFEL0
   else if (((p00 = (( 4 :: int)::ii)))) then Constraint_NOP
   else if (((p00 = (( 5 :: int)::ii)))) then Constraint_TRUE
   else if (((p00 = (( 6 :: int)::ii)))) then Constraint_FALSE
   else if (((p00 = (( 7 :: int)::ii)))) then Constraint_DISABLED
   else if (((p00 = (( 8 :: int)::ii)))) then Constraint_UNCOND
   else if (((p00 = (( 9 :: int)::ii)))) then Constraint_COND
   else if (((p00 = (( 10 :: int)::ii)))) then Constraint_ADDITIONAL_DECODE
   else if (((p00 = (( 11 :: int)::ii)))) then Constraint_WBSUPPRESS
   else if (((p00 = (( 12 :: int)::ii)))) then Constraint_FAULT
   else if (((p00 = (( 13 :: int)::ii)))) then Constraint_FORCE
   else Constraint_FORCENOSLCHECK))"


(*val num_of_Constraint : Constraint -> integer*)

fun num_of_Constraint  :: " Constraint \<Rightarrow> int "  where 
     " num_of_Constraint Constraint_NONE = ( (( 0 :: int)::ii))"
|" num_of_Constraint Constraint_UNKNOWN = ( (( 1 :: int)::ii))"
|" num_of_Constraint Constraint_UNDEF = ( (( 2 :: int)::ii))"
|" num_of_Constraint Constraint_UNDEFEL0 = ( (( 3 :: int)::ii))"
|" num_of_Constraint Constraint_NOP = ( (( 4 :: int)::ii))"
|" num_of_Constraint Constraint_TRUE = ( (( 5 :: int)::ii))"
|" num_of_Constraint Constraint_FALSE = ( (( 6 :: int)::ii))"
|" num_of_Constraint Constraint_DISABLED = ( (( 7 :: int)::ii))"
|" num_of_Constraint Constraint_UNCOND = ( (( 8 :: int)::ii))"
|" num_of_Constraint Constraint_COND = ( (( 9 :: int)::ii))"
|" num_of_Constraint Constraint_ADDITIONAL_DECODE = ( (( 10 :: int)::ii))"
|" num_of_Constraint Constraint_WBSUPPRESS = ( (( 11 :: int)::ii))"
|" num_of_Constraint Constraint_FAULT = ( (( 12 :: int)::ii))"
|" num_of_Constraint Constraint_FORCE = ( (( 13 :: int)::ii))"
|" num_of_Constraint Constraint_FORCENOSLCHECK = ( (( 14 :: int)::ii))"


(*val undefined_Constraint : unit -> M Constraint*)

definition undefined_Constraint  :: " unit \<Rightarrow>((register_value),(Constraint),(exception))monad "  where 
     " undefined_Constraint _ = (
   internal_pick
     [Constraint_NONE,Constraint_UNKNOWN,Constraint_UNDEF,Constraint_UNDEFEL0,Constraint_NOP,Constraint_TRUE,Constraint_FALSE,Constraint_DISABLED,Constraint_UNCOND,Constraint_COND,Constraint_ADDITIONAL_DECODE,Constraint_WBSUPPRESS,Constraint_FAULT,Constraint_FORCE,Constraint_FORCENOSLCHECK])"


(*val InstrSet_of_num : integer -> InstrSet*)

definition InstrSet_of_num  :: " int \<Rightarrow> InstrSet "  where 
     " InstrSet_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then InstrSet_A64
   else if (((p00 = (( 1 :: int)::ii)))) then InstrSet_A32
   else InstrSet_T32))"


(*val num_of_InstrSet : InstrSet -> integer*)

fun num_of_InstrSet  :: " InstrSet \<Rightarrow> int "  where 
     " num_of_InstrSet InstrSet_A64 = ( (( 0 :: int)::ii))"
|" num_of_InstrSet InstrSet_A32 = ( (( 1 :: int)::ii))"
|" num_of_InstrSet InstrSet_T32 = ( (( 2 :: int)::ii))"


(*val undefined_InstrSet : unit -> M InstrSet*)

definition undefined_InstrSet  :: " unit \<Rightarrow>((register_value),(InstrSet),(exception))monad "  where 
     " undefined_InstrSet _ = ( internal_pick [InstrSet_A64,InstrSet_A32,InstrSet_T32])"


(*val undefined_ProcState : unit -> M ProcState*)

definition undefined_ProcState  :: " unit \<Rightarrow>((register_value),(ProcState),(exception))monad "  where 
     " undefined_ProcState _ = (
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__0 ::  1 Word.word) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__1 ::  1 Word.word) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__2 ::  1 Word.word) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__3 ::  1 Word.word) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__4 ::  1 Word.word) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__5 ::  1 Word.word) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__6 ::  1 Word.word) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__7 ::  1 Word.word) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__8 ::  1 Word.word) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__9 ::  1 Word.word) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__10 ::  1 Word.word) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__11 ::  1 Word.word) . 
   (undefined_bitvector (( 2 :: int)::ii)  :: ( 2 Word.word) M) \<bind> (\<lambda> (w__12 ::  2 Word.word) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__13 ::  1 Word.word) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__14 ::  1 Word.word) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__15 ::  1 Word.word) . 
   (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (w__16 ::  4 Word.word) . 
   (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__17 ::  8 Word.word) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__18 ::  1 Word.word) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__19 ::  1 Word.word) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__20 ::  1 Word.word) . 
   (undefined_bitvector (( 5 :: int)::ii)  :: ( 5 Word.word) M) \<bind> (\<lambda> (w__21 ::  5 Word.word) . 
   return ((| ProcState_N = w__0, 
              ProcState_Z = w__1, 
              ProcState_C = w__2, 
              ProcState_V = w__3, 
              ProcState_D = w__4, 
              ProcState_A = w__5, 
              ProcState_I = w__6, 
              ProcState_F = w__7, 
              ProcState_PAN = w__8, 
              ProcState_UAO = w__9, 
              ProcState_SS = w__10, 
              ProcState_IL = w__11, 
              ProcState_EL = w__12, 
              ProcState_nRW = w__13, 
              ProcState_SP = w__14, 
              ProcState_Q = w__15, 
              ProcState_GE = w__16, 
              ProcState_IT = w__17, 
              ProcState_J = w__18, 
              ProcState_T = w__19, 
              ProcState_E = w__20, 
              ProcState_M = w__21 |)))))))))))))))))))))))))"


(*val BranchType_of_num : integer -> BranchType*)

definition BranchType_of_num  :: " int \<Rightarrow> BranchType "  where 
     " BranchType_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then BranchType_CALL
   else if (((p00 = (( 1 :: int)::ii)))) then BranchType_ERET
   else if (((p00 = (( 2 :: int)::ii)))) then BranchType_DBGEXIT
   else if (((p00 = (( 3 :: int)::ii)))) then BranchType_RET
   else if (((p00 = (( 4 :: int)::ii)))) then BranchType_JMP
   else if (((p00 = (( 5 :: int)::ii)))) then BranchType_EXCEPTION
   else BranchType_UNKNOWN))"


(*val num_of_BranchType : BranchType -> integer*)

fun num_of_BranchType  :: " BranchType \<Rightarrow> int "  where 
     " num_of_BranchType BranchType_CALL = ( (( 0 :: int)::ii))"
|" num_of_BranchType BranchType_ERET = ( (( 1 :: int)::ii))"
|" num_of_BranchType BranchType_DBGEXIT = ( (( 2 :: int)::ii))"
|" num_of_BranchType BranchType_RET = ( (( 3 :: int)::ii))"
|" num_of_BranchType BranchType_JMP = ( (( 4 :: int)::ii))"
|" num_of_BranchType BranchType_EXCEPTION = ( (( 5 :: int)::ii))"
|" num_of_BranchType BranchType_UNKNOWN = ( (( 6 :: int)::ii))"


(*val undefined_BranchType : unit -> M BranchType*)

definition undefined_BranchType  :: " unit \<Rightarrow>((register_value),(BranchType),(exception))monad "  where 
     " undefined_BranchType _ = (
   internal_pick
     [BranchType_CALL,BranchType_ERET,BranchType_DBGEXIT,BranchType_RET,BranchType_JMP,BranchType_EXCEPTION,BranchType_UNKNOWN])"


(*val undefined_ExceptionRecord : unit -> M ExceptionRecord*)

definition undefined_ExceptionRecord  :: " unit \<Rightarrow>((register_value),(ExceptionRecord),(exception))monad "  where 
     " undefined_ExceptionRecord _ = (
   undefined_Exception ()  \<bind> (\<lambda> (w__0 :: Exception) . 
   (undefined_bitvector (( 25 :: int)::ii)  :: ( 25 Word.word) M) \<bind> (\<lambda> (w__1 ::  25 Word.word) . 
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::  64 Word.word) . 
   undefined_bool ()  \<bind> (\<lambda> (w__3 :: bool) . 
   (undefined_bitvector (( 52 :: int)::ii)  :: ( 52 Word.word) M) \<bind> (\<lambda> (w__4 ::  52 Word.word) . 
   return ((| ExceptionRecord_typ = w__0, 
              ExceptionRecord_syndrome = w__1, 
              ExceptionRecord_vaddress = w__2, 
              ExceptionRecord_ipavalid = w__3, 
              ExceptionRecord_ipaddress = w__4 |))))))))"


(*val Fault_of_num : integer -> Fault*)

definition Fault_of_num  :: " int \<Rightarrow> Fault "  where 
     " Fault_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then Fault_None
   else if (((p00 = (( 1 :: int)::ii)))) then Fault_AccessFlag
   else if (((p00 = (( 2 :: int)::ii)))) then Fault_Alignment
   else if (((p00 = (( 3 :: int)::ii)))) then Fault_Background
   else if (((p00 = (( 4 :: int)::ii)))) then Fault_Domain
   else if (((p00 = (( 5 :: int)::ii)))) then Fault_Permission
   else if (((p00 = (( 6 :: int)::ii)))) then Fault_Translation
   else if (((p00 = (( 7 :: int)::ii)))) then Fault_AddressSize
   else if (((p00 = (( 8 :: int)::ii)))) then Fault_SyncExternal
   else if (((p00 = (( 9 :: int)::ii)))) then Fault_SyncExternalOnWalk
   else if (((p00 = (( 10 :: int)::ii)))) then Fault_SyncParity
   else if (((p00 = (( 11 :: int)::ii)))) then Fault_SyncParityOnWalk
   else if (((p00 = (( 12 :: int)::ii)))) then Fault_AsyncParity
   else if (((p00 = (( 13 :: int)::ii)))) then Fault_AsyncExternal
   else if (((p00 = (( 14 :: int)::ii)))) then Fault_Debug
   else if (((p00 = (( 15 :: int)::ii)))) then Fault_TLBConflict
   else if (((p00 = (( 16 :: int)::ii)))) then Fault_Lockdown
   else if (((p00 = (( 17 :: int)::ii)))) then Fault_Exclusive
   else Fault_ICacheMaint))"


(*val num_of_Fault : Fault -> integer*)

fun num_of_Fault  :: " Fault \<Rightarrow> int "  where 
     " num_of_Fault Fault_None = ( (( 0 :: int)::ii))"
|" num_of_Fault Fault_AccessFlag = ( (( 1 :: int)::ii))"
|" num_of_Fault Fault_Alignment = ( (( 2 :: int)::ii))"
|" num_of_Fault Fault_Background = ( (( 3 :: int)::ii))"
|" num_of_Fault Fault_Domain = ( (( 4 :: int)::ii))"
|" num_of_Fault Fault_Permission = ( (( 5 :: int)::ii))"
|" num_of_Fault Fault_Translation = ( (( 6 :: int)::ii))"
|" num_of_Fault Fault_AddressSize = ( (( 7 :: int)::ii))"
|" num_of_Fault Fault_SyncExternal = ( (( 8 :: int)::ii))"
|" num_of_Fault Fault_SyncExternalOnWalk = ( (( 9 :: int)::ii))"
|" num_of_Fault Fault_SyncParity = ( (( 10 :: int)::ii))"
|" num_of_Fault Fault_SyncParityOnWalk = ( (( 11 :: int)::ii))"
|" num_of_Fault Fault_AsyncParity = ( (( 12 :: int)::ii))"
|" num_of_Fault Fault_AsyncExternal = ( (( 13 :: int)::ii))"
|" num_of_Fault Fault_Debug = ( (( 14 :: int)::ii))"
|" num_of_Fault Fault_TLBConflict = ( (( 15 :: int)::ii))"
|" num_of_Fault Fault_Lockdown = ( (( 16 :: int)::ii))"
|" num_of_Fault Fault_Exclusive = ( (( 17 :: int)::ii))"
|" num_of_Fault Fault_ICacheMaint = ( (( 18 :: int)::ii))"


(*val undefined_Fault : unit -> M Fault*)

definition undefined_Fault  :: " unit \<Rightarrow>((register_value),(Fault),(exception))monad "  where 
     " undefined_Fault _ = (
   internal_pick
     [Fault_None,Fault_AccessFlag,Fault_Alignment,Fault_Background,Fault_Domain,Fault_Permission,Fault_Translation,Fault_AddressSize,Fault_SyncExternal,Fault_SyncExternalOnWalk,Fault_SyncParity,Fault_SyncParityOnWalk,Fault_AsyncParity,Fault_AsyncExternal,Fault_Debug,Fault_TLBConflict,Fault_Lockdown,Fault_Exclusive,Fault_ICacheMaint])"


(*val AccType_of_num : integer -> AccType*)

definition AccType_of_num  :: " int \<Rightarrow> AccType "  where 
     " AccType_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then AccType_NORMAL
   else if (((p00 = (( 1 :: int)::ii)))) then AccType_VEC
   else if (((p00 = (( 2 :: int)::ii)))) then AccType_STREAM
   else if (((p00 = (( 3 :: int)::ii)))) then AccType_VECSTREAM
   else if (((p00 = (( 4 :: int)::ii)))) then AccType_ATOMIC
   else if (((p00 = (( 5 :: int)::ii)))) then AccType_ATOMICRW
   else if (((p00 = (( 6 :: int)::ii)))) then AccType_ORDERED
   else if (((p00 = (( 7 :: int)::ii)))) then AccType_ORDEREDRW
   else if (((p00 = (( 8 :: int)::ii)))) then AccType_LIMITEDORDERED
   else if (((p00 = (( 9 :: int)::ii)))) then AccType_UNPRIV
   else if (((p00 = (( 10 :: int)::ii)))) then AccType_IFETCH
   else if (((p00 = (( 11 :: int)::ii)))) then AccType_PTW
   else if (((p00 = (( 12 :: int)::ii)))) then AccType_DC
   else if (((p00 = (( 13 :: int)::ii)))) then AccType_IC
   else if (((p00 = (( 14 :: int)::ii)))) then AccType_DCZVA
   else AccType_AT))"


(*val num_of_AccType : AccType -> integer*)

fun num_of_AccType  :: " AccType \<Rightarrow> int "  where 
     " num_of_AccType AccType_NORMAL = ( (( 0 :: int)::ii))"
|" num_of_AccType AccType_VEC = ( (( 1 :: int)::ii))"
|" num_of_AccType AccType_STREAM = ( (( 2 :: int)::ii))"
|" num_of_AccType AccType_VECSTREAM = ( (( 3 :: int)::ii))"
|" num_of_AccType AccType_ATOMIC = ( (( 4 :: int)::ii))"
|" num_of_AccType AccType_ATOMICRW = ( (( 5 :: int)::ii))"
|" num_of_AccType AccType_ORDERED = ( (( 6 :: int)::ii))"
|" num_of_AccType AccType_ORDEREDRW = ( (( 7 :: int)::ii))"
|" num_of_AccType AccType_LIMITEDORDERED = ( (( 8 :: int)::ii))"
|" num_of_AccType AccType_UNPRIV = ( (( 9 :: int)::ii))"
|" num_of_AccType AccType_IFETCH = ( (( 10 :: int)::ii))"
|" num_of_AccType AccType_PTW = ( (( 11 :: int)::ii))"
|" num_of_AccType AccType_DC = ( (( 12 :: int)::ii))"
|" num_of_AccType AccType_IC = ( (( 13 :: int)::ii))"
|" num_of_AccType AccType_DCZVA = ( (( 14 :: int)::ii))"
|" num_of_AccType AccType_AT = ( (( 15 :: int)::ii))"


(*val undefined_AccType : unit -> M AccType*)

definition undefined_AccType  :: " unit \<Rightarrow>((register_value),(AccType),(exception))monad "  where 
     " undefined_AccType _ = (
   internal_pick
     [AccType_NORMAL,AccType_VEC,AccType_STREAM,AccType_VECSTREAM,AccType_ATOMIC,AccType_ATOMICRW,AccType_ORDERED,AccType_ORDEREDRW,AccType_LIMITEDORDERED,AccType_UNPRIV,AccType_IFETCH,AccType_PTW,AccType_DC,AccType_IC,AccType_DCZVA,AccType_AT])"


(*val undefined_FaultRecord : unit -> M FaultRecord*)

definition undefined_FaultRecord  :: " unit \<Rightarrow>((register_value),(FaultRecord),(exception))monad "  where 
     " undefined_FaultRecord _ = (
   undefined_Fault ()  \<bind> (\<lambda> (w__0 :: Fault) . 
   undefined_AccType ()  \<bind> (\<lambda> (w__1 :: AccType) . 
   (undefined_bitvector (( 52 :: int)::ii)  :: ( 52 Word.word) M) \<bind> (\<lambda> (w__2 ::  52 Word.word) . 
   undefined_bool ()  \<bind> (\<lambda> (w__3 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (w__4 :: bool) . 
   undefined_int ()  \<bind> (\<lambda> (w__5 :: ii) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__6 ::  1 Word.word) . 
   undefined_bool ()  \<bind> (\<lambda> (w__7 :: bool) . 
   (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (w__8 ::  4 Word.word) . 
   (undefined_bitvector (( 2 :: int)::ii)  :: ( 2 Word.word) M) \<bind> (\<lambda> (w__9 ::  2 Word.word) . 
   (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (w__10 ::  4 Word.word) . 
   return ((| FaultRecord_typ = w__0, 
              FaultRecord_acctype = w__1, 
              FaultRecord_ipaddress = w__2, 
              FaultRecord_s2fs1walk = w__3, 
              FaultRecord_write = w__4, 
              FaultRecord_level = w__5, 
              FaultRecord_extflag = w__6, 
              FaultRecord_secondstage = w__7, 
              FaultRecord_domain = w__8, 
              FaultRecord_errortype = w__9, 
              FaultRecord_debugmoe = w__10 |))))))))))))))"


(*val MBReqDomain_of_num : integer -> MBReqDomain*)

definition MBReqDomain_of_num  :: " int \<Rightarrow> MBReqDomain "  where 
     " MBReqDomain_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then MBReqDomain_Nonshareable
   else if (((p00 = (( 1 :: int)::ii)))) then MBReqDomain_InnerShareable
   else if (((p00 = (( 2 :: int)::ii)))) then MBReqDomain_OuterShareable
   else MBReqDomain_FullSystem))"


(*val num_of_MBReqDomain : MBReqDomain -> integer*)

fun num_of_MBReqDomain  :: " MBReqDomain \<Rightarrow> int "  where 
     " num_of_MBReqDomain MBReqDomain_Nonshareable = ( (( 0 :: int)::ii))"
|" num_of_MBReqDomain MBReqDomain_InnerShareable = ( (( 1 :: int)::ii))"
|" num_of_MBReqDomain MBReqDomain_OuterShareable = ( (( 2 :: int)::ii))"
|" num_of_MBReqDomain MBReqDomain_FullSystem = ( (( 3 :: int)::ii))"


(*val undefined_MBReqDomain : unit -> M MBReqDomain*)

definition undefined_MBReqDomain  :: " unit \<Rightarrow>((register_value),(MBReqDomain),(exception))monad "  where 
     " undefined_MBReqDomain _ = (
   internal_pick
     [MBReqDomain_Nonshareable,MBReqDomain_InnerShareable,MBReqDomain_OuterShareable,MBReqDomain_FullSystem])"


(*val MBReqTypes_of_num : integer -> MBReqTypes*)

definition MBReqTypes_of_num  :: " int \<Rightarrow> MBReqTypes "  where 
     " MBReqTypes_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then MBReqTypes_Reads
   else if (((p00 = (( 1 :: int)::ii)))) then MBReqTypes_Writes
   else MBReqTypes_All))"


(*val num_of_MBReqTypes : MBReqTypes -> integer*)

fun num_of_MBReqTypes  :: " MBReqTypes \<Rightarrow> int "  where 
     " num_of_MBReqTypes MBReqTypes_Reads = ( (( 0 :: int)::ii))"
|" num_of_MBReqTypes MBReqTypes_Writes = ( (( 1 :: int)::ii))"
|" num_of_MBReqTypes MBReqTypes_All = ( (( 2 :: int)::ii))"


(*val undefined_MBReqTypes : unit -> M MBReqTypes*)

definition undefined_MBReqTypes  :: " unit \<Rightarrow>((register_value),(MBReqTypes),(exception))monad "  where 
     " undefined_MBReqTypes _ = ( internal_pick [MBReqTypes_Reads,MBReqTypes_Writes,MBReqTypes_All])"


(*val MemType_of_num : integer -> MemType*)

definition MemType_of_num  :: " int \<Rightarrow> MemType "  where 
     " MemType_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then MemType_Normal
   else MemType_Device))"


(*val num_of_MemType : MemType -> integer*)

fun num_of_MemType  :: " MemType \<Rightarrow> int "  where 
     " num_of_MemType MemType_Normal = ( (( 0 :: int)::ii))"
|" num_of_MemType MemType_Device = ( (( 1 :: int)::ii))"


(*val undefined_MemType : unit -> M MemType*)

definition undefined_MemType  :: " unit \<Rightarrow>((register_value),(MemType),(exception))monad "  where 
     " undefined_MemType _ = ( internal_pick [MemType_Normal,MemType_Device])"


(*val DeviceType_of_num : integer -> DeviceType*)

definition DeviceType_of_num  :: " int \<Rightarrow> DeviceType "  where 
     " DeviceType_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then DeviceType_GRE
   else if (((p00 = (( 1 :: int)::ii)))) then DeviceType_nGRE
   else if (((p00 = (( 2 :: int)::ii)))) then DeviceType_nGnRE
   else DeviceType_nGnRnE))"


(*val num_of_DeviceType : DeviceType -> integer*)

fun num_of_DeviceType  :: " DeviceType \<Rightarrow> int "  where 
     " num_of_DeviceType DeviceType_GRE = ( (( 0 :: int)::ii))"
|" num_of_DeviceType DeviceType_nGRE = ( (( 1 :: int)::ii))"
|" num_of_DeviceType DeviceType_nGnRE = ( (( 2 :: int)::ii))"
|" num_of_DeviceType DeviceType_nGnRnE = ( (( 3 :: int)::ii))"


(*val undefined_DeviceType : unit -> M DeviceType*)

definition undefined_DeviceType  :: " unit \<Rightarrow>((register_value),(DeviceType),(exception))monad "  where 
     " undefined_DeviceType _ = (
   internal_pick [DeviceType_GRE,DeviceType_nGRE,DeviceType_nGnRE,DeviceType_nGnRnE])"


(*val undefined_MemAttrHints : unit -> M MemAttrHints*)

definition undefined_MemAttrHints  :: " unit \<Rightarrow>((register_value),(MemAttrHints),(exception))monad "  where 
     " undefined_MemAttrHints _ = (
   (undefined_bitvector (( 2 :: int)::ii)  :: ( 2 Word.word) M) \<bind> (\<lambda> (w__0 ::  2 Word.word) . 
   (undefined_bitvector (( 2 :: int)::ii)  :: ( 2 Word.word) M) \<bind> (\<lambda> (w__1 ::  2 Word.word) . 
   undefined_bool ()  \<bind> (\<lambda> (w__2 :: bool) . 
   return ((| MemAttrHints_attrs = w__0, 
              MemAttrHints_hints = w__1, 
              MemAttrHints_transient = w__2 |))))))"


(*val undefined_MemoryAttributes : unit -> M MemoryAttributes*)

definition undefined_MemoryAttributes  :: " unit \<Rightarrow>((register_value),(MemoryAttributes),(exception))monad "  where 
     " undefined_MemoryAttributes _ = (
   undefined_MemType ()  \<bind> (\<lambda> (w__0 :: MemType) . 
   undefined_DeviceType ()  \<bind> (\<lambda> (w__1 :: DeviceType) . 
   undefined_MemAttrHints ()  \<bind> (\<lambda> (w__2 :: MemAttrHints) . 
   undefined_MemAttrHints ()  \<bind> (\<lambda> (w__3 :: MemAttrHints) . 
   undefined_bool ()  \<bind> (\<lambda> (w__4 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (w__5 :: bool) . 
   return ((| MemoryAttributes_typ = w__0, 
              MemoryAttributes_device = w__1, 
              MemoryAttributes_inner = w__2, 
              MemoryAttributes_outer = w__3, 
              MemoryAttributes_shareable = w__4, 
              MemoryAttributes_outershareable = w__5 |)))))))))"


(*val undefined_FullAddress : unit -> M FullAddress*)

definition undefined_FullAddress  :: " unit \<Rightarrow>((register_value),(FullAddress),(exception))monad "  where 
     " undefined_FullAddress _ = (
   (undefined_bitvector (( 52 :: int)::ii)  :: ( 52 Word.word) M) \<bind> (\<lambda> (w__0 ::  52 Word.word) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__1 ::  1 Word.word) . 
   return ((| FullAddress_physicaladdress = w__0, 
              FullAddress_NS = w__1 |)))))"


(*val undefined_AddressDescriptor : unit -> M AddressDescriptor*)

definition undefined_AddressDescriptor  :: " unit \<Rightarrow>((register_value),(AddressDescriptor),(exception))monad "  where 
     " undefined_AddressDescriptor _ = (
   undefined_FaultRecord ()  \<bind> (\<lambda> (w__0 :: FaultRecord) . 
   undefined_MemoryAttributes ()  \<bind> (\<lambda> (w__1 :: MemoryAttributes) . 
   undefined_FullAddress ()  \<bind> (\<lambda> (w__2 :: FullAddress) . 
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::  64 Word.word) . 
   return ((| AddressDescriptor_fault = w__0, 
              AddressDescriptor_memattrs = w__1, 
              AddressDescriptor_paddress = w__2, 
              AddressDescriptor_vaddress = w__3 |)))))))"


(*val undefined_DescriptorUpdate : unit -> M DescriptorUpdate*)

definition undefined_DescriptorUpdate  :: " unit \<Rightarrow>((register_value),(DescriptorUpdate),(exception))monad "  where 
     " undefined_DescriptorUpdate _ = (
   undefined_bool ()  \<bind> (\<lambda> (w__0 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (w__1 :: bool) . 
   undefined_AddressDescriptor ()  \<bind> (\<lambda> (w__2 :: AddressDescriptor) . 
   return ((| DescriptorUpdate_AF = w__0, 
              DescriptorUpdate_AP = w__1, 
              DescriptorUpdate_descaddr = w__2 |))))))"


(*val MemAtomicOp_of_num : integer -> MemAtomicOp*)

definition MemAtomicOp_of_num  :: " int \<Rightarrow> MemAtomicOp "  where 
     " MemAtomicOp_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then MemAtomicOp_ADD
   else if (((p00 = (( 1 :: int)::ii)))) then MemAtomicOp_BIC
   else if (((p00 = (( 2 :: int)::ii)))) then MemAtomicOp_EOR
   else if (((p00 = (( 3 :: int)::ii)))) then MemAtomicOp_ORR
   else if (((p00 = (( 4 :: int)::ii)))) then MemAtomicOp_SMAX
   else if (((p00 = (( 5 :: int)::ii)))) then MemAtomicOp_SMIN
   else if (((p00 = (( 6 :: int)::ii)))) then MemAtomicOp_UMAX
   else if (((p00 = (( 7 :: int)::ii)))) then MemAtomicOp_UMIN
   else MemAtomicOp_SWP))"


(*val num_of_MemAtomicOp : MemAtomicOp -> integer*)

fun num_of_MemAtomicOp  :: " MemAtomicOp \<Rightarrow> int "  where 
     " num_of_MemAtomicOp MemAtomicOp_ADD = ( (( 0 :: int)::ii))"
|" num_of_MemAtomicOp MemAtomicOp_BIC = ( (( 1 :: int)::ii))"
|" num_of_MemAtomicOp MemAtomicOp_EOR = ( (( 2 :: int)::ii))"
|" num_of_MemAtomicOp MemAtomicOp_ORR = ( (( 3 :: int)::ii))"
|" num_of_MemAtomicOp MemAtomicOp_SMAX = ( (( 4 :: int)::ii))"
|" num_of_MemAtomicOp MemAtomicOp_SMIN = ( (( 5 :: int)::ii))"
|" num_of_MemAtomicOp MemAtomicOp_UMAX = ( (( 6 :: int)::ii))"
|" num_of_MemAtomicOp MemAtomicOp_UMIN = ( (( 7 :: int)::ii))"
|" num_of_MemAtomicOp MemAtomicOp_SWP = ( (( 8 :: int)::ii))"


(*val undefined_MemAtomicOp : unit -> M MemAtomicOp*)

definition undefined_MemAtomicOp  :: " unit \<Rightarrow>((register_value),(MemAtomicOp),(exception))monad "  where 
     " undefined_MemAtomicOp _ = (
   internal_pick
     [MemAtomicOp_ADD,MemAtomicOp_BIC,MemAtomicOp_EOR,MemAtomicOp_ORR,MemAtomicOp_SMAX,MemAtomicOp_SMIN,MemAtomicOp_UMAX,MemAtomicOp_UMIN,MemAtomicOp_SWP])"


(*val FPType_of_num : integer -> FPType*)

definition FPType_of_num  :: " int \<Rightarrow> FPType "  where 
     " FPType_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then FPType_Nonzero
   else if (((p00 = (( 1 :: int)::ii)))) then FPType_Zero
   else if (((p00 = (( 2 :: int)::ii)))) then FPType_Infinity
   else if (((p00 = (( 3 :: int)::ii)))) then FPType_QNaN
   else FPType_SNaN))"


(*val num_of_FPType : FPType -> integer*)

fun num_of_FPType  :: " FPType \<Rightarrow> int "  where 
     " num_of_FPType FPType_Nonzero = ( (( 0 :: int)::ii))"
|" num_of_FPType FPType_Zero = ( (( 1 :: int)::ii))"
|" num_of_FPType FPType_Infinity = ( (( 2 :: int)::ii))"
|" num_of_FPType FPType_QNaN = ( (( 3 :: int)::ii))"
|" num_of_FPType FPType_SNaN = ( (( 4 :: int)::ii))"


(*val undefined_FPType : unit -> M FPType*)

definition undefined_FPType  :: " unit \<Rightarrow>((register_value),(FPType),(exception))monad "  where 
     " undefined_FPType _ = (
   internal_pick [FPType_Nonzero,FPType_Zero,FPType_Infinity,FPType_QNaN,FPType_SNaN])"


(*val FPExc_of_num : integer -> FPExc*)

definition FPExc_of_num  :: " int \<Rightarrow> FPExc "  where 
     " FPExc_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then FPExc_InvalidOp
   else if (((p00 = (( 1 :: int)::ii)))) then FPExc_DivideByZero
   else if (((p00 = (( 2 :: int)::ii)))) then FPExc_Overflow
   else if (((p00 = (( 3 :: int)::ii)))) then FPExc_Underflow
   else if (((p00 = (( 4 :: int)::ii)))) then FPExc_Inexact
   else FPExc_InputDenorm))"


(*val num_of_FPExc : FPExc -> integer*)

fun num_of_FPExc  :: " FPExc \<Rightarrow> int "  where 
     " num_of_FPExc FPExc_InvalidOp = ( (( 0 :: int)::ii))"
|" num_of_FPExc FPExc_DivideByZero = ( (( 1 :: int)::ii))"
|" num_of_FPExc FPExc_Overflow = ( (( 2 :: int)::ii))"
|" num_of_FPExc FPExc_Underflow = ( (( 3 :: int)::ii))"
|" num_of_FPExc FPExc_Inexact = ( (( 4 :: int)::ii))"
|" num_of_FPExc FPExc_InputDenorm = ( (( 5 :: int)::ii))"


(*val undefined_FPExc : unit -> M FPExc*)

definition undefined_FPExc  :: " unit \<Rightarrow>((register_value),(FPExc),(exception))monad "  where 
     " undefined_FPExc _ = (
   internal_pick
     [FPExc_InvalidOp,FPExc_DivideByZero,FPExc_Overflow,FPExc_Underflow,FPExc_Inexact,FPExc_InputDenorm])"


(*val FPRounding_of_num : integer -> FPRounding*)

definition FPRounding_of_num  :: " int \<Rightarrow> FPRounding "  where 
     " FPRounding_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then FPRounding_TIEEVEN
   else if (((p00 = (( 1 :: int)::ii)))) then FPRounding_POSINF
   else if (((p00 = (( 2 :: int)::ii)))) then FPRounding_NEGINF
   else if (((p00 = (( 3 :: int)::ii)))) then FPRounding_ZERO
   else if (((p00 = (( 4 :: int)::ii)))) then FPRounding_TIEAWAY
   else FPRounding_ODD))"


(*val num_of_FPRounding : FPRounding -> integer*)

fun num_of_FPRounding  :: " FPRounding \<Rightarrow> int "  where 
     " num_of_FPRounding FPRounding_TIEEVEN = ( (( 0 :: int)::ii))"
|" num_of_FPRounding FPRounding_POSINF = ( (( 1 :: int)::ii))"
|" num_of_FPRounding FPRounding_NEGINF = ( (( 2 :: int)::ii))"
|" num_of_FPRounding FPRounding_ZERO = ( (( 3 :: int)::ii))"
|" num_of_FPRounding FPRounding_TIEAWAY = ( (( 4 :: int)::ii))"
|" num_of_FPRounding FPRounding_ODD = ( (( 5 :: int)::ii))"


(*val undefined_FPRounding : unit -> M FPRounding*)

definition undefined_FPRounding  :: " unit \<Rightarrow>((register_value),(FPRounding),(exception))monad "  where 
     " undefined_FPRounding _ = (
   internal_pick
     [FPRounding_TIEEVEN,FPRounding_POSINF,FPRounding_NEGINF,FPRounding_ZERO,FPRounding_TIEAWAY,FPRounding_ODD])"


(*val SysRegAccess_of_num : integer -> SysRegAccess*)

definition SysRegAccess_of_num  :: " int \<Rightarrow> SysRegAccess "  where 
     " SysRegAccess_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then SysRegAccess_OK
   else if (((p00 = (( 1 :: int)::ii)))) then SysRegAccess_UNDEFINED
   else if (((p00 = (( 2 :: int)::ii)))) then SysRegAccess_TrapToEL1
   else if (((p00 = (( 3 :: int)::ii)))) then SysRegAccess_TrapToEL2
   else SysRegAccess_TrapToEL3))"


(*val num_of_SysRegAccess : SysRegAccess -> integer*)

fun num_of_SysRegAccess  :: " SysRegAccess \<Rightarrow> int "  where 
     " num_of_SysRegAccess SysRegAccess_OK = ( (( 0 :: int)::ii))"
|" num_of_SysRegAccess SysRegAccess_UNDEFINED = ( (( 1 :: int)::ii))"
|" num_of_SysRegAccess SysRegAccess_TrapToEL1 = ( (( 2 :: int)::ii))"
|" num_of_SysRegAccess SysRegAccess_TrapToEL2 = ( (( 3 :: int)::ii))"
|" num_of_SysRegAccess SysRegAccess_TrapToEL3 = ( (( 4 :: int)::ii))"


(*val undefined_SysRegAccess : unit -> M SysRegAccess*)

definition undefined_SysRegAccess  :: " unit \<Rightarrow>((register_value),(SysRegAccess),(exception))monad "  where 
     " undefined_SysRegAccess _ = (
   internal_pick
     [SysRegAccess_OK,SysRegAccess_UNDEFINED,SysRegAccess_TrapToEL1,SysRegAccess_TrapToEL2,SysRegAccess_TrapToEL3])"


(*val SRType_of_num : integer -> SRType*)

definition SRType_of_num  :: " int \<Rightarrow> SRType "  where 
     " SRType_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then SRType_LSL
   else if (((p00 = (( 1 :: int)::ii)))) then SRType_LSR
   else if (((p00 = (( 2 :: int)::ii)))) then SRType_ASR
   else if (((p00 = (( 3 :: int)::ii)))) then SRType_ROR
   else SRType_RRX))"


(*val num_of_SRType : SRType -> integer*)

fun num_of_SRType  :: " SRType \<Rightarrow> int "  where 
     " num_of_SRType SRType_LSL = ( (( 0 :: int)::ii))"
|" num_of_SRType SRType_LSR = ( (( 1 :: int)::ii))"
|" num_of_SRType SRType_ASR = ( (( 2 :: int)::ii))"
|" num_of_SRType SRType_ROR = ( (( 3 :: int)::ii))"
|" num_of_SRType SRType_RRX = ( (( 4 :: int)::ii))"


(*val undefined_SRType : unit -> M SRType*)

definition undefined_SRType  :: " unit \<Rightarrow>((register_value),(SRType),(exception))monad "  where 
     " undefined_SRType _ = ( internal_pick [SRType_LSL,SRType_LSR,SRType_ASR,SRType_ROR,SRType_RRX])"


(*val ShiftType_of_num : integer -> ShiftType*)

definition ShiftType_of_num  :: " int \<Rightarrow> ShiftType "  where 
     " ShiftType_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then ShiftType_LSL
   else if (((p00 = (( 1 :: int)::ii)))) then ShiftType_LSR
   else if (((p00 = (( 2 :: int)::ii)))) then ShiftType_ASR
   else ShiftType_ROR))"


(*val num_of_ShiftType : ShiftType -> integer*)

fun num_of_ShiftType  :: " ShiftType \<Rightarrow> int "  where 
     " num_of_ShiftType ShiftType_LSL = ( (( 0 :: int)::ii))"
|" num_of_ShiftType ShiftType_LSR = ( (( 1 :: int)::ii))"
|" num_of_ShiftType ShiftType_ASR = ( (( 2 :: int)::ii))"
|" num_of_ShiftType ShiftType_ROR = ( (( 3 :: int)::ii))"


(*val undefined_ShiftType : unit -> M ShiftType*)

definition undefined_ShiftType  :: " unit \<Rightarrow>((register_value),(ShiftType),(exception))monad "  where 
     " undefined_ShiftType _ = ( internal_pick [ShiftType_LSL,ShiftType_LSR,ShiftType_ASR,ShiftType_ROR])"


(*val PrefetchHint_of_num : integer -> PrefetchHint*)

definition PrefetchHint_of_num  :: " int \<Rightarrow> PrefetchHint "  where 
     " PrefetchHint_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then Prefetch_READ
   else if (((p00 = (( 1 :: int)::ii)))) then Prefetch_WRITE
   else Prefetch_EXEC))"


(*val num_of_PrefetchHint : PrefetchHint -> integer*)

fun num_of_PrefetchHint  :: " PrefetchHint \<Rightarrow> int "  where 
     " num_of_PrefetchHint Prefetch_READ = ( (( 0 :: int)::ii))"
|" num_of_PrefetchHint Prefetch_WRITE = ( (( 1 :: int)::ii))"
|" num_of_PrefetchHint Prefetch_EXEC = ( (( 2 :: int)::ii))"


(*val undefined_PrefetchHint : unit -> M PrefetchHint*)

definition undefined_PrefetchHint  :: " unit \<Rightarrow>((register_value),(PrefetchHint),(exception))monad "  where 
     " undefined_PrefetchHint _ = ( internal_pick [Prefetch_READ,Prefetch_WRITE,Prefetch_EXEC])"


(*val InterruptID_of_num : integer -> InterruptID*)

definition InterruptID_of_num  :: " int \<Rightarrow> InterruptID "  where 
     " InterruptID_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then InterruptID_PMUIRQ
   else if (((p00 = (( 1 :: int)::ii)))) then InterruptID_COMMIRQ
   else if (((p00 = (( 2 :: int)::ii)))) then InterruptID_CTIIRQ
   else if (((p00 = (( 3 :: int)::ii)))) then InterruptID_COMMRX
   else InterruptID_COMMTX))"


(*val num_of_InterruptID : InterruptID -> integer*)

fun num_of_InterruptID  :: " InterruptID \<Rightarrow> int "  where 
     " num_of_InterruptID InterruptID_PMUIRQ = ( (( 0 :: int)::ii))"
|" num_of_InterruptID InterruptID_COMMIRQ = ( (( 1 :: int)::ii))"
|" num_of_InterruptID InterruptID_CTIIRQ = ( (( 2 :: int)::ii))"
|" num_of_InterruptID InterruptID_COMMRX = ( (( 3 :: int)::ii))"
|" num_of_InterruptID InterruptID_COMMTX = ( (( 4 :: int)::ii))"


(*val undefined_InterruptID : unit -> M InterruptID*)

definition undefined_InterruptID  :: " unit \<Rightarrow>((register_value),(InterruptID),(exception))monad "  where 
     " undefined_InterruptID _ = (
   internal_pick
     [InterruptID_PMUIRQ,InterruptID_COMMIRQ,InterruptID_CTIIRQ,InterruptID_COMMRX,InterruptID_COMMTX])"


(*val CrossTriggerOut_of_num : integer -> CrossTriggerOut*)

definition CrossTriggerOut_of_num  :: " int \<Rightarrow> CrossTriggerOut "  where 
     " CrossTriggerOut_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then CrossTriggerOut_DebugRequest
   else if (((p00 = (( 1 :: int)::ii)))) then CrossTriggerOut_RestartRequest
   else if (((p00 = (( 2 :: int)::ii)))) then CrossTriggerOut_IRQ
   else if (((p00 = (( 3 :: int)::ii)))) then CrossTriggerOut_RSVD3
   else if (((p00 = (( 4 :: int)::ii)))) then CrossTriggerOut_TraceExtIn0
   else if (((p00 = (( 5 :: int)::ii)))) then CrossTriggerOut_TraceExtIn1
   else if (((p00 = (( 6 :: int)::ii)))) then CrossTriggerOut_TraceExtIn2
   else CrossTriggerOut_TraceExtIn3))"


(*val num_of_CrossTriggerOut : CrossTriggerOut -> integer*)

fun num_of_CrossTriggerOut  :: " CrossTriggerOut \<Rightarrow> int "  where 
     " num_of_CrossTriggerOut CrossTriggerOut_DebugRequest = ( (( 0 :: int)::ii))"
|" num_of_CrossTriggerOut CrossTriggerOut_RestartRequest = ( (( 1 :: int)::ii))"
|" num_of_CrossTriggerOut CrossTriggerOut_IRQ = ( (( 2 :: int)::ii))"
|" num_of_CrossTriggerOut CrossTriggerOut_RSVD3 = ( (( 3 :: int)::ii))"
|" num_of_CrossTriggerOut CrossTriggerOut_TraceExtIn0 = ( (( 4 :: int)::ii))"
|" num_of_CrossTriggerOut CrossTriggerOut_TraceExtIn1 = ( (( 5 :: int)::ii))"
|" num_of_CrossTriggerOut CrossTriggerOut_TraceExtIn2 = ( (( 6 :: int)::ii))"
|" num_of_CrossTriggerOut CrossTriggerOut_TraceExtIn3 = ( (( 7 :: int)::ii))"


(*val undefined_CrossTriggerOut : unit -> M CrossTriggerOut*)

definition undefined_CrossTriggerOut  :: " unit \<Rightarrow>((register_value),(CrossTriggerOut),(exception))monad "  where 
     " undefined_CrossTriggerOut _ = (
   internal_pick
     [CrossTriggerOut_DebugRequest,CrossTriggerOut_RestartRequest,CrossTriggerOut_IRQ,CrossTriggerOut_RSVD3,CrossTriggerOut_TraceExtIn0,CrossTriggerOut_TraceExtIn1,CrossTriggerOut_TraceExtIn2,CrossTriggerOut_TraceExtIn3])"


(*val CrossTriggerIn_of_num : integer -> CrossTriggerIn*)

definition CrossTriggerIn_of_num  :: " int \<Rightarrow> CrossTriggerIn "  where 
     " CrossTriggerIn_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then CrossTriggerIn_CrossHalt
   else if (((p00 = (( 1 :: int)::ii)))) then CrossTriggerIn_PMUOverflow
   else if (((p00 = (( 2 :: int)::ii)))) then CrossTriggerIn_RSVD2
   else if (((p00 = (( 3 :: int)::ii)))) then CrossTriggerIn_RSVD3
   else if (((p00 = (( 4 :: int)::ii)))) then CrossTriggerIn_TraceExtOut0
   else if (((p00 = (( 5 :: int)::ii)))) then CrossTriggerIn_TraceExtOut1
   else if (((p00 = (( 6 :: int)::ii)))) then CrossTriggerIn_TraceExtOut2
   else CrossTriggerIn_TraceExtOut3))"


(*val num_of_CrossTriggerIn : CrossTriggerIn -> integer*)

fun num_of_CrossTriggerIn  :: " CrossTriggerIn \<Rightarrow> int "  where 
     " num_of_CrossTriggerIn CrossTriggerIn_CrossHalt = ( (( 0 :: int)::ii))"
|" num_of_CrossTriggerIn CrossTriggerIn_PMUOverflow = ( (( 1 :: int)::ii))"
|" num_of_CrossTriggerIn CrossTriggerIn_RSVD2 = ( (( 2 :: int)::ii))"
|" num_of_CrossTriggerIn CrossTriggerIn_RSVD3 = ( (( 3 :: int)::ii))"
|" num_of_CrossTriggerIn CrossTriggerIn_TraceExtOut0 = ( (( 4 :: int)::ii))"
|" num_of_CrossTriggerIn CrossTriggerIn_TraceExtOut1 = ( (( 5 :: int)::ii))"
|" num_of_CrossTriggerIn CrossTriggerIn_TraceExtOut2 = ( (( 6 :: int)::ii))"
|" num_of_CrossTriggerIn CrossTriggerIn_TraceExtOut3 = ( (( 7 :: int)::ii))"


(*val undefined_CrossTriggerIn : unit -> M CrossTriggerIn*)

definition undefined_CrossTriggerIn  :: " unit \<Rightarrow>((register_value),(CrossTriggerIn),(exception))monad "  where 
     " undefined_CrossTriggerIn _ = (
   internal_pick
     [CrossTriggerIn_CrossHalt,CrossTriggerIn_PMUOverflow,CrossTriggerIn_RSVD2,CrossTriggerIn_RSVD3,CrossTriggerIn_TraceExtOut0,CrossTriggerIn_TraceExtOut1,CrossTriggerIn_TraceExtOut2,CrossTriggerIn_TraceExtOut3])"


(*val MemBarrierOp_of_num : integer -> MemBarrierOp*)

definition MemBarrierOp_of_num  :: " int \<Rightarrow> MemBarrierOp "  where 
     " MemBarrierOp_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then MemBarrierOp_DSB
   else if (((p00 = (( 1 :: int)::ii)))) then MemBarrierOp_DMB
   else MemBarrierOp_ISB))"


(*val num_of_MemBarrierOp : MemBarrierOp -> integer*)

fun num_of_MemBarrierOp  :: " MemBarrierOp \<Rightarrow> int "  where 
     " num_of_MemBarrierOp MemBarrierOp_DSB = ( (( 0 :: int)::ii))"
|" num_of_MemBarrierOp MemBarrierOp_DMB = ( (( 1 :: int)::ii))"
|" num_of_MemBarrierOp MemBarrierOp_ISB = ( (( 2 :: int)::ii))"


(*val undefined_MemBarrierOp : unit -> M MemBarrierOp*)

definition undefined_MemBarrierOp  :: " unit \<Rightarrow>((register_value),(MemBarrierOp),(exception))monad "  where 
     " undefined_MemBarrierOp _ = ( internal_pick [MemBarrierOp_DSB,MemBarrierOp_DMB,MemBarrierOp_ISB])"


(*val undefined_AccessDescriptor : unit -> M AccessDescriptor*)

definition undefined_AccessDescriptor  :: " unit \<Rightarrow>((register_value),(AccessDescriptor),(exception))monad "  where 
     " undefined_AccessDescriptor _ = (
   undefined_AccType ()  \<bind> (\<lambda> (w__0 :: AccType) . 
   undefined_bool ()  \<bind> (\<lambda> (w__1 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (w__2 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (w__3 :: bool) . 
   undefined_int ()  \<bind> (\<lambda> (w__4 :: ii) . 
   return ((| AccessDescriptor_acctype = w__0, 
              AccessDescriptor_page_table_walk = w__1, 
              AccessDescriptor_secondstage = w__2, 
              AccessDescriptor_s2fs1walk = w__3, 
              AccessDescriptor_level = w__4 |))))))))"


(*val undefined_Permissions : unit -> M Permissions*)

definition undefined_Permissions  :: " unit \<Rightarrow>((register_value),(Permissions),(exception))monad "  where 
     " undefined_Permissions _ = (
   (undefined_bitvector (( 3 :: int)::ii)  :: ( 3 Word.word) M) \<bind> (\<lambda> (w__0 ::  3 Word.word) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__1 ::  1 Word.word) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__2 ::  1 Word.word) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__3 ::  1 Word.word) . 
   return ((| Permissions_ap = w__0, 
              Permissions_xn = w__1, 
              Permissions_xxn = w__2, 
              Permissions_pxn = w__3 |)))))))"


(*val undefined_TLBRecord : unit -> M TLBRecord*)

definition undefined_TLBRecord  :: " unit \<Rightarrow>((register_value),(TLBRecord),(exception))monad "  where 
     " undefined_TLBRecord _ = (
   undefined_Permissions ()  \<bind> (\<lambda> (w__0 :: Permissions) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__1 ::  1 Word.word) . 
   (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (w__2 ::  4 Word.word) . 
   undefined_bool ()  \<bind> (\<lambda> (w__3 :: bool) . 
   undefined_int ()  \<bind> (\<lambda> (w__4 :: ii) . 
   undefined_int ()  \<bind> (\<lambda> (w__5 :: ii) . 
   undefined_DescriptorUpdate ()  \<bind> (\<lambda> (w__6 :: DescriptorUpdate) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__7 ::  1 Word.word) . 
   undefined_AddressDescriptor ()  \<bind> (\<lambda> (w__8 :: AddressDescriptor) . 
   return ((| TLBRecord_perms = w__0, 
              TLBRecord_nG = w__1, 
              TLBRecord_domain = w__2, 
              TLBRecord_contiguous = w__3, 
              TLBRecord_level = w__4, 
              TLBRecord_blocksize = w__5, 
              TLBRecord_descupdate = w__6, 
              TLBRecord_CnP = w__7, 
              TLBRecord_addrdesc = w__8 |))))))))))))"


(*val ImmediateOp_of_num : integer -> ImmediateOp*)

definition ImmediateOp_of_num  :: " int \<Rightarrow> ImmediateOp "  where 
     " ImmediateOp_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then ImmediateOp_MOVI
   else if (((p00 = (( 1 :: int)::ii)))) then ImmediateOp_MVNI
   else if (((p00 = (( 2 :: int)::ii)))) then ImmediateOp_ORR
   else ImmediateOp_BIC))"


(*val num_of_ImmediateOp : ImmediateOp -> integer*)

fun num_of_ImmediateOp  :: " ImmediateOp \<Rightarrow> int "  where 
     " num_of_ImmediateOp ImmediateOp_MOVI = ( (( 0 :: int)::ii))"
|" num_of_ImmediateOp ImmediateOp_MVNI = ( (( 1 :: int)::ii))"
|" num_of_ImmediateOp ImmediateOp_ORR = ( (( 2 :: int)::ii))"
|" num_of_ImmediateOp ImmediateOp_BIC = ( (( 3 :: int)::ii))"


(*val undefined_ImmediateOp : unit -> M ImmediateOp*)

definition undefined_ImmediateOp  :: " unit \<Rightarrow>((register_value),(ImmediateOp),(exception))monad "  where 
     " undefined_ImmediateOp _ = (
   internal_pick [ImmediateOp_MOVI,ImmediateOp_MVNI,ImmediateOp_ORR,ImmediateOp_BIC])"


(*val MoveWideOp_of_num : integer -> MoveWideOp*)

definition MoveWideOp_of_num  :: " int \<Rightarrow> MoveWideOp "  where 
     " MoveWideOp_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then MoveWideOp_N
   else if (((p00 = (( 1 :: int)::ii)))) then MoveWideOp_Z
   else MoveWideOp_K))"


(*val num_of_MoveWideOp : MoveWideOp -> integer*)

fun num_of_MoveWideOp  :: " MoveWideOp \<Rightarrow> int "  where 
     " num_of_MoveWideOp MoveWideOp_N = ( (( 0 :: int)::ii))"
|" num_of_MoveWideOp MoveWideOp_Z = ( (( 1 :: int)::ii))"
|" num_of_MoveWideOp MoveWideOp_K = ( (( 2 :: int)::ii))"


(*val undefined_MoveWideOp : unit -> M MoveWideOp*)

definition undefined_MoveWideOp  :: " unit \<Rightarrow>((register_value),(MoveWideOp),(exception))monad "  where 
     " undefined_MoveWideOp _ = ( internal_pick [MoveWideOp_N,MoveWideOp_Z,MoveWideOp_K])"


(*val SystemAccessType_of_num : integer -> SystemAccessType*)

definition SystemAccessType_of_num  :: " int \<Rightarrow> SystemAccessType "  where 
     " SystemAccessType_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then SystemAccessType_RT
   else if (((p00 = (( 1 :: int)::ii)))) then SystemAccessType_RRT
   else SystemAccessType_DT))"


(*val num_of_SystemAccessType : SystemAccessType -> integer*)

fun num_of_SystemAccessType  :: " SystemAccessType \<Rightarrow> int "  where 
     " num_of_SystemAccessType SystemAccessType_RT = ( (( 0 :: int)::ii))"
|" num_of_SystemAccessType SystemAccessType_RRT = ( (( 1 :: int)::ii))"
|" num_of_SystemAccessType SystemAccessType_DT = ( (( 2 :: int)::ii))"


(*val undefined_SystemAccessType : unit -> M SystemAccessType*)

definition undefined_SystemAccessType  :: " unit \<Rightarrow>((register_value),(SystemAccessType),(exception))monad "  where 
     " undefined_SystemAccessType _ = (
   internal_pick [SystemAccessType_RT,SystemAccessType_RRT,SystemAccessType_DT])"


(*val VBitOp_of_num : integer -> VBitOp*)

definition VBitOp_of_num  :: " int \<Rightarrow> VBitOp "  where 
     " VBitOp_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then VBitOp_VBIF
   else if (((p00 = (( 1 :: int)::ii)))) then VBitOp_VBIT
   else if (((p00 = (( 2 :: int)::ii)))) then VBitOp_VBSL
   else VBitOp_VEOR))"


(*val num_of_VBitOp : VBitOp -> integer*)

fun num_of_VBitOp  :: " VBitOp \<Rightarrow> int "  where 
     " num_of_VBitOp VBitOp_VBIF = ( (( 0 :: int)::ii))"
|" num_of_VBitOp VBitOp_VBIT = ( (( 1 :: int)::ii))"
|" num_of_VBitOp VBitOp_VBSL = ( (( 2 :: int)::ii))"
|" num_of_VBitOp VBitOp_VEOR = ( (( 3 :: int)::ii))"


(*val undefined_VBitOp : unit -> M VBitOp*)

definition undefined_VBitOp  :: " unit \<Rightarrow>((register_value),(VBitOp),(exception))monad "  where 
     " undefined_VBitOp _ = ( internal_pick [VBitOp_VBIF,VBitOp_VBIT,VBitOp_VBSL,VBitOp_VEOR])"


(*val TimeStamp_of_num : integer -> TimeStamp*)

definition TimeStamp_of_num  :: " int \<Rightarrow> TimeStamp "  where 
     " TimeStamp_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then TimeStamp_None
   else if (((p00 = (( 1 :: int)::ii)))) then TimeStamp_Virtual
   else TimeStamp_Physical))"


(*val num_of_TimeStamp : TimeStamp -> integer*)

fun num_of_TimeStamp  :: " TimeStamp \<Rightarrow> int "  where 
     " num_of_TimeStamp TimeStamp_None = ( (( 0 :: int)::ii))"
|" num_of_TimeStamp TimeStamp_Virtual = ( (( 1 :: int)::ii))"
|" num_of_TimeStamp TimeStamp_Physical = ( (( 2 :: int)::ii))"


(*val undefined_TimeStamp : unit -> M TimeStamp*)

definition undefined_TimeStamp  :: " unit \<Rightarrow>((register_value),(TimeStamp),(exception))monad "  where 
     " undefined_TimeStamp _ = ( internal_pick [TimeStamp_None,TimeStamp_Virtual,TimeStamp_Physical])"


(*val PrivilegeLevel_of_num : integer -> PrivilegeLevel*)

definition PrivilegeLevel_of_num  :: " int \<Rightarrow> PrivilegeLevel "  where 
     " PrivilegeLevel_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then PL3
   else if (((p00 = (( 1 :: int)::ii)))) then PL2
   else if (((p00 = (( 2 :: int)::ii)))) then PL1
   else PL0))"


(*val num_of_PrivilegeLevel : PrivilegeLevel -> integer*)

fun num_of_PrivilegeLevel  :: " PrivilegeLevel \<Rightarrow> int "  where 
     " num_of_PrivilegeLevel PL3 = ( (( 0 :: int)::ii))"
|" num_of_PrivilegeLevel PL2 = ( (( 1 :: int)::ii))"
|" num_of_PrivilegeLevel PL1 = ( (( 2 :: int)::ii))"
|" num_of_PrivilegeLevel PL0 = ( (( 3 :: int)::ii))"


(*val undefined_PrivilegeLevel : unit -> M PrivilegeLevel*)

definition undefined_PrivilegeLevel  :: " unit \<Rightarrow>((register_value),(PrivilegeLevel),(exception))monad "  where 
     " undefined_PrivilegeLevel _ = ( internal_pick [PL3,PL2,PL1,PL0])"


(*val undefined_AArch32_SErrorSyndrome : unit -> M AArch32_SErrorSyndrome*)

definition undefined_AArch32_SErrorSyndrome  :: " unit \<Rightarrow>((register_value),(AArch32_SErrorSyndrome),(exception))monad "  where 
     " undefined_AArch32_SErrorSyndrome _ = (
   (undefined_bitvector (( 2 :: int)::ii)  :: ( 2 Word.word) M) \<bind> (\<lambda> (w__0 ::  2 Word.word) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__1 ::  1 Word.word) . 
   return ((| AArch32_SErrorSyndrome_AET = w__0, 
              AArch32_SErrorSyndrome_ExT = w__1 |)))))"


(*val SystemOp_of_num : integer -> SystemOp*)

definition SystemOp_of_num  :: " int \<Rightarrow> SystemOp "  where 
     " SystemOp_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then Sys_AT
   else if (((p00 = (( 1 :: int)::ii)))) then Sys_DC
   else if (((p00 = (( 2 :: int)::ii)))) then Sys_IC
   else if (((p00 = (( 3 :: int)::ii)))) then Sys_TLBI
   else Sys_SYS))"


(*val num_of_SystemOp : SystemOp -> integer*)

fun num_of_SystemOp  :: " SystemOp \<Rightarrow> int "  where 
     " num_of_SystemOp Sys_AT = ( (( 0 :: int)::ii))"
|" num_of_SystemOp Sys_DC = ( (( 1 :: int)::ii))"
|" num_of_SystemOp Sys_IC = ( (( 2 :: int)::ii))"
|" num_of_SystemOp Sys_TLBI = ( (( 3 :: int)::ii))"
|" num_of_SystemOp Sys_SYS = ( (( 4 :: int)::ii))"


(*val undefined_SystemOp : unit -> M SystemOp*)

definition undefined_SystemOp  :: " unit \<Rightarrow>((register_value),(SystemOp),(exception))monad "  where 
     " undefined_SystemOp _ = ( internal_pick [Sys_AT,Sys_DC,Sys_IC,Sys_TLBI,Sys_SYS])"


(*val undefined_PCSample : unit -> M PCSample*)

definition undefined_PCSample  :: " unit \<Rightarrow>((register_value),(PCSample),(exception))monad "  where 
     " undefined_PCSample _ = (
   undefined_bool ()  \<bind> (\<lambda> (w__0 :: bool) . 
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   (undefined_bitvector (( 2 :: int)::ii)  :: ( 2 Word.word) M) \<bind> (\<lambda> (w__2 ::  2 Word.word) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__3 ::  1 Word.word) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__4 ::  1 Word.word) . 
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__5 ::  32 Word.word) . 
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__6 ::  32 Word.word) . 
   (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__7 ::  16 Word.word) . 
   return ((| PCSample_valid_name = w__0, 
              PCSample_pc = w__1, 
              PCSample_el = w__2, 
              PCSample_rw = w__3, 
              PCSample_ns = w__4, 
              PCSample_contextidr = w__5, 
              PCSample_contextidr_el2 = w__6, 
              PCSample_vmid = w__7 |)))))))))))"


(*val ReduceOp_of_num : integer -> ReduceOp*)

definition ReduceOp_of_num  :: " int \<Rightarrow> ReduceOp "  where 
     " ReduceOp_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then ReduceOp_FMINNUM
   else if (((p00 = (( 1 :: int)::ii)))) then ReduceOp_FMAXNUM
   else if (((p00 = (( 2 :: int)::ii)))) then ReduceOp_FMIN
   else if (((p00 = (( 3 :: int)::ii)))) then ReduceOp_FMAX
   else if (((p00 = (( 4 :: int)::ii)))) then ReduceOp_FADD
   else ReduceOp_ADD))"


(*val num_of_ReduceOp : ReduceOp -> integer*)

fun num_of_ReduceOp  :: " ReduceOp \<Rightarrow> int "  where 
     " num_of_ReduceOp ReduceOp_FMINNUM = ( (( 0 :: int)::ii))"
|" num_of_ReduceOp ReduceOp_FMAXNUM = ( (( 1 :: int)::ii))"
|" num_of_ReduceOp ReduceOp_FMIN = ( (( 2 :: int)::ii))"
|" num_of_ReduceOp ReduceOp_FMAX = ( (( 3 :: int)::ii))"
|" num_of_ReduceOp ReduceOp_FADD = ( (( 4 :: int)::ii))"
|" num_of_ReduceOp ReduceOp_ADD = ( (( 5 :: int)::ii))"


(*val undefined_ReduceOp : unit -> M ReduceOp*)

definition undefined_ReduceOp  :: " unit \<Rightarrow>((register_value),(ReduceOp),(exception))monad "  where 
     " undefined_ReduceOp _ = (
   internal_pick
     [ReduceOp_FMINNUM,ReduceOp_FMAXNUM,ReduceOp_FMIN,ReduceOp_FMAX,ReduceOp_FADD,ReduceOp_ADD])"


(*val LogicalOp_of_num : integer -> LogicalOp*)

definition LogicalOp_of_num  :: " int \<Rightarrow> LogicalOp "  where 
     " LogicalOp_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then LogicalOp_AND
   else if (((p00 = (( 1 :: int)::ii)))) then LogicalOp_EOR
   else LogicalOp_ORR))"


(*val num_of_LogicalOp : LogicalOp -> integer*)

fun num_of_LogicalOp  :: " LogicalOp \<Rightarrow> int "  where 
     " num_of_LogicalOp LogicalOp_AND = ( (( 0 :: int)::ii))"
|" num_of_LogicalOp LogicalOp_EOR = ( (( 1 :: int)::ii))"
|" num_of_LogicalOp LogicalOp_ORR = ( (( 2 :: int)::ii))"


(*val undefined_LogicalOp : unit -> M LogicalOp*)

definition undefined_LogicalOp  :: " unit \<Rightarrow>((register_value),(LogicalOp),(exception))monad "  where 
     " undefined_LogicalOp _ = ( internal_pick [LogicalOp_AND,LogicalOp_EOR,LogicalOp_ORR])"


(*val ExtendType_of_num : integer -> ExtendType*)

definition ExtendType_of_num  :: " int \<Rightarrow> ExtendType "  where 
     " ExtendType_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then ExtendType_SXTB
   else if (((p00 = (( 1 :: int)::ii)))) then ExtendType_SXTH
   else if (((p00 = (( 2 :: int)::ii)))) then ExtendType_SXTW
   else if (((p00 = (( 3 :: int)::ii)))) then ExtendType_SXTX
   else if (((p00 = (( 4 :: int)::ii)))) then ExtendType_UXTB
   else if (((p00 = (( 5 :: int)::ii)))) then ExtendType_UXTH
   else if (((p00 = (( 6 :: int)::ii)))) then ExtendType_UXTW
   else ExtendType_UXTX))"


(*val num_of_ExtendType : ExtendType -> integer*)

fun num_of_ExtendType  :: " ExtendType \<Rightarrow> int "  where 
     " num_of_ExtendType ExtendType_SXTB = ( (( 0 :: int)::ii))"
|" num_of_ExtendType ExtendType_SXTH = ( (( 1 :: int)::ii))"
|" num_of_ExtendType ExtendType_SXTW = ( (( 2 :: int)::ii))"
|" num_of_ExtendType ExtendType_SXTX = ( (( 3 :: int)::ii))"
|" num_of_ExtendType ExtendType_UXTB = ( (( 4 :: int)::ii))"
|" num_of_ExtendType ExtendType_UXTH = ( (( 5 :: int)::ii))"
|" num_of_ExtendType ExtendType_UXTW = ( (( 6 :: int)::ii))"
|" num_of_ExtendType ExtendType_UXTX = ( (( 7 :: int)::ii))"


(*val undefined_ExtendType : unit -> M ExtendType*)

definition undefined_ExtendType  :: " unit \<Rightarrow>((register_value),(ExtendType),(exception))monad "  where 
     " undefined_ExtendType _ = (
   internal_pick
     [ExtendType_SXTB,ExtendType_SXTH,ExtendType_SXTW,ExtendType_SXTX,ExtendType_UXTB,ExtendType_UXTH,ExtendType_UXTW,ExtendType_UXTX])"


(*val SystemHintOp_of_num : integer -> SystemHintOp*)

definition SystemHintOp_of_num  :: " int \<Rightarrow> SystemHintOp "  where 
     " SystemHintOp_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then SystemHintOp_NOP
   else if (((p00 = (( 1 :: int)::ii)))) then SystemHintOp_YIELD
   else if (((p00 = (( 2 :: int)::ii)))) then SystemHintOp_WFE
   else if (((p00 = (( 3 :: int)::ii)))) then SystemHintOp_WFI
   else if (((p00 = (( 4 :: int)::ii)))) then SystemHintOp_SEV
   else if (((p00 = (( 5 :: int)::ii)))) then SystemHintOp_SEVL
   else if (((p00 = (( 6 :: int)::ii)))) then SystemHintOp_ESB
   else SystemHintOp_PSB))"


(*val num_of_SystemHintOp : SystemHintOp -> integer*)

fun num_of_SystemHintOp  :: " SystemHintOp \<Rightarrow> int "  where 
     " num_of_SystemHintOp SystemHintOp_NOP = ( (( 0 :: int)::ii))"
|" num_of_SystemHintOp SystemHintOp_YIELD = ( (( 1 :: int)::ii))"
|" num_of_SystemHintOp SystemHintOp_WFE = ( (( 2 :: int)::ii))"
|" num_of_SystemHintOp SystemHintOp_WFI = ( (( 3 :: int)::ii))"
|" num_of_SystemHintOp SystemHintOp_SEV = ( (( 4 :: int)::ii))"
|" num_of_SystemHintOp SystemHintOp_SEVL = ( (( 5 :: int)::ii))"
|" num_of_SystemHintOp SystemHintOp_ESB = ( (( 6 :: int)::ii))"
|" num_of_SystemHintOp SystemHintOp_PSB = ( (( 7 :: int)::ii))"


(*val undefined_SystemHintOp : unit -> M SystemHintOp*)

definition undefined_SystemHintOp  :: " unit \<Rightarrow>((register_value),(SystemHintOp),(exception))monad "  where 
     " undefined_SystemHintOp _ = (
   internal_pick
     [SystemHintOp_NOP,SystemHintOp_YIELD,SystemHintOp_WFE,SystemHintOp_WFI,SystemHintOp_SEV,SystemHintOp_SEVL,SystemHintOp_ESB,SystemHintOp_PSB])"


(*val MemOp_of_num : integer -> MemOp*)

definition MemOp_of_num  :: " int \<Rightarrow> MemOp "  where 
     " MemOp_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then MemOp_LOAD
   else if (((p00 = (( 1 :: int)::ii)))) then MemOp_STORE
   else MemOp_PREFETCH))"


(*val num_of_MemOp : MemOp -> integer*)

fun num_of_MemOp  :: " MemOp \<Rightarrow> int "  where 
     " num_of_MemOp MemOp_LOAD = ( (( 0 :: int)::ii))"
|" num_of_MemOp MemOp_STORE = ( (( 1 :: int)::ii))"
|" num_of_MemOp MemOp_PREFETCH = ( (( 2 :: int)::ii))"


(*val undefined_MemOp : unit -> M MemOp*)

definition undefined_MemOp  :: " unit \<Rightarrow>((register_value),(MemOp),(exception))monad "  where 
     " undefined_MemOp _ = ( internal_pick [MemOp_LOAD,MemOp_STORE,MemOp_PREFETCH])"


(*val OpType_of_num : integer -> OpType*)

definition OpType_of_num  :: " int \<Rightarrow> OpType "  where 
     " OpType_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then OpType_Load
   else if (((p00 = (( 1 :: int)::ii)))) then OpType_Store
   else if (((p00 = (( 2 :: int)::ii)))) then OpType_LoadAtomic
   else if (((p00 = (( 3 :: int)::ii)))) then OpType_Branch
   else OpType_Other))"


(*val num_of_OpType : OpType -> integer*)

fun num_of_OpType  :: " OpType \<Rightarrow> int "  where 
     " num_of_OpType OpType_Load = ( (( 0 :: int)::ii))"
|" num_of_OpType OpType_Store = ( (( 1 :: int)::ii))"
|" num_of_OpType OpType_LoadAtomic = ( (( 2 :: int)::ii))"
|" num_of_OpType OpType_Branch = ( (( 3 :: int)::ii))"
|" num_of_OpType OpType_Other = ( (( 4 :: int)::ii))"


(*val undefined_OpType : unit -> M OpType*)

definition undefined_OpType  :: " unit \<Rightarrow>((register_value),(OpType),(exception))monad "  where 
     " undefined_OpType _ = (
   internal_pick [OpType_Load,OpType_Store,OpType_LoadAtomic,OpType_Branch,OpType_Other])"


(*val FPUnaryOp_of_num : integer -> FPUnaryOp*)

definition FPUnaryOp_of_num  :: " int \<Rightarrow> FPUnaryOp "  where 
     " FPUnaryOp_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then FPUnaryOp_ABS
   else if (((p00 = (( 1 :: int)::ii)))) then FPUnaryOp_MOV
   else if (((p00 = (( 2 :: int)::ii)))) then FPUnaryOp_NEG
   else FPUnaryOp_SQRT))"


(*val num_of_FPUnaryOp : FPUnaryOp -> integer*)

fun num_of_FPUnaryOp  :: " FPUnaryOp \<Rightarrow> int "  where 
     " num_of_FPUnaryOp FPUnaryOp_ABS = ( (( 0 :: int)::ii))"
|" num_of_FPUnaryOp FPUnaryOp_MOV = ( (( 1 :: int)::ii))"
|" num_of_FPUnaryOp FPUnaryOp_NEG = ( (( 2 :: int)::ii))"
|" num_of_FPUnaryOp FPUnaryOp_SQRT = ( (( 3 :: int)::ii))"


(*val undefined_FPUnaryOp : unit -> M FPUnaryOp*)

definition undefined_FPUnaryOp  :: " unit \<Rightarrow>((register_value),(FPUnaryOp),(exception))monad "  where 
     " undefined_FPUnaryOp _ = (
   internal_pick [FPUnaryOp_ABS,FPUnaryOp_MOV,FPUnaryOp_NEG,FPUnaryOp_SQRT])"


(*val CompareOp_of_num : integer -> CompareOp*)

definition CompareOp_of_num  :: " int \<Rightarrow> CompareOp "  where 
     " CompareOp_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then CompareOp_GT
   else if (((p00 = (( 1 :: int)::ii)))) then CompareOp_GE
   else if (((p00 = (( 2 :: int)::ii)))) then CompareOp_EQ
   else if (((p00 = (( 3 :: int)::ii)))) then CompareOp_LE
   else CompareOp_LT))"


(*val num_of_CompareOp : CompareOp -> integer*)

fun num_of_CompareOp  :: " CompareOp \<Rightarrow> int "  where 
     " num_of_CompareOp CompareOp_GT = ( (( 0 :: int)::ii))"
|" num_of_CompareOp CompareOp_GE = ( (( 1 :: int)::ii))"
|" num_of_CompareOp CompareOp_EQ = ( (( 2 :: int)::ii))"
|" num_of_CompareOp CompareOp_LE = ( (( 3 :: int)::ii))"
|" num_of_CompareOp CompareOp_LT = ( (( 4 :: int)::ii))"


(*val undefined_CompareOp : unit -> M CompareOp*)

definition undefined_CompareOp  :: " unit \<Rightarrow>((register_value),(CompareOp),(exception))monad "  where 
     " undefined_CompareOp _ = (
   internal_pick [CompareOp_GT,CompareOp_GE,CompareOp_EQ,CompareOp_LE,CompareOp_LT])"


(*val PSTATEField_of_num : integer -> PSTATEField*)

definition PSTATEField_of_num  :: " int \<Rightarrow> PSTATEField "  where 
     " PSTATEField_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then PSTATEField_DAIFSet
   else if (((p00 = (( 1 :: int)::ii)))) then PSTATEField_DAIFClr
   else if (((p00 = (( 2 :: int)::ii)))) then PSTATEField_PAN
   else if (((p00 = (( 3 :: int)::ii)))) then PSTATEField_UAO
   else PSTATEField_SP))"


(*val num_of_PSTATEField : PSTATEField -> integer*)

fun num_of_PSTATEField  :: " PSTATEField \<Rightarrow> int "  where 
     " num_of_PSTATEField PSTATEField_DAIFSet = ( (( 0 :: int)::ii))"
|" num_of_PSTATEField PSTATEField_DAIFClr = ( (( 1 :: int)::ii))"
|" num_of_PSTATEField PSTATEField_PAN = ( (( 2 :: int)::ii))"
|" num_of_PSTATEField PSTATEField_UAO = ( (( 3 :: int)::ii))"
|" num_of_PSTATEField PSTATEField_SP = ( (( 4 :: int)::ii))"


(*val undefined_PSTATEField : unit -> M PSTATEField*)

definition undefined_PSTATEField  :: " unit \<Rightarrow>((register_value),(PSTATEField),(exception))monad "  where 
     " undefined_PSTATEField _ = (
   internal_pick
     [PSTATEField_DAIFSet,PSTATEField_DAIFClr,PSTATEField_PAN,PSTATEField_UAO,PSTATEField_SP])"


(*val FPMaxMinOp_of_num : integer -> FPMaxMinOp*)

definition FPMaxMinOp_of_num  :: " int \<Rightarrow> FPMaxMinOp "  where 
     " FPMaxMinOp_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then FPMaxMinOp_MAX
   else if (((p00 = (( 1 :: int)::ii)))) then FPMaxMinOp_MIN
   else if (((p00 = (( 2 :: int)::ii)))) then FPMaxMinOp_MAXNUM
   else FPMaxMinOp_MINNUM))"


(*val num_of_FPMaxMinOp : FPMaxMinOp -> integer*)

fun num_of_FPMaxMinOp  :: " FPMaxMinOp \<Rightarrow> int "  where 
     " num_of_FPMaxMinOp FPMaxMinOp_MAX = ( (( 0 :: int)::ii))"
|" num_of_FPMaxMinOp FPMaxMinOp_MIN = ( (( 1 :: int)::ii))"
|" num_of_FPMaxMinOp FPMaxMinOp_MAXNUM = ( (( 2 :: int)::ii))"
|" num_of_FPMaxMinOp FPMaxMinOp_MINNUM = ( (( 3 :: int)::ii))"


(*val undefined_FPMaxMinOp : unit -> M FPMaxMinOp*)

definition undefined_FPMaxMinOp  :: " unit \<Rightarrow>((register_value),(FPMaxMinOp),(exception))monad "  where 
     " undefined_FPMaxMinOp _ = (
   internal_pick [FPMaxMinOp_MAX,FPMaxMinOp_MIN,FPMaxMinOp_MAXNUM,FPMaxMinOp_MINNUM])"


(*val CountOp_of_num : integer -> CountOp*)

definition CountOp_of_num  :: " int \<Rightarrow> CountOp "  where 
     " CountOp_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then CountOp_CLZ
   else if (((p00 = (( 1 :: int)::ii)))) then CountOp_CLS
   else CountOp_CNT))"


(*val num_of_CountOp : CountOp -> integer*)

fun num_of_CountOp  :: " CountOp \<Rightarrow> int "  where 
     " num_of_CountOp CountOp_CLZ = ( (( 0 :: int)::ii))"
|" num_of_CountOp CountOp_CLS = ( (( 1 :: int)::ii))"
|" num_of_CountOp CountOp_CNT = ( (( 2 :: int)::ii))"


(*val undefined_CountOp : unit -> M CountOp*)

definition undefined_CountOp  :: " unit \<Rightarrow>((register_value),(CountOp),(exception))monad "  where 
     " undefined_CountOp _ = ( internal_pick [CountOp_CLZ,CountOp_CLS,CountOp_CNT])"


(*val VFPNegMul_of_num : integer -> VFPNegMul*)

definition VFPNegMul_of_num  :: " int \<Rightarrow> VFPNegMul "  where 
     " VFPNegMul_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then VFPNegMul_VNMLA
   else if (((p00 = (( 1 :: int)::ii)))) then VFPNegMul_VNMLS
   else VFPNegMul_VNMUL))"


(*val num_of_VFPNegMul : VFPNegMul -> integer*)

fun num_of_VFPNegMul  :: " VFPNegMul \<Rightarrow> int "  where 
     " num_of_VFPNegMul VFPNegMul_VNMLA = ( (( 0 :: int)::ii))"
|" num_of_VFPNegMul VFPNegMul_VNMLS = ( (( 1 :: int)::ii))"
|" num_of_VFPNegMul VFPNegMul_VNMUL = ( (( 2 :: int)::ii))"


(*val undefined_VFPNegMul : unit -> M VFPNegMul*)

definition undefined_VFPNegMul  :: " unit \<Rightarrow>((register_value),(VFPNegMul),(exception))monad "  where 
     " undefined_VFPNegMul _ = ( internal_pick [VFPNegMul_VNMLA,VFPNegMul_VNMLS,VFPNegMul_VNMUL])"


(*val VBitOps_of_num : integer -> VBitOps*)

definition VBitOps_of_num  :: " int \<Rightarrow> VBitOps "  where 
     " VBitOps_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then VBitOps_VBIF
   else if (((p00 = (( 1 :: int)::ii)))) then VBitOps_VBIT
   else VBitOps_VBSL))"


(*val num_of_VBitOps : VBitOps -> integer*)

fun num_of_VBitOps  :: " VBitOps \<Rightarrow> int "  where 
     " num_of_VBitOps VBitOps_VBIF = ( (( 0 :: int)::ii))"
|" num_of_VBitOps VBitOps_VBIT = ( (( 1 :: int)::ii))"
|" num_of_VBitOps VBitOps_VBSL = ( (( 2 :: int)::ii))"


(*val undefined_VBitOps : unit -> M VBitOps*)

definition undefined_VBitOps  :: " unit \<Rightarrow>((register_value),(VBitOps),(exception))monad "  where 
     " undefined_VBitOps _ = ( internal_pick [VBitOps_VBIF,VBitOps_VBIT,VBitOps_VBSL])"


(*val VCGEtype_of_num : integer -> VCGEtype*)

definition VCGEtype_of_num  :: " int \<Rightarrow> VCGEtype "  where 
     " VCGEtype_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then VCGEtype_signed
   else if (((p00 = (( 1 :: int)::ii)))) then VCGEtype_unsigned
   else VCGEtype_fp))"


(*val num_of_VCGEtype : VCGEtype -> integer*)

fun num_of_VCGEtype  :: " VCGEtype \<Rightarrow> int "  where 
     " num_of_VCGEtype VCGEtype_signed = ( (( 0 :: int)::ii))"
|" num_of_VCGEtype VCGEtype_unsigned = ( (( 1 :: int)::ii))"
|" num_of_VCGEtype VCGEtype_fp = ( (( 2 :: int)::ii))"


(*val undefined_VCGEtype : unit -> M VCGEtype*)

definition undefined_VCGEtype  :: " unit \<Rightarrow>((register_value),(VCGEtype),(exception))monad "  where 
     " undefined_VCGEtype _ = ( internal_pick [VCGEtype_signed,VCGEtype_unsigned,VCGEtype_fp])"


(*val VCGTtype_of_num : integer -> VCGTtype*)

definition VCGTtype_of_num  :: " int \<Rightarrow> VCGTtype "  where 
     " VCGTtype_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then VCGTtype_signed
   else if (((p00 = (( 1 :: int)::ii)))) then VCGTtype_unsigned
   else VCGTtype_fp))"


(*val num_of_VCGTtype : VCGTtype -> integer*)

fun num_of_VCGTtype  :: " VCGTtype \<Rightarrow> int "  where 
     " num_of_VCGTtype VCGTtype_signed = ( (( 0 :: int)::ii))"
|" num_of_VCGTtype VCGTtype_unsigned = ( (( 1 :: int)::ii))"
|" num_of_VCGTtype VCGTtype_fp = ( (( 2 :: int)::ii))"


(*val undefined_VCGTtype : unit -> M VCGTtype*)

definition undefined_VCGTtype  :: " unit \<Rightarrow>((register_value),(VCGTtype),(exception))monad "  where 
     " undefined_VCGTtype _ = ( internal_pick [VCGTtype_signed,VCGTtype_unsigned,VCGTtype_fp])"


(*val __InstrEnc_of_num : integer -> __InstrEnc*)

definition InstrEnc_of_num  :: " int \<Rightarrow> InstrEnc "  where 
     " InstrEnc_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then A64
   else if (((p00 = (( 1 :: int)::ii)))) then A32
   else if (((p00 = (( 2 :: int)::ii)))) then T16
   else T32))"


(*val num_of___InstrEnc : __InstrEnc -> integer*)

fun num_of___InstrEnc  :: " InstrEnc \<Rightarrow> int "  where 
     " num_of___InstrEnc A64 = ( (( 0 :: int)::ii))"
|" num_of___InstrEnc A32 = ( (( 1 :: int)::ii))"
|" num_of___InstrEnc T16 = ( (( 2 :: int)::ii))"
|" num_of___InstrEnc T32 = ( (( 3 :: int)::ii))"


(*val undefined___InstrEnc : unit -> M __InstrEnc*)

definition undefined___InstrEnc  :: " unit \<Rightarrow>((register_value),(InstrEnc),(exception))monad "  where 
     " undefined___InstrEnc _ = ( internal_pick [A64,A32,T16,T32])"


(*val AArch64_CheckAndUpdateDescriptor_SecondStage : DescriptorUpdate -> FaultRecord -> mword ty64 -> AccType -> bool -> bool -> bool -> M FaultRecord*)

(*val AArch64_TranslationTableWalk_SecondStage : mword ty52 -> mword ty64 -> AccType -> bool -> bool -> ii -> M TLBRecord*)

(*val AArch64_SecondStageTranslate : AddressDescriptor -> mword ty64 -> AccType -> bool -> bool -> bool -> ii -> bool -> M AddressDescriptor*)

(*val AArch64_CheckAndUpdateDescriptor : DescriptorUpdate -> FaultRecord -> bool -> mword ty64 -> AccType -> bool -> bool -> bool -> M FaultRecord*)

(*val __UNKNOWN_real : unit -> real*)

definition UNKNOWN_real  :: " unit \<Rightarrow> real "  where 
     " UNKNOWN_real _ = ( (realFromFrac(( 0 :: int))(( 10 :: int))))"


(*val __UNKNOWN_integer : unit -> ii*)

definition UNKNOWN_integer  :: " unit \<Rightarrow> int "  where 
     " UNKNOWN_integer _ = ( (( 0 :: int)::ii))"


(*val aget_PC : unit -> M (mword ty64)*)

definition aget_PC  :: " unit \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " aget_PC _ = ( (read_reg PC_ref  :: ( 64 Word.word) M))"


(*val UndefinedFault : unit -> M unit*)

definition UndefinedFault  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " UndefinedFault _ = ( assert_exp False (''Undefined fault''))"


(*val ThisInstrAddr : forall 'N . Size 'N => integer -> unit -> M (mword 'N)*)

definition ThisInstrAddr  :: " int \<Rightarrow> unit \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " ThisInstrAddr (N__tv :: int) _ = (
   (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 :: 64 bits) . 
   return ((slice w__0 (( 0 :: int)::ii) N__tv  :: ( 'N::len)Word.word))))"


(*val ThisInstr : unit -> M (mword ty32)*)

definition ThisInstr0  :: " unit \<Rightarrow>((register_value),((32)Word.word),(exception))monad "  where 
     " ThisInstr0 _ = ( (read_reg ThisInstr_ref  :: ( 32 Word.word) M))"


(*val __UNKNOWN_SystemHintOp : unit -> SystemHintOp*)

definition UNKNOWN_SystemHintOp  :: " unit \<Rightarrow> SystemHintOp "  where 
     " UNKNOWN_SystemHintOp _ = ( SystemHintOp_NOP )"


(*val SynchronizeContext : unit -> unit*)

definition SynchronizeContext  :: " unit \<Rightarrow> unit "  where 
     " SynchronizeContext _ = ( ()  )"


(*val SErrorPending : unit -> M bool*)

definition SErrorPending  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " SErrorPending _ = ( read_reg PendingPhysicalSError_ref )"


(*val ResetExternalDebugRegisters : bool -> unit*)

definition ResetExternalDebugRegisters  :: " bool \<Rightarrow> unit "  where 
     " ResetExternalDebugRegisters cold_reset = ( ()  )"


(*val ProfilingSynchronizationBarrier : unit -> unit*)

definition ProfilingSynchronizationBarrier  :: " unit \<Rightarrow> unit "  where 
     " ProfilingSynchronizationBarrier _ = ( ()  )"


(*val ProcessorID : unit -> ii*)

definition ProcessorID  :: " unit \<Rightarrow> int "  where 
     " ProcessorID _ = ( (( 0 :: int)::ii))"


(*val __UNKNOWN_PrefetchHint : unit -> PrefetchHint*)

definition UNKNOWN_PrefetchHint  :: " unit \<Rightarrow> PrefetchHint "  where 
     " UNKNOWN_PrefetchHint _ = ( Prefetch_READ )"


(*val __UNKNOWN_PSTATEField : unit -> PSTATEField*)

definition UNKNOWN_PSTATEField  :: " unit \<Rightarrow> PSTATEField "  where 
     " UNKNOWN_PSTATEField _ = ( PSTATEField_DAIFSet )"


(*val PACCellShuffle : mword ty64 -> M (mword ty64)*)

definition PACCellShuffle  :: "(64)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " PACCellShuffle indata = (
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (outdata :: 64 bits) . 
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 0 :: int)::ii) ((slice indata (( 52 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 4 :: int)::ii) ((slice indata (( 24 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 8 :: int)::ii) ((slice indata (( 44 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 12 :: int)::ii) ((slice indata (( 0 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 16 :: int)::ii) ((slice indata (( 28 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 20 :: int)::ii) ((slice indata (( 48 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 24 :: int)::ii) ((slice indata (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 28 :: int)::ii) ((slice indata (( 40 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 32 :: int)::ii) ((slice indata (( 32 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 36 :: int)::ii) ((slice indata (( 12 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 40 :: int)::ii) ((slice indata (( 56 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 44 :: int)::ii) ((slice indata (( 20 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 48 :: int)::ii) ((slice indata (( 8 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 52 :: int)::ii) ((slice indata (( 36 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 56 :: int)::ii) ((slice indata (( 16 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 60 :: int)::ii) ((slice indata (( 60 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   return outdata))))))))))))))))))"


(*val PACCellInvShuffle : mword ty64 -> M (mword ty64)*)

definition PACCellInvShuffle  :: "(64)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " PACCellInvShuffle indata = (
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (outdata :: 64 bits) . 
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 0 :: int)::ii) ((slice indata (( 12 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 4 :: int)::ii) ((slice indata (( 24 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 8 :: int)::ii) ((slice indata (( 48 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 12 :: int)::ii) ((slice indata (( 36 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 16 :: int)::ii) ((slice indata (( 56 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 20 :: int)::ii) ((slice indata (( 44 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 24 :: int)::ii) ((slice indata (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 28 :: int)::ii) ((slice indata (( 16 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 32 :: int)::ii) ((slice indata (( 32 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 36 :: int)::ii) ((slice indata (( 52 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 40 :: int)::ii) ((slice indata (( 28 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 44 :: int)::ii) ((slice indata (( 8 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 48 :: int)::ii) ((slice indata (( 20 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 52 :: int)::ii) ((slice indata (( 0 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 56 :: int)::ii) ((slice indata (( 40 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 60 :: int)::ii) ((slice indata (( 60 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   return outdata))))))))))))))))))"


(*val __UNKNOWN_MoveWideOp : unit -> MoveWideOp*)

definition UNKNOWN_MoveWideOp  :: " unit \<Rightarrow> MoveWideOp "  where 
     " UNKNOWN_MoveWideOp _ = ( MoveWideOp_N )"


(*val __UNKNOWN_MemType : unit -> MemType*)

definition UNKNOWN_MemType  :: " unit \<Rightarrow> MemType "  where 
     " UNKNOWN_MemType _ = ( MemType_Normal )"


(*val __UNKNOWN_MemOp : unit -> MemOp*)

definition UNKNOWN_MemOp  :: " unit \<Rightarrow> MemOp "  where 
     " UNKNOWN_MemOp _ = ( MemOp_LOAD )"


definition MemHint_RWA  :: "(2)Word.word "  where 
     " MemHint_RWA = ( (vec_of_bits [B1,B1]  ::  2 Word.word))"


definition MemHint_RA  :: "(2)Word.word "  where 
     " MemHint_RA = ( (vec_of_bits [B1,B0]  ::  2 Word.word))"


definition MemHint_No  :: "(2)Word.word "  where 
     " MemHint_No = ( (vec_of_bits [B0,B0]  ::  2 Word.word))"


(*val __UNKNOWN_MemBarrierOp : unit -> MemBarrierOp*)

definition UNKNOWN_MemBarrierOp  :: " unit \<Rightarrow> MemBarrierOp "  where 
     " UNKNOWN_MemBarrierOp _ = ( MemBarrierOp_DSB )"


definition MemAttr_WT  :: "(2)Word.word "  where 
     " MemAttr_WT = ( (vec_of_bits [B1,B0]  ::  2 Word.word))"


definition MemAttr_WB  :: "(2)Word.word "  where 
     " MemAttr_WB = ( (vec_of_bits [B1,B1]  ::  2 Word.word))"


definition MemAttr_NC  :: "(2)Word.word "  where 
     " MemAttr_NC = ( (vec_of_bits [B0,B0]  ::  2 Word.word))"


(*val __UNKNOWN_MemAtomicOp : unit -> MemAtomicOp*)

definition UNKNOWN_MemAtomicOp  :: " unit \<Rightarrow> MemAtomicOp "  where 
     " UNKNOWN_MemAtomicOp _ = ( MemAtomicOp_ADD )"


(*val __UNKNOWN_MBReqTypes : unit -> MBReqTypes*)

definition UNKNOWN_MBReqTypes  :: " unit \<Rightarrow> MBReqTypes "  where 
     " UNKNOWN_MBReqTypes _ = ( MBReqTypes_Reads )"


(*val __UNKNOWN_MBReqDomain : unit -> MBReqDomain*)

definition UNKNOWN_MBReqDomain  :: " unit \<Rightarrow> MBReqDomain "  where 
     " UNKNOWN_MBReqDomain _ = ( MBReqDomain_Nonshareable )"


definition M32_User  :: "(5)Word.word "  where 
     " M32_User = ( (vec_of_bits [B1,B0,B0,B0,B0]  ::  5 Word.word))"


definition M32_Undef  :: "(5)Word.word "  where 
     " M32_Undef = ( (vec_of_bits [B1,B1,B0,B1,B1]  ::  5 Word.word))"


definition M32_System  :: "(5)Word.word "  where 
     " M32_System = ( (vec_of_bits [B1,B1,B1,B1,B1]  ::  5 Word.word))"


definition M32_Svc  :: "(5)Word.word "  where 
     " M32_Svc = ( (vec_of_bits [B1,B0,B0,B1,B1]  ::  5 Word.word))"


definition M32_Monitor  :: "(5)Word.word "  where 
     " M32_Monitor = ( (vec_of_bits [B1,B0,B1,B1,B0]  ::  5 Word.word))"


definition M32_IRQ  :: "(5)Word.word "  where 
     " M32_IRQ = ( (vec_of_bits [B1,B0,B0,B1,B0]  ::  5 Word.word))"


definition M32_Hyp  :: "(5)Word.word "  where 
     " M32_Hyp = ( (vec_of_bits [B1,B1,B0,B1,B0]  ::  5 Word.word))"


definition M32_FIQ  :: "(5)Word.word "  where 
     " M32_FIQ = ( (vec_of_bits [B1,B0,B0,B0,B1]  ::  5 Word.word))"


definition M32_Abort  :: "(5)Word.word "  where 
     " M32_Abort = ( (vec_of_bits [B1,B0,B1,B1,B1]  ::  5 Word.word))"


(*val __UNKNOWN_LogicalOp : unit -> LogicalOp*)

definition UNKNOWN_LogicalOp  :: " unit \<Rightarrow> LogicalOp "  where 
     " UNKNOWN_LogicalOp _ = ( LogicalOp_AND )"


(*val IsExclusiveLocal : FullAddress -> ii -> ii -> M bool*)

definition IsExclusiveLocal  :: " FullAddress \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " IsExclusiveLocal paddress processorid size1 = ( read_reg ExclusiveLocal_ref )"


(*val InterruptPending : unit -> M bool*)

definition InterruptPending  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " InterruptPending _ = ( read_reg PendingInterrupt_ref )"


(*val asl_Int : forall 'N . Size 'N => mword 'N -> bool -> ii*)

definition asl_Int  :: "('N::len)Word.word \<Rightarrow> bool \<Rightarrow> int "  where 
     " asl_Int x unsigned = ( if unsigned then Word.uint x else Word.sint x )"


(*val InstructionSynchronizationBarrier : unit -> unit*)

definition InstructionSynchronizationBarrier  :: " unit \<Rightarrow> unit "  where 
     " InstructionSynchronizationBarrier _ = ( ()  )"


(*val __UNKNOWN_InstrSet : unit -> InstrSet*)

definition UNKNOWN_InstrSet  :: " unit \<Rightarrow> InstrSet "  where 
     " UNKNOWN_InstrSet _ = ( InstrSet_A64 )"


(*val Hint_Yield : unit -> unit*)

definition Hint_Yield  :: " unit \<Rightarrow> unit "  where 
     " Hint_Yield _ = ( ()  )"


(*val Hint_Prefetch : mword ty64 -> PrefetchHint -> ii -> bool -> unit*)

definition Hint_Prefetch  :: "(64)Word.word \<Rightarrow> PrefetchHint \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> unit "  where 
     " Hint_Prefetch address hint target stream = ( ()  )"


(*val Hint_Branch : BranchType -> unit*)

definition Hint_Branch  :: " BranchType \<Rightarrow> unit "  where 
     " Hint_Branch hint = ( ()  )"


(*val HaveFP16Ext : unit -> bool*)

definition HaveFP16Ext  :: " unit \<Rightarrow> bool "  where 
     " HaveFP16Ext _ = ( True )"


(*val HaveAnyAArch32 : unit -> bool*)

definition HaveAnyAArch32  :: " unit \<Rightarrow> bool "  where 
     " HaveAnyAArch32 _ = ( False )"


(*val __UNKNOWN_Fault : unit -> Fault*)

definition UNKNOWN_Fault  :: " unit \<Rightarrow> Fault "  where 
     " UNKNOWN_Fault _ = ( Fault_None )"


(*val __UNKNOWN_FPUnaryOp : unit -> FPUnaryOp*)

definition UNKNOWN_FPUnaryOp  :: " unit \<Rightarrow> FPUnaryOp "  where 
     " UNKNOWN_FPUnaryOp _ = ( FPUnaryOp_ABS )"


(*val __UNKNOWN_FPType : unit -> FPType*)

definition UNKNOWN_FPType  :: " unit \<Rightarrow> FPType "  where 
     " UNKNOWN_FPType _ = ( FPType_Nonzero )"


(*val __UNKNOWN_FPRounding : unit -> FPRounding*)

definition UNKNOWN_FPRounding  :: " unit \<Rightarrow> FPRounding "  where 
     " UNKNOWN_FPRounding _ = ( FPRounding_TIEEVEN )"


(*val __UNKNOWN_FPMaxMinOp : unit -> FPMaxMinOp*)

definition UNKNOWN_FPMaxMinOp  :: " unit \<Rightarrow> FPMaxMinOp "  where 
     " UNKNOWN_FPMaxMinOp _ = ( FPMaxMinOp_MAX )"


(*val FPDecodeRounding : mword ty2 -> FPRounding*)

definition FPDecodeRounding  :: "(2)Word.word \<Rightarrow> FPRounding "  where 
     " FPDecodeRounding rmode = (
   (let b__0 = rmode in
   if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then FPRounding_TIEEVEN
   else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then FPRounding_POSINF
   else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then FPRounding_NEGINF
   else FPRounding_ZERO))"


(*val FPRoundingMode : mword ty32 -> FPRounding*)

definition FPRoundingMode  :: "(32)Word.word \<Rightarrow> FPRounding "  where 
     " FPRoundingMode fpcr = ( FPDecodeRounding ((slice fpcr (( 22 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)))"


(*val __UNKNOWN_FPConvOp : unit -> FPConvOp*)

definition UNKNOWN_FPConvOp  :: " unit \<Rightarrow> FPConvOp "  where 
     " UNKNOWN_FPConvOp _ = ( FPConvOp_CVT_FtoI )"


(*val __UNKNOWN_boolean : unit -> bool*)

definition UNKNOWN_boolean  :: " unit \<Rightarrow> bool "  where 
     " UNKNOWN_boolean _ = ( False )"


(*val __ResetInterruptState : unit -> M unit*)

definition ResetInterruptState  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " ResetInterruptState _ = (
   write_reg PendingPhysicalSError_ref False \<then> write_reg PendingInterrupt_ref False )"


(*val __ResetExecuteState : unit -> M unit*)

definition ResetExecuteState  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " ResetExecuteState _ = ( write_reg Sleeping_ref False )"


(*val Unreachable : unit -> M unit*)

definition Unreachable  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " Unreachable _ = ( assert_exp False (''FALSE''))"


(*val RBankSelect : mword ty5 -> ii -> ii -> ii -> ii -> ii -> ii -> ii -> M ii*)

definition RBankSelect  :: "(5)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(int),(exception))monad "  where 
     " RBankSelect mode usr fiq irq svc abt und hyp = (
   undefined_int ()  \<bind> (\<lambda> (result :: ii) . 
   (let pat0 = mode in
   if (((pat0 = M32_User))) then return usr
   else if (((pat0 = M32_FIQ))) then return fiq
   else if (((pat0 = M32_IRQ))) then return irq
   else if (((pat0 = M32_Svc))) then return svc
   else if (((pat0 = M32_Abort))) then return abt
   else if (((pat0 = M32_Hyp))) then return hyp
   else if (((pat0 = M32_Undef))) then return und
   else if (((pat0 = M32_System))) then return usr
   else Unreachable ()  \<then> return result)))"


(*val TakeUnmaskedSErrorInterrupts : unit -> M unit*)

definition TakeUnmaskedSErrorInterrupts  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " TakeUnmaskedSErrorInterrupts _ = ( assert_exp False (''FALSE''))"


(*val TakeUnmaskedPhysicalSErrorInterrupts : bool -> M unit*)

definition TakeUnmaskedPhysicalSErrorInterrupts  :: " bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " TakeUnmaskedPhysicalSErrorInterrupts iesb_req = ( assert_exp False (''FALSE''))"


(*val StopInstructionPrefetchAndEnableITR : unit -> M unit*)

definition StopInstructionPrefetchAndEnableITR  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " StopInstructionPrefetchAndEnableITR _ = ( assert_exp False (''FALSE''))"


(*val SendEvent : unit -> M unit*)

definition SendEvent  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " SendEvent _ = ( assert_exp False (''FALSE''))"


(*val MarkExclusiveLocal : FullAddress -> ii -> ii -> M unit*)

definition MarkExclusiveLocal  :: " FullAddress \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " MarkExclusiveLocal paddress processorid size1 = ( write_reg ExclusiveLocal_ref False )"


(*val MarkExclusiveGlobal : FullAddress -> ii -> ii -> M unit*)

definition MarkExclusiveGlobal  :: " FullAddress \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " MarkExclusiveGlobal paddress processorid size1 = ( assert_exp False (''FALSE''))"


(*val IsExclusiveGlobal : FullAddress -> ii -> ii -> M bool*)

definition IsExclusiveGlobal  :: " FullAddress \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " IsExclusiveGlobal paddress processorid size1 = ( assert_exp False (''FALSE'') \<then> return False )"


(*val ExclusiveMonitorsStatus : unit -> M (mword ty1)*)

definition ExclusiveMonitorsStatus  :: " unit \<Rightarrow>((register_value),((1)Word.word),(exception))monad "  where 
     " ExclusiveMonitorsStatus _ = ( assert_exp False (''FALSE'') \<then> return (vec_of_bits [B0]  ::  1 Word.word))"


(*val __UNKNOWN_Exception : unit -> Exception*)

definition UNKNOWN_Exception  :: " unit \<Rightarrow> Exception "  where 
     " UNKNOWN_Exception _ = ( Exception_Uncategorized )"


(*val SendEventLocal : unit -> M unit*)

definition SendEventLocal  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " SendEventLocal _ = ( write_reg EventRegister_ref (vec_of_bits [B1]  ::  1 Word.word))"


(*val ErrorSynchronizationBarrier : MBReqDomain -> MBReqTypes -> unit*)

definition ErrorSynchronizationBarrier  :: " MBReqDomain \<Rightarrow> MBReqTypes \<Rightarrow> unit "  where 
     " ErrorSynchronizationBarrier domain1 types1 = ( ()  )"


(*val EnterLowPowerState : unit -> M unit*)

definition EnterLowPowerState  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " EnterLowPowerState _ = ( write_reg Sleeping_ref True )"


(*val WaitForInterrupt : unit -> M unit*)

definition WaitForInterrupt  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " WaitForInterrupt _ = ( EnterLowPowerState ()  )"


(*val EndOfInstruction : unit -> M unit*)

definition EndOfInstruction  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " EndOfInstruction _ = ( throw (Error_ExceptionTaken () ))"


(*val TweakCellRot : mword ty4 -> M (mword ty4)*)

definition TweakCellRot  :: "(4)Word.word \<Rightarrow>((register_value),((4)Word.word),(exception))monad "  where 
     " TweakCellRot incell_name = (
   (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (outcell :: 4 bits) . 
   (let (outcell :: 4 bits) =
     ((set_slice (( 4 :: int)::ii) (( 1 :: int)::ii) outcell (( 3 :: int)::ii)
        ((xor_vec (vec_of_bits [access_vec_dec incell_name (( 0 :: int)::ii)]  ::  1 Word.word)
            (vec_of_bits [access_vec_dec incell_name (( 1 :: int)::ii)]  ::  1 Word.word)
           ::  1 Word.word))
       ::  4 Word.word)) in
   (let (outcell :: 4 bits) =
     ((set_slice (( 4 :: int)::ii) (( 1 :: int)::ii) outcell (( 2 :: int)::ii)
        (vec_of_bits [access_vec_dec incell_name (( 3 :: int)::ii)]  ::  1 Word.word)
       ::  4 Word.word)) in
   (let (outcell :: 4 bits) =
     ((set_slice (( 4 :: int)::ii) (( 1 :: int)::ii) outcell (( 1 :: int)::ii)
        (vec_of_bits [access_vec_dec incell_name (( 2 :: int)::ii)]  ::  1 Word.word)
       ::  4 Word.word)) in
   (let (outcell :: 4 bits) =
     ((set_slice (( 4 :: int)::ii) (( 1 :: int)::ii) outcell (( 0 :: int)::ii)
        (vec_of_bits [access_vec_dec incell_name (( 1 :: int)::ii)]  ::  1 Word.word)
       ::  4 Word.word)) in
   return outcell))))))"


(*val TweakShuffle : mword ty64 -> M (mword ty64)*)

definition TweakShuffle  :: "(64)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " TweakShuffle indata = (
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (outdata :: 64 bits) . 
   (let (outdata :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 0 :: int)::ii) ((slice indata (( 16 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let outdata =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 4 :: int)::ii) ((slice indata (( 20 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (TweakCellRot ((slice indata (( 24 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))  :: ( 4 Word.word) M) \<bind> (\<lambda> (w__0 ::
      4 Word.word) . 
   (let outdata = ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 8 :: int)::ii) w__0  ::  64 Word.word)) in
   (let outdata =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 12 :: int)::ii) ((slice indata (( 28 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (TweakCellRot ((slice indata (( 44 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))  :: ( 4 Word.word) M) \<bind> (\<lambda> (w__1 ::
      4 Word.word) . 
   (let outdata = ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 16 :: int)::ii) w__1  ::  64 Word.word)) in
   (let outdata =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 20 :: int)::ii) ((slice indata (( 8 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let outdata =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 24 :: int)::ii) ((slice indata (( 12 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (TweakCellRot ((slice indata (( 32 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))  :: ( 4 Word.word) M) \<bind> (\<lambda> (w__2 ::
      4 Word.word) . 
   (let outdata = ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 28 :: int)::ii) w__2  ::  64 Word.word)) in
   (let outdata =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 32 :: int)::ii) ((slice indata (( 48 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let outdata =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 36 :: int)::ii) ((slice indata (( 52 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let outdata =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 40 :: int)::ii) ((slice indata (( 56 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (TweakCellRot ((slice indata (( 60 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))  :: ( 4 Word.word) M) \<bind> (\<lambda> (w__3 ::
      4 Word.word) . 
   (let outdata = ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 44 :: int)::ii) w__3  ::  64 Word.word)) in
   (TweakCellRot ((slice indata (( 0 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))  :: ( 4 Word.word) M) \<bind> (\<lambda> (w__4 ::
      4 Word.word) . 
   (let outdata = ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 48 :: int)::ii) w__4  ::  64 Word.word)) in
   (let outdata =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 52 :: int)::ii) ((slice indata (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (TweakCellRot ((slice indata (( 40 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))  :: ( 4 Word.word) M) \<bind> (\<lambda> (w__5 ::
      4 Word.word) . 
   (let outdata = ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 56 :: int)::ii) w__5  ::  64 Word.word)) in
   (TweakCellRot ((slice indata (( 36 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))  :: ( 4 Word.word) M) \<bind> (\<lambda> (w__6 ::
      4 Word.word) . 
   (let (outdata :: 64 bits) = ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 60 :: int)::ii) w__6  ::  64 Word.word)) in
   return outdata)))))))))))))))))))))))))"


(*val TweakCellInvRot : mword ty4 -> M (mword ty4)*)

definition TweakCellInvRot  :: "(4)Word.word \<Rightarrow>((register_value),((4)Word.word),(exception))monad "  where 
     " TweakCellInvRot incell_name = (
   (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (outcell :: 4 bits) . 
   (let (outcell :: 4 bits) =
     ((set_slice (( 4 :: int)::ii) (( 1 :: int)::ii) outcell (( 3 :: int)::ii)
        (vec_of_bits [access_vec_dec incell_name (( 2 :: int)::ii)]  ::  1 Word.word)
       ::  4 Word.word)) in
   (let (outcell :: 4 bits) =
     ((set_slice (( 4 :: int)::ii) (( 1 :: int)::ii) outcell (( 2 :: int)::ii)
        (vec_of_bits [access_vec_dec incell_name (( 1 :: int)::ii)]  ::  1 Word.word)
       ::  4 Word.word)) in
   (let (outcell :: 4 bits) =
     ((set_slice (( 4 :: int)::ii) (( 1 :: int)::ii) outcell (( 1 :: int)::ii)
        (vec_of_bits [access_vec_dec incell_name (( 0 :: int)::ii)]  ::  1 Word.word)
       ::  4 Word.word)) in
   (let (outcell :: 4 bits) =
     ((set_slice (( 4 :: int)::ii) (( 1 :: int)::ii) outcell (( 0 :: int)::ii)
        ((xor_vec (vec_of_bits [access_vec_dec incell_name (( 0 :: int)::ii)]  ::  1 Word.word)
            (vec_of_bits [access_vec_dec incell_name (( 3 :: int)::ii)]  ::  1 Word.word)
           ::  1 Word.word))
       ::  4 Word.word)) in
   return outcell))))))"


(*val TweakInvShuffle : mword ty64 -> M (mword ty64)*)

definition TweakInvShuffle  :: "(64)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " TweakInvShuffle indata = (
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (outdata :: 64 bits) . 
   (TweakCellInvRot ((slice indata (( 48 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))  :: ( 4 Word.word) M) \<bind> (\<lambda> (w__0 ::
      4 Word.word) . 
   (let (outdata :: 64 bits) = ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 0 :: int)::ii) w__0  ::  64 Word.word)) in
   (let outdata =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 4 :: int)::ii) ((slice indata (( 52 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let outdata =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 8 :: int)::ii) ((slice indata (( 20 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let outdata =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 12 :: int)::ii) ((slice indata (( 24 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let outdata =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 16 :: int)::ii) ((slice indata (( 0 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let outdata =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 20 :: int)::ii) ((slice indata (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (TweakCellInvRot ((slice indata (( 8 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))  :: ( 4 Word.word) M) \<bind> (\<lambda> (w__1 ::
      4 Word.word) . 
   (let outdata = ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 24 :: int)::ii) w__1  ::  64 Word.word)) in
   (let outdata =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 28 :: int)::ii) ((slice indata (( 12 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (TweakCellInvRot ((slice indata (( 28 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))  :: ( 4 Word.word) M) \<bind> (\<lambda> (w__2 ::
      4 Word.word) . 
   (let outdata = ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 32 :: int)::ii) w__2  ::  64 Word.word)) in
   (TweakCellInvRot ((slice indata (( 60 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))  :: ( 4 Word.word) M) \<bind> (\<lambda> (w__3 ::
      4 Word.word) . 
   (let outdata = ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 36 :: int)::ii) w__3  ::  64 Word.word)) in
   (TweakCellInvRot ((slice indata (( 56 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))  :: ( 4 Word.word) M) \<bind> (\<lambda> (w__4 ::
      4 Word.word) . 
   (let outdata = ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 40 :: int)::ii) w__4  ::  64 Word.word)) in
   (TweakCellInvRot ((slice indata (( 16 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))  :: ( 4 Word.word) M) \<bind> (\<lambda> (w__5 ::
      4 Word.word) . 
   (let outdata = ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 44 :: int)::ii) w__5  ::  64 Word.word)) in
   (let outdata =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 48 :: int)::ii) ((slice indata (( 32 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let outdata =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 52 :: int)::ii) ((slice indata (( 36 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (let outdata =
     ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 56 :: int)::ii) ((slice indata (( 40 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
       ::  64 Word.word)) in
   (TweakCellInvRot ((slice indata (( 44 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))  :: ( 4 Word.word) M) \<bind> (\<lambda> (w__6 ::
      4 Word.word) . 
   (let (outdata :: 64 bits) = ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) outdata (( 60 :: int)::ii) w__6  ::  64 Word.word)) in
   return outdata)))))))))))))))))))))))))"


definition EL3  :: "(2)Word.word "  where 
     " EL3 = ( (vec_of_bits [B1,B1]  ::  2 Word.word))"


definition EL2  :: "(2)Word.word "  where 
     " EL2 = ( (vec_of_bits [B1,B0]  ::  2 Word.word))"


definition EL1  :: "(2)Word.word "  where 
     " EL1 = ( (vec_of_bits [B0,B1]  ::  2 Word.word))"


definition EL0  :: "(2)Word.word "  where 
     " EL0 = ( (vec_of_bits [B0,B0]  ::  2 Word.word))"


(*val __UNKNOWN_DeviceType : unit -> DeviceType*)

definition UNKNOWN_DeviceType  :: " unit \<Rightarrow> DeviceType "  where 
     " UNKNOWN_DeviceType _ = ( DeviceType_GRE )"


(*val DecodeShift : mword ty2 -> ShiftType*)

definition DecodeShift  :: "(2)Word.word \<Rightarrow> ShiftType "  where 
     " DecodeShift op1 = (
   (let b__0 = op1 in
   if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then ShiftType_LSL
   else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then ShiftType_LSR
   else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then ShiftType_ASR
   else ShiftType_ROR))"


(*val DecodeRegExtend : mword ty3 -> ExtendType*)

definition DecodeRegExtend  :: "(3)Word.word \<Rightarrow> ExtendType "  where 
     " DecodeRegExtend op1 = (
   (let b__0 = op1 in
   if (((b__0 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) then ExtendType_UXTB
   else if (((b__0 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) then ExtendType_UXTH
   else if (((b__0 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) then ExtendType_UXTW
   else if (((b__0 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) then ExtendType_UXTX
   else if (((b__0 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) then ExtendType_SXTB
   else if (((b__0 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) then ExtendType_SXTH
   else if (((b__0 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) then ExtendType_SXTW
   else ExtendType_SXTX))"


definition DebugHalt_Watchpoint  :: "(6)Word.word "  where 
     " DebugHalt_Watchpoint = ( (vec_of_bits [B1,B0,B1,B0,B1,B1]  ::  6 Word.word))"


definition DebugHalt_HaltInstruction  :: "(6)Word.word "  where 
     " DebugHalt_HaltInstruction = ( (vec_of_bits [B1,B0,B1,B1,B1,B1]  ::  6 Word.word))"


definition DebugHalt_Breakpoint  :: "(6)Word.word "  where 
     " DebugHalt_Breakpoint = ( (vec_of_bits [B0,B0,B0,B1,B1,B1]  ::  6 Word.word))"


definition DebugException_VectorCatch  :: "(4)Word.word "  where 
     " DebugException_VectorCatch = ( (vec_of_bits [B0,B1,B0,B1]  ::  4 Word.word))"


(*val DataSynchronizationBarrier : MBReqDomain -> MBReqTypes -> unit*)

definition DataSynchronizationBarrier  :: " MBReqDomain \<Rightarrow> MBReqTypes \<Rightarrow> unit "  where 
     " DataSynchronizationBarrier domain1 types1 = ( ()  )"


(*val DataMemoryBarrier : MBReqDomain -> MBReqTypes -> unit*)

definition DataMemoryBarrier  :: " MBReqDomain \<Rightarrow> MBReqTypes \<Rightarrow> unit "  where 
     " DataMemoryBarrier domain1 types1 = ( ()  )"


(*val aarch64_system_barriers : MBReqDomain -> MemBarrierOp -> MBReqTypes -> unit*)

fun aarch64_system_barriers  :: " MBReqDomain \<Rightarrow> MemBarrierOp \<Rightarrow> MBReqTypes \<Rightarrow> unit "  where 
     " aarch64_system_barriers domain1 MemBarrierOp_DSB types1 = ( DataSynchronizationBarrier domain1 types1 )"
|" aarch64_system_barriers domain1 MemBarrierOp_DMB types1 = ( DataMemoryBarrier domain1 types1 )"
|" aarch64_system_barriers domain1 MemBarrierOp_ISB types1 = ( InstructionSynchronizationBarrier ()  )"


(*val __UNKNOWN_Constraint : unit -> Constraint*)

definition UNKNOWN_Constraint  :: " unit \<Rightarrow> Constraint "  where 
     " UNKNOWN_Constraint _ = ( Constraint_NONE )"


(*val ConstrainUnpredictable : Unpredictable -> Constraint*)

fun ConstrainUnpredictable  :: " Unpredictable \<Rightarrow> Constraint "  where 
     " ConstrainUnpredictable Unpredictable_WBOVERLAPLD = ( Constraint_WBSUPPRESS )"
|" ConstrainUnpredictable Unpredictable_WBOVERLAPST = ( Constraint_NONE )"
|" ConstrainUnpredictable Unpredictable_LDPOVERLAP = ( Constraint_UNDEF )"
|" ConstrainUnpredictable Unpredictable_BASEOVERLAP = ( Constraint_NONE )"
|" ConstrainUnpredictable Unpredictable_DATAOVERLAP = ( Constraint_NONE )"
|" ConstrainUnpredictable Unpredictable_DEVPAGE2 = ( Constraint_FAULT )"
|" ConstrainUnpredictable Unpredictable_INSTRDEVICE = ( Constraint_NONE )"
|" ConstrainUnpredictable Unpredictable_RESCPACR = ( Constraint_UNKNOWN )"
|" ConstrainUnpredictable Unpredictable_RESMAIR = ( Constraint_UNKNOWN )"
|" ConstrainUnpredictable Unpredictable_RESTEXCB = ( Constraint_UNKNOWN )"
|" ConstrainUnpredictable Unpredictable_RESDACR = ( Constraint_UNKNOWN )"
|" ConstrainUnpredictable Unpredictable_RESPRRR = ( Constraint_UNKNOWN )"
|" ConstrainUnpredictable Unpredictable_RESVTCRS = ( Constraint_UNKNOWN )"
|" ConstrainUnpredictable Unpredictable_RESTnSZ = ( Constraint_FORCE )"
|" ConstrainUnpredictable Unpredictable_OORTnSZ = ( Constraint_FORCE )"
|" ConstrainUnpredictable Unpredictable_LARGEIPA = ( Constraint_FORCE )"
|" ConstrainUnpredictable Unpredictable_ESRCONDPASS = ( Constraint_FALSE )"
|" ConstrainUnpredictable Unpredictable_ILZEROIT = ( Constraint_FALSE )"
|" ConstrainUnpredictable Unpredictable_ILZEROT = ( Constraint_FALSE )"
|" ConstrainUnpredictable Unpredictable_BPVECTORCATCHPRI = ( Constraint_TRUE )"
|" ConstrainUnpredictable Unpredictable_VCMATCHHALF = ( Constraint_FALSE )"
|" ConstrainUnpredictable Unpredictable_VCMATCHDAPA = ( Constraint_FALSE )"
|" ConstrainUnpredictable Unpredictable_WPMASKANDBAS = ( Constraint_FALSE )"
|" ConstrainUnpredictable Unpredictable_WPBASCONTIGUOUS = ( Constraint_FALSE )"
|" ConstrainUnpredictable Unpredictable_RESWPMASK = ( Constraint_DISABLED )"
|" ConstrainUnpredictable Unpredictable_WPMASKEDBITS = ( Constraint_FALSE )"
|" ConstrainUnpredictable Unpredictable_RESBPWPCTRL = ( Constraint_DISABLED )"
|" ConstrainUnpredictable Unpredictable_BPNOTIMPL = ( Constraint_DISABLED )"
|" ConstrainUnpredictable Unpredictable_RESBPTYPE = ( Constraint_DISABLED )"
|" ConstrainUnpredictable Unpredictable_BPNOTCTXCMP = ( Constraint_DISABLED )"
|" ConstrainUnpredictable Unpredictable_BPMATCHHALF = ( Constraint_FALSE )"
|" ConstrainUnpredictable Unpredictable_BPMISMATCHHALF = ( Constraint_FALSE )"
|" ConstrainUnpredictable Unpredictable_RESTARTALIGNPC = ( Constraint_FALSE )"
|" ConstrainUnpredictable Unpredictable_RESTARTZEROUPPERPC = ( Constraint_TRUE )"
|" ConstrainUnpredictable Unpredictable_ZEROUPPER = ( Constraint_TRUE )"
|" ConstrainUnpredictable Unpredictable_ERETZEROUPPERPC = ( Constraint_TRUE )"
|" ConstrainUnpredictable Unpredictable_A32FORCEALIGNPC = ( Constraint_FALSE )"
|" ConstrainUnpredictable Unpredictable_SMD = ( Constraint_UNDEF )"
|" ConstrainUnpredictable Unpredictable_AFUPDATE = ( Constraint_TRUE )"
|" ConstrainUnpredictable Unpredictable_IESBinDebug = ( Constraint_TRUE )"
|" ConstrainUnpredictable Unpredictable_CLEARERRITEZERO = ( Constraint_FALSE )"


(*val ClearPendingPhysicalSError : unit -> M unit*)

definition ClearPendingPhysicalSError  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " ClearPendingPhysicalSError _ = ( write_reg PendingPhysicalSError_ref False )"


(*val ClearExclusiveLocal : ii -> M unit*)

definition ClearExclusiveLocal  :: " int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " ClearExclusiveLocal processorid = ( write_reg ExclusiveLocal_ref False )"


(*val aarch64_system_monitors : unit -> M unit*)

definition aarch64_system_monitors  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_system_monitors _ = ( ClearExclusiveLocal ((ProcessorID () )))"


(*val system_monitors_decode : mword ty1 -> mword ty2 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty3 -> mword ty5 -> M unit*)

definition system_monitors_decode  :: "(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " system_monitors_decode L op0 op1 CRn CRm op2 Rt = (
   write_reg unconditional_ref True \<then> aarch64_system_monitors ()  )"


(*val ClearExclusiveByAddress : FullAddress -> ii -> ii -> unit*)

definition ClearExclusiveByAddress  :: " FullAddress \<Rightarrow> int \<Rightarrow> int \<Rightarrow> unit "  where 
     " ClearExclusiveByAddress paddress processorid size1 = ( ()  )"


(*val ClearEventRegister : unit -> M unit*)

definition ClearEventRegister  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " ClearEventRegister _ = ( write_reg EventRegister_ref (vec_of_bits [B0]  ::  1 Word.word))"


(*val CTI_SignalEvent : CrossTriggerIn -> M unit*)

definition CTI_SignalEvent  :: " CrossTriggerIn \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " CTI_SignalEvent id1 = ( assert_exp False (''FALSE''))"


(*val __UNKNOWN_BranchType : unit -> BranchType*)

definition UNKNOWN_BranchType  :: " unit \<Rightarrow> BranchType "  where 
     " UNKNOWN_BranchType _ = ( BranchType_CALL )"


(*val __UNKNOWN_AccType : unit -> AccType*)

definition UNKNOWN_AccType  :: " unit \<Rightarrow> AccType "  where 
     " UNKNOWN_AccType _ = ( AccType_NORMAL )"


(*val CreateAccessDescriptorPTW : AccType -> bool -> bool -> ii -> M AccessDescriptor*)

definition CreateAccessDescriptorPTW  :: " AccType \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(AccessDescriptor),(exception))monad "  where 
     " CreateAccessDescriptorPTW acctype secondstage s2fs1walk level = (
   undefined_AccessDescriptor ()  \<bind> (\<lambda> (accdesc :: AccessDescriptor) . 
   (let (accdesc :: AccessDescriptor) = ((accdesc (| AccessDescriptor_acctype := acctype |))) in
   (let (accdesc :: AccessDescriptor) = ((accdesc (| AccessDescriptor_page_table_walk := True |))) in
   (let (accdesc :: AccessDescriptor) = ((accdesc (| AccessDescriptor_secondstage := s2fs1walk |))) in
   (let (accdesc :: AccessDescriptor) = ((accdesc (| AccessDescriptor_secondstage := secondstage |))) in
   (let (accdesc :: AccessDescriptor) = ((accdesc (| AccessDescriptor_level := level |))) in
   return accdesc)))))))"


(*val CreateAccessDescriptor : AccType -> M AccessDescriptor*)

definition CreateAccessDescriptor  :: " AccType \<Rightarrow>((register_value),(AccessDescriptor),(exception))monad "  where 
     " CreateAccessDescriptor acctype = (
   undefined_AccessDescriptor ()  \<bind> (\<lambda> (accdesc :: AccessDescriptor) . 
   (let (accdesc :: AccessDescriptor) = ((accdesc (| AccessDescriptor_acctype := acctype |))) in
   (let (accdesc :: AccessDescriptor) = ((accdesc (| AccessDescriptor_page_table_walk := False |))) in
   return accdesc))))"


(*val aarch64_system_register_cpsr : PSTATEField -> mword ty4 -> M unit*)

fun aarch64_system_register_cpsr  :: " PSTATEField \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_system_register_cpsr PSTATEField_SP operand = (
      read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) . 
      write_reg
        PSTATE_ref
        (w__0 (| ProcState_SP := ((vec_of_bits [access_vec_dec operand (( 0 :: int)::ii)]  ::  1 Word.word))|))))"
|" aarch64_system_register_cpsr PSTATEField_DAIFSet operand = (
      read_reg PSTATE_ref \<bind> (\<lambda> (w__1 :: ProcState) . 
      read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) . 
      (write_reg
        PSTATE_ref
        (w__1 (|
          ProcState_D :=
            ((or_vec(ProcState_D   w__2) (vec_of_bits [access_vec_dec operand (( 3 :: int)::ii)]  ::  1 Word.word)
               ::  1 Word.word))|)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__3 :: ProcState) . 
      read_reg PSTATE_ref \<bind> (\<lambda> (w__4 :: ProcState) . 
      (write_reg
        PSTATE_ref
        (w__3 (|
          ProcState_A :=
            ((or_vec(ProcState_A   w__4) (vec_of_bits [access_vec_dec operand (( 2 :: int)::ii)]  ::  1 Word.word)
               ::  1 Word.word))|)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__5 :: ProcState) . 
      read_reg PSTATE_ref \<bind> (\<lambda> (w__6 :: ProcState) . 
      (write_reg
        PSTATE_ref
        (w__5 (|
          ProcState_I :=
            ((or_vec(ProcState_I   w__6) (vec_of_bits [access_vec_dec operand (( 1 :: int)::ii)]  ::  1 Word.word)
               ::  1 Word.word))|)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__7 :: ProcState) . 
      read_reg PSTATE_ref \<bind> (\<lambda> (w__8 :: ProcState) . 
      write_reg
        PSTATE_ref
        (w__7 (|
          ProcState_F :=
            ((or_vec(ProcState_F   w__8) (vec_of_bits [access_vec_dec operand (( 0 :: int)::ii)]  ::  1 Word.word)
               ::  1 Word.word))|)))))))))))"
|" aarch64_system_register_cpsr PSTATEField_DAIFClr operand = (
      read_reg PSTATE_ref \<bind> (\<lambda> (w__9 :: ProcState) . 
      read_reg PSTATE_ref \<bind> (\<lambda> (w__10 :: ProcState) . 
      (write_reg
        PSTATE_ref
        (w__9 (|
          ProcState_D :=
            ((and_vec(ProcState_D   w__10)
                ((not_vec (vec_of_bits [access_vec_dec operand (( 3 :: int)::ii)]  ::  1 Word.word)  ::  1 Word.word))
               ::  1 Word.word))|)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__11 :: ProcState) . 
      read_reg PSTATE_ref \<bind> (\<lambda> (w__12 :: ProcState) . 
      (write_reg
        PSTATE_ref
        (w__11 (|
          ProcState_A :=
            ((and_vec(ProcState_A   w__12)
                ((not_vec (vec_of_bits [access_vec_dec operand (( 2 :: int)::ii)]  ::  1 Word.word)  ::  1 Word.word))
               ::  1 Word.word))|)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__13 :: ProcState) . 
      read_reg PSTATE_ref \<bind> (\<lambda> (w__14 :: ProcState) . 
      (write_reg
        PSTATE_ref
        (w__13 (|
          ProcState_I :=
            ((and_vec(ProcState_I   w__14)
                ((not_vec (vec_of_bits [access_vec_dec operand (( 1 :: int)::ii)]  ::  1 Word.word)  ::  1 Word.word))
               ::  1 Word.word))|)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__15 :: ProcState) . 
      read_reg PSTATE_ref \<bind> (\<lambda> (w__16 :: ProcState) . 
      write_reg
        PSTATE_ref
        (w__15 (|
          ProcState_F :=
            ((and_vec(ProcState_F   w__16)
                ((not_vec (vec_of_bits [access_vec_dec operand (( 0 :: int)::ii)]  ::  1 Word.word)  ::  1 Word.word))
               ::  1 Word.word))|)))))))))))"
|" aarch64_system_register_cpsr PSTATEField_PAN operand = (
      read_reg PSTATE_ref \<bind> (\<lambda> (w__17 :: ProcState) . 
      write_reg
        PSTATE_ref
        (w__17 (| ProcState_PAN := ((vec_of_bits [access_vec_dec operand (( 0 :: int)::ii)]  ::  1 Word.word))|))))"
|" aarch64_system_register_cpsr PSTATEField_UAO operand = (
      read_reg PSTATE_ref \<bind> (\<lambda> (w__18 :: ProcState) . 
      write_reg
        PSTATE_ref
        (w__18 (| ProcState_UAO := ((vec_of_bits [access_vec_dec operand (( 0 :: int)::ii)]  ::  1 Word.word))|))))"


(*val AArch64_SysRegWrite : ii -> ii -> ii -> ii -> ii -> mword ty64 -> M unit*)

definition AArch64_SysRegWrite  :: " int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_SysRegWrite op0 op1 crn crm op2 val_name = ( assert_exp False (''FALSE''))"


(*val AArch64_SysRegRead : ii -> ii -> ii -> ii -> ii -> M (mword ty64)*)

definition AArch64_SysRegRead  :: " int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " AArch64_SysRegRead arg0 arg1 arg2 arg3 arg4 = (
   (let g__301 = (arg0, arg1, arg2, arg3, arg4) in
   assert_exp False (''Tried to read system register'') \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)))"


(*val AArch64_SysInstr : ii -> ii -> ii -> ii -> ii -> mword ty64 -> M unit*)

definition AArch64_SysInstr  :: " int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_SysInstr op0 op1 crn crm op2 val_name = ( assert_exp False (''FALSE''))"


(*val AArch64_ResetControlRegisters : bool -> unit*)

definition AArch64_ResetControlRegisters  :: " bool \<Rightarrow> unit "  where 
     " AArch64_ResetControlRegisters cold_reset = ( ()  )"


(*val AArch64_ReportDeferredSError : mword ty25 -> M (mword ty64)*)

definition AArch64_ReportDeferredSError  :: "(25)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " AArch64_ReportDeferredSError syndrome = (
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (target :: 64 bits) . 
   (let (target :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 1 :: int)::ii) target (( 31 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)  ::  64 Word.word)) in
   (let (target :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 1 :: int)::ii) target (( 24 :: int)::ii)
        (vec_of_bits [access_vec_dec syndrome (( 24 :: int)::ii)]  ::  1 Word.word)
       ::  64 Word.word)) in
   (let (target :: 64 bits) =
     ((set_slice (( 64 :: int)::ii) (( 24 :: int)::ii) target (( 0 :: int)::ii) ((slice syndrome (( 0 :: int)::ii) (( 24 :: int)::ii)  ::  24 Word.word))
       ::  64 Word.word)) in
   return target)))))"


(*val AArch64_MarkExclusiveVA : mword ty64 -> ii -> ii -> M unit*)

definition AArch64_MarkExclusiveVA  :: "(64)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_MarkExclusiveVA address processorid size1 = ( assert_exp False (''FALSE''))"


(*val AArch64_IsExclusiveVA : mword ty64 -> ii -> ii -> M bool*)

definition AArch64_IsExclusiveVA  :: "(64)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " AArch64_IsExclusiveVA address processorid size1 = ( assert_exp False (''FALSE'') \<then> return False )"


(*val AArch64_CreateFaultRecord : Fault -> mword ty52 -> ii -> AccType -> bool -> mword ty1 -> mword ty2 -> bool -> bool -> M FaultRecord*)

definition AArch64_CreateFaultRecord  :: " Fault \<Rightarrow>(52)Word.word \<Rightarrow> int \<Rightarrow> AccType \<Rightarrow> bool \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(FaultRecord),(exception))monad "  where 
     " AArch64_CreateFaultRecord typ1 ipaddress level acctype write1 extflag errortype secondstage s2fs1walk = (
   undefined_FaultRecord ()  \<bind> (\<lambda> (fault :: FaultRecord) . 
   (let fault = ((fault (| FaultRecord_typ := typ1 |))) in
   (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (w__0 ::  4 Word.word) . 
   (let fault = ((fault (| FaultRecord_domain := w__0 |))) in
   (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (w__1 ::  4 Word.word) . 
   (let (fault :: FaultRecord) = ((fault (| FaultRecord_debugmoe := w__1 |))) in
   (let (fault :: FaultRecord) = ((fault (| FaultRecord_errortype := errortype |))) in
   (let (fault :: FaultRecord) = ((fault (| FaultRecord_ipaddress := ipaddress |))) in
   (let (fault :: FaultRecord) = ((fault (| FaultRecord_level := level |))) in
   (let (fault :: FaultRecord) = ((fault (| FaultRecord_acctype := acctype |))) in
   (let (fault :: FaultRecord) = ((fault (| FaultRecord_write := write1 |))) in
   (let (fault :: FaultRecord) = ((fault (| FaultRecord_extflag := extflag |))) in
   (let (fault :: FaultRecord) = ((fault (| FaultRecord_secondstage := secondstage |))) in
   (let (fault :: FaultRecord) = ((fault (| FaultRecord_s2fs1walk := s2fs1walk |))) in
   return fault)))))))))))))))"


(*val AArch64_TranslationFault : mword ty52 -> ii -> AccType -> bool -> bool -> bool -> M FaultRecord*)

definition AArch64_TranslationFault  :: "(52)Word.word \<Rightarrow> int \<Rightarrow> AccType \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(FaultRecord),(exception))monad "  where 
     " AArch64_TranslationFault ipaddress level acctype iswrite secondstage s2fs1walk = (
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (extflag :: 1 bits) . 
   (undefined_bitvector (( 2 :: int)::ii)  :: ( 2 Word.word) M) \<bind> (\<lambda> (errortype :: 2 bits) . 
   AArch64_CreateFaultRecord Fault_Translation ipaddress level acctype iswrite extflag errortype
     secondstage s2fs1walk)))"


(*val AArch64_PermissionFault : mword ty52 -> ii -> AccType -> bool -> bool -> bool -> M FaultRecord*)

definition AArch64_PermissionFault  :: "(52)Word.word \<Rightarrow> int \<Rightarrow> AccType \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(FaultRecord),(exception))monad "  where 
     " AArch64_PermissionFault ipaddress level acctype iswrite secondstage s2fs1walk = (
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (extflag :: 1 bits) . 
   (undefined_bitvector (( 2 :: int)::ii)  :: ( 2 Word.word) M) \<bind> (\<lambda> (errortype :: 2 bits) . 
   AArch64_CreateFaultRecord Fault_Permission ipaddress level acctype iswrite extflag errortype
     secondstage s2fs1walk)))"


(*val AArch64_NoFault : unit -> M FaultRecord*)

definition AArch64_NoFault  :: " unit \<Rightarrow>((register_value),(FaultRecord),(exception))monad "  where 
     " AArch64_NoFault _ = (
   (undefined_bitvector (( 52 :: int)::ii)  :: ( 52 Word.word) M) \<bind> (\<lambda> (ipaddress :: 52 bits) . 
   undefined_int ()  \<bind> (\<lambda> (level :: ii) . 
   (let (acctype :: AccType) = AccType_NORMAL in
   undefined_bool ()  \<bind> (\<lambda> (iswrite :: bool) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (extflag :: 1 bits) . 
   (undefined_bitvector (( 2 :: int)::ii)  :: ( 2 Word.word) M) \<bind> (\<lambda> (errortype :: 2 bits) . 
   (let (secondstage :: bool) = False in
   (let (s2fs1walk :: bool) = False in
   AArch64_CreateFaultRecord Fault_None ipaddress level acctype iswrite extflag errortype
     secondstage s2fs1walk)))))))))"


(*val AArch64_DebugFault : AccType -> bool -> M FaultRecord*)

definition AArch64_DebugFault  :: " AccType \<Rightarrow> bool \<Rightarrow>((register_value),(FaultRecord),(exception))monad "  where 
     " AArch64_DebugFault acctype iswrite = (
   (undefined_bitvector (( 52 :: int)::ii)  :: ( 52 Word.word) M) \<bind> (\<lambda> (ipaddress :: 52 bits) . 
   (undefined_bitvector (( 2 :: int)::ii)  :: ( 2 Word.word) M) \<bind> (\<lambda> (errortype :: 2 bits) . 
   undefined_int ()  \<bind> (\<lambda> (level :: ii) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (extflag :: 1 bits) . 
   (let (secondstage :: bool) = False in
   (let (s2fs1walk :: bool) = False in
   AArch64_CreateFaultRecord Fault_Debug ipaddress level acctype iswrite extflag errortype
     secondstage s2fs1walk)))))))"


(*val AArch64_CheckUnallocatedSystemAccess : mword ty2 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty3 -> mword ty1 -> M bool*)

definition AArch64_CheckUnallocatedSystemAccess  :: "(2)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " AArch64_CheckUnallocatedSystemAccess op0 op1 crn crm op2 read = (
   assert_exp False (''FALSE'') \<then> return False )"


(*val AArch64_CheckSystemRegisterTraps : mword ty2 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty3 -> mword ty1 -> M (bool * mword ty2)*)

definition AArch64_CheckSystemRegisterTraps  :: "(2)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(bool*(2)Word.word),(exception))monad "  where 
     " AArch64_CheckSystemRegisterTraps op0 op1 crn crm op2 read = (
   assert_exp False (''FALSE'') \<then> return (False, (vec_of_bits [B0,B0]  ::  2 Word.word)))"


(*val AArch64_CheckAdvSIMDFPSystemRegisterTraps : mword ty2 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty3 -> mword ty1 -> M (bool * mword ty2)*)

definition AArch64_CheckAdvSIMDFPSystemRegisterTraps  :: "(2)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(bool*(2)Word.word),(exception))monad "  where 
     " AArch64_CheckAdvSIMDFPSystemRegisterTraps op0 op1 crn crm op2 read = (
   assert_exp False (''FALSE'') \<then> return (False, (vec_of_bits [B0,B0]  ::  2 Word.word)))"


(*val AArch64_AlignmentFault : AccType -> bool -> bool -> M FaultRecord*)

definition AArch64_AlignmentFault  :: " AccType \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(FaultRecord),(exception))monad "  where 
     " AArch64_AlignmentFault acctype iswrite secondstage = (
   (undefined_bitvector (( 52 :: int)::ii)  :: ( 52 Word.word) M) \<bind> (\<lambda> (ipaddress :: 52 bits) . 
   undefined_int ()  \<bind> (\<lambda> (level :: ii) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (extflag :: 1 bits) . 
   (undefined_bitvector (( 2 :: int)::ii)  :: ( 2 Word.word) M) \<bind> (\<lambda> (errortype :: 2 bits) . 
   undefined_bool ()  \<bind> (\<lambda> (s2fs1walk :: bool) . 
   AArch64_CreateFaultRecord Fault_Alignment ipaddress level acctype iswrite extflag errortype
     secondstage s2fs1walk))))))"


(*val AArch64_AddressSizeFault : mword ty52 -> ii -> AccType -> bool -> bool -> bool -> M FaultRecord*)

definition AArch64_AddressSizeFault  :: "(52)Word.word \<Rightarrow> int \<Rightarrow> AccType \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(FaultRecord),(exception))monad "  where 
     " AArch64_AddressSizeFault ipaddress level acctype iswrite secondstage s2fs1walk = (
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (extflag :: 1 bits) . 
   (undefined_bitvector (( 2 :: int)::ii)  :: ( 2 Word.word) M) \<bind> (\<lambda> (errortype :: 2 bits) . 
   AArch64_CreateFaultRecord Fault_AddressSize ipaddress level acctype iswrite extflag errortype
     secondstage s2fs1walk)))"


(*val AArch64_AccessFlagFault : mword ty52 -> ii -> AccType -> bool -> bool -> bool -> M FaultRecord*)

definition AArch64_AccessFlagFault  :: "(52)Word.word \<Rightarrow> int \<Rightarrow> AccType \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(FaultRecord),(exception))monad "  where 
     " AArch64_AccessFlagFault ipaddress level acctype iswrite secondstage s2fs1walk = (
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (extflag :: 1 bits) . 
   (undefined_bitvector (( 2 :: int)::ii)  :: ( 2 Word.word) M) \<bind> (\<lambda> (errortype :: 2 bits) . 
   AArch64_CreateFaultRecord Fault_AccessFlag ipaddress level acctype iswrite extflag errortype
     secondstage s2fs1walk)))"


(*val AArch32_CurrentCond : unit -> M (mword ty4)*)

definition AArch32_CurrentCond  :: " unit \<Rightarrow>((register_value),((4)Word.word),(exception))monad "  where 
     " AArch32_CurrentCond _ = ( (read_reg currentCond_ref  :: ( 4 Word.word) M))"


(*val aget_SP : forall 'width . Size 'width => integer -> unit -> M (mword 'width)*)

definition aget_SP  :: " int \<Rightarrow> unit \<Rightarrow>((register_value),(('width::len)Word.word),(exception))monad "  where 
     " aget_SP (width__tv :: int) _ = (
   (assert_exp ((((((width__tv = (( 8 :: int)::ii)))) \<or> ((((((width__tv = (( 16 :: int)::ii)))) \<or> ((((((width__tv = (( 32 :: int)::ii)))) \<or> (((width__tv = (( 64 :: int)::ii))))))))))))) (''((width == 8) || ((width == 16) || ((width == 32) || (width == 64))))'') \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__0 :: ProcState) . 
   if ((((ProcState_SP   w__0) = (vec_of_bits [B0]  ::  1 Word.word)))) then
     (read_reg SP_EL0_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 :: 64 bits) . 
     return ((slice w__1 (( 0 :: int)::ii) width__tv  :: ( 'width::len)Word.word)))
   else
     read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) . 
     (let p__300 = ((ProcState_EL   w__2)) in
     (let pat0 = p__300 in
     if (((pat0 = EL0))) then
       (read_reg SP_EL0_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 :: 64 bits) . 
       return ((slice w__3 (( 0 :: int)::ii) width__tv  :: ( 'width::len)Word.word)))
     else if (((pat0 = EL1))) then
       (read_reg SP_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 :: 64 bits) . 
       return ((slice w__4 (( 0 :: int)::ii) width__tv  :: ( 'width::len)Word.word)))
     else if (((pat0 = EL2))) then
       (read_reg SP_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 :: 64 bits) . 
       return ((slice w__5 (( 0 :: int)::ii) width__tv  :: ( 'width::len)Word.word)))
     else
       (read_reg SP_EL3_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__6 :: 64 bits) . 
       return ((slice w__6 (( 0 :: int)::ii) width__tv  :: ( 'width::len)Word.word))))))))"


(*val __IMPDEF_integer : string -> ii*)

definition IMPDEF_integer  :: " string \<Rightarrow> int "  where 
     " IMPDEF_integer x = (
   if (((x = (''Maximum Physical Address Size'')))) then (( 52 :: int)::ii)
   else if (((x = (''Maximum Virtual Address Size'')))) then (( 56 :: int)::ii)
   else (( 0 :: int)::ii))"


(*val VAMax : unit -> ii*)

definition VAMax  :: " unit \<Rightarrow> int "  where 
     " VAMax _ = ( IMPDEF_integer (''Maximum Virtual Address Size''))"


(*val PAMax : unit -> ii*)

definition PAMax  :: " unit \<Rightarrow> int "  where 
     " PAMax _ = ( IMPDEF_integer (''Maximum Physical Address Size''))"


(*val __IMPDEF_boolean : string -> bool*)

definition IMPDEF_boolean  :: " string \<Rightarrow> bool "  where 
     " IMPDEF_boolean x = (
   if (((x = (''Condition valid for trapped T32'')))) then True
   else if (((x = (''Has Dot Product extension'')))) then True
   else if (((x = (''Has RAS extension'')))) then True
   else if (((x = (''Has SHA512 and SHA3 Crypto instructions'')))) then True
   else if (((x = (''Has SM3 and SM4 Crypto instructions'')))) then True
   else if (((x = (''Has basic Crypto instructions'')))) then True
   else if (((x = (''Have CRC extension'')))) then True
   else if (((x = (''Report I-cache maintenance fault in IFSR'')))) then True
   else if (((x = (''Reserved Control Space EL0 Trapped'')))) then True
   else if (((x = (''Translation fault on misprogrammed contiguous bit'')))) then True
   else if (((x = (''UNDEF unallocated CP15 access at NS EL0'')))) then True
   else if (((x = (''UNDEF unallocated CP15 access at NS EL0'')))) then True
   else False )"


(*val WaitForEvent : unit -> M unit*)

definition WaitForEvent  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " WaitForEvent _ = (
   (read_reg EventRegister_ref  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__0 :: 1 bits) . 
   if (((w__0 = (vec_of_bits [B0]  ::  1 Word.word)))) then EnterLowPowerState () 
   else return () ))"


(*val ThisInstrLength : unit -> M ii*)

definition ThisInstrLength  :: " unit \<Rightarrow>((register_value),(int),(exception))monad "  where 
     " ThisInstrLength _ = (
   read_reg ThisInstrEnc_ref \<bind> (\<lambda> (w__0 :: InstrEnc) . 
   return (if (((w__0 = T16))) then (( 16 :: int)::ii)
           else (( 32 :: int)::ii))))"


(*val RoundTowardsZero : real -> ii*)

definition RoundTowardsZero  :: " real \<Rightarrow> int "  where 
     " RoundTowardsZero x = (
   if (((x = (realFromFrac(( 0 :: int))(( 10 :: int)))))) then (( 0 :: int)::ii)
   else if ((x \<ge> (realFromFrac(( 0 :: int))(( 10 :: int))))) then floor x
   else ceiling x )"


(*val Restarting : unit -> M bool*)

definition Restarting  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " Restarting _ = (
   (read_reg EDSCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 :: 32 bits) . 
   return (((((slice w__0 (( 0 :: int)::ii) (( 6 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1]  ::  6 Word.word))))))"


(*val PtrHasUpperAndLowerAddRanges : unit -> M bool*)

definition PtrHasUpperAndLowerAddRanges  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " PtrHasUpperAndLowerAddRanges _ = (
   or_boolM
     (or_boolM
        (read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) .  return ((((ProcState_EL   w__0) = EL1)))))
        (read_reg PSTATE_ref \<bind> (\<lambda> (w__1 :: ProcState) .  return ((((ProcState_EL   w__1) = EL0))))))
     (and_boolM
        (read_reg PSTATE_ref \<bind> (\<lambda> (w__3 :: ProcState) .  return ((((ProcState_EL   w__3) = EL2)))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__4 (( 34 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))))"


(*val MemAttrDefaults : MemoryAttributes -> M MemoryAttributes*)

definition MemAttrDefaults  :: " MemoryAttributes \<Rightarrow>((register_value),(MemoryAttributes),(exception))monad "  where 
     " MemAttrDefaults memattrs__arg = (
   (let memattrs = memattrs__arg in
   if ((((MemoryAttributes_typ   memattrs) = MemType_Device))) then
     undefined_MemAttrHints ()  \<bind> (\<lambda> (w__0 :: MemAttrHints) . 
     (let memattrs = ((memattrs (| MemoryAttributes_inner := w__0 |))) in
     undefined_MemAttrHints ()  \<bind> (\<lambda> (w__1 :: MemAttrHints) . 
     (let (memattrs :: MemoryAttributes) = ((memattrs (| MemoryAttributes_outer := w__1 |))) in
     (let (memattrs :: MemoryAttributes) = ((memattrs (| MemoryAttributes_shareable := True |))) in
     (let (memattrs :: MemoryAttributes) = ((memattrs (| MemoryAttributes_outershareable := True |))) in
     return memattrs))))))
   else
     undefined_DeviceType ()  \<bind> (\<lambda> (w__2 :: DeviceType) . 
     (let (memattrs :: MemoryAttributes) = ((memattrs (| MemoryAttributes_device := w__2 |))) in
     (let (memattrs :: MemoryAttributes) =
       (if (((((((MemAttrHints_attrs  (MemoryAttributes_inner   memattrs)) = MemAttr_NC))) \<and> ((((MemAttrHints_attrs  (MemoryAttributes_outer   memattrs)) = MemAttr_NC)))))) then
         (let (memattrs :: MemoryAttributes) = ((memattrs (| MemoryAttributes_shareable := True |))) in
         (memattrs (| MemoryAttributes_outershareable := True |)))
       else memattrs) in
     return memattrs)))))"


(*val IsEventRegisterSet : unit -> M bool*)

definition IsEventRegisterSet  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " IsEventRegisterSet _ = (
   (read_reg EventRegister_ref  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__0 :: 1 bits) . 
   return (((w__0 = (vec_of_bits [B1]  ::  1 Word.word))))))"


(*val HaveEL : mword ty2 -> bool*)

definition HaveEL  :: "(2)Word.word \<Rightarrow> bool "  where 
     " HaveEL el = ( if ((((((el = EL1))) \<or> (((el = EL0)))))) then True else True )"


(*val HighestEL : unit -> mword ty2*)

definition HighestEL  :: " unit \<Rightarrow>(2)Word.word "  where 
     " HighestEL _ = ( if ((HaveEL EL3)) then EL3 else if ((HaveEL EL2)) then EL2 else EL1 )"


(*val Have16bitVMID : unit -> bool*)

definition Have16bitVMID  :: " unit \<Rightarrow> bool "  where 
     " Have16bitVMID _ = ( HaveEL EL2 )"


(*val HasArchVersion : ArchVersion -> bool*)

definition HasArchVersion  :: " ArchVersion \<Rightarrow> bool "  where 
     " HasArchVersion version = (
   ((((version = ARMv8p0))) \<or> ((((((version = ARMv8p1))) \<or> ((((((version = ARMv8p2))) \<or> (((version = ARMv8p3)))))))))))"


(*val HaveVirtHostExt : unit -> bool*)

definition HaveVirtHostExt  :: " unit \<Rightarrow> bool "  where 
     " HaveVirtHostExt _ = ( HasArchVersion ARMv8p1 )"


(*val HaveUAOExt : unit -> bool*)

definition HaveUAOExt  :: " unit \<Rightarrow> bool "  where 
     " HaveUAOExt _ = ( HasArchVersion ARMv8p2 )"


(*val HaveTrapLoadStoreMultipleDeviceExt : unit -> bool*)

definition HaveTrapLoadStoreMultipleDeviceExt  :: " unit \<Rightarrow> bool "  where 
     " HaveTrapLoadStoreMultipleDeviceExt _ = ( HasArchVersion ARMv8p2 )"


(*val HaveStatisticalProfiling : unit -> bool*)

definition HaveStatisticalProfiling  :: " unit \<Rightarrow> bool "  where 
     " HaveStatisticalProfiling _ = ( HasArchVersion ARMv8p2 )"


(*val HaveRASExt : unit -> bool*)

definition HaveRASExt  :: " unit \<Rightarrow> bool "  where 
     " HaveRASExt _ = ( (((HasArchVersion ARMv8p2)) \<or> ((IMPDEF_boolean (''Has RAS extension'')))))"


(*val HavePrivATExt : unit -> bool*)

definition HavePrivATExt  :: " unit \<Rightarrow> bool "  where 
     " HavePrivATExt _ = ( HasArchVersion ARMv8p2 )"


(*val HavePANExt : unit -> bool*)

definition HavePANExt  :: " unit \<Rightarrow> bool "  where 
     " HavePANExt _ = ( HasArchVersion ARMv8p1 )"


(*val HavePACExt : unit -> bool*)

definition HavePACExt  :: " unit \<Rightarrow> bool "  where 
     " HavePACExt _ = ( HasArchVersion ARMv8p3 )"


(*val HaveNVExt : unit -> bool*)

definition HaveNVExt  :: " unit \<Rightarrow> bool "  where 
     " HaveNVExt _ = ( HasArchVersion ARMv8p3 )"


(*val HaveFJCVTZSExt : unit -> bool*)

definition HaveFJCVTZSExt  :: " unit \<Rightarrow> bool "  where 
     " HaveFJCVTZSExt _ = ( HasArchVersion ARMv8p3 )"


(*val HaveExtendedExecuteNeverExt : unit -> bool*)

definition HaveExtendedExecuteNeverExt  :: " unit \<Rightarrow> bool "  where 
     " HaveExtendedExecuteNeverExt _ = ( HasArchVersion ARMv8p2 )"


(*val HaveDirtyBitModifierExt : unit -> bool*)

definition HaveDirtyBitModifierExt  :: " unit \<Rightarrow> bool "  where 
     " HaveDirtyBitModifierExt _ = ( HasArchVersion ARMv8p1 )"


(*val HaveCommonNotPrivateTransExt : unit -> bool*)

definition HaveCommonNotPrivateTransExt  :: " unit \<Rightarrow> bool "  where 
     " HaveCommonNotPrivateTransExt _ = ( HasArchVersion ARMv8p2 )"


(*val HaveCRCExt : unit -> bool*)

definition HaveCRCExt  :: " unit \<Rightarrow> bool "  where 
     " HaveCRCExt _ = ( (((HasArchVersion ARMv8p1)) \<or> ((IMPDEF_boolean (''Have CRC extension'')))))"


(*val HaveAtomicExt : unit -> bool*)

definition HaveAtomicExt  :: " unit \<Rightarrow> bool "  where 
     " HaveAtomicExt _ = ( HasArchVersion ARMv8p1 )"


(*val HaveAccessFlagUpdateExt : unit -> bool*)

definition HaveAccessFlagUpdateExt  :: " unit \<Rightarrow> bool "  where 
     " HaveAccessFlagUpdateExt _ = ( HasArchVersion ARMv8p1 )"


(*val Have52BitVAExt : unit -> bool*)

definition Have52BitVAExt  :: " unit \<Rightarrow> bool "  where 
     " Have52BitVAExt _ = ( HasArchVersion ARMv8p2 )"


(*val Have52BitPAExt : unit -> bool*)

definition Have52BitPAExt  :: " unit \<Rightarrow> bool "  where 
     " Have52BitPAExt _ = ( HasArchVersion ARMv8p2 )"


(*val AArch64_HaveHPDExt : unit -> bool*)

definition AArch64_HaveHPDExt  :: " unit \<Rightarrow> bool "  where 
     " AArch64_HaveHPDExt _ = ( HasArchVersion ARMv8p1 )"


(*val ExternalInvasiveDebugEnabled : unit -> M bool*)

definition ExternalInvasiveDebugEnabled  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " ExternalInvasiveDebugEnabled _ = (
   read_reg DBGEN_ref \<bind> (\<lambda> (w__0 :: signal) .  return (((w__0 = HIGH)))))"


(*val ConstrainUnpredictableInteger : ii -> ii -> Unpredictable -> M (Constraint * ii)*)

definition ConstrainUnpredictableInteger  :: " int \<Rightarrow> int \<Rightarrow> Unpredictable \<Rightarrow>((register_value),(Constraint*int),(exception))monad "  where 
     " ConstrainUnpredictableInteger low high which = (
   (let (c :: Constraint) = (ConstrainUnpredictable which) in
   if (((c = Constraint_UNKNOWN))) then return (c, low)
   else undefined_int ()  \<bind> (\<lambda> (w__0 :: ii) .  return (c, w__0))))"


(*val ConstrainUnpredictableBool : Unpredictable -> M bool*)

definition ConstrainUnpredictableBool  :: " Unpredictable \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " ConstrainUnpredictableBool which = (
   (let (c :: Constraint) = (ConstrainUnpredictable which) in
   assert_exp ((((((c = Constraint_TRUE))) \<or> (((c = Constraint_FALSE)))))) (''((c == Constraint_TRUE) || (c == Constraint_FALSE))'') \<then>
   return (((c = Constraint_TRUE)))))"


(*val CombineS1S2Device : DeviceType -> DeviceType -> M DeviceType*)

definition CombineS1S2Device  :: " DeviceType \<Rightarrow> DeviceType \<Rightarrow>((register_value),(DeviceType),(exception))monad "  where 
     " CombineS1S2Device s1device s2device = (
   undefined_DeviceType ()  \<bind> (\<lambda> (result :: DeviceType) . 
   (let (result :: DeviceType) =
     (if ((((((s2device = DeviceType_nGnRnE))) \<or> (((s1device = DeviceType_nGnRnE)))))) then
       DeviceType_nGnRnE
     else if ((((((s2device = DeviceType_nGnRE))) \<or> (((s1device = DeviceType_nGnRE)))))) then
       DeviceType_nGnRE
     else if ((((((s2device = DeviceType_nGRE))) \<or> (((s1device = DeviceType_nGRE)))))) then
       DeviceType_nGRE
     else DeviceType_GRE) in
   return result)))"


(*val CombineS1S2AttrHints : MemAttrHints -> MemAttrHints -> M MemAttrHints*)

definition CombineS1S2AttrHints  :: " MemAttrHints \<Rightarrow> MemAttrHints \<Rightarrow>((register_value),(MemAttrHints),(exception))monad "  where 
     " CombineS1S2AttrHints s1desc s2desc = (
   undefined_MemAttrHints ()  \<bind> (\<lambda> (result :: MemAttrHints) . 
   (if (((((((MemAttrHints_attrs   s2desc) = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<or> ((((MemAttrHints_attrs   s1desc) = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
      (undefined_bitvector (( 2 :: int)::ii)  :: ( 2 Word.word) M) \<bind> (\<lambda> (w__0 ::  2 Word.word) . 
      (let (result :: MemAttrHints) = ((result (| MemAttrHints_attrs := w__0 |))) in
      return result))
    else
      (let (result :: MemAttrHints) =
        (if (((((((MemAttrHints_attrs   s2desc) = MemAttr_NC))) \<or> ((((MemAttrHints_attrs   s1desc) = MemAttr_NC)))))) then
          (result (| MemAttrHints_attrs := MemAttr_NC |))
        else if (((((((MemAttrHints_attrs   s2desc) = MemAttr_WT))) \<or> ((((MemAttrHints_attrs   s1desc) = MemAttr_WT)))))) then
          (result (| MemAttrHints_attrs := MemAttr_WT |))
        else (result (| MemAttrHints_attrs := MemAttr_WB |))) in
      return result)) \<bind> (\<lambda> (result :: MemAttrHints) . 
   (let (result :: MemAttrHints) = ((result (| MemAttrHints_hints := ((MemAttrHints_hints   s1desc))|))) in
   (let (result :: MemAttrHints) =
     ((result (| MemAttrHints_transient := ((MemAttrHints_transient   s1desc))|))) in
   return result)))))"


(*val AArch64_InstructionDevice : AddressDescriptor -> mword ty64 -> mword ty52 -> ii -> AccType -> bool -> bool -> bool -> M AddressDescriptor*)

definition AArch64_InstructionDevice  :: " AddressDescriptor \<Rightarrow>(64)Word.word \<Rightarrow>(52)Word.word \<Rightarrow> int \<Rightarrow> AccType \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(AddressDescriptor),(exception))monad "  where 
     " AArch64_InstructionDevice addrdesc__arg vaddress ipaddress level acctype iswrite secondstage s2fs1walk = (
   (let addrdesc = addrdesc__arg in
   (let (c :: Constraint) = (ConstrainUnpredictable Unpredictable_INSTRDEVICE) in
   assert_exp ((((((c = Constraint_NONE))) \<or> (((c = Constraint_FAULT)))))) (''((c == Constraint_NONE) || (c == Constraint_FAULT))'') \<then>
   (if (((c = Constraint_FAULT))) then
     AArch64_PermissionFault ipaddress level acctype iswrite secondstage s2fs1walk \<bind> (\<lambda> (w__0 ::
       FaultRecord) . 
     (let (addrdesc :: AddressDescriptor) = ((addrdesc (| AddressDescriptor_fault := w__0 |))) in
     return addrdesc))
   else
     (let (tmp_120 :: MemoryAttributes) = ((AddressDescriptor_memattrs   addrdesc)) in
     (let tmp_120 = ((tmp_120 (| MemoryAttributes_typ := MemType_Normal |))) in
     (let addrdesc = ((addrdesc (| AddressDescriptor_memattrs := tmp_120 |))) in
     (let (tmp_130 :: MemAttrHints) = ((MemoryAttributes_inner  (AddressDescriptor_memattrs   addrdesc))) in
     (let tmp_130 = ((tmp_130 (| MemAttrHints_attrs := MemAttr_NC |))) in
     (let (tmp_140 :: MemoryAttributes) = ((AddressDescriptor_memattrs   addrdesc)) in
     (let tmp_140 = ((tmp_140 (| MemoryAttributes_inner := tmp_130 |))) in
     (let addrdesc = ((addrdesc (| AddressDescriptor_memattrs := tmp_140 |))) in
     (let (tmp_150 :: MemAttrHints) = ((MemoryAttributes_inner  (AddressDescriptor_memattrs   addrdesc))) in
     (let tmp_150 = ((tmp_150 (| MemAttrHints_hints := MemHint_No |))) in
     (let (tmp_160 :: MemoryAttributes) = ((AddressDescriptor_memattrs   addrdesc)) in
     (let tmp_160 = ((tmp_160 (| MemoryAttributes_inner := tmp_150 |))) in
     (let addrdesc = ((addrdesc (| AddressDescriptor_memattrs := tmp_160 |))) in
     (let (tmp_170 :: MemoryAttributes) = ((AddressDescriptor_memattrs   addrdesc)) in
     (let tmp_170 =
       ((tmp_170 (|
         MemoryAttributes_outer := ((MemoryAttributes_inner  (AddressDescriptor_memattrs   addrdesc)))|))) in
     (let addrdesc = ((addrdesc (| AddressDescriptor_memattrs := tmp_170 |))) in
     MemAttrDefaults(AddressDescriptor_memattrs   addrdesc) \<bind> (\<lambda> (w__1 :: MemoryAttributes) . 
     (let (addrdesc :: AddressDescriptor) = ((addrdesc (| AddressDescriptor_memattrs := w__1 |))) in
     return addrdesc))))))))))))))))))))))"


(*val aget_Vpart : forall 'width . Size 'width => integer -> ii -> ii -> M (mword 'width)*)

definition aget_Vpart  :: " int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(('width::len)Word.word),(exception))monad "  where 
     " aget_Vpart (width__tv :: int) n part = (
   (assert_exp (((((n \<ge> (( 0 :: int)::ii))) \<and> ((n \<le> (( 31 :: int)::ii)))))) (''((n >= 0) && (n <= 31))'') \<then>
   assert_exp ((((((part = (( 0 :: int)::ii)))) \<or> (((part = (( 1 :: int)::ii))))))) (''((part == 0) || (part == 1))'')) \<then>
   (if (((part = (( 0 :: int)::ii)))) then
     (assert_exp ((((((width__tv = (( 8 :: int)::ii)))) \<or> ((((((width__tv = (( 16 :: int)::ii)))) \<or> ((((((width__tv = (( 32 :: int)::ii)))) \<or> (((width__tv = (( 64 :: int)::ii))))))))))))) (''((width == 8) || ((width == 16) || ((width == 32) || (width == 64))))'') \<then>
     read_reg V_ref) \<bind> (\<lambda> (w__0 :: ( 128 bits) list) . 
     return ((slice ((access_list_dec w__0 n  ::  128 Word.word)) (( 0 :: int)::ii) width__tv  :: ( 'width::len)Word.word)))
   else
     (assert_exp (((width__tv = (( 64 :: int)::ii)))) (''(width == 64)'') \<then>
     read_reg V_ref) \<bind> (\<lambda> (w__1 :: ( 128 bits) list) . 
     return ((Word.ucast
                ((slice ((access_list_dec w__1 n  ::  128 Word.word)) (( 64 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))
               :: ( 'width::len)Word.word)))))"


(*val aget_V : forall 'width . Size 'width => integer -> ii -> M (mword 'width)*)

definition aget_V  :: " int \<Rightarrow> int \<Rightarrow>((register_value),(('width::len)Word.word),(exception))monad "  where 
     " aget_V (width__tv :: int) n = (
   ((assert_exp (((((n \<ge> (( 0 :: int)::ii))) \<and> ((n \<le> (( 31 :: int)::ii)))))) (''((n >= 0) && (n <= 31))'') \<then>
   assert_exp ((((((width__tv = (( 8 :: int)::ii)))) \<or> ((((((width__tv = (( 16 :: int)::ii)))) \<or> ((((((width__tv = (( 32 :: int)::ii)))) \<or> ((((((width__tv = (( 64 :: int)::ii)))) \<or> (((width__tv = (( 128 :: int)::ii)))))))))))))))) (''((width == 8) || ((width == 16) || ((width == 32) || ((width == 64) || (width == 128)))))'')) \<then>
   read_reg V_ref) \<bind> (\<lambda> (w__0 :: ( 128 bits) list) . 
   return ((slice ((access_list_dec w__0 n  ::  128 Word.word)) (( 0 :: int)::ii) width__tv  :: ( 'width::len)Word.word))))"


(*val LookUpRIndex : ii -> mword ty5 -> M ii*)

definition LookUpRIndex  :: " int \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(int),(exception))monad "  where 
     " LookUpRIndex n mode = (
   (assert_exp (((((n \<ge> (( 0 :: int)::ii))) \<and> ((n \<le> (( 14 :: int)::ii)))))) (''((n >= 0) && (n <= 14))'') \<then>
   undefined_int () ) \<bind> (\<lambda> (result :: ii) . 
   (let p00 = n in
   if (((p00 = (( 8 :: int)::ii)))) then RBankSelect mode (( 8 :: int)::ii) (( 24 :: int)::ii) (( 8 :: int)::ii) (( 8 :: int)::ii) (( 8 :: int)::ii) (( 8 :: int)::ii) (( 8 :: int)::ii)
   else if (((p00 = (( 9 :: int)::ii)))) then RBankSelect mode (( 9 :: int)::ii) (( 25 :: int)::ii) (( 9 :: int)::ii) (( 9 :: int)::ii) (( 9 :: int)::ii) (( 9 :: int)::ii) (( 9 :: int)::ii)
   else if (((p00 = (( 10 :: int)::ii)))) then
     RBankSelect mode (( 10 :: int)::ii) (( 26 :: int)::ii) (( 10 :: int)::ii) (( 10 :: int)::ii) (( 10 :: int)::ii) (( 10 :: int)::ii) (( 10 :: int)::ii)
   else if (((p00 = (( 11 :: int)::ii)))) then
     RBankSelect mode (( 11 :: int)::ii) (( 27 :: int)::ii) (( 11 :: int)::ii) (( 11 :: int)::ii) (( 11 :: int)::ii) (( 11 :: int)::ii) (( 11 :: int)::ii)
   else if (((p00 = (( 12 :: int)::ii)))) then
     RBankSelect mode (( 12 :: int)::ii) (( 28 :: int)::ii) (( 12 :: int)::ii) (( 12 :: int)::ii) (( 12 :: int)::ii) (( 12 :: int)::ii) (( 12 :: int)::ii)
   else if (((p00 = (( 13 :: int)::ii)))) then
     RBankSelect mode (( 13 :: int)::ii) (( 29 :: int)::ii) (( 17 :: int)::ii) (( 19 :: int)::ii) (( 21 :: int)::ii) (( 23 :: int)::ii) (( 15 :: int)::ii)
   else if (((p00 = (( 14 :: int)::ii)))) then
     RBankSelect mode (( 14 :: int)::ii) (( 30 :: int)::ii) (( 16 :: int)::ii) (( 18 :: int)::ii) (( 20 :: int)::ii) (( 22 :: int)::ii) (( 14 :: int)::ii)
   else return n)))"


(*val HighestSetBit : forall 'N . Size 'N => mword 'N -> M ii*)

definition HighestSetBit  :: "('N::len)Word.word \<Rightarrow>((register_value),(int),(exception))monad "  where 
     " HighestSetBit x = (
   catch_early_return
     ((foreachM (index_list ((((int (size x))) - (( 1 :: int)::ii))) (( 0 :: int)::ii) (- (( 1 :: int)::ii))) () 
        (\<lambda> i unit_var . 
          if ((((vec_of_bits [access_vec_dec x i]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
            (early_return i :: (unit, ii) MR)
          else return () )) \<then>
      return ((- (( 1 :: int)::ii)))))"


(*val CountLeadingZeroBits : forall 'N . Size 'N => mword 'N -> M ii*)

definition CountLeadingZeroBits  :: "('N::len)Word.word \<Rightarrow>((register_value),(int),(exception))monad "  where 
     " CountLeadingZeroBits x = (
   HighestSetBit x \<bind> (\<lambda> (w__0 :: ii) . 
   return ((((((int (size x))) - (( 1 :: int)::ii))) - ((ex_int w__0))))))"


(*val CountLeadingSignBits : forall 'N . Size 'N => mword 'N -> M ii*)

definition CountLeadingSignBits  :: "('N::len)Word.word \<Rightarrow>((register_value),(ii),(exception))monad "  where 
     " CountLeadingSignBits x = (
   CountLeadingZeroBits
     ((xor_vec ((shiftr x (( 1 :: int)::ii)  :: ( 'N::len)Word.word))
         ((and_vec x ((slice_mask ((int (size x))) (( 0 :: int)::ii) ((int (size x)))  :: ( 'N::len)Word.word))  :: ( 'N::len)Word.word))
        :: ( 'N::len)Word.word)))"


(*val BitReverse : forall 'N . Size 'N => mword 'N -> M (mword 'N)*)

definition BitReverse  :: "('N::len)Word.word \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " BitReverse data = (
   (undefined_bitvector ((int (size data)))  :: (( 'N::len)Word.word) M) \<bind> (\<lambda> result . 
   (let result =
     (foreach (index_list (( 0 :: int)::ii) ((((int (size data))) - (( 1 :: int)::ii))) (( 1 :: int)::ii)) result
       (\<lambda> i result . 
         (set_slice ((int (size data))) (( 1 :: int)::ii) result
            ((((((int (size data))) - i)) - (( 1 :: int)::ii)))
            (vec_of_bits [access_vec_dec data i]  ::  1 Word.word)
           :: ( 'N::len)Word.word))) in
   return result)))"


(*val NextInstrAddr : forall 'N . Size 'N => integer -> unit -> M (mword 'N)*)

definition NextInstrAddr  :: " int \<Rightarrow> unit \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " NextInstrAddr (N__tv :: int) _ = (
   (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 :: 64 bits) . 
   ThisInstrLength ()  \<bind> (\<lambda> (w__1 :: ii) . 
   return ((slice ((add_vec_int w__0 ((((ex_int w__1)) div (( 8 :: int)::ii)))  ::  64 Word.word)) (( 0 :: int)::ii)
              N__tv
             :: ( 'N::len)Word.word)))))"


(*val AArch32_ExceptionClass : Exception -> M (ii * mword ty1)*)

definition AArch32_ExceptionClass  :: " Exception \<Rightarrow>((register_value),(int*(1)Word.word),(exception))monad "  where 
     " AArch32_ExceptionClass typ1 = (
   ThisInstrLength ()  \<bind> (\<lambda> (w__0 :: ii) . 
   (let (il :: 1 bits) =
     (if (((((ex_int w__0)) = (( 32 :: int)::ii)))) then (vec_of_bits [B1]  ::  1 Word.word)
     else (vec_of_bits [B0]  ::  1 Word.word)) in
   undefined_int ()  \<bind> (\<lambda> (ec :: ii) . 
   (case  typ1 of
     Exception_Uncategorized =>
      (let (ec :: ii) = ((( 0 :: int)::ii)) in
      (let (il :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
      return (ec, il)))
   | Exception_WFxTrap =>
      (let (ec :: ii) = ((( 1 :: int)::ii)) in
      return (ec, il))
   | Exception_CP15RTTrap =>
      (let (ec :: ii) = ((( 3 :: int)::ii)) in
      return (ec, il))
   | Exception_CP15RRTTrap =>
      (let (ec :: ii) = ((( 4 :: int)::ii)) in
      return (ec, il))
   | Exception_CP14RTTrap =>
      (let (ec :: ii) = ((( 5 :: int)::ii)) in
      return (ec, il))
   | Exception_CP14DTTrap =>
      (let (ec :: ii) = ((( 6 :: int)::ii)) in
      return (ec, il))
   | Exception_AdvSIMDFPAccessTrap =>
      (let (ec :: ii) = ((( 7 :: int)::ii)) in
      return (ec, il))
   | Exception_FPIDTrap =>
      (let (ec :: ii) = ((( 8 :: int)::ii)) in
      return (ec, il))
   | Exception_CP14RRTTrap =>
      (let (ec :: ii) = ((( 12 :: int)::ii)) in
      return (ec, il))
   | Exception_IllegalState =>
      (let (ec :: ii) = ((( 14 :: int)::ii)) in
      (let (il :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
      return (ec, il)))
   | Exception_SupervisorCall =>
      (let (ec :: ii) = ((( 17 :: int)::ii)) in
      return (ec, il))
   | Exception_HypervisorCall =>
      (let (ec :: ii) = ((( 18 :: int)::ii)) in
      return (ec, il))
   | Exception_MonitorCall =>
      (let (ec :: ii) = ((( 19 :: int)::ii)) in
      return (ec, il))
   | Exception_InstructionAbort =>
      (let (ec :: ii) = ((( 32 :: int)::ii)) in
      (let (il :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
      return (ec, il)))
   | Exception_PCAlignment =>
      (let (ec :: ii) = ((( 34 :: int)::ii)) in
      (let (il :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
      return (ec, il)))
   | Exception_DataAbort =>
      (let (ec :: ii) = ((( 36 :: int)::ii)) in
      return (ec, il))
   | Exception_FPTrappedException =>
      (let (ec :: ii) = ((( 40 :: int)::ii)) in
      return (ec, il))
   | _ => Unreachable ()  \<then> return (ec, il)
   ) \<bind> (\<lambda> varstup .  (let ((ec :: ii), (il :: 1 bits)) = varstup in
   and_boolM (return ((((((((ex_int ec)) = (( 32 :: int)::ii)))) \<or> (((((ex_int ec)) = (( 36 :: int)::ii))))))))
     (read_reg PSTATE_ref \<bind> (\<lambda> (w__1 :: ProcState) .  return ((((ProcState_EL   w__1) = EL2))))) \<bind> (\<lambda> (w__2 ::
     bool) . 
   (let (ec :: ii) = (if w__2 then ((ex_int ec)) + (( 1 :: int)::ii) else ec) in
   return (ec, il)))))))))"


(*val RotCell : mword ty4 -> ii -> M (mword ty4)*)

definition RotCell  :: "(4)Word.word \<Rightarrow> int \<Rightarrow>((register_value),((4)Word.word),(exception))monad "  where 
     " RotCell incell_name amount = (
   (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> (\<lambda> (tmp :: 8 bits) . 
   (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (outcell :: 4 bits) . 
   (let (tmp :: 8 bits) =
     ((set_slice (( 8 :: int)::ii) (( 8 :: int)::ii) tmp (( 0 :: int)::ii)
        ((concat_vec ((slice incell_name (( 0 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
            ((slice incell_name (( 0 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
           ::  8 Word.word))
       ::  8 Word.word)) in
   (let (outcell :: 4 bits) = ((slice tmp (((( 4 :: int)::ii) - amount)) (( 4 :: int)::ii)  ::  4 Word.word)) in
   return outcell)))))"


(*val FPNeg : forall 'N . Size 'N => mword 'N -> M (mword 'N)*)

definition FPNeg  :: "('N::len)Word.word \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " FPNeg op1 = (
   (let p00 = (int (size op1)) in
   if (((p00 = (( 16 :: int)::ii)))) then
     (let (op1 ::  16 Word.word) = ((Word.ucast op1  ::  16 Word.word)) in
     assert_exp True (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
     return ((Word.ucast
                ((concat_vec
                    ((not_vec
                        (vec_of_bits [access_vec_dec op1 (((( 16 :: int)::ii) - (( 1 :: int)::ii)))]
                          ::  1 Word.word)
                       ::  1 Word.word))
                    ((slice op1 (( 0 :: int)::ii) (((( 16 :: int)::ii) - (( 1 :: int)::ii)))  ::  15 Word.word))
                   ::  16 Word.word))
               :: ( 'N::len)Word.word)))
   else if (((p00 = (( 32 :: int)::ii)))) then
     (let (op1 ::  32 Word.word) = ((Word.ucast op1  ::  32 Word.word)) in
     assert_exp True (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
     return ((Word.ucast
                ((concat_vec
                    ((not_vec
                        (vec_of_bits [access_vec_dec op1 (((( 32 :: int)::ii) - (( 1 :: int)::ii)))]
                          ::  1 Word.word)
                       ::  1 Word.word))
                    ((slice op1 (( 0 :: int)::ii) (((( 32 :: int)::ii) - (( 1 :: int)::ii)))  ::  31 Word.word))
                   ::  32 Word.word))
               :: ( 'N::len)Word.word)))
   else if (((p00 = (( 64 :: int)::ii)))) then
     (let (op1 ::  64 Word.word) = ((Word.ucast op1  ::  64 Word.word)) in
     assert_exp True (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
     return ((Word.ucast
                ((concat_vec
                    ((not_vec
                        (vec_of_bits [access_vec_dec op1 (((( 64 :: int)::ii) - (( 1 :: int)::ii)))]
                          ::  1 Word.word)
                       ::  1 Word.word))
                    ((slice op1 (( 0 :: int)::ii) (((( 64 :: int)::ii) - (( 1 :: int)::ii)))  ::  63 Word.word))
                   ::  64 Word.word))
               :: ( 'N::len)Word.word)))
   else assert_exp False (''((N == 16) || ((N == 32) || (N == 64)))'') \<then> exit0 () ))"


(*val FPAbs : forall 'N . Size 'N => mword 'N -> M (mword 'N)*)

definition FPAbs  :: "('N::len)Word.word \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " FPAbs op1 = (
   (let p00 = (int (size op1)) in
   if (((p00 = (( 16 :: int)::ii)))) then
     (let (op1 ::  16 Word.word) = ((Word.ucast op1  ::  16 Word.word)) in
     assert_exp True (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
     return ((Word.ucast
                ((concat_vec (vec_of_bits [B0]  ::  1 Word.word)
                    ((slice op1 (( 0 :: int)::ii) (((( 16 :: int)::ii) - (( 1 :: int)::ii)))  ::  15 Word.word))
                   ::  16 Word.word))
               :: ( 'N::len)Word.word)))
   else if (((p00 = (( 32 :: int)::ii)))) then
     (let (op1 ::  32 Word.word) = ((Word.ucast op1  ::  32 Word.word)) in
     assert_exp True (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
     return ((Word.ucast
                ((concat_vec (vec_of_bits [B0]  ::  1 Word.word)
                    ((slice op1 (( 0 :: int)::ii) (((( 32 :: int)::ii) - (( 1 :: int)::ii)))  ::  31 Word.word))
                   ::  32 Word.word))
               :: ( 'N::len)Word.word)))
   else if (((p00 = (( 64 :: int)::ii)))) then
     (let (op1 ::  64 Word.word) = ((Word.ucast op1  ::  64 Word.word)) in
     assert_exp True (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
     return ((Word.ucast
                ((concat_vec (vec_of_bits [B0]  ::  1 Word.word)
                    ((slice op1 (( 0 :: int)::ii) (((( 64 :: int)::ii) - (( 1 :: int)::ii)))  ::  63 Word.word))
                   ::  64 Word.word))
               :: ( 'N::len)Word.word)))
   else assert_exp False (''((N == 16) || ((N == 32) || (N == 64)))'') \<then> exit0 () ))"


(*val EncodeLDFSC : Fault -> ii -> M (mword ty6)*)

definition EncodeLDFSC  :: " Fault \<Rightarrow> int \<Rightarrow>((register_value),((6)Word.word),(exception))monad "  where 
     " EncodeLDFSC typ1 level = (
   (undefined_bitvector (( 6 :: int)::ii)  :: ( 6 Word.word) M) \<bind> (\<lambda> (result :: 6 bits) . 
   (case  typ1 of
     Fault_AddressSize =>
      (let result =
        ((concat_vec (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)
           ((GetSlice_int ((make_the_value (( 2 :: int)::ii)  ::  2 itself)) level (( 0 :: int)::ii)  ::  2 Word.word))
          ::  6 Word.word)) in
      assert_exp ((((((level = (( 0 :: int)::ii)))) \<or> ((((((level = (( 1 :: int)::ii)))) \<or> ((((((level = (( 2 :: int)::ii)))) \<or> (((level = (( 3 :: int)::ii))))))))))))) (''((level == 0) || ((level == 1) || ((level == 2) || (level == 3))))'') \<then>
      return result)
   | Fault_AccessFlag =>
      (let result =
        ((concat_vec (vec_of_bits [B0,B0,B1,B0]  ::  4 Word.word)
           ((GetSlice_int ((make_the_value (( 2 :: int)::ii)  ::  2 itself)) level (( 0 :: int)::ii)  ::  2 Word.word))
          ::  6 Word.word)) in
      assert_exp ((((((level = (( 1 :: int)::ii)))) \<or> ((((((level = (( 2 :: int)::ii)))) \<or> (((level = (( 3 :: int)::ii)))))))))) (''((level == 1) || ((level == 2) || (level == 3)))'') \<then>
      return result)
   | Fault_Permission =>
      (let result =
        ((concat_vec (vec_of_bits [B0,B0,B1,B1]  ::  4 Word.word)
           ((GetSlice_int ((make_the_value (( 2 :: int)::ii)  ::  2 itself)) level (( 0 :: int)::ii)  ::  2 Word.word))
          ::  6 Word.word)) in
      assert_exp ((((((level = (( 1 :: int)::ii)))) \<or> ((((((level = (( 2 :: int)::ii)))) \<or> (((level = (( 3 :: int)::ii)))))))))) (''((level == 1) || ((level == 2) || (level == 3)))'') \<then>
      return result)
   | Fault_Translation =>
      (let result =
        ((concat_vec (vec_of_bits [B0,B0,B0,B1]  ::  4 Word.word)
           ((GetSlice_int ((make_the_value (( 2 :: int)::ii)  ::  2 itself)) level (( 0 :: int)::ii)  ::  2 Word.word))
          ::  6 Word.word)) in
      assert_exp ((((((level = (( 0 :: int)::ii)))) \<or> ((((((level = (( 1 :: int)::ii)))) \<or> ((((((level = (( 2 :: int)::ii)))) \<or> (((level = (( 3 :: int)::ii))))))))))))) (''((level == 0) || ((level == 1) || ((level == 2) || (level == 3))))'') \<then>
      return result)
   | Fault_SyncExternal =>
      (let (result :: 6 bits) = ((vec_of_bits [B0,B1,B0,B0,B0,B0]  ::  6 Word.word)) in
      return result)
   | Fault_SyncExternalOnWalk =>
      (let result =
        ((concat_vec (vec_of_bits [B0,B1,B0,B1]  ::  4 Word.word)
           ((GetSlice_int ((make_the_value (( 2 :: int)::ii)  ::  2 itself)) level (( 0 :: int)::ii)  ::  2 Word.word))
          ::  6 Word.word)) in
      assert_exp ((((((level = (( 0 :: int)::ii)))) \<or> ((((((level = (( 1 :: int)::ii)))) \<or> ((((((level = (( 2 :: int)::ii)))) \<or> (((level = (( 3 :: int)::ii))))))))))))) (''((level == 0) || ((level == 1) || ((level == 2) || (level == 3))))'') \<then>
      return result)
   | Fault_SyncParity =>
      (let (result :: 6 bits) = ((vec_of_bits [B0,B1,B1,B0,B0,B0]  ::  6 Word.word)) in
      return result)
   | Fault_SyncParityOnWalk =>
      (let result =
        ((concat_vec (vec_of_bits [B0,B1,B1,B1]  ::  4 Word.word)
           ((GetSlice_int ((make_the_value (( 2 :: int)::ii)  ::  2 itself)) level (( 0 :: int)::ii)  ::  2 Word.word))
          ::  6 Word.word)) in
      assert_exp ((((((level = (( 0 :: int)::ii)))) \<or> ((((((level = (( 1 :: int)::ii)))) \<or> ((((((level = (( 2 :: int)::ii)))) \<or> (((level = (( 3 :: int)::ii))))))))))))) (''((level == 0) || ((level == 1) || ((level == 2) || (level == 3))))'') \<then>
      return result)
   | Fault_AsyncParity =>
      (let (result :: 6 bits) = ((vec_of_bits [B0,B1,B1,B0,B0,B1]  ::  6 Word.word)) in
      return result)
   | Fault_AsyncExternal =>
      (let (result :: 6 bits) = ((vec_of_bits [B0,B1,B0,B0,B0,B1]  ::  6 Word.word)) in
      return result)
   | Fault_Alignment =>
      (let (result :: 6 bits) = ((vec_of_bits [B1,B0,B0,B0,B0,B1]  ::  6 Word.word)) in
      return result)
   | Fault_Debug =>
      (let (result :: 6 bits) = ((vec_of_bits [B1,B0,B0,B0,B1,B0]  ::  6 Word.word)) in
      return result)
   | Fault_TLBConflict =>
      (let (result :: 6 bits) = ((vec_of_bits [B1,B1,B0,B0,B0,B0]  ::  6 Word.word)) in
      return result)
   | Fault_Lockdown =>
      (let (result :: 6 bits) = ((vec_of_bits [B1,B1,B0,B1,B0,B0]  ::  6 Word.word)) in
      return result)
   | Fault_Exclusive =>
      (let (result :: 6 bits) = ((vec_of_bits [B1,B1,B0,B1,B0,B1]  ::  6 Word.word)) in
      return result)
   | _ => Unreachable ()  \<then> return result
   )))"




(*val AArch32_ReportHypEntry : ExceptionRecord -> M unit*)

definition AArch32_ReportHypEntry  :: " ExceptionRecord \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch32_ReportHypEntry exception = (
   (let (typ1 :: Exception) = ((ExceptionRecord_typ   exception)) in
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (il :: 1 bits) . 
   undefined_int ()  \<bind> (\<lambda> (ec :: ii) . 
   (AArch32_ExceptionClass typ1  :: ((ii *  1 Word.word)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1) = varstup in
   (let ec = tup__0 in
   (let il = tup__1 in
   (let (iss :: 25 bits) = ((ExceptionRecord_syndrome   exception)) in
   (let (il :: 1 bits) =
     (if (((((((((((ex_int ec)) = (( 36 :: int)::ii)))) \<or> (((((ex_int ec)) = (( 37 :: int)::ii))))))) \<and> ((((vec_of_bits [access_vec_dec iss (( 24 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))) then
       (vec_of_bits [B1]  ::  1 Word.word)
     else il) in
   (write_reg
     HSR_ref
     ((concat_vec
         ((concat_vec
             ((GetSlice_int ((make_the_value (( 6 :: int)::ii)  ::  6 itself)) ec (( 0 :: int)::ii)  ::  6 Word.word)) il
            ::  7 Word.word)) iss
        ::  32 Word.word)) \<then>
   (if ((((((typ1 = Exception_InstructionAbort))) \<or> (((typ1 = Exception_PCAlignment)))))) then
      (write_reg HIFAR_ref ((slice(ExceptionRecord_vaddress   exception) (( 0 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) \<then>
      (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__0 ::  32 Word.word) . 
      write_reg HDFAR_ref w__0)
    else if (((typ1 = Exception_DataAbort))) then
      (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 ::  32 Word.word) . 
      write_reg HIFAR_ref w__1 \<then>
      write_reg HDFAR_ref ((slice(ExceptionRecord_vaddress   exception) (( 0 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)))
    else return () )) \<then>
   (if(ExceptionRecord_ipavalid   exception) then
     (read_reg HPFAR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__2 :: 32 bits) . 
     write_reg
       HPFAR_ref
       ((set_slice (( 32 :: int)::ii) (( 28 :: int)::ii) w__2 (( 4 :: int)::ii)
           ((slice(ExceptionRecord_ipaddress   exception) (( 12 :: int)::ii) (( 28 :: int)::ii)  ::  28 Word.word))
          ::  32 Word.word)))
   else
     (read_reg HPFAR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__3 :: 32 bits) . 
     (undefined_bitvector (( 28 :: int)::ii)  :: ( 28 Word.word) M) \<bind> (\<lambda> (w__4 ::  28 Word.word) . 
     write_reg HPFAR_ref ((set_slice (( 32 :: int)::ii) (( 28 :: int)::ii) w__3 (( 4 :: int)::ii) w__4  ::  32 Word.word)))))))))))))))"


(*val aset_Elem__0 : forall 'N 'size . Size 'N, Size 'size => mword 'N -> ii -> itself 'size -> mword 'size -> M (mword 'N)*)

(*val aset_Elem__1 : forall 'N 'size . Size 'N, Size 'size => mword 'N -> ii -> mword 'size -> M (mword 'N)*)

definition aset_Elem__0  :: "('N::len)Word.word \<Rightarrow> int \<Rightarrow>('size::len)itself \<Rightarrow>('size::len)Word.word \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " aset_Elem__0 vector_name__arg e size1 value_name = (
   (let size1 = (size_itself_int size1) in
   (let vector_name = vector_name__arg in
   assert_exp (((((e \<ge> (( 0 :: int)::ii))) \<and> ((((((e + (( 1 :: int)::ii))) * size1)) \<le> ((int (size vector_name)))))))) (''((e >= 0) && (((e + 1) * size) <= N))'') \<then>
   ((let (vector_name :: ( 'N::len)Word.word) =
     ((set_slice ((int (size vector_name))) size1 vector_name ((e * size1)) value_name
       :: ( 'N::len)Word.word)) in
   return vector_name)))))"


definition aset_Elem__1  :: "('N::len)Word.word \<Rightarrow> int \<Rightarrow>('size::len)Word.word \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " aset_Elem__1 vector_name__arg e value_name = (
   (let vector_name = vector_name__arg in
   (aset_Elem__0 vector_name e ((make_the_value ((int (size value_name))) )) value_name  :: (( 'N::len)Word.word) M)))"


(*val aget_Elem__0 : forall 'N 'size . Size 'N, Size 'size => mword 'N -> ii -> itself 'size -> M (mword 'size)*)

(*val aget_Elem__1 : forall 'N 'size . Size 'N, Size 'size => integer -> mword 'N -> ii -> M (mword 'size)*)

definition aget_Elem__0  :: "('N::len)Word.word \<Rightarrow> int \<Rightarrow>('size::len)itself \<Rightarrow>((register_value),(('size::len)Word.word),(exception))monad "  where 
     " aget_Elem__0 vector_name e size1 = (
   (let size1 = (size_itself_int size1) in
   assert_exp (((((e \<ge> (( 0 :: int)::ii))) \<and> ((((((e + (( 1 :: int)::ii))) * size1)) \<le> ((int (size vector_name)))))))) (''((e >= 0) && (((e + 1) * size) <= N))'') \<then>
   return ((slice vector_name ((e * size1)) size1  :: ( 'size::len)Word.word))))"


definition aget_Elem__1  :: " int \<Rightarrow>('N::len)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(('size::len)Word.word),(exception))monad "  where 
     " aget_Elem__1 (size__tv :: int) vector_name e = (
   (aget_Elem__0 vector_name e ((make_the_value size__tv ))  :: (( 'size::len)Word.word) M))"


(*val UnsignedSatQ : forall 'N . Size 'N => ii -> itself 'N -> M (mword 'N * bool)*)

definition UnsignedSatQ  :: " int \<Rightarrow>('N::len)itself \<Rightarrow>((register_value),(('N::len)Word.word*bool),(exception))monad "  where 
     " UnsignedSatQ i N = (
   (let N = (size_itself_int N) in
   undefined_bool ()  \<bind> (\<lambda> (saturated :: bool) . 
   undefined_int ()  \<bind> (\<lambda> (result :: ii) . 
   (let ((result :: ii), (saturated :: bool)) =
     (if ((i > ((((pow2 N)) - (( 1 :: int)::ii))))) then
       (let (result :: ii) = (((pow2 N)) - (( 1 :: int)::ii)) in
       (let (saturated :: bool) = True in
       (result, saturated)))
     else
       (let ((result :: ii), (saturated :: bool)) =
         (if ((i < (( 0 :: int)::ii))) then
           (let (result :: ii) = ((( 0 :: int)::ii)) in
           (let (saturated :: bool) = True in
           (result, saturated)))
         else
           (let (result :: ii) = i in
           (let (saturated :: bool) = False in
           (result, saturated)))) in
       (result, saturated))) in
   return ((GetSlice_int ((make_the_value N )) result (( 0 :: int)::ii)  :: ( 'N::len)Word.word), saturated))))))"


(*val SignedSatQ : forall 'N . Size 'N => ii -> itself 'N -> M (mword 'N * bool)*)

definition SignedSatQ  :: " int \<Rightarrow>('N::len)itself \<Rightarrow>((register_value),(('N::len)Word.word*bool),(exception))monad "  where 
     " SignedSatQ i N = (
   (let N = (size_itself_int N) in
   undefined_bool ()  \<bind> (\<lambda> (saturated :: bool) . 
   undefined_int ()  \<bind> (\<lambda> (result :: ii) . 
   (let ((result :: ii), (saturated :: bool)) =
     (if ((i > ((((pow2 ((N - (( 1 :: int)::ii))))) - (( 1 :: int)::ii))))) then
       (let (result :: ii) = (((pow2 ((N - (( 1 :: int)::ii))))) - (( 1 :: int)::ii)) in
       (let (saturated :: bool) = True in
       (result, saturated)))
     else
       (let ((result :: ii), (saturated :: bool)) =
         (if ((i < ((- ((pow2 ((N - (( 1 :: int)::ii))))))))) then
           (let (result :: ii) = (- ((pow2 ((N - (( 1 :: int)::ii)))))) in
           (let (saturated :: bool) = True in
           (result, saturated)))
         else
           (let (result :: ii) = i in
           (let (saturated :: bool) = False in
           (result, saturated)))) in
       (result, saturated))) in
   return ((GetSlice_int ((make_the_value N )) result (( 0 :: int)::ii)  :: ( 'N::len)Word.word), saturated))))))"


(*val SatQ : forall 'N . Size 'N => ii -> itself 'N -> bool -> M (mword 'N * bool)*)

definition SatQ  :: " int \<Rightarrow>('N::len)itself \<Rightarrow> bool \<Rightarrow>((register_value),(('N::len)Word.word*bool),(exception))monad "  where 
     " SatQ i N unsigned = (
   (let N = (size_itself_int N) in
   undefined_bool ()  \<bind> (\<lambda> (sat :: bool) . 
   (undefined_bitvector N  :: (( 'N::len)Word.word) M) \<bind> (\<lambda> result . 
   (if unsigned then (UnsignedSatQ i ((make_the_value N )) )
    else (SignedSatQ i ((make_the_value N )) )) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1) = varstup in
   (let result = tup__0 in
   (let (sat :: bool) = tup__1 in
   return (result, sat)))))))))"


(*val Replicate : forall 'M 'N . Size 'M, Size 'N => integer -> mword 'M -> M (mword 'N)*)

definition Replicate  :: " int \<Rightarrow>('M::len)Word.word \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " Replicate (N__tv :: int) x = (
   assert_exp (((((N__tv mod ((int (size x))))) = (( 0 :: int)::ii)))) (''((N MOD M) == 0)'') \<then>
   ((let O1 = (N__tv div ((int (size x)))) in
   assert_exp True ('''') \<then> return ((replicate_bits x ((N__tv div ((int (size x))))))))))"


(*val Zeros__0 : forall 'N . Size 'N => itself 'N -> mword 'N*)

(*val Zeros__1 : forall 'N . Size 'N => integer -> unit -> mword 'N*)

definition Zeros__0  :: "('N::len)itself \<Rightarrow>('N::len)Word.word "  where 
     " Zeros__0 N = (
   (let N = (size_itself_int N) in
   (replicate_bits (vec_of_bits [B0]  ::  1 Word.word) N  :: ( 'N::len)Word.word)))"


definition Zeros__1  :: " int \<Rightarrow> unit \<Rightarrow>('N::len)Word.word "  where 
     " Zeros__1 (N__tv :: int) _ = ( (Zeros__0 ((make_the_value N__tv ))  :: ( 'N::len)Word.word))"


(*val __ResetMemoryState : unit -> M unit*)

definition ResetMemoryState  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " ResetMemoryState _ = (
   (read_reg Memory_ref  :: ( 52 Word.word) M) \<bind> (\<lambda> (w__0 :: 52 bits) . 
   (let (_ :: unit) =
     (InitRAM (( 52 :: int)::ii) (( 1 :: int)::ii) w__0 ((Zeros__0 ((make_the_value (( 8 :: int)::ii)  ::  8 itself))  ::  8 Word.word))) in
   write_reg ExclusiveLocal_ref False)))"


(*val ZeroExtend__0 : forall 'M 'N . Size 'M, Size 'N => mword 'M -> itself 'N -> M (mword 'N)*)

(*val ZeroExtend__1 : forall 'M 'N . Size 'M, Size 'N => integer -> mword 'M -> M (mword 'N)*)

definition ZeroExtend__0  :: "('M::len)Word.word \<Rightarrow>('N::len)itself \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " ZeroExtend__0 x N = (
   (let N = (size_itself_int N) in
   assert_exp ((N \<ge> ((int (size x))))) ('''') \<then> return ((extzv N x  :: ( 'N::len)Word.word))))"


definition ZeroExtend__1  :: " int \<Rightarrow>('M::len)Word.word \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " ZeroExtend__1 (N__tv :: int) x = ( (ZeroExtend__0 x ((make_the_value N__tv ))  :: (( 'N::len)Word.word) M))"


(*val aset_Vpart : forall 'width . Size 'width => ii -> ii -> mword 'width -> M unit*)

definition aset_Vpart  :: " int \<Rightarrow> int \<Rightarrow>('width::len)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aset_Vpart n part value_name = (
   (assert_exp (((((n \<ge> (( 0 :: int)::ii))) \<and> ((n \<le> (( 31 :: int)::ii)))))) (''((n >= 0) && (n <= 31))'') \<then>
   assert_exp ((((((part = (( 0 :: int)::ii)))) \<or> (((part = (( 1 :: int)::ii))))))) (''((part == 0) || (part == 1))'')) \<then>
   (if (((part = (( 0 :: int)::ii)))) then
     (assert_exp ((((((((int (size value_name))) = (( 8 :: int)::ii)))) \<or> ((((((((int (size value_name))) = (( 16 :: int)::ii)))) \<or> ((((((((int (size value_name))) = (( 32 :: int)::ii)))) \<or> (((((int (size value_name))) = (( 64 :: int)::ii))))))))))))) (''((width == 8) || ((width == 16) || ((width == 32) || (width == 64))))'') \<then>
     read_reg V_ref) \<bind> (\<lambda> (w__0 :: ( 128 bits) list) . 
     (ZeroExtend__1 (( 128 :: int)::ii) value_name  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__1 ::  128 Word.word) . 
     write_reg V_ref ((update_list_dec w__0 n w__1  :: ( 128 Word.word) list))))
   else
     (assert_exp (((((int (size value_name))) = (( 64 :: int)::ii)))) (''(width == 64)'') \<then>
     read_reg V_ref) \<bind> (\<lambda> (w__2 :: ( 128 bits) list) . 
     (let (tmp_2870 :: 128 bits) = ((access_list_dec w__2 n  ::  128 Word.word)) in
     (let tmp_2870 =
       ((update_subrange_vec_dec tmp_2870 (( 127 :: int)::ii) (( 64 :: int)::ii)
          ((subrange_vec_dec value_name (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
         ::  128 Word.word)) in
     read_reg V_ref \<bind> (\<lambda> (w__3 :: ( 128 bits) list) . 
     write_reg V_ref ((update_list_dec w__3 n tmp_2870  :: ( 128 Word.word) list))))))))"


(*val aset_V : forall 'width . Size 'width => ii -> mword 'width -> M unit*)

definition aset_V  :: " int \<Rightarrow>('width::len)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aset_V n value_name = (
   ((assert_exp (((((n \<ge> (( 0 :: int)::ii))) \<and> ((n \<le> (( 31 :: int)::ii)))))) (''((n >= 0) && (n <= 31))'') \<then>
   assert_exp ((((((((int (size value_name))) = (( 8 :: int)::ii)))) \<or> ((((((((int (size value_name))) = (( 16 :: int)::ii)))) \<or> ((((((((int (size value_name))) = (( 32 :: int)::ii)))) \<or> ((((((((int (size value_name))) = (( 64 :: int)::ii)))) \<or> (((((int (size value_name))) = (( 128 :: int)::ii)))))))))))))))) (''((width == 8) || ((width == 16) || ((width == 32) || ((width == 64) || (width == 128)))))'')) \<then>
   read_reg V_ref) \<bind> (\<lambda> (w__0 :: ( 128 bits) list) . 
   (ZeroExtend__1 (( 128 :: int)::ii) value_name  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__1 ::  128 Word.word) . 
   write_reg V_ref ((update_list_dec w__0 n w__1  :: ( 128 Word.word) list)))))"


(*val AArch64_ResetSIMDFPRegisters : unit -> M unit*)

definition AArch64_ResetSIMDFPRegisters  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_ResetSIMDFPRegisters _ = (
   (foreachM (index_list (( 0 :: int)::ii) (( 31 :: int)::ii) (( 1 :: int)::ii)) () 
     (\<lambda> i unit_var . 
       (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) .  aset_V i w__0))))"


(*val aset_SP : forall 'width . Size 'width => mword 'width -> M unit*)

definition aset_SP  :: "('width::len)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aset_SP value_name = (
   (assert_exp ((((((((int (size value_name))) = (( 32 :: int)::ii)))) \<or> (((((int (size value_name))) = (( 64 :: int)::ii))))))) (''((width == 32) || (width == 64))'') \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__0 :: ProcState) . 
   if ((((ProcState_SP   w__0) = (vec_of_bits [B0]  ::  1 Word.word)))) then
     (ZeroExtend__1 (( 64 :: int)::ii) value_name  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
     write_reg SP_EL0_ref w__1)
   else
     read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) . 
     (let p__299 = ((ProcState_EL   w__2)) in
     (let pat0 = p__299 in
     if (((pat0 = EL0))) then
       (ZeroExtend__1 (( 64 :: int)::ii) value_name  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::  64 Word.word) . 
       write_reg SP_EL0_ref w__3)
     else if (((pat0 = EL1))) then
       (ZeroExtend__1 (( 64 :: int)::ii) value_name  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 ::  64 Word.word) . 
       write_reg SP_EL1_ref w__4)
     else if (((pat0 = EL2))) then
       (ZeroExtend__1 (( 64 :: int)::ii) value_name  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 ::  64 Word.word) . 
       write_reg SP_EL2_ref w__5)
     else
       (ZeroExtend__1 (( 64 :: int)::ii) value_name  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__6 ::  64 Word.word) . 
       write_reg SP_EL3_ref w__6))))))"


(*val LSR_C : forall 'N . Size 'N => mword 'N -> ii -> M (mword 'N * mword ty1)*)

definition LSR_C  :: "('N::len)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(('N::len)Word.word*(1)Word.word),(exception))monad "  where 
     " LSR_C x shift = (
   assert_exp ((shift > (( 0 :: int)::ii))) (''(shift > 0)'') \<then>
   ((let result = ((shiftr x shift  :: ( 'N::len)Word.word)) in
   (let (carry_out :: 1 bits) =
     (if ((shift > ((int (size result))))) then (vec_of_bits [B0]  ::  1 Word.word)
     else (vec_of_bits [access_vec_dec x ((shift - (( 1 :: int)::ii)))]  ::  1 Word.word)) in
   return (result, carry_out)))))"


(*val LSR : forall 'N . Size 'N => mword 'N -> ii -> M (mword 'N)*)

definition LSR  :: "('N::len)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " LSR x shift = (
   (assert_exp ((shift \<ge> (( 0 :: int)::ii))) (''(shift >= 0)'') \<then>
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> (\<lambda> (anon10 :: 1 bits) . 
   (undefined_bitvector ((int (size x)))  :: (( 'N::len)Word.word) M) \<bind> (\<lambda> result . 
   if (((shift = (( 0 :: int)::ii)))) then return x
   else
     (LSR_C x shift ) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1) = varstup in
     (let result = tup__0 in
     (let (anon10 :: 1 bits) = tup__1 in
     return result)))))))"


(*val Poly32Mod2 : forall 'N . Size 'N => mword 'N -> mword ty32 -> M (mword ty32)*)

definition Poly32Mod2  :: "('N::len)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),((32)Word.word),(exception))monad "  where 
     " Poly32Mod2 data__arg poly = (
   (let data = data__arg in
   assert_exp ((((int (size data))) > (( 32 :: int)::ii))) (''(N > 32)'') \<then>
   ((let poly' = ((extzv ((int (size data))) poly  :: ( 'N::len)Word.word)) in
   (let (data :: ( 'N::len)Word.word) =
     (foreach (index_list ((((int (size data))) - (( 1 :: int)::ii))) (( 32 :: int)::ii) (- (( 1 :: int)::ii))) data
       (\<lambda> i data . 
         if ((((vec_of_bits [access_vec_dec data i]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
           (or_vec data ((sub_vec_int ((shiftl poly' i  :: ( 'N::len)Word.word)) (( 32 :: int)::ii)  :: ( 'N::len)Word.word))
             :: ( 'N::len)Word.word)
         else data)) in
   return ((slice data (( 0 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)))))))"


(*val LSL_C : forall 'N . Size 'N => mword 'N -> ii -> M (mword 'N * mword ty1)*)

definition LSL_C  :: "('N::len)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(('N::len)Word.word*(1)Word.word),(exception))monad "  where 
     " LSL_C x shift = (
   assert_exp ((shift > (( 0 :: int)::ii))) (''(shift > 0)'') \<then>
   ((let result = ((shiftl x shift  :: ( 'N::len)Word.word)) in
   (let (carry_out :: 1 bits) =
     (if ((shift > ((int (size result))))) then (vec_of_bits [B0]  ::  1 Word.word)
     else (vec_of_bits [access_vec_dec x ((((int (size result))) - shift))]  ::  1 Word.word)) in
   return (result, carry_out)))))"


(*val LSL : forall 'N . Size 'N => mword 'N -> ii -> M (mword 'N)*)

definition LSL  :: "('N::len)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " LSL x shift = (
   (assert_exp ((shift \<ge> (( 0 :: int)::ii))) (''(shift >= 0)'') \<then>
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> (\<lambda> (anon10 :: 1 bits) . 
   (undefined_bitvector ((int (size x)))  :: (( 'N::len)Word.word) M) \<bind> (\<lambda> result . 
   if (((shift = (( 0 :: int)::ii)))) then return x
   else
     (LSL_C x shift ) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1) = varstup in
     (let result = tup__0 in
     (let (anon10 :: 1 bits) = tup__1 in
     return result)))))))"


(*val AArch32_ITAdvance : unit -> M unit*)

definition AArch32_ITAdvance  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch32_ITAdvance _ = (
   read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) . 
   if (((((slice(ProcState_IT   w__0) (( 0 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) then
     read_reg PSTATE_ref \<bind> (\<lambda> (w__1 :: ProcState) . 
     write_reg
       PSTATE_ref
       (w__1 (| ProcState_IT := ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word))|)))
   else
     read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) . 
     (let (tmp_2760 :: 8 bits) = ((ProcState_IT   w__2)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__3 :: ProcState) . 
     (LSL ((slice(ProcState_IT   w__3) (( 0 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) (( 1 :: int)::ii)  :: ( 5 Word.word) M) \<bind> (\<lambda> (w__4 ::
        5 Word.word) . 
     (let tmp_2760 = ((set_slice (( 8 :: int)::ii) (( 5 :: int)::ii) tmp_2760 (( 0 :: int)::ii) w__4  ::  8 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__5 :: ProcState) . 
     write_reg PSTATE_ref (w__5 (| ProcState_IT := tmp_2760 |))))))))))"


(*val LSInstructionSyndrome : unit -> M (mword ty11)*)

definition LSInstructionSyndrome  :: " unit \<Rightarrow>((register_value),((11)Word.word),(exception))monad "  where 
     " LSInstructionSyndrome _ = (
   assert_exp False (''FALSE'') \<then>
   return ((Zeros__0 ((make_the_value (( 11 :: int)::ii)  ::  11 itself))  ::  11 Word.word)))"


(*val IsZero : forall 'N . Size 'N => mword 'N -> bool*)

definition IsZero  :: "('N::len)Word.word \<Rightarrow> bool "  where 
     " IsZero x = ( (x = ((Zeros__0 ((make_the_value ((int (size x))) ))  :: ( 'N::len)Word.word))))"


(*val IsZeroBit : forall 'N . Size 'N => mword 'N -> mword ty1*)

definition IsZeroBit  :: "('N::len)Word.word \<Rightarrow>(1)Word.word "  where 
     " IsZeroBit x = (
   if ((IsZero x)) then (vec_of_bits [B1]  ::  1 Word.word)
   else (vec_of_bits [B0]  ::  1 Word.word))"


(*val AddWithCarry : forall 'N . Size 'N => mword 'N -> mword 'N -> mword ty1 -> (mword 'N * mword ty4)*)

definition AddWithCarry  :: "('N::len)Word.word \<Rightarrow>('N::len)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>('N::len)Word.word*(4)Word.word "  where 
     " AddWithCarry x y carry_in = (
   (let (unsigned_sum :: ii) = (((((Word.uint x)) + ((Word.uint y)))) + ((Word.uint carry_in))) in
   (let (signed_sum :: ii) = (((((Word.sint x)) + ((Word.sint y)))) + ((Word.uint carry_in))) in
   (let result = ((GetSlice_int ((make_the_value ((int (size x))) )) unsigned_sum (( 0 :: int)::ii)  :: ( 'N::len)Word.word)) in
   (let (n :: 1 bits) =
     ((vec_of_bits [access_vec_dec result ((((int (size result))) - (( 1 :: int)::ii)))]  ::  1 Word.word)) in
   (let (z :: 1 bits) =
     (if ((IsZero result)) then (vec_of_bits [B1]  ::  1 Word.word)
     else (vec_of_bits [B0]  ::  1 Word.word)) in
   (let (c :: 1 bits) =
     (if (((((Word.uint result)) = ((ex_int unsigned_sum))))) then (vec_of_bits [B0]  ::  1 Word.word)
     else (vec_of_bits [B1]  ::  1 Word.word)) in
   (let (v :: 1 bits) =
     (if (((((Word.sint result)) = ((ex_int signed_sum))))) then (vec_of_bits [B0]  ::  1 Word.word)
     else (vec_of_bits [B1]  ::  1 Word.word)) in
   (result,
    (concat_vec ((concat_vec ((concat_vec n z  ::  2 Word.word)) c  ::  3 Word.word)) v  ::  4 Word.word))))))))))"


(*val GetPSRFromPSTATE : unit -> M (mword ty32)*)

definition GetPSRFromPSTATE  :: " unit \<Rightarrow>((register_value),((32)Word.word),(exception))monad "  where 
     " GetPSRFromPSTATE _ = (
   (let (spsr :: 32 bits) = ((Zeros__1 (( 32 :: int)::ii) ()   ::  32 Word.word)) in
   read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) . 
   (let spsr = ((update_subrange_vec_dec spsr (( 31 :: int)::ii) (( 31 :: int)::ii)(ProcState_N   w__0)  ::  32 Word.word)) in
   read_reg PSTATE_ref \<bind> (\<lambda> (w__1 :: ProcState) . 
   (let spsr = ((update_subrange_vec_dec spsr (( 30 :: int)::ii) (( 30 :: int)::ii)(ProcState_Z   w__1)  ::  32 Word.word)) in
   read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) . 
   (let spsr = ((update_subrange_vec_dec spsr (( 29 :: int)::ii) (( 29 :: int)::ii)(ProcState_C   w__2)  ::  32 Word.word)) in
   read_reg PSTATE_ref \<bind> (\<lambda> (w__3 :: ProcState) . 
   (let spsr = ((update_subrange_vec_dec spsr (( 28 :: int)::ii) (( 28 :: int)::ii)(ProcState_V   w__3)  ::  32 Word.word)) in
   read_reg PSTATE_ref \<bind> (\<lambda> (w__4 :: ProcState) . 
   (let spsr = ((update_subrange_vec_dec spsr (( 21 :: int)::ii) (( 21 :: int)::ii)(ProcState_SS   w__4)  ::  32 Word.word)) in
   read_reg PSTATE_ref \<bind> (\<lambda> (w__5 :: ProcState) . 
   (let spsr = ((update_subrange_vec_dec spsr (( 20 :: int)::ii) (( 20 :: int)::ii)(ProcState_IL   w__5)  ::  32 Word.word)) in
   read_reg PSTATE_ref \<bind> (\<lambda> (w__6 :: ProcState) . 
   if ((((ProcState_nRW   w__6) = (vec_of_bits [B1]  ::  1 Word.word)))) then
     read_reg PSTATE_ref \<bind> (\<lambda> (w__7 :: ProcState) . 
     (let spsr = ((update_subrange_vec_dec spsr (( 27 :: int)::ii) (( 27 :: int)::ii)(ProcState_Q   w__7)  ::  32 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__8 :: ProcState) . 
     (let spsr =
       ((update_subrange_vec_dec spsr (( 26 :: int)::ii) (( 25 :: int)::ii)
          ((subrange_vec_dec(ProcState_IT   w__8) (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
         ::  32 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__9 :: ProcState) . 
     (let spsr = ((update_subrange_vec_dec spsr (( 19 :: int)::ii) (( 16 :: int)::ii)(ProcState_GE   w__9)  ::  32 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__10 :: ProcState) . 
     (let spsr =
       ((update_subrange_vec_dec spsr (( 15 :: int)::ii) (( 10 :: int)::ii)
          ((subrange_vec_dec(ProcState_IT   w__10) (( 7 :: int)::ii) (( 2 :: int)::ii)  ::  6 Word.word))
         ::  32 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__11 :: ProcState) . 
     (let spsr = ((update_subrange_vec_dec spsr (( 9 :: int)::ii) (( 9 :: int)::ii)(ProcState_E   w__11)  ::  32 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__12 :: ProcState) . 
     (let spsr = ((update_subrange_vec_dec spsr (( 8 :: int)::ii) (( 8 :: int)::ii)(ProcState_A   w__12)  ::  32 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__13 :: ProcState) . 
     (let spsr = ((update_subrange_vec_dec spsr (( 7 :: int)::ii) (( 7 :: int)::ii)(ProcState_I   w__13)  ::  32 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__14 :: ProcState) . 
     (let spsr = ((update_subrange_vec_dec spsr (( 6 :: int)::ii) (( 6 :: int)::ii)(ProcState_F   w__14)  ::  32 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__15 :: ProcState) . 
     (let spsr = ((update_subrange_vec_dec spsr (( 5 :: int)::ii) (( 5 :: int)::ii)(ProcState_T   w__15)  ::  32 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__16 :: ProcState) . 
     read_reg PSTATE_ref \<bind> (\<lambda> (w__17 :: ProcState) . 
     (assert_exp ((((vec_of_bits [access_vec_dec(ProcState_M   w__16) (( 4 :: int)::ii)]  ::  1 Word.word) =(ProcState_nRW   w__17)))) (''(((PSTATE).M)<4> == (PSTATE).nRW)'') \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__18 :: ProcState) . 
     (let (spsr :: 32 bits) =
       ((update_subrange_vec_dec spsr (( 4 :: int)::ii) (( 0 :: int)::ii)(ProcState_M   w__18)  ::  32 Word.word)) in
     return spsr))))))))))))))))))))))
   else
     read_reg PSTATE_ref \<bind> (\<lambda> (w__19 :: ProcState) . 
     (let spsr = ((update_subrange_vec_dec spsr (( 9 :: int)::ii) (( 9 :: int)::ii)(ProcState_D   w__19)  ::  32 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__20 :: ProcState) . 
     (let spsr = ((update_subrange_vec_dec spsr (( 8 :: int)::ii) (( 8 :: int)::ii)(ProcState_A   w__20)  ::  32 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__21 :: ProcState) . 
     (let spsr = ((update_subrange_vec_dec spsr (( 7 :: int)::ii) (( 7 :: int)::ii)(ProcState_I   w__21)  ::  32 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__22 :: ProcState) . 
     (let spsr = ((update_subrange_vec_dec spsr (( 6 :: int)::ii) (( 6 :: int)::ii)(ProcState_F   w__22)  ::  32 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__23 :: ProcState) . 
     (let spsr = ((update_subrange_vec_dec spsr (( 4 :: int)::ii) (( 4 :: int)::ii)(ProcState_nRW   w__23)  ::  32 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__24 :: ProcState) . 
     (let spsr = ((update_subrange_vec_dec spsr (( 3 :: int)::ii) (( 2 :: int)::ii)(ProcState_EL   w__24)  ::  32 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__25 :: ProcState) . 
     (let (spsr :: 32 bits) =
       ((update_subrange_vec_dec spsr (( 0 :: int)::ii) (( 0 :: int)::ii)(ProcState_SP   w__25)  ::  32 Word.word)) in
     return spsr)))))))))))))))))))))))))))))"


(*val FPZero : forall 'N . Size 'N => integer -> mword ty1 -> M (mword 'N)*)

definition FPZero  :: " int \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " FPZero (N__tv :: int) sign = (
   (let p00 = N__tv in
   if (((p00 = (( 16 :: int)::ii)))) then
     assert_exp True (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
     ((let (F :: int) = ((((( 16 :: int)::ii) - (( 5 :: int)::ii))) - (( 1 :: int)::ii)) in
     (let (exp1 :: 5 bits) = ((Zeros__0 ((make_the_value (( 5 :: int)::ii)  ::  5 itself))  ::  5 Word.word)) in
     (let (frac :: 10 bits) = ((Zeros__0 ((make_the_value F  ::  10 itself))  ::  10 Word.word)) in
     return ((Word.ucast ((concat_vec ((concat_vec sign exp1  ::  6 Word.word)) frac  ::  16 Word.word))
               :: ( 'N::len)Word.word))))))
   else if (((p00 = (( 32 :: int)::ii)))) then
     assert_exp True (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
     ((let (F :: int) = ((((( 32 :: int)::ii) - (( 8 :: int)::ii))) - (( 1 :: int)::ii)) in
     (let (exp1 :: 8 bits) = ((Zeros__0 ((make_the_value (( 8 :: int)::ii)  ::  8 itself))  ::  8 Word.word)) in
     (let (frac :: 23 bits) = ((Zeros__0 ((make_the_value F  ::  23 itself))  ::  23 Word.word)) in
     return ((Word.ucast ((concat_vec ((concat_vec sign exp1  ::  9 Word.word)) frac  ::  32 Word.word))
               :: ( 'N::len)Word.word))))))
   else if (((p00 = (( 64 :: int)::ii)))) then
     assert_exp True (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
     ((let (F :: int) = ((((( 64 :: int)::ii) - (( 11 :: int)::ii))) - (( 1 :: int)::ii)) in
     (let (exp1 :: 11 bits) = ((Zeros__0 ((make_the_value (( 11 :: int)::ii)  ::  11 itself))  ::  11 Word.word)) in
     (let (frac :: 52 bits) = ((Zeros__0 ((make_the_value F  ::  52 itself))  ::  52 Word.word)) in
     return ((Word.ucast ((concat_vec ((concat_vec sign exp1  ::  12 Word.word)) frac  ::  64 Word.word))
               :: ( 'N::len)Word.word))))))
   else assert_exp False (''((N == 16) || ((N == 32) || (N == 64)))'') \<then> exit0 () ))"


(*val ExceptionSyndrome : Exception -> M ExceptionRecord*)

definition ExceptionSyndrome  :: " Exception \<Rightarrow>((register_value),(ExceptionRecord),(exception))monad "  where 
     " ExceptionSyndrome typ1 = (
   undefined_ExceptionRecord ()  \<bind> (\<lambda> (r :: ExceptionRecord) . 
   (let (r :: ExceptionRecord) = ((r (| ExceptionRecord_typ := typ1 |))) in
   (let (r :: ExceptionRecord) =
     ((r (| ExceptionRecord_syndrome := ((Zeros__1 (( 25 :: int)::ii) ()   ::  25 Word.word))|))) in
   (let (r :: ExceptionRecord) =
     ((r (| ExceptionRecord_vaddress := ((Zeros__1 (( 64 :: int)::ii) ()   ::  64 Word.word))|))) in
   (let (r :: ExceptionRecord) = ((r (| ExceptionRecord_ipavalid := False |))) in
   (let (r :: ExceptionRecord) =
     ((r (| ExceptionRecord_ipaddress := ((Zeros__1 (( 52 :: int)::ii) ()   ::  52 Word.word))|))) in
   return r)))))))"


(*val ConstrainUnpredictableBits : forall 'width . Size 'width => integer -> Unpredictable -> M (Constraint * mword 'width)*)

definition ConstrainUnpredictableBits  :: " int \<Rightarrow> Unpredictable \<Rightarrow>((register_value),(Constraint*('width::len)Word.word),(exception))monad "  where 
     " ConstrainUnpredictableBits (width__tv :: int) which = (
   (let (c :: Constraint) = (ConstrainUnpredictable which) in
   if (((c = Constraint_UNKNOWN))) then
     return (c, (Zeros__0 ((make_the_value width__tv ))  :: ( 'width::len)Word.word))
   else
     (undefined_bitvector width__tv  :: (( 'width::len)Word.word) M) \<bind> (\<lambda> (w__0 :: ( 'width::len)Word.word) . 
     return (c, w__0))))"


(*val AArch64_SysInstrWithResult : ii -> ii -> ii -> ii -> ii -> M (mword ty64)*)

definition AArch64_SysInstrWithResult  :: " int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " AArch64_SysInstrWithResult op0 op1 crn crm op2 = (
   assert_exp False (''FALSE'') \<then>
   return ((Zeros__0 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  ::  64 Word.word)))"


(*val AArch64_PhysicalSErrorSyndrome : bool -> M (mword ty25)*)

definition AArch64_PhysicalSErrorSyndrome  :: " bool \<Rightarrow>((register_value),((25)Word.word),(exception))monad "  where 
     " AArch64_PhysicalSErrorSyndrome implicit_esb = (
   assert_exp False (''FALSE'') \<then>
   return ((Zeros__0 ((make_the_value (( 25 :: int)::ii)  ::  25 itself))  ::  25 Word.word)))"


(*val AArch32_PhysicalSErrorSyndrome : unit -> M AArch32_SErrorSyndrome*)

definition AArch32_PhysicalSErrorSyndrome  :: " unit \<Rightarrow>((register_value),(AArch32_SErrorSyndrome),(exception))monad "  where 
     " AArch32_PhysicalSErrorSyndrome _ = (
   (assert_exp False (''FALSE'') \<then>
   undefined_AArch32_SErrorSyndrome () ) \<bind> (\<lambda> (r :: AArch32_SErrorSyndrome) . 
   (let (r :: AArch32_SErrorSyndrome) =
     ((r (|
       AArch32_SErrorSyndrome_AET :=
         ((Zeros__0 ((make_the_value (( 2 :: int)::ii)  ::  2 itself))  ::  2 Word.word))|))) in
   (let (r :: AArch32_SErrorSyndrome) =
     ((r (|
       AArch32_SErrorSyndrome_ExT :=
         ((Zeros__0 ((make_the_value (( 1 :: int)::ii)  ::  1 itself))  ::  1 Word.word))|))) in
   return r))))"


(*val VFPExpandImm : forall 'N . Size 'N => integer -> mword ty8 -> M (mword 'N)*)

definition VFPExpandImm  :: " int \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " VFPExpandImm (N__tv :: int) imm8 = (
   (let p00 = N__tv in
   if (((p00 = (( 16 :: int)::ii)))) then
     assert_exp True (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
     ((let (F :: int) = ((((( 16 :: int)::ii) - (( 5 :: int)::ii))) - (( 1 :: int)::ii)) in
     (let (sign :: 1 bits) = ((vec_of_bits [access_vec_dec imm8 (( 7 :: int)::ii)]  ::  1 Word.word)) in
     (let (exp1 :: 5 bits) =
       ((concat_vec
          ((concat_vec
              ((not_vec (vec_of_bits [access_vec_dec imm8 (( 6 :: int)::ii)]  ::  1 Word.word)  ::  1 Word.word))
              ((replicate_bits (vec_of_bits [access_vec_dec imm8 (( 6 :: int)::ii)]  ::  1 Word.word)
                  (((( 5 :: int)::ii) - (( 3 :: int)::ii)))
                 ::  2 Word.word))
             ::  3 Word.word)) ((subrange_vec_dec imm8 (( 5 :: int)::ii) (( 4 :: int)::ii)  ::  2 Word.word))
         ::  5 Word.word)) in
     (let (frac :: 10 bits) =
       ((concat_vec ((subrange_vec_dec imm8 (( 3 :: int)::ii) (( 0 :: int)::ii)  ::  4 Word.word))
          ((Zeros__0 ((make_the_value ((F - (( 4 :: int)::ii)))  ::  6 itself))  ::  6 Word.word))
         ::  10 Word.word)) in
     return ((Word.ucast ((concat_vec ((concat_vec sign exp1  ::  6 Word.word)) frac  ::  16 Word.word))
               :: ( 'N::len)Word.word)))))))
   else if (((p00 = (( 32 :: int)::ii)))) then
     assert_exp True (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
     ((let (F :: int) = ((((( 32 :: int)::ii) - (( 8 :: int)::ii))) - (( 1 :: int)::ii)) in
     (let (sign :: 1 bits) = ((vec_of_bits [access_vec_dec imm8 (( 7 :: int)::ii)]  ::  1 Word.word)) in
     (let (exp1 :: 8 bits) =
       ((concat_vec
          ((concat_vec
              ((not_vec (vec_of_bits [access_vec_dec imm8 (( 6 :: int)::ii)]  ::  1 Word.word)  ::  1 Word.word))
              ((replicate_bits (vec_of_bits [access_vec_dec imm8 (( 6 :: int)::ii)]  ::  1 Word.word)
                  (((( 8 :: int)::ii) - (( 3 :: int)::ii)))
                 ::  5 Word.word))
             ::  6 Word.word)) ((subrange_vec_dec imm8 (( 5 :: int)::ii) (( 4 :: int)::ii)  ::  2 Word.word))
         ::  8 Word.word)) in
     (let (frac :: 23 bits) =
       ((concat_vec ((subrange_vec_dec imm8 (( 3 :: int)::ii) (( 0 :: int)::ii)  ::  4 Word.word))
          ((Zeros__0 ((make_the_value ((F - (( 4 :: int)::ii)))  ::  19 itself))  ::  19 Word.word))
         ::  23 Word.word)) in
     return ((Word.ucast ((concat_vec ((concat_vec sign exp1  ::  9 Word.word)) frac  ::  32 Word.word))
               :: ( 'N::len)Word.word)))))))
   else if (((p00 = (( 64 :: int)::ii)))) then
     assert_exp True (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
     ((let (F :: int) = ((((( 64 :: int)::ii) - (( 11 :: int)::ii))) - (( 1 :: int)::ii)) in
     (let (sign :: 1 bits) = ((vec_of_bits [access_vec_dec imm8 (( 7 :: int)::ii)]  ::  1 Word.word)) in
     (let (exp1 :: 11 bits) =
       ((concat_vec
          ((concat_vec
              ((not_vec (vec_of_bits [access_vec_dec imm8 (( 6 :: int)::ii)]  ::  1 Word.word)  ::  1 Word.word))
              ((replicate_bits (vec_of_bits [access_vec_dec imm8 (( 6 :: int)::ii)]  ::  1 Word.word)
                  (((( 11 :: int)::ii) - (( 3 :: int)::ii)))
                 ::  8 Word.word))
             ::  9 Word.word)) ((subrange_vec_dec imm8 (( 5 :: int)::ii) (( 4 :: int)::ii)  ::  2 Word.word))
         ::  11 Word.word)) in
     (let (frac :: 52 bits) =
       ((concat_vec ((subrange_vec_dec imm8 (( 3 :: int)::ii) (( 0 :: int)::ii)  ::  4 Word.word))
          ((Zeros__0 ((make_the_value ((F - (( 4 :: int)::ii)))  ::  48 itself))  ::  48 Word.word))
         ::  52 Word.word)) in
     return ((Word.ucast ((concat_vec ((concat_vec sign exp1  ::  12 Word.word)) frac  ::  64 Word.word))
               :: ( 'N::len)Word.word)))))))
   else assert_exp False (''((N == 16) || ((N == 32) || (N == 64)))'') \<then> exit0 () ))"


(*val SignExtend__0 : forall 'M 'N . Size 'M, Size 'N => mword 'M -> itself 'N -> M (mword 'N)*)

(*val SignExtend__1 : forall 'M 'N . Size 'M, Size 'N => integer -> mword 'M -> M (mword 'N)*)

definition SignExtend__0  :: "('M::len)Word.word \<Rightarrow>('N::len)itself \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " SignExtend__0 x N = (
   (let N = (size_itself_int N) in
   assert_exp ((N \<ge> ((int (size x))))) ('''') \<then> return ((extsv N x  :: ( 'N::len)Word.word))))"


definition SignExtend__1  :: " int \<Rightarrow>('M::len)Word.word \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " SignExtend__1 (N__tv :: int) x = ( (SignExtend__0 x ((make_the_value N__tv ))  :: (( 'N::len)Word.word) M))"


(*val Extend__0 : forall 'M 'N . Size 'M, Size 'N => mword 'M -> itself 'N -> bool -> M (mword 'N)*)

(*val Extend__1 : forall 'M 'N . Size 'M, Size 'N => integer -> mword 'M -> bool -> M (mword 'N)*)

definition Extend__0  :: "('M::len)Word.word \<Rightarrow>('N::len)itself \<Rightarrow> bool \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " Extend__0 x N unsigned = (
   (let N = (size_itself_int N) in
   if unsigned then (ZeroExtend__0 x ((make_the_value N ))  :: (( 'N::len)Word.word) M)
   else (SignExtend__0 x ((make_the_value N ))  :: (( 'N::len)Word.word) M)))"


definition Extend__1  :: " int \<Rightarrow>('M::len)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " Extend__1 (N__tv :: int) x unsigned = (
   (Extend__0 x ((make_the_value N__tv )) unsigned  :: (( 'N::len)Word.word) M))"


(*val ASR_C : forall 'N . Size 'N => mword 'N -> ii -> M (mword 'N * mword ty1)*)

definition ASR_C  :: "('N::len)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(('N::len)Word.word*(1)Word.word),(exception))monad "  where 
     " ASR_C x shift = (
   assert_exp ((shift > (( 0 :: int)::ii))) (''(shift > 0)'') \<then>
   ((let result = ((arith_shiftr x shift  :: ( 'N::len)Word.word)) in
   (let (carry_out :: 1 bits) =
     (if ((shift > ((int (size result))))) then
       (vec_of_bits [access_vec_dec x ((((int (size result))) - (( 1 :: int)::ii)))]  ::  1 Word.word)
     else (vec_of_bits [access_vec_dec x ((shift - (( 1 :: int)::ii)))]  ::  1 Word.word)) in
   return (result, carry_out)))))"


(*val ASR : forall 'N . Size 'N => mword 'N -> ii -> M (mword 'N)*)

definition ASR  :: "('N::len)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " ASR x shift = (
   (assert_exp ((shift \<ge> (( 0 :: int)::ii))) (''(shift >= 0)'') \<then>
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> (\<lambda> (anon10 :: 1 bits) . 
   (undefined_bitvector ((int (size x)))  :: (( 'N::len)Word.word) M) \<bind> (\<lambda> result . 
   if (((shift = (( 0 :: int)::ii)))) then return x
   else
     (ASR_C x shift ) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1) = varstup in
     (let result = tup__0 in
     (let (anon10 :: 1 bits) = tup__1 in
     return result)))))))"


(*val Ones__0 : forall 'N . Size 'N => itself 'N -> mword 'N*)

(*val Ones__1 : forall 'N . Size 'N => integer -> unit -> mword 'N*)

definition Ones__0  :: "('N::len)itself \<Rightarrow>('N::len)Word.word "  where 
     " Ones__0 N = (
   (let N = (size_itself_int N) in
   (replicate_bits (vec_of_bits [B1]  ::  1 Word.word) N  :: ( 'N::len)Word.word)))"


definition Ones__1  :: " int \<Rightarrow> unit \<Rightarrow>('N::len)Word.word "  where 
     " Ones__1 (N__tv :: int) _ = ( (Ones__0 ((make_the_value N__tv ))  :: ( 'N::len)Word.word))"


(*val IsOnes : forall 'N . Size 'N => mword 'N -> bool*)

definition IsOnes  :: "('N::len)Word.word \<Rightarrow> bool "  where 
     " IsOnes x = ( (x = ((Ones__0 ((make_the_value ((int (size x))) ))  :: ( 'N::len)Word.word))))"


(*val FPMaxNormal : forall 'N . Size 'N => integer -> mword ty1 -> M (mword 'N)*)

definition FPMaxNormal  :: " int \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " FPMaxNormal (N__tv :: int) sign = (
   (let p00 = N__tv in
   if (((p00 = (( 16 :: int)::ii)))) then
     assert_exp True (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
     ((let (F :: int) = ((((( 16 :: int)::ii) - (( 5 :: int)::ii))) - (( 1 :: int)::ii)) in
     (let (exp1 :: 5 bits) =
       ((concat_vec
          ((Ones__0 ((make_the_value (((( 5 :: int)::ii) - (( 1 :: int)::ii)))  ::  4 itself))  ::  4 Word.word))
          (vec_of_bits [B0]  ::  1 Word.word)
         ::  5 Word.word)) in
     (let (frac :: 10 bits) = ((Ones__0 ((make_the_value F  ::  10 itself))  ::  10 Word.word)) in
     return ((Word.ucast ((concat_vec ((concat_vec sign exp1  ::  6 Word.word)) frac  ::  16 Word.word))
               :: ( 'N::len)Word.word))))))
   else if (((p00 = (( 32 :: int)::ii)))) then
     assert_exp True (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
     ((let (F :: int) = ((((( 32 :: int)::ii) - (( 8 :: int)::ii))) - (( 1 :: int)::ii)) in
     (let (exp1 :: 8 bits) =
       ((concat_vec
          ((Ones__0 ((make_the_value (((( 8 :: int)::ii) - (( 1 :: int)::ii)))  ::  7 itself))  ::  7 Word.word))
          (vec_of_bits [B0]  ::  1 Word.word)
         ::  8 Word.word)) in
     (let (frac :: 23 bits) = ((Ones__0 ((make_the_value F  ::  23 itself))  ::  23 Word.word)) in
     return ((Word.ucast ((concat_vec ((concat_vec sign exp1  ::  9 Word.word)) frac  ::  32 Word.word))
               :: ( 'N::len)Word.word))))))
   else if (((p00 = (( 64 :: int)::ii)))) then
     assert_exp True (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
     ((let (F :: int) = ((((( 64 :: int)::ii) - (( 11 :: int)::ii))) - (( 1 :: int)::ii)) in
     (let (exp1 :: 11 bits) =
       ((concat_vec
          ((Ones__0 ((make_the_value (((( 11 :: int)::ii) - (( 1 :: int)::ii)))  ::  10 itself))  ::  10 Word.word))
          (vec_of_bits [B0]  ::  1 Word.word)
         ::  11 Word.word)) in
     (let (frac :: 52 bits) = ((Ones__0 ((make_the_value F  ::  52 itself))  ::  52 Word.word)) in
     return ((Word.ucast ((concat_vec ((concat_vec sign exp1  ::  12 Word.word)) frac  ::  64 Word.word))
               :: ( 'N::len)Word.word))))))
   else assert_exp False (''((N == 16) || ((N == 32) || (N == 64)))'') \<then> exit0 () ))"


(*val FPInfinity : forall 'N . Size 'N => integer -> mword ty1 -> M (mword 'N)*)

definition FPInfinity  :: " int \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " FPInfinity (N__tv :: int) sign = (
   (let p00 = N__tv in
   if (((p00 = (( 16 :: int)::ii)))) then
     assert_exp True (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
     ((let (F :: int) = ((((( 16 :: int)::ii) - (( 5 :: int)::ii))) - (( 1 :: int)::ii)) in
     (let (exp1 :: 5 bits) = ((Ones__0 ((make_the_value (( 5 :: int)::ii)  ::  5 itself))  ::  5 Word.word)) in
     (let (frac :: 10 bits) = ((Zeros__0 ((make_the_value F  ::  10 itself))  ::  10 Word.word)) in
     return ((Word.ucast ((concat_vec ((concat_vec sign exp1  ::  6 Word.word)) frac  ::  16 Word.word))
               :: ( 'N::len)Word.word))))))
   else if (((p00 = (( 32 :: int)::ii)))) then
     assert_exp True (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
     ((let (F :: int) = ((((( 32 :: int)::ii) - (( 8 :: int)::ii))) - (( 1 :: int)::ii)) in
     (let (exp1 :: 8 bits) = ((Ones__0 ((make_the_value (( 8 :: int)::ii)  ::  8 itself))  ::  8 Word.word)) in
     (let (frac :: 23 bits) = ((Zeros__0 ((make_the_value F  ::  23 itself))  ::  23 Word.word)) in
     return ((Word.ucast ((concat_vec ((concat_vec sign exp1  ::  9 Word.word)) frac  ::  32 Word.word))
               :: ( 'N::len)Word.word))))))
   else if (((p00 = (( 64 :: int)::ii)))) then
     assert_exp True (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
     ((let (F :: int) = ((((( 64 :: int)::ii) - (( 11 :: int)::ii))) - (( 1 :: int)::ii)) in
     (let (exp1 :: 11 bits) = ((Ones__0 ((make_the_value (( 11 :: int)::ii)  ::  11 itself))  ::  11 Word.word)) in
     (let (frac :: 52 bits) = ((Zeros__0 ((make_the_value F  ::  52 itself))  ::  52 Word.word)) in
     return ((Word.ucast ((concat_vec ((concat_vec sign exp1  ::  12 Word.word)) frac  ::  64 Word.word))
               :: ( 'N::len)Word.word))))))
   else assert_exp False (''((N == 16) || ((N == 32) || (N == 64)))'') \<then> exit0 () ))"


(*val FPDefaultNaN : forall 'N . Size 'N => integer -> unit -> M (mword 'N)*)

definition FPDefaultNaN  :: " int \<Rightarrow> unit \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " FPDefaultNaN (N__tv :: int) _ = (
   (let p00 = N__tv in
   if (((p00 = (( 16 :: int)::ii)))) then
     assert_exp True (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
     ((let (F :: int) = ((((( 16 :: int)::ii) - (( 5 :: int)::ii))) - (( 1 :: int)::ii)) in
     (let (sign :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
     (let (exp1 :: 5 bits) = ((Ones__0 ((make_the_value (( 5 :: int)::ii)  ::  5 itself))  ::  5 Word.word)) in
     (let (frac :: 10 bits) =
       ((concat_vec (vec_of_bits [B1]  ::  1 Word.word)
          ((Zeros__0 ((make_the_value ((F - (( 1 :: int)::ii)))  ::  9 itself))  ::  9 Word.word))
         ::  10 Word.word)) in
     return ((Word.ucast
                ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) exp1  ::  6 Word.word)) frac
                   ::  16 Word.word))
               :: ( 'N::len)Word.word)))))))
   else if (((p00 = (( 32 :: int)::ii)))) then
     assert_exp True (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
     ((let (F :: int) = ((((( 32 :: int)::ii) - (( 8 :: int)::ii))) - (( 1 :: int)::ii)) in
     (let (sign :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
     (let (exp1 :: 8 bits) = ((Ones__0 ((make_the_value (( 8 :: int)::ii)  ::  8 itself))  ::  8 Word.word)) in
     (let (frac :: 23 bits) =
       ((concat_vec (vec_of_bits [B1]  ::  1 Word.word)
          ((Zeros__0 ((make_the_value ((F - (( 1 :: int)::ii)))  ::  22 itself))  ::  22 Word.word))
         ::  23 Word.word)) in
     return ((Word.ucast
                ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) exp1  ::  9 Word.word)) frac
                   ::  32 Word.word))
               :: ( 'N::len)Word.word)))))))
   else if (((p00 = (( 64 :: int)::ii)))) then
     assert_exp True (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
     ((let (F :: int) = ((((( 64 :: int)::ii) - (( 11 :: int)::ii))) - (( 1 :: int)::ii)) in
     (let (sign :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
     (let (exp1 :: 11 bits) = ((Ones__0 ((make_the_value (( 11 :: int)::ii)  ::  11 itself))  ::  11 Word.word)) in
     (let (frac :: 52 bits) =
       ((concat_vec (vec_of_bits [B1]  ::  1 Word.word)
          ((Zeros__0 ((make_the_value ((F - (( 1 :: int)::ii)))  ::  51 itself))  ::  51 Word.word))
         ::  52 Word.word)) in
     return ((Word.ucast
                ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) exp1  ::  12 Word.word)) frac
                   ::  64 Word.word))
               :: ( 'N::len)Word.word)))))))
   else assert_exp False (''((N == 16) || ((N == 32) || (N == 64)))'') \<then> exit0 () ))"


(*val FPConvertNaN : forall 'N 'M . Size 'M, Size 'N => integer -> mword 'N -> M (mword 'M)*)

definition FPConvertNaN  :: " int \<Rightarrow>('N::len)Word.word \<Rightarrow>((register_value),(('M::len)Word.word),(exception))monad "  where 
     " FPConvertNaN (M__tv :: int) op1 = (
   ((assert_exp ((((((((int (size op1))) = (( 16 :: int)::ii)))) \<or> ((((((((int (size op1))) = (( 32 :: int)::ii)))) \<or> (((((int (size op1))) = (( 64 :: int)::ii)))))))))) (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
   assert_exp ((((((M__tv = (( 16 :: int)::ii)))) \<or> ((((((M__tv = (( 32 :: int)::ii)))) \<or> (((M__tv = (( 64 :: int)::ii)))))))))) (''((M == 16) || ((M == 32) || (M == 64)))'')) \<then>
   (undefined_bitvector M__tv  :: (( 'M::len)Word.word) M)) \<bind> (\<lambda> result . 
   (undefined_bitvector (( 51 :: int)::ii)  :: ( 51 Word.word) M) \<bind> (\<lambda> (frac :: 51 bits) . 
   (let (sign :: 1 bits) =
     ((vec_of_bits [access_vec_dec op1 ((((int (size op1))) - (( 1 :: int)::ii)))]  ::  1 Word.word)) in
   (let p00 = (int (size op1)) in
   (let (frac :: 51 bits) =
     (if (((p00 = (( 64 :: int)::ii)))) then
       (let (op1 ::  64 Word.word) = ((Word.ucast op1  ::  64 Word.word)) in
       (slice op1 (( 0 :: int)::ii) (( 51 :: int)::ii)  ::  51 Word.word))
     else if (((p00 = (( 32 :: int)::ii)))) then
       (let (op1 ::  32 Word.word) = ((Word.ucast op1  ::  32 Word.word)) in
       (concat_vec ((slice op1 (( 0 :: int)::ii) (( 22 :: int)::ii)  ::  22 Word.word))
          ((Zeros__0 ((make_the_value (( 29 :: int)::ii)  ::  29 itself))  ::  29 Word.word))
         ::  51 Word.word))
     else
       (let (op1 ::  16 Word.word) = ((Word.ucast op1  ::  16 Word.word)) in
       (concat_vec ((slice op1 (( 0 :: int)::ii) (( 9 :: int)::ii)  ::  9 Word.word))
          ((Zeros__0 ((make_the_value (( 42 :: int)::ii)  ::  42 itself))  ::  42 Word.word))
         ::  51 Word.word))) in
   (let p00 = (int (size result)) in
   (let result =
     (if (((p00 = (( 64 :: int)::ii)))) then
       (Word.ucast
          ((concat_vec
              ((concat_vec sign
                  ((Ones__0 ((make_the_value (((( 64 :: int)::ii) - (( 52 :: int)::ii))) ))  ::  12 Word.word))
                 ::  13 Word.word)) frac
             ::  64 Word.word))
         :: ( 'M::len)Word.word)
     else if (((p00 = (( 32 :: int)::ii)))) then
       (Word.ucast
          ((concat_vec
              ((concat_vec sign
                  ((Ones__0 ((make_the_value (((( 32 :: int)::ii) - (( 23 :: int)::ii))) ))  ::  9 Word.word))
                 ::  10 Word.word)) ((slice frac (( 29 :: int)::ii) (( 22 :: int)::ii)  ::  22 Word.word))
             ::  32 Word.word))
         :: ( 'M::len)Word.word)
     else
       (Word.ucast
          ((concat_vec
              ((concat_vec sign
                  ((Ones__0 ((make_the_value ((p00 - (( 10 :: int)::ii))) ))  ::  6 Word.word))
                 ::  7 Word.word)) ((slice frac (( 42 :: int)::ii) (( 9 :: int)::ii)  ::  9 Word.word))
             ::  16 Word.word))
         :: ( 'M::len)Word.word)) in
   return result))))))))"


(*val ExcVectorBase : unit -> M (mword ty32)*)

definition ExcVectorBase  :: " unit \<Rightarrow>((register_value),((32)Word.word),(exception))monad "  where 
     " ExcVectorBase _ = (
   (read_reg SCTLR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 :: 32 bits) . 
   if ((((vec_of_bits [access_vec_dec w__0 (( 13 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
     return ((concat_vec ((Ones__0 ((make_the_value (( 16 :: int)::ii)  ::  16 itself))  ::  16 Word.word))
                ((Zeros__0 ((make_the_value (( 16 :: int)::ii)  ::  16 itself))  ::  16 Word.word))
               ::  32 Word.word))
   else
     (read_reg VBAR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 :: 32 bits) . 
     return ((concat_vec ((slice w__1 (( 5 :: int)::ii) (( 27 :: int)::ii)  ::  27 Word.word))
                ((Zeros__0 ((make_the_value (( 5 :: int)::ii)  ::  5 itself))  ::  5 Word.word))
               ::  32 Word.word)))))"


(*val PACSub : mword ty64 -> M (mword ty64)*)

definition PACSub  :: "(64)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " PACSub Tinput = (
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (Toutput :: 64 bits) . 
   (let (Toutput :: 64 bits) =
     (foreach (index_list (( 0 :: int)::ii) (( 15 :: int)::ii) (( 1 :: int)::ii)) Toutput
       (\<lambda> i Toutput . 
         (let b__0 = ((slice Tinput (((( 4 :: int)::ii) * i)) (( 4 :: int)::ii)  ::  4 Word.word)) in
         if (((b__0 = (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)))) then
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B1,B0,B1,B1]  ::  4 Word.word)
             ::  64 Word.word)
         else if (((b__0 = (vec_of_bits [B0,B0,B0,B1]  ::  4 Word.word)))) then
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B0,B1,B1,B0]  ::  4 Word.word)
             ::  64 Word.word)
         else if (((b__0 = (vec_of_bits [B0,B0,B1,B0]  ::  4 Word.word)))) then
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)
             ::  64 Word.word)
         else if (((b__0 = (vec_of_bits [B0,B0,B1,B1]  ::  4 Word.word)))) then
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B1,B1,B1,B1]  ::  4 Word.word)
             ::  64 Word.word)
         else if (((b__0 = (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)))) then
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B1,B1,B0,B0]  ::  4 Word.word)
             ::  64 Word.word)
         else if (((b__0 = (vec_of_bits [B0,B1,B0,B1]  ::  4 Word.word)))) then
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)
             ::  64 Word.word)
         else if (((b__0 = (vec_of_bits [B0,B1,B1,B0]  ::  4 Word.word)))) then
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B1,B0,B0,B1]  ::  4 Word.word)
             ::  64 Word.word)
         else if (((b__0 = (vec_of_bits [B0,B1,B1,B1]  ::  4 Word.word)))) then
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B1,B1,B1,B0]  ::  4 Word.word)
             ::  64 Word.word)
         else if (((b__0 = (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)))) then
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B0,B0,B1,B1]  ::  4 Word.word)
             ::  64 Word.word)
         else if (((b__0 = (vec_of_bits [B1,B0,B0,B1]  ::  4 Word.word)))) then
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B0,B1,B1,B1]  ::  4 Word.word)
             ::  64 Word.word)
         else if (((b__0 = (vec_of_bits [B1,B0,B1,B0]  ::  4 Word.word)))) then
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)
             ::  64 Word.word)
         else if (((b__0 = (vec_of_bits [B1,B0,B1,B1]  ::  4 Word.word)))) then
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B0,B1,B0,B1]  ::  4 Word.word)
             ::  64 Word.word)
         else if (((b__0 = (vec_of_bits [B1,B1,B0,B0]  ::  4 Word.word)))) then
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B1,B1,B0,B1]  ::  4 Word.word)
             ::  64 Word.word)
         else if (((b__0 = (vec_of_bits [B1,B1,B0,B1]  ::  4 Word.word)))) then
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B0,B0,B1,B0]  ::  4 Word.word)
             ::  64 Word.word)
         else if (((b__0 = (vec_of_bits [B1,B1,B1,B0]  ::  4 Word.word)))) then
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B0,B0,B0,B1]  ::  4 Word.word)
             ::  64 Word.word)
         else
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B1,B0,B1,B0]  ::  4 Word.word)
             ::  64 Word.word)))) in
   return Toutput)))"


(*val PACMult : mword ty64 -> M (mword ty64)*)

definition PACMult  :: "(64)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " PACMult Sinput = (
   (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (t0 :: 4 bits) . 
   (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (t1 :: 4 bits) . 
   (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (t2 :: 4 bits) . 
   (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (t3 :: 4 bits) . 
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (Soutput :: 64 bits) . 
   (foreachM (index_list (( 0 :: int)::ii) (( 3 :: int)::ii) (( 1 :: int)::ii)) (Soutput, t0, t1, t2, t3)
     (\<lambda> i varstup .  (let (Soutput, t0, t1, t2, t3) = varstup in
       (RotCell ((slice Sinput (((( 4 :: int)::ii) * ((i + (( 8 :: int)::ii))))) (( 4 :: int)::ii)  ::  4 Word.word))
          (( 1 :: int)::ii)
         :: ( 4 Word.word) M) \<bind> (\<lambda> (w__0 ::  4 Word.word) . 
       (RotCell ((slice Sinput (((( 4 :: int)::ii) * ((i + (( 4 :: int)::ii))))) (( 4 :: int)::ii)  ::  4 Word.word))
          (( 2 :: int)::ii)
         :: ( 4 Word.word) M) \<bind> (\<lambda> (w__1 ::  4 Word.word) . 
       (let t0 = ((set_slice (( 4 :: int)::ii) (( 4 :: int)::ii) t0 (( 0 :: int)::ii) ((xor_vec w__0 w__1  ::  4 Word.word))  ::  4 Word.word)) in
       (RotCell ((slice Sinput (((( 4 :: int)::ii) * i)) (( 4 :: int)::ii)  ::  4 Word.word)) (( 1 :: int)::ii)
         :: ( 4 Word.word) M) \<bind> (\<lambda> (w__2 ::  4 Word.word) . 
       (let t0 =
         ((set_slice (( 4 :: int)::ii) (( 4 :: int)::ii) t0 (( 0 :: int)::ii)
            ((xor_vec ((slice t0 (( 0 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) w__2  ::  4 Word.word))
           ::  4 Word.word)) in
       (RotCell ((slice Sinput (((( 4 :: int)::ii) * ((i + (( 12 :: int)::ii))))) (( 4 :: int)::ii)  ::  4 Word.word))
          (( 1 :: int)::ii)
         :: ( 4 Word.word) M) \<bind> (\<lambda> (w__3 ::  4 Word.word) . 
       (RotCell ((slice Sinput (((( 4 :: int)::ii) * ((i + (( 4 :: int)::ii))))) (( 4 :: int)::ii)  ::  4 Word.word))
          (( 1 :: int)::ii)
         :: ( 4 Word.word) M) \<bind> (\<lambda> (w__4 ::  4 Word.word) . 
       (let t1 = ((set_slice (( 4 :: int)::ii) (( 4 :: int)::ii) t1 (( 0 :: int)::ii) ((xor_vec w__3 w__4  ::  4 Word.word))  ::  4 Word.word)) in
       (RotCell ((slice Sinput (((( 4 :: int)::ii) * i)) (( 4 :: int)::ii)  ::  4 Word.word)) (( 2 :: int)::ii)
         :: ( 4 Word.word) M) \<bind> (\<lambda> (w__5 ::  4 Word.word) . 
       (let t1 =
         ((set_slice (( 4 :: int)::ii) (( 4 :: int)::ii) t1 (( 0 :: int)::ii)
            ((xor_vec ((slice t1 (( 0 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) w__5  ::  4 Word.word))
           ::  4 Word.word)) in
       (RotCell ((slice Sinput (((( 4 :: int)::ii) * ((i + (( 12 :: int)::ii))))) (( 4 :: int)::ii)  ::  4 Word.word))
          (( 2 :: int)::ii)
         :: ( 4 Word.word) M) \<bind> (\<lambda> (w__6 ::  4 Word.word) . 
       (RotCell ((slice Sinput (((( 4 :: int)::ii) * ((i + (( 8 :: int)::ii))))) (( 4 :: int)::ii)  ::  4 Word.word))
          (( 1 :: int)::ii)
         :: ( 4 Word.word) M) \<bind> (\<lambda> (w__7 ::  4 Word.word) . 
       (let t2 = ((set_slice (( 4 :: int)::ii) (( 4 :: int)::ii) t2 (( 0 :: int)::ii) ((xor_vec w__6 w__7  ::  4 Word.word))  ::  4 Word.word)) in
       (RotCell ((slice Sinput (((( 4 :: int)::ii) * i)) (( 4 :: int)::ii)  ::  4 Word.word)) (( 1 :: int)::ii)
         :: ( 4 Word.word) M) \<bind> (\<lambda> (w__8 ::  4 Word.word) . 
       (let t2 =
         ((set_slice (( 4 :: int)::ii) (( 4 :: int)::ii) t2 (( 0 :: int)::ii)
            ((xor_vec ((slice t2 (( 0 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) w__8  ::  4 Word.word))
           ::  4 Word.word)) in
       (RotCell ((slice Sinput (((( 4 :: int)::ii) * ((i + (( 12 :: int)::ii))))) (( 4 :: int)::ii)  ::  4 Word.word))
          (( 1 :: int)::ii)
         :: ( 4 Word.word) M) \<bind> (\<lambda> (w__9 ::  4 Word.word) . 
       (RotCell ((slice Sinput (((( 4 :: int)::ii) * ((i + (( 8 :: int)::ii))))) (( 4 :: int)::ii)  ::  4 Word.word))
          (( 2 :: int)::ii)
         :: ( 4 Word.word) M) \<bind> (\<lambda> (w__10 ::  4 Word.word) . 
       (let t3 = ((set_slice (( 4 :: int)::ii) (( 4 :: int)::ii) t3 (( 0 :: int)::ii) ((xor_vec w__9 w__10  ::  4 Word.word))  ::  4 Word.word)) in
       (RotCell ((slice Sinput (((( 4 :: int)::ii) * ((i + (( 4 :: int)::ii))))) (( 4 :: int)::ii)  ::  4 Word.word))
          (( 1 :: int)::ii)
         :: ( 4 Word.word) M) \<bind> (\<lambda> (w__11 ::  4 Word.word) . 
       (let (t3 :: 4 bits) =
         ((set_slice (( 4 :: int)::ii) (( 4 :: int)::ii) t3 (( 0 :: int)::ii)
            ((xor_vec ((slice t3 (( 0 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) w__11  ::  4 Word.word))
           ::  4 Word.word)) in
       (let (Soutput :: 64 bits) =
         ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Soutput (((( 4 :: int)::ii) * i))
            ((slice t3 (( 0 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
           ::  64 Word.word)) in
       (let (Soutput :: 64 bits) =
         ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Soutput (((( 4 :: int)::ii) * ((i + (( 4 :: int)::ii)))))
            ((slice t2 (( 0 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
           ::  64 Word.word)) in
       (let (Soutput :: 64 bits) =
         ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Soutput (((( 4 :: int)::ii) * ((i + (( 8 :: int)::ii)))))
            ((slice t1 (( 0 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
           ::  64 Word.word)) in
       (let (Soutput :: 64 bits) =
         ((set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Soutput (((( 4 :: int)::ii) * ((i + (( 12 :: int)::ii)))))
            ((slice t0 (( 0 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
           ::  64 Word.word)) in
       return (Soutput, t0, t1, t2, t3)))))))))))))))))))))))))))) \<bind> (\<lambda> varstup .  (let ((Soutput :: 64 bits), (t0 :: 4
     bits), (t1 :: 4 bits), (t2 :: 4 bits), (t3 :: 4 bits)) = varstup in
   return Soutput))))))))"


(*val PACInvSub : mword ty64 -> M (mword ty64)*)

definition PACInvSub  :: "(64)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " PACInvSub Tinput = (
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (Toutput :: 64 bits) . 
   (let (Toutput :: 64 bits) =
     (foreach (index_list (( 0 :: int)::ii) (( 15 :: int)::ii) (( 1 :: int)::ii)) Toutput
       (\<lambda> i Toutput . 
         (let b__0 = ((slice Tinput (((( 4 :: int)::ii) * i)) (( 4 :: int)::ii)  ::  4 Word.word)) in
         if (((b__0 = (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)))) then
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B0,B1,B0,B1]  ::  4 Word.word)
             ::  64 Word.word)
         else if (((b__0 = (vec_of_bits [B0,B0,B0,B1]  ::  4 Word.word)))) then
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B1,B1,B1,B0]  ::  4 Word.word)
             ::  64 Word.word)
         else if (((b__0 = (vec_of_bits [B0,B0,B1,B0]  ::  4 Word.word)))) then
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B1,B1,B0,B1]  ::  4 Word.word)
             ::  64 Word.word)
         else if (((b__0 = (vec_of_bits [B0,B0,B1,B1]  ::  4 Word.word)))) then
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)
             ::  64 Word.word)
         else if (((b__0 = (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)))) then
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B1,B0,B1,B0]  ::  4 Word.word)
             ::  64 Word.word)
         else if (((b__0 = (vec_of_bits [B0,B1,B0,B1]  ::  4 Word.word)))) then
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B1,B0,B1,B1]  ::  4 Word.word)
             ::  64 Word.word)
         else if (((b__0 = (vec_of_bits [B0,B1,B1,B0]  ::  4 Word.word)))) then
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B0,B0,B0,B1]  ::  4 Word.word)
             ::  64 Word.word)
         else if (((b__0 = (vec_of_bits [B0,B1,B1,B1]  ::  4 Word.word)))) then
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B1,B0,B0,B1]  ::  4 Word.word)
             ::  64 Word.word)
         else if (((b__0 = (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)))) then
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B0,B0,B1,B0]  ::  4 Word.word)
             ::  64 Word.word)
         else if (((b__0 = (vec_of_bits [B1,B0,B0,B1]  ::  4 Word.word)))) then
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B0,B1,B1,B0]  ::  4 Word.word)
             ::  64 Word.word)
         else if (((b__0 = (vec_of_bits [B1,B0,B1,B0]  ::  4 Word.word)))) then
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B1,B1,B1,B1]  ::  4 Word.word)
             ::  64 Word.word)
         else if (((b__0 = (vec_of_bits [B1,B0,B1,B1]  ::  4 Word.word)))) then
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)
             ::  64 Word.word)
         else if (((b__0 = (vec_of_bits [B1,B1,B0,B0]  ::  4 Word.word)))) then
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)
             ::  64 Word.word)
         else if (((b__0 = (vec_of_bits [B1,B1,B0,B1]  ::  4 Word.word)))) then
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B1,B1,B0,B0]  ::  4 Word.word)
             ::  64 Word.word)
         else if (((b__0 = (vec_of_bits [B1,B1,B1,B0]  ::  4 Word.word)))) then
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B0,B1,B1,B1]  ::  4 Word.word)
             ::  64 Word.word)
         else
           (set_slice (( 64 :: int)::ii) (( 4 :: int)::ii) Toutput (((( 4 :: int)::ii) * i))
              (vec_of_bits [B0,B0,B1,B1]  ::  4 Word.word)
             ::  64 Word.word)))) in
   return Toutput)))"


(*val ComputePAC : mword ty64 -> mword ty64 -> mword ty64 -> mword ty64 -> M (mword ty64)*)

definition ComputePAC  :: "(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " ComputePAC data modifier key0 key1 = (
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (workingval :: 64 bits) . 
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (runningmod :: 64 bits) . 
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (roundkey :: 64 bits) . 
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (modk0 :: 64 bits) . 
   (hex_slice (''0xC0AC29B7C97C50DD'') (( 64 :: int)::ii) (( 0 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (Alpha :: 64 bits) . 
   read_reg RC_ref \<bind> (\<lambda> (w__0 :: ( 64 bits) list) . 
   (hex_slice (''0x0'') (( 64 :: int)::ii) (( 0 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   (write_reg RC_ref ((update_list_dec w__0 (( 0 :: int)::ii) w__1  :: ( 64 Word.word) list)) \<then>
   read_reg RC_ref) \<bind> (\<lambda> (w__2 :: ( 64 bits) list) . 
   (hex_slice (''0x13198A2E03707344'') (( 64 :: int)::ii) (( 0 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::  64 Word.word) . 
   (write_reg RC_ref ((update_list_dec w__2 (( 1 :: int)::ii) w__3  :: ( 64 Word.word) list)) \<then>
   read_reg RC_ref) \<bind> (\<lambda> (w__4 :: ( 64 bits) list) . 
   (hex_slice (''0xA493822299F31D0'') (( 64 :: int)::ii) (( 0 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 ::  64 Word.word) . 
   (write_reg RC_ref ((update_list_dec w__4 (( 2 :: int)::ii) w__5  :: ( 64 Word.word) list)) \<then>
   read_reg RC_ref) \<bind> (\<lambda> (w__6 :: ( 64 bits) list) . 
   (hex_slice (''0x82EFA98EC4E6C89'') (( 64 :: int)::ii) (( 0 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__7 ::  64 Word.word) . 
   (write_reg RC_ref ((update_list_dec w__6 (( 3 :: int)::ii) w__7  :: ( 64 Word.word) list)) \<then>
   read_reg RC_ref) \<bind> (\<lambda> (w__8 :: ( 64 bits) list) . 
   (hex_slice (''0x452821E638D01377'') (( 64 :: int)::ii) (( 0 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__9 ::  64 Word.word) . 
   write_reg RC_ref ((update_list_dec w__8 (( 4 :: int)::ii) w__9  :: ( 64 Word.word) list)) \<then>
   ((let modk0 =
     ((concat_vec
        ((concat_vec (vec_of_bits [access_vec_dec key0 (( 0 :: int)::ii)]  ::  1 Word.word)
            ((slice key0 (( 2 :: int)::ii) (( 62 :: int)::ii)  ::  62 Word.word))
           ::  63 Word.word))
        ((xor_vec (vec_of_bits [access_vec_dec key0 (( 63 :: int)::ii)]  ::  1 Word.word)
            (vec_of_bits [access_vec_dec key0 (( 1 :: int)::ii)]  ::  1 Word.word)
           ::  1 Word.word))
       ::  64 Word.word)) in
   (let runningmod = modifier in
   (let workingval = ((xor_vec data key0  ::  64 Word.word)) in
   (foreachM (index_list (( 0 :: int)::ii) (( 4 :: int)::ii) (( 1 :: int)::ii)) (roundkey, runningmod, workingval)
     (\<lambda> i varstup .  (let (roundkey, runningmod, workingval) = varstup in
       (let roundkey = ((xor_vec key1 runningmod  ::  64 Word.word)) in
       (let workingval = ((xor_vec workingval roundkey  ::  64 Word.word)) in
       read_reg RC_ref \<bind> (\<lambda> (w__10 :: ( 64 bits) list) . 
       (let workingval = ((xor_vec workingval ((access_list_dec w__10 i  ::  64 Word.word))  ::  64 Word.word)) in
       (if ((i > (( 0 :: int)::ii))) then
          (PACCellShuffle workingval  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__11 ::  64 Word.word) . 
          (let workingval = w__11 in
          (PACMult workingval  :: ( 64 Word.word) M)))
        else return workingval) \<bind> (\<lambda> (workingval :: 64 bits) . 
       (PACSub workingval  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__13 ::  64 Word.word) . 
       (let workingval = w__13 in
       (TweakShuffle ((slice runningmod (( 0 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__14 ::
          64 Word.word) . 
       (let (runningmod :: 64 bits) = w__14 in
       return (roundkey, runningmod, workingval))))))))))))) \<bind> (\<lambda> varstup .  (let ((roundkey :: 64 bits), (runningmod :: 64
     bits), (workingval :: 64 bits)) = varstup in
   (let roundkey = ((xor_vec modk0 runningmod  ::  64 Word.word)) in
   (let workingval = ((xor_vec workingval roundkey  ::  64 Word.word)) in
   (PACCellShuffle workingval  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__15 ::  64 Word.word) . 
   (let workingval = w__15 in
   (PACMult workingval  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__16 ::  64 Word.word) . 
   (let workingval = w__16 in
   (PACSub workingval  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__17 ::  64 Word.word) . 
   (let workingval = w__17 in
   (PACCellShuffle workingval  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__18 ::  64 Word.word) . 
   (let workingval = w__18 in
   (PACMult workingval  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__19 ::  64 Word.word) . 
   (let workingval = w__19 in
   (let workingval = ((xor_vec key1 workingval  ::  64 Word.word)) in
   (PACCellInvShuffle workingval  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__20 ::  64 Word.word) . 
   (let workingval = w__20 in
   (PACInvSub workingval  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__21 ::  64 Word.word) . 
   (let workingval = w__21 in
   (PACMult workingval  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__22 ::  64 Word.word) . 
   (let workingval = w__22 in
   (PACCellInvShuffle workingval  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__23 ::  64 Word.word) . 
   (let workingval = w__23 in
   (let workingval = ((xor_vec workingval key0  ::  64 Word.word)) in
   (let workingval = ((xor_vec workingval runningmod  ::  64 Word.word)) in
   (foreachM (index_list (( 0 :: int)::ii) (( 4 :: int)::ii) (( 1 :: int)::ii)) (roundkey, runningmod, workingval)
     (\<lambda> i varstup .  (let (roundkey, runningmod, workingval) = varstup in
       (PACInvSub workingval  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__24 ::  64 Word.word) . 
       (let workingval = w__24 in
       (if ((i < (( 4 :: int)::ii))) then
          (PACMult workingval  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__25 ::  64 Word.word) . 
          (let workingval = w__25 in
          (PACCellInvShuffle workingval  :: ( 64 Word.word) M)))
        else return workingval) \<bind> (\<lambda> (workingval :: 64 bits) . 
       (TweakInvShuffle ((slice runningmod (( 0 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__27 ::
          64 Word.word) . 
       (let runningmod = w__27 in
       (let roundkey = ((xor_vec key1 runningmod  ::  64 Word.word)) in
       read_reg RC_ref \<bind> (\<lambda> (w__28 :: ( 64 bits) list) . 
       (let (workingval :: 64 bits) =
         ((xor_vec workingval ((access_list_dec w__28 (((( 4 :: int)::ii) - i))  ::  64 Word.word))
           ::  64 Word.word)) in
       (let (workingval :: 64 bits) = ((xor_vec workingval roundkey  ::  64 Word.word)) in
       (let (workingval :: 64 bits) = ((xor_vec workingval Alpha  ::  64 Word.word)) in
       return (roundkey, runningmod, workingval)))))))))))))) \<bind> (\<lambda> varstup .  (let ((roundkey :: 64 bits), (runningmod :: 64
     bits), (workingval :: 64 bits)) = varstup in
   (let (workingval :: 64 bits) = ((xor_vec workingval modk0  ::  64 Word.word)) in
   return workingval))))))))))))))))))))))))))))))))))))))))))))))))"


(*val Align__0 : ii -> ii -> ii*)

(*val Align__1 : forall 'N . Size 'N => mword 'N -> ii -> mword 'N*)

definition Align__0  :: " int \<Rightarrow> int \<Rightarrow> int "  where 
     " Align__0 x y = ( y * ((x div y)))"


definition Align__1  :: "('N::len)Word.word \<Rightarrow> int \<Rightarrow>('N::len)Word.word "  where 
     " Align__1 x y = (
   (GetSlice_int ((make_the_value ((int (size x))) )) ((Align__0 ((Word.uint x)) y)) (( 0 :: int)::ii)  :: ( 'N::len)Word.word))"


(*val aset__Mem : forall   'p8_times_size_ . Size 'p8_times_size_ => AddressDescriptor -> integer -> AccessDescriptor -> mword 'p8_times_size_ -> M unit*)

definition aset__Mem  :: " AddressDescriptor \<Rightarrow> int \<Rightarrow> AccessDescriptor \<Rightarrow>('p8_times_size_::len)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aset__Mem desc size1 accdesc value_name = (
   assert_exp ((((((size1 = (( 1 :: int)::ii)))) \<or> ((((((size1 = (( 2 :: int)::ii)))) \<or> ((((((size1 = (( 4 :: int)::ii)))) \<or> ((((((size1 = (( 8 :: int)::ii)))) \<or> (((size1 = (( 16 :: int)::ii)))))))))))))))) (''((size == 1) || ((size == 2) || ((size == 4) || ((size == 8) || (size == 16)))))'') \<then>
   ((let (address :: 52 bits) = ((FullAddress_physicaladdress  (AddressDescriptor_paddress   desc))) in
   (assert_exp (((address = ((Align__1 address size1  ::  52 Word.word))))) (''(address == Align(address, size))'') \<then>
   (hex_slice (''0x13000000'') (( 52 :: int)::ii) (( 0 :: int)::ii)  :: ( 52 Word.word) M)) \<bind> (\<lambda> (w__0 ::  52 Word.word) . 
   if (((address = w__0))) then
     if (((((Word.uint value_name)) = (( 4 :: int)::ii)))) then
       (let (_ :: unit) = (prerr ([(CHR ''P''), (CHR ''r''), (CHR ''o''), (CHR ''g''), (CHR ''r''), (CHR ''a''), (CHR ''m''), (CHR '' ''), (CHR ''e''), (CHR ''x''), (CHR ''i''), (CHR ''t''), (CHR ''e''), (CHR ''d''), (CHR '' ''), (CHR ''b''), (CHR ''y''), (CHR '' ''), (CHR ''w''), (CHR ''r''), (CHR ''i''), (CHR ''t''), (CHR ''i''), (CHR ''n''), (CHR ''g''), (CHR '' ''), (CHR ''^''), (CHR ''D''), (CHR '' ''), (CHR ''t''), (CHR ''o''), (CHR '' ''), (CHR ''T''), (CHR ''U''), (CHR ''B''), (CHR ''E''), (CHR 0x27)])) in
       exit0 () )
     else return ((putchar ((Word.uint ((slice value_name (( 0 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))))))
   else
     (read_reg Memory_ref  :: ( 52 Word.word) M) \<bind> (\<lambda> (w__1 :: 52 bits) . 
     WriteRAM ((make_the_value (( 52 :: int)::ii)  ::  52 itself)) size1 w__1 address value_name)))))"


(*val aget__Mem : forall   'p8_times_size_ . Size 'p8_times_size_ => AddressDescriptor -> integer -> AccessDescriptor -> M (mword 'p8_times_size_)*)

definition aget__Mem  :: " AddressDescriptor \<Rightarrow> int \<Rightarrow> AccessDescriptor \<Rightarrow>((register_value),(('p8_times_size_::len)Word.word),(exception))monad "  where 
     " aget__Mem desc size1 accdesc = (
   assert_exp ((((((size1 = (( 1 :: int)::ii)))) \<or> ((((((size1 = (( 2 :: int)::ii)))) \<or> ((((((size1 = (( 4 :: int)::ii)))) \<or> ((((((size1 = (( 8 :: int)::ii)))) \<or> (((size1 = (( 16 :: int)::ii)))))))))))))))) (''((size == 1) || ((size == 2) || ((size == 4) || ((size == 8) || (size == 16)))))'') \<then>
   ((let (address :: 52 bits) = ((FullAddress_physicaladdress  (AddressDescriptor_paddress   desc))) in
   (assert_exp (((address = ((Align__1 address size1  ::  52 Word.word))))) (''(address == Align(address, size))'') \<then>
   (read_reg Memory_ref  :: ( 52 Word.word) M)) \<bind> (\<lambda> (w__0 :: 52 bits) . 
   (ReadRAM ((make_the_value (( 52 :: int)::ii)  ::  52 itself)) size1 w__0 address
     :: (( 'p8_times_size_::len)Word.word) M)))))"


(*val aset_X : forall 'width . Size 'width => ii -> mword 'width -> M unit*)

definition aset_X  :: " int \<Rightarrow>('width::len)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aset_X n value_name = (
   (assert_exp (((((n \<ge> (( 0 :: int)::ii))) \<and> ((n \<le> (( 31 :: int)::ii)))))) (''((n >= 0) && (n <= 31))'') \<then>
   assert_exp ((((((((int (size value_name))) = (( 32 :: int)::ii)))) \<or> (((((int (size value_name))) = (( 64 :: int)::ii))))))) (''((width == 32) || (width == 64))'')) \<then>
   (if (((n \<noteq> (( 31 :: int)::ii)))) then
     read_reg R_ref \<bind> (\<lambda> (w__0 :: ( 64 bits) list) . 
     (ZeroExtend__0 value_name ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::
        64 Word.word) . 
     write_reg R_ref ((update_list_dec w__0 n w__1  :: ( 64 Word.word) list))))
   else return () ))"


(*val aarch64_integer_arithmetic_address_pcrel : ii -> mword ty64 -> bool -> M unit*)

definition aarch64_integer_arithmetic_address_pcrel  :: " int \<Rightarrow>(64)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_arithmetic_address_pcrel d imm page = (
   (aget_PC ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (base :: 64 bits) . 
   (let (base :: 64 bits) =
     (if page then
       (set_slice (( 64 :: int)::ii) (( 12 :: int)::ii) base (( 0 :: int)::ii)
          ((Zeros__0 ((make_the_value (( 12 :: int)::ii)  ::  12 itself))  ::  12 Word.word))
         ::  64 Word.word)
     else base) in
   aset_X d ((add_vec base imm  ::  64 Word.word)))))"


(*val integer_arithmetic_address_pcrel_decode : mword ty1 -> mword ty2 -> mword ty19 -> mword ty5 -> M unit*)

definition integer_arithmetic_address_pcrel_decode  :: "(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(19)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_arithmetic_address_pcrel_decode op1 immlo immhi Rd = (
   write_reg unconditional_ref True \<then>
   ((let (d :: ii) = (Word.uint Rd) in
   (let (page :: bool) = (op1 = (vec_of_bits [B1]  ::  1 Word.word)) in
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (imm :: 64 bits) . 
   (if page then
      (SignExtend__0
         ((concat_vec ((concat_vec immhi immlo  ::  21 Word.word))
             ((Zeros__0 ((make_the_value (( 12 :: int)::ii)  ::  12 itself))  ::  12 Word.word))
            ::  33 Word.word)) ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
        :: ( 64 Word.word) M)
    else
      (SignExtend__0 ((concat_vec immhi immlo  ::  21 Word.word))
         ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
        :: ( 64 Word.word) M)) \<bind> (\<lambda> (imm :: 64 bits) . 
   aarch64_integer_arithmetic_address_pcrel d imm page))))))"


(*val AArch64_ResetGeneralRegisters : unit -> M unit*)

definition AArch64_ResetGeneralRegisters  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_ResetGeneralRegisters _ = (
   (foreachM (index_list (( 0 :: int)::ii) (( 30 :: int)::ii) (( 1 :: int)::ii)) () 
     (\<lambda> i unit_var . 
       (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) .  aset_X i w__0))))"


(*val aset_ELR__0 : mword ty2 -> mword ty64 -> M unit*)

(*val aset_ELR__1 : mword ty64 -> M unit*)

definition aset_ELR__0  :: "(2)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aset_ELR__0 el value_name = (
   (let (r :: 64 bits) = value_name in
   (let pat0 = el in
   if (((pat0 = EL1))) then write_reg ELR_EL1_ref r
   else if (((pat0 = EL2))) then write_reg ELR_EL2_ref r
   else if (((pat0 = EL3))) then write_reg ELR_EL3_ref r
   else Unreachable () )))"


definition aset_ELR__1  :: "(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aset_ELR__1 value_name = (
   read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) . 
   (assert_exp ((((ProcState_EL   w__0) \<noteq> EL0))) ('''') \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__1 :: ProcState) .  aset_ELR__0(ProcState_EL   w__1) value_name)))"


(*val aget_X : forall 'width . Size 'width => integer -> ii -> M (mword 'width)*)

definition aget_X  :: " int \<Rightarrow> int \<Rightarrow>((register_value),(('width::len)Word.word),(exception))monad "  where 
     " aget_X (width__tv :: int) n = (
   (assert_exp (((((n \<ge> (( 0 :: int)::ii))) \<and> ((n \<le> (( 31 :: int)::ii)))))) (''((n >= 0) && (n <= 31))'') \<then>
   assert_exp ((((((width__tv = (( 8 :: int)::ii)))) \<or> ((((((width__tv = (( 16 :: int)::ii)))) \<or> ((((((width__tv = (( 32 :: int)::ii)))) \<or> (((width__tv = (( 64 :: int)::ii))))))))))))) (''((width == 8) || ((width == 16) || ((width == 32) || (width == 64))))'')) \<then>
   (if (((n \<noteq> (( 31 :: int)::ii)))) then
     read_reg R_ref \<bind> (\<lambda> (w__0 :: ( 64 bits) list) . 
     return ((slice ((access_list_dec w__0 n  ::  64 Word.word)) (( 0 :: int)::ii) width__tv  :: ( 'width::len)Word.word)))
   else return ((Zeros__0 ((make_the_value width__tv ))  :: ( 'width::len)Word.word))))"


(*val aarch64_system_sysops : bool -> ii -> ii -> ii -> ii -> ii -> ii -> M unit*)

definition aarch64_system_sysops  :: " bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_system_sysops has_result sys_crm sys_crn sys_op0 sys_op1 sys_op2 t = (
   if has_result then
     (AArch64_SysInstrWithResult sys_op0 sys_op1 sys_crn sys_crm sys_op2  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::
        64 Word.word) . 
     aset_X t w__0)
   else
     (aget_X (( 64 :: int)::ii) t  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
     AArch64_SysInstr sys_op0 sys_op1 sys_crn sys_crm sys_op2 w__1))"


(*val aarch64_system_register_system : bool -> ii -> ii -> ii -> ii -> ii -> ii -> M unit*)

definition aarch64_system_register_system  :: " bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_system_register_system read sys_crm sys_crn sys_op0 sys_op1 sys_op2 t = (
   if read then
     (AArch64_SysRegRead sys_op0 sys_op1 sys_crn sys_crm sys_op2  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::
        64 Word.word) . 
     aset_X t w__0)
   else
     (aget_X (( 64 :: int)::ii) t  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
     AArch64_SysRegWrite sys_op0 sys_op1 sys_crn sys_crm sys_op2 w__1))"


(*val aarch64_integer_insext_insert_movewide : ii -> ii -> mword ty16 -> MoveWideOp -> ii -> M unit*)

definition aarch64_integer_insext_insert_movewide  :: " int \<Rightarrow> int \<Rightarrow>(16)Word.word \<Rightarrow> MoveWideOp \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_insext_insert_movewide d l__267 imm opcode pos = (
   if (((l__267 = (( 8 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M)) \<bind> (\<lambda> (result :: 8 bits) . 
     (if (((opcode = MoveWideOp_K))) then (aget_X (( 8 :: int)::ii) d  :: ( 8 Word.word) M)
      else
        (let (result :: 8 bits) = ((Zeros__1 (( 8 :: int)::ii) ()   ::  8 Word.word)) in
        return result)) \<bind> (\<lambda> (result :: 8 bits) . 
     (let result = ((set_slice (( 8 :: int)::ii) (( 16 :: int)::ii) result pos imm  ::  8 Word.word)) in
     (let (result :: 8 bits) =
       (if (((opcode = MoveWideOp_N))) then (not_vec result  ::  8 Word.word)
       else result) in
     aset_X d result)))))
   else if (((l__267 = (( 16 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M)) \<bind> (\<lambda> (result :: 16 bits) . 
     (if (((opcode = MoveWideOp_K))) then (aget_X (( 16 :: int)::ii) d  :: ( 16 Word.word) M)
      else
        (let (result :: 16 bits) = ((Zeros__1 (( 16 :: int)::ii) ()   ::  16 Word.word)) in
        return result)) \<bind> (\<lambda> (result :: 16 bits) . 
     (let result = ((set_slice (( 16 :: int)::ii) (( 16 :: int)::ii) result pos imm  ::  16 Word.word)) in
     (let (result :: 16 bits) =
       (if (((opcode = MoveWideOp_N))) then (not_vec result  ::  16 Word.word)
       else result) in
     aset_X d result)))))
   else if (((l__267 = (( 32 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (result :: 32 bits) . 
     (if (((opcode = MoveWideOp_K))) then (aget_X (( 32 :: int)::ii) d  :: ( 32 Word.word) M)
      else
        (let (result :: 32 bits) = ((Zeros__1 (( 32 :: int)::ii) ()   ::  32 Word.word)) in
        return result)) \<bind> (\<lambda> (result :: 32 bits) . 
     (let result = ((set_slice (( 32 :: int)::ii) (( 16 :: int)::ii) result pos imm  ::  32 Word.word)) in
     (let (result :: 32 bits) =
       (if (((opcode = MoveWideOp_N))) then (not_vec result  ::  32 Word.word)
       else result) in
     aset_X d result)))))
   else if (((l__267 = (( 64 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (result :: 64 bits) . 
     (if (((opcode = MoveWideOp_K))) then (aget_X (( 64 :: int)::ii) d  :: ( 64 Word.word) M)
      else
        (let (result :: 64 bits) = ((Zeros__1 (( 64 :: int)::ii) ()   ::  64 Word.word)) in
        return result)) \<bind> (\<lambda> (result :: 64 bits) . 
     (let result = ((set_slice (( 64 :: int)::ii) (( 16 :: int)::ii) result pos imm  ::  64 Word.word)) in
     (let (result :: 64 bits) =
       (if (((opcode = MoveWideOp_N))) then (not_vec result  ::  64 Word.word)
       else result) in
     aset_X d result)))))
   else if (((l__267 = (( 128 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M)) \<bind> (\<lambda> (result :: 128 bits) . 
     (if (((opcode = MoveWideOp_K))) then (aget_X (( 128 :: int)::ii) d  :: ( 128 Word.word) M)
      else
        (let (result :: 128 bits) = ((Zeros__1 (( 128 :: int)::ii) ()   ::  128 Word.word)) in
        return result)) \<bind> (\<lambda> (result :: 128 bits) . 
     (let result = ((set_slice (( 128 :: int)::ii) (( 16 :: int)::ii) result pos imm  ::  128 Word.word)) in
     (let (result :: 128 bits) =
       (if (((opcode = MoveWideOp_N))) then (not_vec result  ::  128 Word.word)
       else result) in
     aset_X d result)))))
   else
     (let dbytes = (ex_int ((l__267 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))"


(*val aarch64_integer_insext_extract_immediate : ii -> ii -> ii -> ii -> ii -> M unit*)

definition aarch64_integer_insext_extract_immediate  :: " int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_insext_extract_immediate d l__262 lsb1 m n = (
   if (((l__262 = (( 8 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M)) \<bind> (\<lambda> (result :: 8 bits) . 
     (aget_X (( 8 :: int)::ii) n  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand1 :: 8 bits) . 
     (aget_X (( 8 :: int)::ii) m  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand2 :: 8 bits) . 
     (let (concat1 :: 16 bits) = ((concat_vec operand1 operand2  ::  16 Word.word)) in
     (let result = ((slice concat1 lsb1 (( 8 :: int)::ii)  ::  8 Word.word)) in
     aset_X d result))))))
   else if (((l__262 = (( 16 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M)) \<bind> (\<lambda> (result :: 16 bits) . 
     (aget_X (( 16 :: int)::ii) n  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand1 :: 16 bits) . 
     (aget_X (( 16 :: int)::ii) m  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand2 :: 16 bits) . 
     (let (concat1 :: 32 bits) = ((concat_vec operand1 operand2  ::  32 Word.word)) in
     (let result = ((slice concat1 lsb1 (( 16 :: int)::ii)  ::  16 Word.word)) in
     aset_X d result))))))
   else if (((l__262 = (( 32 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (result :: 32 bits) . 
     (aget_X (( 32 :: int)::ii) n  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand1 :: 32 bits) . 
     (aget_X (( 32 :: int)::ii) m  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand2 :: 32 bits) . 
     (let (concat1 :: 64 bits) = ((concat_vec operand1 operand2  ::  64 Word.word)) in
     (let result = ((slice concat1 lsb1 (( 32 :: int)::ii)  ::  32 Word.word)) in
     aset_X d result))))))
   else if (((l__262 = (( 64 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (result :: 64 bits) . 
     (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand1 :: 64 bits) . 
     (aget_X (( 64 :: int)::ii) m  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand2 :: 64 bits) . 
     (let (concat1 :: 128 bits) = ((concat_vec operand1 operand2  ::  128 Word.word)) in
     (let result = ((slice concat1 lsb1 (( 64 :: int)::ii)  ::  64 Word.word)) in
     aset_X d result))))))
   else if (((l__262 = (( 128 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M)) \<bind> (\<lambda> (result :: 128 bits) . 
     (aget_X (( 128 :: int)::ii) n  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand1 :: 128 bits) . 
     (aget_X (( 128 :: int)::ii) m  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand2 :: 128 bits) . 
     (let (concat1 :: 256 bits) = ((concat_vec operand1 operand2  ::  256 Word.word)) in
     (let result = ((slice concat1 lsb1 (( 128 :: int)::ii)  ::  128 Word.word)) in
     aset_X d result))))))
   else
     (let dbytes = (ex_int ((l__262 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))"


(*val aarch64_integer_arithmetic_rev : ii -> ii -> ii -> ii -> M unit*)

definition aarch64_integer_arithmetic_rev  :: " int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_arithmetic_rev container_size d l__257 n = (
   if (((l__257 = (( 8 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 8 :: int)::ii) n  :: ( 8 Word.word) M)) \<bind> (\<lambda> (operand :: 8 bits) . 
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> (\<lambda> (result :: 8 bits) . 
     (let (containers :: ii) = ((( 8 :: int)::ii) div container_size) in
     (let (elements_per_container :: ii) = (container_size div (( 8 :: int)::ii)) in
     (let (index1 :: ii) = ((( 0 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (rev_index :: ii) . 
     (let ((index1 :: ii), (result :: 8 bits), (rev_index :: ii)) =
       (foreach (index_list (( 0 :: int)::ii) ((((ex_int containers)) - (( 1 :: int)::ii))) (( 1 :: int)::ii)) (index1,
                                                                                          result,
                                                                                          rev_index)
         (\<lambda> c varstup .  (let (index1, result, rev_index) = varstup in
           (let (rev_index :: ii) =
             (((ex_int index1)) +
               ((((((ex_int elements_per_container)) - (( 1 :: int)::ii))) * (( 8 :: int)::ii)))) in
           (let ((index1 :: ii), (result :: 8 bits), (rev_index :: ii)) =
             (foreach (index_list (( 0 :: int)::ii) ((((ex_int elements_per_container)) - (( 1 :: int)::ii))) (( 1 :: int)::ii)) (index1,
                                                                                                            result,
                                                                                                            rev_index)
               (\<lambda> e varstup .  (let (index1, result, rev_index) = varstup in
                 (let (result :: 8 bits) =
                   ((set_slice (( 8 :: int)::ii) (( 8 :: int)::ii) result rev_index
                      ((slice operand index1 (( 8 :: int)::ii)  ::  8 Word.word))
                     ::  8 Word.word)) in
                 (let (index1 :: ii) = (((ex_int index1)) + (( 8 :: int)::ii)) in
                 (let (rev_index :: ii) = (((ex_int rev_index)) - (( 8 :: int)::ii)) in
                 (index1, result, rev_index))))))) in
           (index1, result, rev_index)))))) in
     aset_X d result))))))))
   else if (((l__257 = (( 16 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 16 :: int)::ii) n  :: ( 16 Word.word) M)) \<bind> (\<lambda> (operand :: 16 bits) . 
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (result :: 16 bits) . 
     (let (containers :: ii) = ((( 16 :: int)::ii) div container_size) in
     (let (elements_per_container :: ii) = (container_size div (( 8 :: int)::ii)) in
     (let (index1 :: ii) = ((( 0 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (rev_index :: ii) . 
     (let ((index1 :: ii), (result :: 16 bits), (rev_index :: ii)) =
       (foreach (index_list (( 0 :: int)::ii) ((((ex_int containers)) - (( 1 :: int)::ii))) (( 1 :: int)::ii)) (index1,
                                                                                          result,
                                                                                          rev_index)
         (\<lambda> c varstup .  (let (index1, result, rev_index) = varstup in
           (let (rev_index :: ii) =
             (((ex_int index1)) +
               ((((((ex_int elements_per_container)) - (( 1 :: int)::ii))) * (( 8 :: int)::ii)))) in
           (let ((index1 :: ii), (result :: 16 bits), (rev_index :: ii)) =
             (foreach (index_list (( 0 :: int)::ii) ((((ex_int elements_per_container)) - (( 1 :: int)::ii))) (( 1 :: int)::ii)) (index1,
                                                                                                            result,
                                                                                                            rev_index)
               (\<lambda> e varstup .  (let (index1, result, rev_index) = varstup in
                 (let (result :: 16 bits) =
                   ((set_slice (( 16 :: int)::ii) (( 8 :: int)::ii) result rev_index
                      ((slice operand index1 (( 8 :: int)::ii)  ::  8 Word.word))
                     ::  16 Word.word)) in
                 (let (index1 :: ii) = (((ex_int index1)) + (( 8 :: int)::ii)) in
                 (let (rev_index :: ii) = (((ex_int rev_index)) - (( 8 :: int)::ii)) in
                 (index1, result, rev_index))))))) in
           (index1, result, rev_index)))))) in
     aset_X d result))))))))
   else if (((l__257 = (( 32 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 32 :: int)::ii) n  :: ( 32 Word.word) M)) \<bind> (\<lambda> (operand :: 32 bits) . 
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (result :: 32 bits) . 
     (let (containers :: ii) = ((( 32 :: int)::ii) div container_size) in
     (let (elements_per_container :: ii) = (container_size div (( 8 :: int)::ii)) in
     (let (index1 :: ii) = ((( 0 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (rev_index :: ii) . 
     (let ((index1 :: ii), (result :: 32 bits), (rev_index :: ii)) =
       (foreach (index_list (( 0 :: int)::ii) ((((ex_int containers)) - (( 1 :: int)::ii))) (( 1 :: int)::ii)) (index1,
                                                                                          result,
                                                                                          rev_index)
         (\<lambda> c varstup .  (let (index1, result, rev_index) = varstup in
           (let (rev_index :: ii) =
             (((ex_int index1)) +
               ((((((ex_int elements_per_container)) - (( 1 :: int)::ii))) * (( 8 :: int)::ii)))) in
           (let ((index1 :: ii), (result :: 32 bits), (rev_index :: ii)) =
             (foreach (index_list (( 0 :: int)::ii) ((((ex_int elements_per_container)) - (( 1 :: int)::ii))) (( 1 :: int)::ii)) (index1,
                                                                                                            result,
                                                                                                            rev_index)
               (\<lambda> e varstup .  (let (index1, result, rev_index) = varstup in
                 (let (result :: 32 bits) =
                   ((set_slice (( 32 :: int)::ii) (( 8 :: int)::ii) result rev_index
                      ((slice operand index1 (( 8 :: int)::ii)  ::  8 Word.word))
                     ::  32 Word.word)) in
                 (let (index1 :: ii) = (((ex_int index1)) + (( 8 :: int)::ii)) in
                 (let (rev_index :: ii) = (((ex_int rev_index)) - (( 8 :: int)::ii)) in
                 (index1, result, rev_index))))))) in
           (index1, result, rev_index)))))) in
     aset_X d result))))))))
   else if (((l__257 = (( 64 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (operand :: 64 bits) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (result :: 64 bits) . 
     (let (containers :: ii) = ((( 64 :: int)::ii) div container_size) in
     (let (elements_per_container :: ii) = (container_size div (( 8 :: int)::ii)) in
     (let (index1 :: ii) = ((( 0 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (rev_index :: ii) . 
     (let ((index1 :: ii), (result :: 64 bits), (rev_index :: ii)) =
       (foreach (index_list (( 0 :: int)::ii) ((((ex_int containers)) - (( 1 :: int)::ii))) (( 1 :: int)::ii)) (index1,
                                                                                          result,
                                                                                          rev_index)
         (\<lambda> c varstup .  (let (index1, result, rev_index) = varstup in
           (let (rev_index :: ii) =
             (((ex_int index1)) +
               ((((((ex_int elements_per_container)) - (( 1 :: int)::ii))) * (( 8 :: int)::ii)))) in
           (let ((index1 :: ii), (result :: 64 bits), (rev_index :: ii)) =
             (foreach (index_list (( 0 :: int)::ii) ((((ex_int elements_per_container)) - (( 1 :: int)::ii))) (( 1 :: int)::ii)) (index1,
                                                                                                            result,
                                                                                                            rev_index)
               (\<lambda> e varstup .  (let (index1, result, rev_index) = varstup in
                 (let (result :: 64 bits) =
                   ((set_slice (( 64 :: int)::ii) (( 8 :: int)::ii) result rev_index
                      ((slice operand index1 (( 8 :: int)::ii)  ::  8 Word.word))
                     ::  64 Word.word)) in
                 (let (index1 :: ii) = (((ex_int index1)) + (( 8 :: int)::ii)) in
                 (let (rev_index :: ii) = (((ex_int rev_index)) - (( 8 :: int)::ii)) in
                 (index1, result, rev_index))))))) in
           (index1, result, rev_index)))))) in
     aset_X d result))))))))
   else if (((l__257 = (( 128 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 128 :: int)::ii) n  :: ( 128 Word.word) M)) \<bind> (\<lambda> (operand :: 128 bits) . 
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> (\<lambda> (result :: 128 bits) . 
     (let (containers :: ii) = ((( 128 :: int)::ii) div container_size) in
     (let (elements_per_container :: ii) = (container_size div (( 8 :: int)::ii)) in
     (let (index1 :: ii) = ((( 0 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (rev_index :: ii) . 
     (let ((index1 :: ii), (result :: 128 bits), (rev_index :: ii)) =
       (foreach (index_list (( 0 :: int)::ii) ((((ex_int containers)) - (( 1 :: int)::ii))) (( 1 :: int)::ii)) (index1,
                                                                                          result,
                                                                                          rev_index)
         (\<lambda> c varstup .  (let (index1, result, rev_index) = varstup in
           (let (rev_index :: ii) =
             (((ex_int index1)) +
               ((((((ex_int elements_per_container)) - (( 1 :: int)::ii))) * (( 8 :: int)::ii)))) in
           (let ((index1 :: ii), (result :: 128 bits), (rev_index :: ii)) =
             (foreach (index_list (( 0 :: int)::ii) ((((ex_int elements_per_container)) - (( 1 :: int)::ii))) (( 1 :: int)::ii)) (index1,
                                                                                                            result,
                                                                                                            rev_index)
               (\<lambda> e varstup .  (let (index1, result, rev_index) = varstup in
                 (let (result :: 128 bits) =
                   ((set_slice (( 128 :: int)::ii) (( 8 :: int)::ii) result rev_index
                      ((slice operand index1 (( 8 :: int)::ii)  ::  8 Word.word))
                     ::  128 Word.word)) in
                 (let (index1 :: ii) = (((ex_int index1)) + (( 8 :: int)::ii)) in
                 (let (rev_index :: ii) = (((ex_int rev_index)) - (( 8 :: int)::ii)) in
                 (index1, result, rev_index))))))) in
           (index1, result, rev_index)))))) in
     aset_X d result))))))))
   else
     (let dbytes = (ex_int ((l__257 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))"


(*val aarch64_integer_arithmetic_rbit : ii -> ii -> ii -> M unit*)

definition aarch64_integer_arithmetic_rbit  :: " int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_arithmetic_rbit d l__252 n = (
   if (((l__252 = (( 8 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 8 :: int)::ii) n  :: ( 8 Word.word) M)) \<bind> (\<lambda> (operand :: 8 bits) . 
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> (\<lambda> (result :: 8 bits) . 
     (let (result :: 8 bits) =
       (foreach (index_list (( 0 :: int)::ii) (((( 8 :: int)::ii) - (( 1 :: int)::ii))) (( 1 :: int)::ii)) result
         (\<lambda> i result . 
           (set_slice (( 8 :: int)::ii) (( 1 :: int)::ii) result (((((( 8 :: int)::ii) - (( 1 :: int)::ii))) - i))
              (vec_of_bits [access_vec_dec operand i]  ::  1 Word.word)
             ::  8 Word.word))) in
     aset_X d result))))
   else if (((l__252 = (( 16 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 16 :: int)::ii) n  :: ( 16 Word.word) M)) \<bind> (\<lambda> (operand :: 16 bits) . 
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (result :: 16 bits) . 
     (let (result :: 16 bits) =
       (foreach (index_list (( 0 :: int)::ii) (((( 16 :: int)::ii) - (( 1 :: int)::ii))) (( 1 :: int)::ii)) result
         (\<lambda> i result . 
           (set_slice (( 16 :: int)::ii) (( 1 :: int)::ii) result (((((( 16 :: int)::ii) - (( 1 :: int)::ii))) - i))
              (vec_of_bits [access_vec_dec operand i]  ::  1 Word.word)
             ::  16 Word.word))) in
     aset_X d result))))
   else if (((l__252 = (( 32 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 32 :: int)::ii) n  :: ( 32 Word.word) M)) \<bind> (\<lambda> (operand :: 32 bits) . 
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (result :: 32 bits) . 
     (let (result :: 32 bits) =
       (foreach (index_list (( 0 :: int)::ii) (((( 32 :: int)::ii) - (( 1 :: int)::ii))) (( 1 :: int)::ii)) result
         (\<lambda> i result . 
           (set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) result (((((( 32 :: int)::ii) - (( 1 :: int)::ii))) - i))
              (vec_of_bits [access_vec_dec operand i]  ::  1 Word.word)
             ::  32 Word.word))) in
     aset_X d result))))
   else if (((l__252 = (( 64 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (operand :: 64 bits) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (result :: 64 bits) . 
     (let (result :: 64 bits) =
       (foreach (index_list (( 0 :: int)::ii) (((( 64 :: int)::ii) - (( 1 :: int)::ii))) (( 1 :: int)::ii)) result
         (\<lambda> i result . 
           (set_slice (( 64 :: int)::ii) (( 1 :: int)::ii) result (((((( 64 :: int)::ii) - (( 1 :: int)::ii))) - i))
              (vec_of_bits [access_vec_dec operand i]  ::  1 Word.word)
             ::  64 Word.word))) in
     aset_X d result))))
   else if (((l__252 = (( 128 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 128 :: int)::ii) n  :: ( 128 Word.word) M)) \<bind> (\<lambda> (operand :: 128 bits) . 
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> (\<lambda> (result :: 128 bits) . 
     (let (result :: 128 bits) =
       (foreach (index_list (( 0 :: int)::ii) (((( 128 :: int)::ii) - (( 1 :: int)::ii))) (( 1 :: int)::ii)) result
         (\<lambda> i result . 
           (set_slice (( 128 :: int)::ii) (( 1 :: int)::ii) result (((((( 128 :: int)::ii) - (( 1 :: int)::ii))) - i))
              (vec_of_bits [access_vec_dec operand i]  ::  1 Word.word)
             ::  128 Word.word))) in
     aset_X d result))))
   else
     (let dbytes = (ex_int ((l__252 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))"


(*val integer_arithmetic_rbit_decode : mword ty1 -> mword ty1 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition integer_arithmetic_rbit_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_arithmetic_rbit_decode sf S opcode2 Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   (let (datasize :: int) =
     (if (((sf = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 64 :: int)::ii)
     else (( 32 :: int)::ii)) in
   aarch64_integer_arithmetic_rbit d datasize n)))))"


(*val aarch64_integer_arithmetic_mul_widening_64128hi : ii -> ii -> ii -> ii -> bool -> M unit*)

definition aarch64_integer_arithmetic_mul_widening_64128hi  :: " int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_arithmetic_mul_widening_64128hi d l__247 m n unsigned = (
   if (((l__247 = (( 8 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 8 :: int)::ii) n  :: ( 8 Word.word) M)) \<bind> (\<lambda> (operand1 :: 8 bits) . 
     (aget_X (( 8 :: int)::ii) m  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand2 :: 8 bits) . 
     (let (result :: ii) =
       (((ex_int ((asl_Int operand1 unsigned)))) * ((ex_int ((asl_Int operand2 unsigned))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) result (( 64 :: int)::ii)  ::  64 Word.word))))))
   else if (((l__247 = (( 16 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 16 :: int)::ii) n  :: ( 16 Word.word) M)) \<bind> (\<lambda> (operand1 :: 16 bits) . 
     (aget_X (( 16 :: int)::ii) m  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand2 :: 16 bits) . 
     (let (result :: ii) =
       (((ex_int ((asl_Int operand1 unsigned)))) * ((ex_int ((asl_Int operand2 unsigned))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) result (( 64 :: int)::ii)  ::  64 Word.word))))))
   else if (((l__247 = (( 32 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 32 :: int)::ii) n  :: ( 32 Word.word) M)) \<bind> (\<lambda> (operand1 :: 32 bits) . 
     (aget_X (( 32 :: int)::ii) m  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand2 :: 32 bits) . 
     (let (result :: ii) =
       (((ex_int ((asl_Int operand1 unsigned)))) * ((ex_int ((asl_Int operand2 unsigned))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) result (( 64 :: int)::ii)  ::  64 Word.word))))))
   else if (((l__247 = (( 64 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (operand1 :: 64 bits) . 
     (aget_X (( 64 :: int)::ii) m  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand2 :: 64 bits) . 
     (let (result :: ii) =
       (((ex_int ((asl_Int operand1 unsigned)))) * ((ex_int ((asl_Int operand2 unsigned))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) result (( 64 :: int)::ii)  ::  64 Word.word))))))
   else if (((l__247 = (( 128 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 128 :: int)::ii) n  :: ( 128 Word.word) M)) \<bind> (\<lambda> (operand1 :: 128 bits) . 
     (aget_X (( 128 :: int)::ii) m  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand2 :: 128 bits) . 
     (let (result :: ii) =
       (((ex_int ((asl_Int operand1 unsigned)))) * ((ex_int ((asl_Int operand2 unsigned))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) result (( 64 :: int)::ii)  ::  64 Word.word))))))
   else
     (let dbytes = (ex_int ((l__247 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))"


(*val integer_arithmetic_mul_widening_64128hi_decode : mword ty1 -> mword ty2 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition integer_arithmetic_mul_widening_64128hi_decode  :: "(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_arithmetic_mul_widening_64128hi_decode sf op54 U Rm o0 Ra Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   (let (m :: ii) = (Word.uint Rm) in
   (let (a :: ii) = (Word.uint Ra) in
   (let (destsize :: int) = ((( 64 :: int)::ii)) in
   (let (datasize :: ii) = destsize in
   (let (unsigned :: bool) = (U = (vec_of_bits [B1]  ::  1 Word.word)) in
   aarch64_integer_arithmetic_mul_widening_64128hi d datasize m n unsigned)))))))))"


(*val aarch64_integer_arithmetic_mul_widening_3264 : ii -> ii -> ii -> ii -> ii -> ii -> bool -> bool -> M unit*)

definition aarch64_integer_arithmetic_mul_widening_3264  :: " int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_arithmetic_mul_widening_3264 a d l__220 l__221 m n sub_op unsigned = (
   if ((((((l__220 = (( 8 :: int)::ii)))) \<and> (((l__221 = (( 32 :: int)::ii))))))) then
     assert_exp True (''destsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 8 :: int)::ii) n  :: ( 8 Word.word) M)) \<bind> (\<lambda> (operand1 :: 8 bits) . 
     (aget_X (( 8 :: int)::ii) m  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand2 :: 8 bits) . 
     (aget_X (( 32 :: int)::ii) a  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand3 :: 32 bits) . 
     undefined_int ()  \<bind> (\<lambda> (result :: ii) . 
     (let (result :: ii) =
       (if sub_op then
         ((ex_int ((asl_Int operand3 unsigned)))) -
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))
       else
         ((ex_int ((asl_Int operand3 unsigned)))) +
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) result (( 0 :: int)::ii)  ::  64 Word.word)))))))))
   else if ((((((l__220 = (( 8 :: int)::ii)))) \<and> (((l__221 = (( 64 :: int)::ii))))))) then
     assert_exp True (''destsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 8 :: int)::ii) n  :: ( 8 Word.word) M)) \<bind> (\<lambda> (operand1 :: 8 bits) . 
     (aget_X (( 8 :: int)::ii) m  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand2 :: 8 bits) . 
     (aget_X (( 64 :: int)::ii) a  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand3 :: 64 bits) . 
     undefined_int ()  \<bind> (\<lambda> (result :: ii) . 
     (let (result :: ii) =
       (if sub_op then
         ((ex_int ((asl_Int operand3 unsigned)))) -
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))
       else
         ((ex_int ((asl_Int operand3 unsigned)))) +
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) result (( 0 :: int)::ii)  ::  64 Word.word)))))))))
   else if (((l__220 = (( 8 :: int)::ii)))) then assert_exp True (''destsize constraint'')
   else if ((((((l__220 = (( 16 :: int)::ii)))) \<and> (((l__221 = (( 32 :: int)::ii))))))) then
     assert_exp True (''destsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 16 :: int)::ii) n  :: ( 16 Word.word) M)) \<bind> (\<lambda> (operand1 :: 16 bits) . 
     (aget_X (( 16 :: int)::ii) m  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand2 :: 16 bits) . 
     (aget_X (( 32 :: int)::ii) a  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand3 :: 32 bits) . 
     undefined_int ()  \<bind> (\<lambda> (result :: ii) . 
     (let (result :: ii) =
       (if sub_op then
         ((ex_int ((asl_Int operand3 unsigned)))) -
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))
       else
         ((ex_int ((asl_Int operand3 unsigned)))) +
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) result (( 0 :: int)::ii)  ::  64 Word.word)))))))))
   else if ((((((l__220 = (( 16 :: int)::ii)))) \<and> (((l__221 = (( 64 :: int)::ii))))))) then
     assert_exp True (''destsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 16 :: int)::ii) n  :: ( 16 Word.word) M)) \<bind> (\<lambda> (operand1 :: 16 bits) . 
     (aget_X (( 16 :: int)::ii) m  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand2 :: 16 bits) . 
     (aget_X (( 64 :: int)::ii) a  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand3 :: 64 bits) . 
     undefined_int ()  \<bind> (\<lambda> (result :: ii) . 
     (let (result :: ii) =
       (if sub_op then
         ((ex_int ((asl_Int operand3 unsigned)))) -
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))
       else
         ((ex_int ((asl_Int operand3 unsigned)))) +
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) result (( 0 :: int)::ii)  ::  64 Word.word)))))))))
   else if (((l__220 = (( 16 :: int)::ii)))) then assert_exp True (''destsize constraint'')
   else if ((((((l__220 = (( 32 :: int)::ii)))) \<and> (((l__221 = (( 32 :: int)::ii))))))) then
     assert_exp True (''destsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 32 :: int)::ii) n  :: ( 32 Word.word) M)) \<bind> (\<lambda> (operand1 :: 32 bits) . 
     (aget_X (( 32 :: int)::ii) m  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand2 :: 32 bits) . 
     (aget_X (( 32 :: int)::ii) a  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand3 :: 32 bits) . 
     undefined_int ()  \<bind> (\<lambda> (result :: ii) . 
     (let (result :: ii) =
       (if sub_op then
         ((ex_int ((asl_Int operand3 unsigned)))) -
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))
       else
         ((ex_int ((asl_Int operand3 unsigned)))) +
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) result (( 0 :: int)::ii)  ::  64 Word.word)))))))))
   else if ((((((l__220 = (( 32 :: int)::ii)))) \<and> (((l__221 = (( 64 :: int)::ii))))))) then
     assert_exp True (''destsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 32 :: int)::ii) n  :: ( 32 Word.word) M)) \<bind> (\<lambda> (operand1 :: 32 bits) . 
     (aget_X (( 32 :: int)::ii) m  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand2 :: 32 bits) . 
     (aget_X (( 64 :: int)::ii) a  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand3 :: 64 bits) . 
     undefined_int ()  \<bind> (\<lambda> (result :: ii) . 
     (let (result :: ii) =
       (if sub_op then
         ((ex_int ((asl_Int operand3 unsigned)))) -
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))
       else
         ((ex_int ((asl_Int operand3 unsigned)))) +
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) result (( 0 :: int)::ii)  ::  64 Word.word)))))))))
   else if (((l__220 = (( 32 :: int)::ii)))) then assert_exp True (''destsize constraint'')
   else if ((((((l__220 = (( 64 :: int)::ii)))) \<and> (((l__221 = (( 32 :: int)::ii))))))) then
     assert_exp True (''destsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (operand1 :: 64 bits) . 
     (aget_X (( 64 :: int)::ii) m  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand2 :: 64 bits) . 
     (aget_X (( 32 :: int)::ii) a  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand3 :: 32 bits) . 
     undefined_int ()  \<bind> (\<lambda> (result :: ii) . 
     (let (result :: ii) =
       (if sub_op then
         ((ex_int ((asl_Int operand3 unsigned)))) -
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))
       else
         ((ex_int ((asl_Int operand3 unsigned)))) +
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) result (( 0 :: int)::ii)  ::  64 Word.word)))))))))
   else if ((((((l__220 = (( 64 :: int)::ii)))) \<and> (((l__221 = (( 64 :: int)::ii))))))) then
     assert_exp True (''destsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (operand1 :: 64 bits) . 
     (aget_X (( 64 :: int)::ii) m  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand2 :: 64 bits) . 
     (aget_X (( 64 :: int)::ii) a  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand3 :: 64 bits) . 
     undefined_int ()  \<bind> (\<lambda> (result :: ii) . 
     (let (result :: ii) =
       (if sub_op then
         ((ex_int ((asl_Int operand3 unsigned)))) -
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))
       else
         ((ex_int ((asl_Int operand3 unsigned)))) +
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) result (( 0 :: int)::ii)  ::  64 Word.word)))))))))
   else if (((l__220 = (( 64 :: int)::ii)))) then assert_exp True (''destsize constraint'')
   else if ((((((l__220 = (( 128 :: int)::ii)))) \<and> (((l__221 = (( 32 :: int)::ii))))))) then
     assert_exp True (''destsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 128 :: int)::ii) n  :: ( 128 Word.word) M)) \<bind> (\<lambda> (operand1 :: 128 bits) . 
     (aget_X (( 128 :: int)::ii) m  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand2 :: 128 bits) . 
     (aget_X (( 32 :: int)::ii) a  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand3 :: 32 bits) . 
     undefined_int ()  \<bind> (\<lambda> (result :: ii) . 
     (let (result :: ii) =
       (if sub_op then
         ((ex_int ((asl_Int operand3 unsigned)))) -
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))
       else
         ((ex_int ((asl_Int operand3 unsigned)))) +
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) result (( 0 :: int)::ii)  ::  64 Word.word)))))))))
   else if ((((((l__220 = (( 128 :: int)::ii)))) \<and> (((l__221 = (( 64 :: int)::ii))))))) then
     assert_exp True (''destsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 128 :: int)::ii) n  :: ( 128 Word.word) M)) \<bind> (\<lambda> (operand1 :: 128 bits) . 
     (aget_X (( 128 :: int)::ii) m  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand2 :: 128 bits) . 
     (aget_X (( 64 :: int)::ii) a  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand3 :: 64 bits) . 
     undefined_int ()  \<bind> (\<lambda> (result :: ii) . 
     (let (result :: ii) =
       (if sub_op then
         ((ex_int ((asl_Int operand3 unsigned)))) -
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))
       else
         ((ex_int ((asl_Int operand3 unsigned)))) +
           ((((ex_int ((asl_Int operand1 unsigned)))) *
               ((ex_int ((asl_Int operand2 unsigned))))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) result (( 0 :: int)::ii)  ::  64 Word.word)))))))))
   else if (((l__220 = (( 128 :: int)::ii)))) then assert_exp True (''destsize constraint'')
   else if (((l__221 = (( 32 :: int)::ii)))) then
     assert_exp True (''destsize constraint'') \<then>
     ((let dbytes = (ex_int ((l__220 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))
   else if (((l__221 = (( 64 :: int)::ii)))) then
     assert_exp True (''destsize constraint'') \<then>
     ((let dbytes = (ex_int ((l__220 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))
   else assert_exp True (''destsize constraint''))"


(*val integer_arithmetic_mul_widening_3264_decode : mword ty1 -> mword ty2 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition integer_arithmetic_mul_widening_3264_decode  :: "(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_arithmetic_mul_widening_3264_decode sf op54 U Rm o0 Ra Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   (let (m :: ii) = (Word.uint Rm) in
   (let (a :: ii) = (Word.uint Ra) in
   (let (destsize :: int) = ((( 64 :: int)::ii)) in
   (let (datasize :: int) = ((( 32 :: int)::ii)) in
   (let (sub_op :: bool) = (o0 = (vec_of_bits [B1]  ::  1 Word.word)) in
   (let (unsigned :: bool) = (U = (vec_of_bits [B1]  ::  1 Word.word)) in
   aarch64_integer_arithmetic_mul_widening_3264 a d datasize destsize m n sub_op unsigned))))))))))"


(*val aarch64_integer_arithmetic_mul_uniform_addsub : ii -> ii -> ii -> ii -> ii -> ii -> bool -> M unit*)

definition aarch64_integer_arithmetic_mul_uniform_addsub  :: " int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_arithmetic_mul_uniform_addsub a d l__193 l__194 m n sub_op = (
   if ((((((l__193 = (( 8 :: int)::ii)))) \<and> (((l__194 = (( 32 :: int)::ii))))))) then
     assert_exp True (''destsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 8 :: int)::ii) n  :: ( 8 Word.word) M)) \<bind> (\<lambda> (operand1 :: 8 bits) . 
     (aget_X (( 8 :: int)::ii) m  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand2 :: 8 bits) . 
     (aget_X (( 32 :: int)::ii) a  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand3 :: 32 bits) . 
     undefined_int ()  \<bind> (\<lambda> (result :: ii) . 
     (let (result :: ii) =
       (if sub_op then
         ((Word.uint operand3)) - ((((Word.uint operand1)) * ((Word.uint operand2))))
       else ((Word.uint operand3)) + ((((Word.uint operand1)) * ((Word.uint operand2))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) result (( 0 :: int)::ii)  ::  32 Word.word)))))))))
   else if ((((((l__193 = (( 8 :: int)::ii)))) \<and> (((l__194 = (( 64 :: int)::ii))))))) then
     assert_exp True (''destsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 8 :: int)::ii) n  :: ( 8 Word.word) M)) \<bind> (\<lambda> (operand1 :: 8 bits) . 
     (aget_X (( 8 :: int)::ii) m  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand2 :: 8 bits) . 
     (aget_X (( 64 :: int)::ii) a  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand3 :: 64 bits) . 
     undefined_int ()  \<bind> (\<lambda> (result :: ii) . 
     (let (result :: ii) =
       (if sub_op then
         ((Word.uint operand3)) - ((((Word.uint operand1)) * ((Word.uint operand2))))
       else ((Word.uint operand3)) + ((((Word.uint operand1)) * ((Word.uint operand2))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) result (( 0 :: int)::ii)  ::  64 Word.word)))))))))
   else if (((l__193 = (( 8 :: int)::ii)))) then assert_exp True (''destsize constraint'')
   else if ((((((l__193 = (( 16 :: int)::ii)))) \<and> (((l__194 = (( 32 :: int)::ii))))))) then
     assert_exp True (''destsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 16 :: int)::ii) n  :: ( 16 Word.word) M)) \<bind> (\<lambda> (operand1 :: 16 bits) . 
     (aget_X (( 16 :: int)::ii) m  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand2 :: 16 bits) . 
     (aget_X (( 32 :: int)::ii) a  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand3 :: 32 bits) . 
     undefined_int ()  \<bind> (\<lambda> (result :: ii) . 
     (let (result :: ii) =
       (if sub_op then
         ((Word.uint operand3)) - ((((Word.uint operand1)) * ((Word.uint operand2))))
       else ((Word.uint operand3)) + ((((Word.uint operand1)) * ((Word.uint operand2))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) result (( 0 :: int)::ii)  ::  32 Word.word)))))))))
   else if ((((((l__193 = (( 16 :: int)::ii)))) \<and> (((l__194 = (( 64 :: int)::ii))))))) then
     assert_exp True (''destsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 16 :: int)::ii) n  :: ( 16 Word.word) M)) \<bind> (\<lambda> (operand1 :: 16 bits) . 
     (aget_X (( 16 :: int)::ii) m  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand2 :: 16 bits) . 
     (aget_X (( 64 :: int)::ii) a  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand3 :: 64 bits) . 
     undefined_int ()  \<bind> (\<lambda> (result :: ii) . 
     (let (result :: ii) =
       (if sub_op then
         ((Word.uint operand3)) - ((((Word.uint operand1)) * ((Word.uint operand2))))
       else ((Word.uint operand3)) + ((((Word.uint operand1)) * ((Word.uint operand2))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) result (( 0 :: int)::ii)  ::  64 Word.word)))))))))
   else if (((l__193 = (( 16 :: int)::ii)))) then assert_exp True (''destsize constraint'')
   else if ((((((l__193 = (( 32 :: int)::ii)))) \<and> (((l__194 = (( 32 :: int)::ii))))))) then
     assert_exp True (''destsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 32 :: int)::ii) n  :: ( 32 Word.word) M)) \<bind> (\<lambda> (operand1 :: 32 bits) . 
     (aget_X (( 32 :: int)::ii) m  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand2 :: 32 bits) . 
     (aget_X (( 32 :: int)::ii) a  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand3 :: 32 bits) . 
     undefined_int ()  \<bind> (\<lambda> (result :: ii) . 
     (let (result :: ii) =
       (if sub_op then
         ((Word.uint operand3)) - ((((Word.uint operand1)) * ((Word.uint operand2))))
       else ((Word.uint operand3)) + ((((Word.uint operand1)) * ((Word.uint operand2))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) result (( 0 :: int)::ii)  ::  32 Word.word)))))))))
   else if ((((((l__193 = (( 32 :: int)::ii)))) \<and> (((l__194 = (( 64 :: int)::ii))))))) then
     assert_exp True (''destsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 32 :: int)::ii) n  :: ( 32 Word.word) M)) \<bind> (\<lambda> (operand1 :: 32 bits) . 
     (aget_X (( 32 :: int)::ii) m  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand2 :: 32 bits) . 
     (aget_X (( 64 :: int)::ii) a  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand3 :: 64 bits) . 
     undefined_int ()  \<bind> (\<lambda> (result :: ii) . 
     (let (result :: ii) =
       (if sub_op then
         ((Word.uint operand3)) - ((((Word.uint operand1)) * ((Word.uint operand2))))
       else ((Word.uint operand3)) + ((((Word.uint operand1)) * ((Word.uint operand2))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) result (( 0 :: int)::ii)  ::  64 Word.word)))))))))
   else if (((l__193 = (( 32 :: int)::ii)))) then assert_exp True (''destsize constraint'')
   else if ((((((l__193 = (( 64 :: int)::ii)))) \<and> (((l__194 = (( 32 :: int)::ii))))))) then
     assert_exp True (''destsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (operand1 :: 64 bits) . 
     (aget_X (( 64 :: int)::ii) m  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand2 :: 64 bits) . 
     (aget_X (( 32 :: int)::ii) a  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand3 :: 32 bits) . 
     undefined_int ()  \<bind> (\<lambda> (result :: ii) . 
     (let (result :: ii) =
       (if sub_op then
         ((Word.uint operand3)) - ((((Word.uint operand1)) * ((Word.uint operand2))))
       else ((Word.uint operand3)) + ((((Word.uint operand1)) * ((Word.uint operand2))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) result (( 0 :: int)::ii)  ::  32 Word.word)))))))))
   else if ((((((l__193 = (( 64 :: int)::ii)))) \<and> (((l__194 = (( 64 :: int)::ii))))))) then
     assert_exp True (''destsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (operand1 :: 64 bits) . 
     (aget_X (( 64 :: int)::ii) m  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand2 :: 64 bits) . 
     (aget_X (( 64 :: int)::ii) a  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand3 :: 64 bits) . 
     undefined_int ()  \<bind> (\<lambda> (result :: ii) . 
     (let (result :: ii) =
       (if sub_op then
         ((Word.uint operand3)) - ((((Word.uint operand1)) * ((Word.uint operand2))))
       else ((Word.uint operand3)) + ((((Word.uint operand1)) * ((Word.uint operand2))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) result (( 0 :: int)::ii)  ::  64 Word.word)))))))))
   else if (((l__193 = (( 64 :: int)::ii)))) then assert_exp True (''destsize constraint'')
   else if ((((((l__193 = (( 128 :: int)::ii)))) \<and> (((l__194 = (( 32 :: int)::ii))))))) then
     assert_exp True (''destsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 128 :: int)::ii) n  :: ( 128 Word.word) M)) \<bind> (\<lambda> (operand1 :: 128 bits) . 
     (aget_X (( 128 :: int)::ii) m  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand2 :: 128 bits) . 
     (aget_X (( 32 :: int)::ii) a  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand3 :: 32 bits) . 
     undefined_int ()  \<bind> (\<lambda> (result :: ii) . 
     (let (result :: ii) =
       (if sub_op then
         ((Word.uint operand3)) - ((((Word.uint operand1)) * ((Word.uint operand2))))
       else ((Word.uint operand3)) + ((((Word.uint operand1)) * ((Word.uint operand2))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) result (( 0 :: int)::ii)  ::  32 Word.word)))))))))
   else if ((((((l__193 = (( 128 :: int)::ii)))) \<and> (((l__194 = (( 64 :: int)::ii))))))) then
     assert_exp True (''destsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 128 :: int)::ii) n  :: ( 128 Word.word) M)) \<bind> (\<lambda> (operand1 :: 128 bits) . 
     (aget_X (( 128 :: int)::ii) m  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand2 :: 128 bits) . 
     (aget_X (( 64 :: int)::ii) a  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand3 :: 64 bits) . 
     undefined_int ()  \<bind> (\<lambda> (result :: ii) . 
     (let (result :: ii) =
       (if sub_op then
         ((Word.uint operand3)) - ((((Word.uint operand1)) * ((Word.uint operand2))))
       else ((Word.uint operand3)) + ((((Word.uint operand1)) * ((Word.uint operand2))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) result (( 0 :: int)::ii)  ::  64 Word.word)))))))))
   else if (((l__193 = (( 128 :: int)::ii)))) then assert_exp True (''destsize constraint'')
   else if (((l__194 = (( 32 :: int)::ii)))) then
     assert_exp True (''destsize constraint'') \<then>
     ((let dbytes = (ex_int ((l__193 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))
   else if (((l__194 = (( 64 :: int)::ii)))) then
     assert_exp True (''destsize constraint'') \<then>
     ((let dbytes = (ex_int ((l__193 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))
   else assert_exp True (''destsize constraint''))"


(*val integer_arithmetic_mul_uniform_addsub_decode : mword ty1 -> mword ty2 -> mword ty3 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition integer_arithmetic_mul_uniform_addsub_decode  :: "(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_arithmetic_mul_uniform_addsub_decode sf op54 op31 Rm o0 Ra Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   (let (m :: ii) = (Word.uint Rm) in
   (let (a :: ii) = (Word.uint Ra) in
   (let (destsize :: int) =
     (if (((sf = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 64 :: int)::ii)
     else (( 32 :: int)::ii)) in
   (let (datasize :: ii) = destsize in
   (let (sub_op :: bool) = (o0 = (vec_of_bits [B1]  ::  1 Word.word)) in
   aarch64_integer_arithmetic_mul_uniform_addsub a d datasize destsize m n sub_op)))))))))"


(*val aarch64_integer_arithmetic_div : ii -> ii -> ii -> ii -> bool -> M unit*)

definition aarch64_integer_arithmetic_div  :: " int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_arithmetic_div d l__188 m n unsigned = (
   if (((l__188 = (( 8 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 8 :: int)::ii) n  :: ( 8 Word.word) M)) \<bind> (\<lambda> (operand1 :: 8 bits) . 
     (aget_X (( 8 :: int)::ii) m  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand2 :: 8 bits) . 
     undefined_int ()  \<bind> (\<lambda> (result :: ii) . 
     (let (result :: ii) =
       (if ((IsZero operand2)) then (( 0 :: int)::ii)
       else
         RoundTowardsZero
           (((((real_of_int ((asl_Int operand1 unsigned))))) div
               (((real_of_int ((asl_Int operand2 unsigned)))))))) in
     aset_X d ((GetSlice_int ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) result (( 0 :: int)::ii)  ::  8 Word.word)))))))
   else if (((l__188 = (( 16 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 16 :: int)::ii) n  :: ( 16 Word.word) M)) \<bind> (\<lambda> (operand1 :: 16 bits) . 
     (aget_X (( 16 :: int)::ii) m  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand2 :: 16 bits) . 
     undefined_int ()  \<bind> (\<lambda> (result :: ii) . 
     (let (result :: ii) =
       (if ((IsZero operand2)) then (( 0 :: int)::ii)
       else
         RoundTowardsZero
           (((((real_of_int ((asl_Int operand1 unsigned))))) div
               (((real_of_int ((asl_Int operand2 unsigned)))))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) result (( 0 :: int)::ii)  ::  16 Word.word)))))))
   else if (((l__188 = (( 32 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 32 :: int)::ii) n  :: ( 32 Word.word) M)) \<bind> (\<lambda> (operand1 :: 32 bits) . 
     (aget_X (( 32 :: int)::ii) m  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand2 :: 32 bits) . 
     undefined_int ()  \<bind> (\<lambda> (result :: ii) . 
     (let (result :: ii) =
       (if ((IsZero operand2)) then (( 0 :: int)::ii)
       else
         RoundTowardsZero
           (((((real_of_int ((asl_Int operand1 unsigned))))) div
               (((real_of_int ((asl_Int operand2 unsigned)))))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) result (( 0 :: int)::ii)  ::  32 Word.word)))))))
   else if (((l__188 = (( 64 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (operand1 :: 64 bits) . 
     (aget_X (( 64 :: int)::ii) m  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand2 :: 64 bits) . 
     undefined_int ()  \<bind> (\<lambda> (result :: ii) . 
     (let (result :: ii) =
       (if ((IsZero operand2)) then (( 0 :: int)::ii)
       else
         RoundTowardsZero
           (((((real_of_int ((asl_Int operand1 unsigned))))) div
               (((real_of_int ((asl_Int operand2 unsigned)))))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) result (( 0 :: int)::ii)  ::  64 Word.word)))))))
   else if (((l__188 = (( 128 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 128 :: int)::ii) n  :: ( 128 Word.word) M)) \<bind> (\<lambda> (operand1 :: 128 bits) . 
     (aget_X (( 128 :: int)::ii) m  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand2 :: 128 bits) . 
     undefined_int ()  \<bind> (\<lambda> (result :: ii) . 
     (let (result :: ii) =
       (if ((IsZero operand2)) then (( 0 :: int)::ii)
       else
         RoundTowardsZero
           (((((real_of_int ((asl_Int operand1 unsigned))))) div
               (((real_of_int ((asl_Int operand2 unsigned)))))))) in
     aset_X d
       ((GetSlice_int ((make_the_value (( 128 :: int)::ii)  ::  128 itself)) result (( 0 :: int)::ii)  ::  128 Word.word)))))))
   else
     (let dbytes = (ex_int ((l__188 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))"


(*val integer_arithmetic_div_decode : mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

definition integer_arithmetic_div_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_arithmetic_div_decode sf op1 S Rm opcode2 o1 Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   (let (m :: ii) = (Word.uint Rm) in
   (let (datasize :: int) =
     (if (((sf = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 64 :: int)::ii)
     else (( 32 :: int)::ii)) in
   (let (unsigned :: bool) = (o1 = (vec_of_bits [B0]  ::  1 Word.word)) in
   aarch64_integer_arithmetic_div d datasize m n unsigned)))))))"


(*val aarch64_integer_arithmetic_cnt : ii -> ii -> ii -> CountOp -> M unit*)

definition aarch64_integer_arithmetic_cnt  :: " int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> CountOp \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_arithmetic_cnt d l__183 n opcode = (
   if (((l__183 = (( 8 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     undefined_int () ) \<bind> (\<lambda> (result :: ii) . 
     (aget_X (( 8 :: int)::ii) n  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand1 :: 8 bits) . 
     (if (((opcode = CountOp_CLZ))) then CountLeadingZeroBits operand1
      else CountLeadingSignBits operand1) \<bind> (\<lambda> (result :: ii) . 
     aset_X d ((GetSlice_int ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) result (( 0 :: int)::ii)  ::  8 Word.word))))))
   else if (((l__183 = (( 16 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     undefined_int () ) \<bind> (\<lambda> (result :: ii) . 
     (aget_X (( 16 :: int)::ii) n  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand1 :: 16 bits) . 
     (if (((opcode = CountOp_CLZ))) then CountLeadingZeroBits operand1
      else CountLeadingSignBits operand1) \<bind> (\<lambda> (result :: ii) . 
     aset_X d
       ((GetSlice_int ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) result (( 0 :: int)::ii)  ::  16 Word.word))))))
   else if (((l__183 = (( 32 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     undefined_int () ) \<bind> (\<lambda> (result :: ii) . 
     (aget_X (( 32 :: int)::ii) n  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand1 :: 32 bits) . 
     (if (((opcode = CountOp_CLZ))) then CountLeadingZeroBits operand1
      else CountLeadingSignBits operand1) \<bind> (\<lambda> (result :: ii) . 
     aset_X d
       ((GetSlice_int ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) result (( 0 :: int)::ii)  ::  32 Word.word))))))
   else if (((l__183 = (( 64 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     undefined_int () ) \<bind> (\<lambda> (result :: ii) . 
     (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand1 :: 64 bits) . 
     (if (((opcode = CountOp_CLZ))) then CountLeadingZeroBits operand1
      else CountLeadingSignBits operand1) \<bind> (\<lambda> (result :: ii) . 
     aset_X d
       ((GetSlice_int ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) result (( 0 :: int)::ii)  ::  64 Word.word))))))
   else if (((l__183 = (( 128 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     undefined_int () ) \<bind> (\<lambda> (result :: ii) . 
     (aget_X (( 128 :: int)::ii) n  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand1 :: 128 bits) . 
     (if (((opcode = CountOp_CLZ))) then CountLeadingZeroBits operand1
      else CountLeadingSignBits operand1) \<bind> (\<lambda> (result :: ii) . 
     aset_X d
       ((GetSlice_int ((make_the_value (( 128 :: int)::ii)  ::  128 itself)) result (( 0 :: int)::ii)  ::  128 Word.word))))))
   else
     (let dbytes = (ex_int ((l__183 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))"


(*val integer_arithmetic_cnt_decode : mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

definition integer_arithmetic_cnt_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_arithmetic_cnt_decode sf S opcode2 op1 Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   (let (datasize :: int) =
     (if (((sf = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 64 :: int)::ii)
     else (( 32 :: int)::ii)) in
   (let (opcode :: CountOp) =
     (if (((op1 = (vec_of_bits [B0]  ::  1 Word.word)))) then CountOp_CLZ
     else CountOp_CLS) in
   aarch64_integer_arithmetic_cnt d datasize n opcode))))))"


(*val aarch64_integer_arithmetic_addsub_carry : ii -> ii -> ii -> ii -> bool -> bool -> M unit*)

definition aarch64_integer_arithmetic_addsub_carry  :: " int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_arithmetic_addsub_carry d l__178 m n setflags sub_op = (
   if (((l__178 = (( 8 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M)) \<bind> (\<lambda> (result :: 8 bits) . 
     (aget_X (( 8 :: int)::ii) n  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand1 :: 8 bits) . 
     (aget_X (( 8 :: int)::ii) m  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand2 :: 8 bits) . 
     (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (nzcv :: 4 bits) . 
     (let (operand2 :: 8 bits) = (if sub_op then (not_vec operand2  ::  8 Word.word) else operand2) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) . 
     (let (tup__0, tup__1) =
       ((AddWithCarry operand1 operand2(ProcState_C   w__0)  :: ( 8 Word.word *  4 Word.word))) in
     (let result = tup__0 in
     (let nzcv = tup__1 in
     (if setflags then
        (let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        read_reg PSTATE_ref \<bind> (\<lambda> (w__1 :: ProcState) . 
        (write_reg PSTATE_ref (w__1 (| ProcState_N := tup__0 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__2 :: ProcState) . 
        (write_reg PSTATE_ref (w__2 (| ProcState_Z := tup__1 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__3 :: ProcState) . 
        (write_reg PSTATE_ref (w__3 (| ProcState_C := tup__2 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__4 :: ProcState) . 
        write_reg PSTATE_ref (w__4 (| ProcState_V := tup__3 |)))))))
      else return () ) \<then>
     aset_X d result))))))))))
   else if (((l__178 = (( 16 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M)) \<bind> (\<lambda> (result :: 16 bits) . 
     (aget_X (( 16 :: int)::ii) n  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand1 :: 16 bits) . 
     (aget_X (( 16 :: int)::ii) m  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand2 :: 16 bits) . 
     (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (nzcv :: 4 bits) . 
     (let (operand2 :: 16 bits) = (if sub_op then (not_vec operand2  ::  16 Word.word) else operand2) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__5 :: ProcState) . 
     (let (tup__0, tup__1) =
       ((AddWithCarry operand1 operand2(ProcState_C   w__5)  :: ( 16 Word.word *  4 Word.word))) in
     (let result = tup__0 in
     (let nzcv = tup__1 in
     (if setflags then
        (let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        read_reg PSTATE_ref \<bind> (\<lambda> (w__6 :: ProcState) . 
        (write_reg PSTATE_ref (w__6 (| ProcState_N := tup__0 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__7 :: ProcState) . 
        (write_reg PSTATE_ref (w__7 (| ProcState_Z := tup__1 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__8 :: ProcState) . 
        (write_reg PSTATE_ref (w__8 (| ProcState_C := tup__2 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__9 :: ProcState) . 
        write_reg PSTATE_ref (w__9 (| ProcState_V := tup__3 |)))))))
      else return () ) \<then>
     aset_X d result))))))))))
   else if (((l__178 = (( 32 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (result :: 32 bits) . 
     (aget_X (( 32 :: int)::ii) n  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand1 :: 32 bits) . 
     (aget_X (( 32 :: int)::ii) m  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand2 :: 32 bits) . 
     (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (nzcv :: 4 bits) . 
     (let (operand2 :: 32 bits) = (if sub_op then (not_vec operand2  ::  32 Word.word) else operand2) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__10 :: ProcState) . 
     (let (tup__0, tup__1) =
       ((AddWithCarry operand1 operand2(ProcState_C   w__10)  :: ( 32 Word.word *  4 Word.word))) in
     (let result = tup__0 in
     (let nzcv = tup__1 in
     (if setflags then
        (let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        read_reg PSTATE_ref \<bind> (\<lambda> (w__11 :: ProcState) . 
        (write_reg PSTATE_ref (w__11 (| ProcState_N := tup__0 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__12 :: ProcState) . 
        (write_reg PSTATE_ref (w__12 (| ProcState_Z := tup__1 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__13 :: ProcState) . 
        (write_reg PSTATE_ref (w__13 (| ProcState_C := tup__2 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__14 :: ProcState) . 
        write_reg PSTATE_ref (w__14 (| ProcState_V := tup__3 |)))))))
      else return () ) \<then>
     aset_X d result))))))))))
   else if (((l__178 = (( 64 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (result :: 64 bits) . 
     (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand1 :: 64 bits) . 
     (aget_X (( 64 :: int)::ii) m  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand2 :: 64 bits) . 
     (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (nzcv :: 4 bits) . 
     (let (operand2 :: 64 bits) = (if sub_op then (not_vec operand2  ::  64 Word.word) else operand2) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__15 :: ProcState) . 
     (let (tup__0, tup__1) =
       ((AddWithCarry operand1 operand2(ProcState_C   w__15)  :: ( 64 Word.word *  4 Word.word))) in
     (let result = tup__0 in
     (let nzcv = tup__1 in
     (if setflags then
        (let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        read_reg PSTATE_ref \<bind> (\<lambda> (w__16 :: ProcState) . 
        (write_reg PSTATE_ref (w__16 (| ProcState_N := tup__0 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__17 :: ProcState) . 
        (write_reg PSTATE_ref (w__17 (| ProcState_Z := tup__1 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__18 :: ProcState) . 
        (write_reg PSTATE_ref (w__18 (| ProcState_C := tup__2 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__19 :: ProcState) . 
        write_reg PSTATE_ref (w__19 (| ProcState_V := tup__3 |)))))))
      else return () ) \<then>
     aset_X d result))))))))))
   else if (((l__178 = (( 128 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M)) \<bind> (\<lambda> (result :: 128 bits) . 
     (aget_X (( 128 :: int)::ii) n  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand1 :: 128 bits) . 
     (aget_X (( 128 :: int)::ii) m  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand2 :: 128 bits) . 
     (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (nzcv :: 4 bits) . 
     (let (operand2 :: 128 bits) = (if sub_op then (not_vec operand2  ::  128 Word.word) else operand2) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__20 :: ProcState) . 
     (let (tup__0, tup__1) =
       ((AddWithCarry operand1 operand2(ProcState_C   w__20)  :: ( 128 Word.word *  4 Word.word))) in
     (let result = tup__0 in
     (let nzcv = tup__1 in
     (if setflags then
        (let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        read_reg PSTATE_ref \<bind> (\<lambda> (w__21 :: ProcState) . 
        (write_reg PSTATE_ref (w__21 (| ProcState_N := tup__0 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__22 :: ProcState) . 
        (write_reg PSTATE_ref (w__22 (| ProcState_Z := tup__1 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__23 :: ProcState) . 
        (write_reg PSTATE_ref (w__23 (| ProcState_C := tup__2 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__24 :: ProcState) . 
        write_reg PSTATE_ref (w__24 (| ProcState_V := tup__3 |)))))))
      else return () ) \<then>
     aset_X d result))))))))))
   else
     (let dbytes = (ex_int ((l__178 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))"


(*val integer_arithmetic_addsub_carry_decode : mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty6 -> mword ty5 -> mword ty5 -> M unit*)

definition integer_arithmetic_addsub_carry_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_arithmetic_addsub_carry_decode sf op1 S Rm opcode2 Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   (let (m :: ii) = (Word.uint Rm) in
   (let (datasize :: int) =
     (if (((sf = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 64 :: int)::ii)
     else (( 32 :: int)::ii)) in
   (let (sub_op :: bool) = (op1 = (vec_of_bits [B1]  ::  1 Word.word)) in
   (let (setflags :: bool) = (S = (vec_of_bits [B1]  ::  1 Word.word)) in
   aarch64_integer_arithmetic_addsub_carry d datasize m n setflags sub_op))))))))"


(*val ExtendReg : forall 'N . Size 'N => integer -> ii -> ExtendType -> ii -> M (mword 'N)*)

definition ExtendReg  :: " int \<Rightarrow> int \<Rightarrow> ExtendType \<Rightarrow> int \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " ExtendReg (N__tv :: int) reg typ1 shift = (
   (assert_exp (((((shift \<ge> (( 0 :: int)::ii))) \<and> ((shift \<le> (( 4 :: int)::ii)))))) (''((shift >= 0) && (shift <= 4))'') \<then>
   (aget_X N__tv reg  :: (( 'N::len)Word.word) M)) \<bind> (\<lambda> val_name . 
   undefined_bool ()  \<bind> (\<lambda> (unsigned :: bool) . 
   undefined_int ()  \<bind> (\<lambda> (len :: ii) . 
   (let (len :: ii) =
     ((case  typ1 of
       ExtendType_SXTB =>
        (let (unsigned :: bool) = False in
        (( 8 :: int)::ii))
     | ExtendType_SXTH =>
        (let (unsigned :: bool) = False in
        (( 16 :: int)::ii))
     | ExtendType_SXTW =>
        (let (unsigned :: bool) = False in
        (( 32 :: int)::ii))
     | ExtendType_SXTX =>
        (let (unsigned :: bool) = False in
        (( 64 :: int)::ii))
     | ExtendType_UXTB =>
        (let (unsigned :: bool) = True in
        (( 8 :: int)::ii))
     | ExtendType_UXTH =>
        (let (unsigned :: bool) = True in
        (( 16 :: int)::ii))
     | ExtendType_UXTW =>
        (let (unsigned :: bool) = True in
        (( 32 :: int)::ii))
     | ExtendType_UXTX =>
        (let (unsigned :: bool) = True in
        (( 64 :: int)::ii))
     )) in
   (let len = (min len ((((int (size val_name))) - shift))) in
   coerce_int_nat shift \<bind> (\<lambda> shift2 . 
   (let (len2 :: int) = (ex_int len) in
   assert_exp True (''hack'') \<then>
   return ((place_subrange ((int (size val_name))) val_name ((len2 - (( 1 :: int)::ii))) (( 0 :: int)::ii)
              ((ex_nat shift2))
             :: ( 'N::len)Word.word))))))))))"


(*val aget_ELR__0 : mword ty2 -> M (mword ty64)*)

(*val aget_ELR__1 : unit -> M (mword ty64)*)

definition aget_ELR__0  :: "(2)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " aget_ELR__0 el = (
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (r :: 64 bits) . 
   (let pat0 = el in
   if (((pat0 = EL1))) then (read_reg ELR_EL1_ref  :: ( 64 Word.word) M)
   else if (((pat0 = EL2))) then (read_reg ELR_EL2_ref  :: ( 64 Word.word) M)
   else if (((pat0 = EL3))) then (read_reg ELR_EL3_ref  :: ( 64 Word.word) M)
   else Unreachable ()  \<then> return r)))"


definition aget_ELR__1  :: " unit \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " aget_ELR__1 _ = (
   read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) . 
   (assert_exp ((((ProcState_EL   w__0) \<noteq> EL0))) ('''') \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__1 :: ProcState) . 
   (aget_ELR__0(ProcState_EL   w__1)  :: ( 64 Word.word) M))))"


(*val ROR_C : forall 'N . Size 'N => mword 'N -> ii -> M (mword 'N * mword ty1)*)

definition ROR_C  :: "('N::len)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(('N::len)Word.word*(1)Word.word),(exception))monad "  where 
     " ROR_C x shift = (
   assert_exp (((shift \<noteq> (( 0 :: int)::ii)))) (''(shift != 0)'') \<then>
   ((let (m :: ii) = (shift mod ((int (size x)))) in
   (LSR x m  :: (( 'N::len)Word.word) M) \<bind> (\<lambda> (w__0 :: ( 'N::len)Word.word) . 
   (LSL x ((((int (size x))) - ((ex_int m))))  :: (( 'N::len)Word.word) M) \<bind> (\<lambda> (w__1 :: ( 'N::len)Word.word) . 
   (let result = ((or_vec w__0 w__1  :: ( 'N::len)Word.word)) in
   (let (carry_out :: 1 bits) =
     ((vec_of_bits [access_vec_dec result ((((int (size result))) - (( 1 :: int)::ii)))]  ::  1 Word.word)) in
   return (result, carry_out))))))))"


(*val ROR : forall 'N . Size 'N => mword 'N -> ii -> M (mword 'N)*)

definition ROR  :: "('N::len)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " ROR x shift = (
   (assert_exp ((shift \<ge> (( 0 :: int)::ii))) (''(shift >= 0)'') \<then>
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> (\<lambda> (anon10 :: 1 bits) . 
   (undefined_bitvector ((int (size x)))  :: (( 'N::len)Word.word) M) \<bind> (\<lambda> result . 
   if (((shift = (( 0 :: int)::ii)))) then return x
   else
     (ROR_C x shift ) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1) = varstup in
     (let result = tup__0 in
     (let (anon10 :: 1 bits) = tup__1 in
     return result)))))))"


(*val aarch64_integer_bitfield : forall 'datasize. Size 'datasize => ii -> ii -> ii -> itself 'datasize -> bool -> bool -> ii -> mword 'datasize -> mword 'datasize -> M unit*)

definition aarch64_integer_bitfield  :: " int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('datasize::len)itself \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>('datasize::len)Word.word \<Rightarrow>('datasize::len)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_bitfield R1 S d datasize extend1 inzero n tmask wmask = (
   (let datasize = (size_itself_int datasize) in
   (let dbytes = (ex_int ((datasize div (( 8 :: int)::ii)))) in
   ((assert_exp True (''datasize constraint'') \<then>
   assert_exp True (''dbytes constraint'')) \<then>
   (if inzero then return ((Zeros__1 datasize ()   :: ( 'datasize::len)Word.word))
    else (aget_X datasize d  :: (( 'datasize::len)Word.word) M))) \<bind> (\<lambda> dst . 
   (aget_X datasize n  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> src . 
   (ROR src R1  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> (w__1 :: ( 'datasize::len)Word.word) . 
   (let bot =
     ((or_vec ((and_vec dst ((not_vec wmask  :: ( 'datasize::len)Word.word))  :: ( 'datasize::len)Word.word))
        ((and_vec w__1 wmask  :: ( 'datasize::len)Word.word))
       :: ( 'datasize::len)Word.word)) in
   (if extend1 then
      (Replicate ((int (size bot))) (vec_of_bits [access_vec_dec src S]  ::  1 Word.word)
        :: (( 'datasize::len)Word.word) M)
    else return dst) \<bind> (\<lambda> top1 . 
   aset_X d
     ((or_vec ((and_vec top1 ((not_vec tmask  :: ( 'datasize::len)Word.word))  :: ( 'datasize::len)Word.word))
         ((and_vec bot tmask  :: ( 'datasize::len)Word.word))
        :: ( 'datasize::len)Word.word))))))))))"


(*val ShiftReg : forall 'N . Size 'N => integer -> ii -> ShiftType -> ii -> M (mword 'N)*)

definition ShiftReg  :: " int \<Rightarrow> int \<Rightarrow> ShiftType \<Rightarrow> int \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " ShiftReg (N__tv :: int) reg typ1 amount = (
   (aget_X N__tv reg  :: (( 'N::len)Word.word) M) \<bind> (\<lambda> result . 
   (case  typ1 of
     ShiftType_LSL => (LSL result amount  :: (( 'N::len)Word.word) M)
   | ShiftType_LSR => (LSR result amount  :: (( 'N::len)Word.word) M)
   | ShiftType_ASR => (ASR result amount  :: (( 'N::len)Word.word) M)
   | ShiftType_ROR => (ROR result amount  :: (( 'N::len)Word.word) M)
   )))"


(*val aarch64_integer_shift_variable : ii -> ii -> ii -> ii -> ShiftType -> M unit*)

definition aarch64_integer_shift_variable  :: " int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> ShiftType \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_shift_variable d l__173 m n shift_type = (
   if (((l__173 = (( 8 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M)) \<bind> (\<lambda> (result :: 8 bits) . 
     (aget_X (( 8 :: int)::ii) m  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand2 :: 8 bits) . 
     (ShiftReg (( 8 :: int)::ii) n shift_type ((((Word.uint operand2)) mod (( 8 :: int)::ii)))  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__0 ::
        8 Word.word) . 
     (let result = w__0 in
     aset_X d result)))))
   else if (((l__173 = (( 16 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M)) \<bind> (\<lambda> (result :: 16 bits) . 
     (aget_X (( 16 :: int)::ii) m  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand2 :: 16 bits) . 
     (ShiftReg (( 16 :: int)::ii) n shift_type ((((Word.uint operand2)) mod (( 16 :: int)::ii)))  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__1 ::
        16 Word.word) . 
     (let result = w__1 in
     aset_X d result)))))
   else if (((l__173 = (( 32 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (result :: 32 bits) . 
     (aget_X (( 32 :: int)::ii) m  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand2 :: 32 bits) . 
     (ShiftReg (( 32 :: int)::ii) n shift_type ((((Word.uint operand2)) mod (( 32 :: int)::ii)))  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__2 ::
        32 Word.word) . 
     (let result = w__2 in
     aset_X d result)))))
   else if (((l__173 = (( 64 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (result :: 64 bits) . 
     (aget_X (( 64 :: int)::ii) m  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand2 :: 64 bits) . 
     (ShiftReg (( 64 :: int)::ii) n shift_type ((((Word.uint operand2)) mod (( 64 :: int)::ii)))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::
        64 Word.word) . 
     (let result = w__3 in
     aset_X d result)))))
   else if (((l__173 = (( 128 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M)) \<bind> (\<lambda> (result :: 128 bits) . 
     (aget_X (( 128 :: int)::ii) m  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand2 :: 128 bits) . 
     (ShiftReg (( 128 :: int)::ii) n shift_type ((((Word.uint operand2)) mod (( 128 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__4 ::
        128 Word.word) . 
     (let result = w__4 in
     aset_X d result)))))
   else
     (let dbytes = (ex_int ((l__173 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))"


(*val integer_shift_variable_decode : mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty4 -> mword ty2 -> mword ty5 -> mword ty5 -> M unit*)

definition integer_shift_variable_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_shift_variable_decode sf op1 S Rm opcode2 op2 Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   (let (m :: ii) = (Word.uint Rm) in
   (let (datasize :: int) =
     (if (((sf = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 64 :: int)::ii)
     else (( 32 :: int)::ii)) in
   (let (shift_type :: ShiftType) = (DecodeShift op2) in
   aarch64_integer_shift_variable d datasize m n shift_type)))))))"


(*val aarch64_integer_logical_shiftedreg : ii -> ii -> bool -> ii -> ii -> LogicalOp -> bool -> ii -> ShiftType -> M unit*)

definition aarch64_integer_logical_shiftedreg  :: " int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> LogicalOp \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> ShiftType \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_logical_shiftedreg d l__168 invert m n op1 setflags shift_amount shift_type = (
   if (((l__168 = (( 8 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 8 :: int)::ii) n  :: ( 8 Word.word) M)) \<bind> (\<lambda> (operand1 :: 8 bits) . 
     (ShiftReg (( 8 :: int)::ii) m shift_type shift_amount  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand2 :: 8 bits) . 
     (let (operand2 :: 8 bits) = (if invert then (not_vec operand2  ::  8 Word.word) else operand2) in
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> (\<lambda> (result :: 8 bits) . 
     (let (result :: 8 bits) =
       ((case  op1 of
         LogicalOp_AND => (and_vec operand1 operand2  ::  8 Word.word)
       | LogicalOp_ORR => (or_vec operand1 operand2  ::  8 Word.word)
       | LogicalOp_EOR => (xor_vec operand1 operand2  ::  8 Word.word)
       )) in
     (if setflags then
        (let split_vec =
          ((concat_vec
             ((concat_vec
                 (vec_of_bits [access_vec_dec result (((( 8 :: int)::ii) - (( 1 :: int)::ii)))]  ::  1 Word.word)
                 ((IsZeroBit result  ::  1 Word.word))
                ::  2 Word.word)) (vec_of_bits [B0,B0]  ::  2 Word.word)
            ::  4 Word.word)) in
        (let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec split_vec (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec split_vec (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec split_vec (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec split_vec (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) . 
        (write_reg PSTATE_ref (w__0 (| ProcState_N := tup__0 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__1 :: ProcState) . 
        (write_reg PSTATE_ref (w__1 (| ProcState_Z := tup__1 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__2 :: ProcState) . 
        (write_reg PSTATE_ref (w__2 (| ProcState_C := tup__2 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__3 :: ProcState) . 
        write_reg PSTATE_ref (w__3 (| ProcState_V := tup__3 |))))))))
      else return () ) \<then>
     aset_X d result))))))
   else if (((l__168 = (( 16 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 16 :: int)::ii) n  :: ( 16 Word.word) M)) \<bind> (\<lambda> (operand1 :: 16 bits) . 
     (ShiftReg (( 16 :: int)::ii) m shift_type shift_amount  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand2 :: 16 bits) . 
     (let (operand2 :: 16 bits) = (if invert then (not_vec operand2  ::  16 Word.word) else operand2) in
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (result :: 16 bits) . 
     (let (result :: 16 bits) =
       ((case  op1 of
         LogicalOp_AND => (and_vec operand1 operand2  ::  16 Word.word)
       | LogicalOp_ORR => (or_vec operand1 operand2  ::  16 Word.word)
       | LogicalOp_EOR => (xor_vec operand1 operand2  ::  16 Word.word)
       )) in
     (if setflags then
        (let split_vec =
          ((concat_vec
             ((concat_vec
                 (vec_of_bits [access_vec_dec result (((( 16 :: int)::ii) - (( 1 :: int)::ii)))]  ::  1 Word.word)
                 ((IsZeroBit result  ::  1 Word.word))
                ::  2 Word.word)) (vec_of_bits [B0,B0]  ::  2 Word.word)
            ::  4 Word.word)) in
        (let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec split_vec (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec split_vec (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec split_vec (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec split_vec (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        read_reg PSTATE_ref \<bind> (\<lambda> (w__4 :: ProcState) . 
        (write_reg PSTATE_ref (w__4 (| ProcState_N := tup__0 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__5 :: ProcState) . 
        (write_reg PSTATE_ref (w__5 (| ProcState_Z := tup__1 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__6 :: ProcState) . 
        (write_reg PSTATE_ref (w__6 (| ProcState_C := tup__2 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__7 :: ProcState) . 
        write_reg PSTATE_ref (w__7 (| ProcState_V := tup__3 |))))))))
      else return () ) \<then>
     aset_X d result))))))
   else if (((l__168 = (( 32 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 32 :: int)::ii) n  :: ( 32 Word.word) M)) \<bind> (\<lambda> (operand1 :: 32 bits) . 
     (ShiftReg (( 32 :: int)::ii) m shift_type shift_amount  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand2 :: 32 bits) . 
     (let (operand2 :: 32 bits) = (if invert then (not_vec operand2  ::  32 Word.word) else operand2) in
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (result :: 32 bits) . 
     (let (result :: 32 bits) =
       ((case  op1 of
         LogicalOp_AND => (and_vec operand1 operand2  ::  32 Word.word)
       | LogicalOp_ORR => (or_vec operand1 operand2  ::  32 Word.word)
       | LogicalOp_EOR => (xor_vec operand1 operand2  ::  32 Word.word)
       )) in
     (if setflags then
        (let split_vec =
          ((concat_vec
             ((concat_vec
                 (vec_of_bits [access_vec_dec result (((( 32 :: int)::ii) - (( 1 :: int)::ii)))]  ::  1 Word.word)
                 ((IsZeroBit result  ::  1 Word.word))
                ::  2 Word.word)) (vec_of_bits [B0,B0]  ::  2 Word.word)
            ::  4 Word.word)) in
        (let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec split_vec (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec split_vec (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec split_vec (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec split_vec (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        read_reg PSTATE_ref \<bind> (\<lambda> (w__8 :: ProcState) . 
        (write_reg PSTATE_ref (w__8 (| ProcState_N := tup__0 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__9 :: ProcState) . 
        (write_reg PSTATE_ref (w__9 (| ProcState_Z := tup__1 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__10 :: ProcState) . 
        (write_reg PSTATE_ref (w__10 (| ProcState_C := tup__2 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__11 :: ProcState) . 
        write_reg PSTATE_ref (w__11 (| ProcState_V := tup__3 |))))))))
      else return () ) \<then>
     aset_X d result))))))
   else if (((l__168 = (( 64 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (operand1 :: 64 bits) . 
     (ShiftReg (( 64 :: int)::ii) m shift_type shift_amount  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand2 :: 64 bits) . 
     (let (operand2 :: 64 bits) = (if invert then (not_vec operand2  ::  64 Word.word) else operand2) in
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (result :: 64 bits) . 
     (let (result :: 64 bits) =
       ((case  op1 of
         LogicalOp_AND => (and_vec operand1 operand2  ::  64 Word.word)
       | LogicalOp_ORR => (or_vec operand1 operand2  ::  64 Word.word)
       | LogicalOp_EOR => (xor_vec operand1 operand2  ::  64 Word.word)
       )) in
     (if setflags then
        (let split_vec =
          ((concat_vec
             ((concat_vec
                 (vec_of_bits [access_vec_dec result (((( 64 :: int)::ii) - (( 1 :: int)::ii)))]  ::  1 Word.word)
                 ((IsZeroBit result  ::  1 Word.word))
                ::  2 Word.word)) (vec_of_bits [B0,B0]  ::  2 Word.word)
            ::  4 Word.word)) in
        (let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec split_vec (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec split_vec (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec split_vec (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec split_vec (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        read_reg PSTATE_ref \<bind> (\<lambda> (w__12 :: ProcState) . 
        (write_reg PSTATE_ref (w__12 (| ProcState_N := tup__0 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__13 :: ProcState) . 
        (write_reg PSTATE_ref (w__13 (| ProcState_Z := tup__1 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__14 :: ProcState) . 
        (write_reg PSTATE_ref (w__14 (| ProcState_C := tup__2 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__15 :: ProcState) . 
        write_reg PSTATE_ref (w__15 (| ProcState_V := tup__3 |))))))))
      else return () ) \<then>
     aset_X d result))))))
   else if (((l__168 = (( 128 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 128 :: int)::ii) n  :: ( 128 Word.word) M)) \<bind> (\<lambda> (operand1 :: 128 bits) . 
     (ShiftReg (( 128 :: int)::ii) m shift_type shift_amount  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand2 :: 128 bits) . 
     (let (operand2 :: 128 bits) = (if invert then (not_vec operand2  ::  128 Word.word) else operand2) in
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> (\<lambda> (result :: 128 bits) . 
     (let (result :: 128 bits) =
       ((case  op1 of
         LogicalOp_AND => (and_vec operand1 operand2  ::  128 Word.word)
       | LogicalOp_ORR => (or_vec operand1 operand2  ::  128 Word.word)
       | LogicalOp_EOR => (xor_vec operand1 operand2  ::  128 Word.word)
       )) in
     (if setflags then
        (let split_vec =
          ((concat_vec
             ((concat_vec
                 (vec_of_bits [access_vec_dec result (((( 128 :: int)::ii) - (( 1 :: int)::ii)))]  ::  1 Word.word)
                 ((IsZeroBit result  ::  1 Word.word))
                ::  2 Word.word)) (vec_of_bits [B0,B0]  ::  2 Word.word)
            ::  4 Word.word)) in
        (let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec split_vec (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec split_vec (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec split_vec (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec split_vec (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        read_reg PSTATE_ref \<bind> (\<lambda> (w__16 :: ProcState) . 
        (write_reg PSTATE_ref (w__16 (| ProcState_N := tup__0 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__17 :: ProcState) . 
        (write_reg PSTATE_ref (w__17 (| ProcState_Z := tup__1 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__18 :: ProcState) . 
        (write_reg PSTATE_ref (w__18 (| ProcState_C := tup__2 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__19 :: ProcState) . 
        write_reg PSTATE_ref (w__19 (| ProcState_V := tup__3 |))))))))
      else return () ) \<then>
     aset_X d result))))))
   else
     (let dbytes = (ex_int ((l__168 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))"


(*val aarch64_integer_arithmetic_addsub_shiftedreg : ii -> ii -> ii -> ii -> bool -> ii -> ShiftType -> bool -> M unit*)

definition aarch64_integer_arithmetic_addsub_shiftedreg  :: " int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> ShiftType \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_arithmetic_addsub_shiftedreg d l__163 m n setflags shift_amount shift_type sub_op = (
   if (((l__163 = (( 8 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M)) \<bind> (\<lambda> (result :: 8 bits) . 
     (aget_X (( 8 :: int)::ii) n  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand1 :: 8 bits) . 
     (ShiftReg (( 8 :: int)::ii) m shift_type shift_amount  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand2 :: 8 bits) . 
     (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (nzcv :: 4 bits) . 
     (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (carry_in :: 1 bits) . 
     (let ((carry_in :: 1 bits), (operand2 :: 8 bits)) =
       (if sub_op then
         (let (operand2 :: 8 bits) = ((not_vec operand2  ::  8 Word.word)) in
         (let (carry_in :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
         (carry_in, operand2)))
       else
         (let (carry_in :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
         (carry_in, operand2))) in
     (let (tup__0, tup__1) = ((AddWithCarry operand1 operand2 carry_in  :: ( 8 Word.word *  4 Word.word))) in
     (let result = tup__0 in
     (let nzcv = tup__1 in
     (if setflags then
        (let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) . 
        (write_reg PSTATE_ref (w__0 (| ProcState_N := tup__0 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__1 :: ProcState) . 
        (write_reg PSTATE_ref (w__1 (| ProcState_Z := tup__1 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__2 :: ProcState) . 
        (write_reg PSTATE_ref (w__2 (| ProcState_C := tup__2 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__3 :: ProcState) . 
        write_reg PSTATE_ref (w__3 (| ProcState_V := tup__3 |)))))))
      else return () ) \<then>
     aset_X d result))))))))))
   else if (((l__163 = (( 16 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M)) \<bind> (\<lambda> (result :: 16 bits) . 
     (aget_X (( 16 :: int)::ii) n  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand1 :: 16 bits) . 
     (ShiftReg (( 16 :: int)::ii) m shift_type shift_amount  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand2 :: 16 bits) . 
     (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (nzcv :: 4 bits) . 
     (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (carry_in :: 1 bits) . 
     (let ((carry_in :: 1 bits), (operand2 :: 16 bits)) =
       (if sub_op then
         (let (operand2 :: 16 bits) = ((not_vec operand2  ::  16 Word.word)) in
         (let (carry_in :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
         (carry_in, operand2)))
       else
         (let (carry_in :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
         (carry_in, operand2))) in
     (let (tup__0, tup__1) = ((AddWithCarry operand1 operand2 carry_in  :: ( 16 Word.word *  4 Word.word))) in
     (let result = tup__0 in
     (let nzcv = tup__1 in
     (if setflags then
        (let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        read_reg PSTATE_ref \<bind> (\<lambda> (w__4 :: ProcState) . 
        (write_reg PSTATE_ref (w__4 (| ProcState_N := tup__0 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__5 :: ProcState) . 
        (write_reg PSTATE_ref (w__5 (| ProcState_Z := tup__1 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__6 :: ProcState) . 
        (write_reg PSTATE_ref (w__6 (| ProcState_C := tup__2 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__7 :: ProcState) . 
        write_reg PSTATE_ref (w__7 (| ProcState_V := tup__3 |)))))))
      else return () ) \<then>
     aset_X d result))))))))))
   else if (((l__163 = (( 32 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (result :: 32 bits) . 
     (aget_X (( 32 :: int)::ii) n  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand1 :: 32 bits) . 
     (ShiftReg (( 32 :: int)::ii) m shift_type shift_amount  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand2 :: 32 bits) . 
     (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (nzcv :: 4 bits) . 
     (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (carry_in :: 1 bits) . 
     (let ((carry_in :: 1 bits), (operand2 :: 32 bits)) =
       (if sub_op then
         (let (operand2 :: 32 bits) = ((not_vec operand2  ::  32 Word.word)) in
         (let (carry_in :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
         (carry_in, operand2)))
       else
         (let (carry_in :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
         (carry_in, operand2))) in
     (let (tup__0, tup__1) = ((AddWithCarry operand1 operand2 carry_in  :: ( 32 Word.word *  4 Word.word))) in
     (let result = tup__0 in
     (let nzcv = tup__1 in
     (if setflags then
        (let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        read_reg PSTATE_ref \<bind> (\<lambda> (w__8 :: ProcState) . 
        (write_reg PSTATE_ref (w__8 (| ProcState_N := tup__0 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__9 :: ProcState) . 
        (write_reg PSTATE_ref (w__9 (| ProcState_Z := tup__1 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__10 :: ProcState) . 
        (write_reg PSTATE_ref (w__10 (| ProcState_C := tup__2 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__11 :: ProcState) . 
        write_reg PSTATE_ref (w__11 (| ProcState_V := tup__3 |)))))))
      else return () ) \<then>
     aset_X d result))))))))))
   else if (((l__163 = (( 64 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (result :: 64 bits) . 
     (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand1 :: 64 bits) . 
     (ShiftReg (( 64 :: int)::ii) m shift_type shift_amount  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand2 :: 64 bits) . 
     (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (nzcv :: 4 bits) . 
     (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (carry_in :: 1 bits) . 
     (let ((carry_in :: 1 bits), (operand2 :: 64 bits)) =
       (if sub_op then
         (let (operand2 :: 64 bits) = ((not_vec operand2  ::  64 Word.word)) in
         (let (carry_in :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
         (carry_in, operand2)))
       else
         (let (carry_in :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
         (carry_in, operand2))) in
     (let (tup__0, tup__1) = ((AddWithCarry operand1 operand2 carry_in  :: ( 64 Word.word *  4 Word.word))) in
     (let result = tup__0 in
     (let nzcv = tup__1 in
     (if setflags then
        (let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        read_reg PSTATE_ref \<bind> (\<lambda> (w__12 :: ProcState) . 
        (write_reg PSTATE_ref (w__12 (| ProcState_N := tup__0 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__13 :: ProcState) . 
        (write_reg PSTATE_ref (w__13 (| ProcState_Z := tup__1 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__14 :: ProcState) . 
        (write_reg PSTATE_ref (w__14 (| ProcState_C := tup__2 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__15 :: ProcState) . 
        write_reg PSTATE_ref (w__15 (| ProcState_V := tup__3 |)))))))
      else return () ) \<then>
     aset_X d result))))))))))
   else if (((l__163 = (( 128 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M)) \<bind> (\<lambda> (result :: 128 bits) . 
     (aget_X (( 128 :: int)::ii) n  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand1 :: 128 bits) . 
     (ShiftReg (( 128 :: int)::ii) m shift_type shift_amount  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand2 :: 128 bits) . 
     (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (nzcv :: 4 bits) . 
     (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (carry_in :: 1 bits) . 
     (let ((carry_in :: 1 bits), (operand2 :: 128 bits)) =
       (if sub_op then
         (let (operand2 :: 128 bits) = ((not_vec operand2  ::  128 Word.word)) in
         (let (carry_in :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
         (carry_in, operand2)))
       else
         (let (carry_in :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
         (carry_in, operand2))) in
     (let (tup__0, tup__1) = ((AddWithCarry operand1 operand2 carry_in  :: ( 128 Word.word *  4 Word.word))) in
     (let result = tup__0 in
     (let nzcv = tup__1 in
     (if setflags then
        (let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        read_reg PSTATE_ref \<bind> (\<lambda> (w__16 :: ProcState) . 
        (write_reg PSTATE_ref (w__16 (| ProcState_N := tup__0 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__17 :: ProcState) . 
        (write_reg PSTATE_ref (w__17 (| ProcState_Z := tup__1 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__18 :: ProcState) . 
        (write_reg PSTATE_ref (w__18 (| ProcState_C := tup__2 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__19 :: ProcState) . 
        write_reg PSTATE_ref (w__19 (| ProcState_V := tup__3 |)))))))
      else return () ) \<then>
     aset_X d result))))))))))
   else
     (let dbytes = (ex_int ((l__163 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))"


(*val Prefetch : mword ty64 -> mword ty5 -> M unit*)

definition Prefetch  :: "(64)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " Prefetch address prfop = (
   undefined_PrefetchHint ()  \<bind> (\<lambda> (hint :: PrefetchHint) . 
   undefined_int ()  \<bind> (\<lambda> (target :: ii) . 
   undefined_bool ()  \<bind> (\<lambda> (stream :: bool) . 
   (let b__0 = ((slice prfop (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) in
   (let (hint :: PrefetchHint) =
     (if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then Prefetch_READ
     else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then Prefetch_EXEC
     else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then Prefetch_WRITE
     else hint) in
   (let (target :: ii) = (Word.uint ((slice prfop (( 1 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))) in
   (let (stream :: bool) =
     ((vec_of_bits [access_vec_dec prfop (( 0 :: int)::ii)]  ::  1 Word.word) \<noteq> (vec_of_bits [B0]  ::  1 Word.word)) in
   (let (_ :: unit) = (Hint_Prefetch address hint target stream) in
   return () )))))))))"


(*val IsSecondStage : FaultRecord -> M bool*)

definition IsSecondStage  :: " FaultRecord \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " IsSecondStage fault = (
   assert_exp ((((FaultRecord_typ   fault) \<noteq> Fault_None))) (''((fault).type != Fault_None)'') \<then>
   return(FaultRecord_secondstage   fault))"


(*val IsFault : AddressDescriptor -> bool*)

definition IsFault  :: " AddressDescriptor \<Rightarrow> bool "  where 
     " IsFault addrdesc = ( ((FaultRecord_typ  (AddressDescriptor_fault   addrdesc)) \<noteq> Fault_None))"


(*val CombineS1S2Desc : AddressDescriptor -> AddressDescriptor -> M AddressDescriptor*)

definition CombineS1S2Desc  :: " AddressDescriptor \<Rightarrow> AddressDescriptor \<Rightarrow>((register_value),(AddressDescriptor),(exception))monad "  where 
     " CombineS1S2Desc s1desc s2desc = (
   undefined_AddressDescriptor ()  \<bind> (\<lambda> (result :: AddressDescriptor) . 
   (let result = ((result (| AddressDescriptor_paddress := ((AddressDescriptor_paddress   s2desc))|))) in
   (if (((((IsFault s1desc)) \<or> ((IsFault s2desc))))) then
      (let (result :: AddressDescriptor) = (if ((IsFault s1desc)) then s1desc else s2desc) in
      return result)
    else if (((((((MemoryAttributes_typ  (AddressDescriptor_memattrs   s2desc)) = MemType_Device))) \<or> ((((MemoryAttributes_typ  (AddressDescriptor_memattrs   s1desc)) = MemType_Device)))))) then
      (let (tmp_610 :: MemoryAttributes) = ((AddressDescriptor_memattrs   result)) in
      (let tmp_610 = ((tmp_610 (| MemoryAttributes_typ := MemType_Device |))) in
      (let result = ((result (| AddressDescriptor_memattrs := tmp_610 |))) in
      if ((((MemoryAttributes_typ  (AddressDescriptor_memattrs   s1desc)) = MemType_Normal))) then
        (let (tmp_620 :: MemoryAttributes) = ((AddressDescriptor_memattrs   result)) in
        (let (tmp_620 :: MemoryAttributes) =
          ((tmp_620 (|
            MemoryAttributes_device := ((MemoryAttributes_device  (AddressDescriptor_memattrs   s2desc)))|))) in
        (let (result :: AddressDescriptor) = ((result (| AddressDescriptor_memattrs := tmp_620 |))) in
        return result)))
      else if ((((MemoryAttributes_typ  (AddressDescriptor_memattrs   s2desc)) = MemType_Normal))) then
        (let (tmp_630 :: MemoryAttributes) = ((AddressDescriptor_memattrs   result)) in
        (let (tmp_630 :: MemoryAttributes) =
          ((tmp_630 (|
            MemoryAttributes_device := ((MemoryAttributes_device  (AddressDescriptor_memattrs   s1desc)))|))) in
        (let (result :: AddressDescriptor) = ((result (| AddressDescriptor_memattrs := tmp_630 |))) in
        return result)))
      else
        (let (tmp_640 :: MemoryAttributes) = ((AddressDescriptor_memattrs   result)) in
        CombineS1S2Device(MemoryAttributes_device  (AddressDescriptor_memattrs   s1desc))(MemoryAttributes_device  (AddressDescriptor_memattrs  
          s2desc)) \<bind> (\<lambda> (w__0 :: DeviceType) . 
        (let (tmp_640 :: MemoryAttributes) = ((tmp_640 (| MemoryAttributes_device := w__0 |))) in
        (let (result :: AddressDescriptor) = ((result (| AddressDescriptor_memattrs := tmp_640 |))) in
        return result)))))))
    else
      (let (tmp_650 :: MemoryAttributes) = ((AddressDescriptor_memattrs   result)) in
      (let tmp_650 = ((tmp_650 (| MemoryAttributes_typ := MemType_Normal |))) in
      (let result = ((result (| AddressDescriptor_memattrs := tmp_650 |))) in
      (let (tmp_660 :: MemoryAttributes) = ((AddressDescriptor_memattrs   result)) in
      undefined_DeviceType ()  \<bind> (\<lambda> (w__1 :: DeviceType) . 
      (let tmp_660 = ((tmp_660 (| MemoryAttributes_device := w__1 |))) in
      (let result = ((result (| AddressDescriptor_memattrs := tmp_660 |))) in
      (let (tmp_670 :: MemoryAttributes) = ((AddressDescriptor_memattrs   result)) in
      CombineS1S2AttrHints(MemoryAttributes_inner  (AddressDescriptor_memattrs   s1desc))(MemoryAttributes_inner  (AddressDescriptor_memattrs  
        s2desc)) \<bind> (\<lambda> (w__2 :: MemAttrHints) . 
      (let tmp_670 = ((tmp_670 (| MemoryAttributes_inner := w__2 |))) in
      (let result = ((result (| AddressDescriptor_memattrs := tmp_670 |))) in
      (let (tmp_680 :: MemoryAttributes) = ((AddressDescriptor_memattrs   result)) in
      CombineS1S2AttrHints(MemoryAttributes_outer  (AddressDescriptor_memattrs   s1desc))(MemoryAttributes_outer  (AddressDescriptor_memattrs  
        s2desc)) \<bind> (\<lambda> (w__3 :: MemAttrHints) . 
      (let (tmp_680 :: MemoryAttributes) = ((tmp_680 (| MemoryAttributes_outer := w__3 |))) in
      (let (result :: AddressDescriptor) = ((result (| AddressDescriptor_memattrs := tmp_680 |))) in
      (let (tmp_690 :: MemoryAttributes) = ((AddressDescriptor_memattrs   result)) in
      (let (tmp_690 :: MemoryAttributes) =
        ((tmp_690 (|
          MemoryAttributes_shareable :=
            ((((MemoryAttributes_shareable  (AddressDescriptor_memattrs   s1desc)) \<or>(MemoryAttributes_shareable  (AddressDescriptor_memattrs   s2desc)))))|))) in
      (let (result :: AddressDescriptor) = ((result (| AddressDescriptor_memattrs := tmp_690 |))) in
      (let (tmp_700 :: MemoryAttributes) = ((AddressDescriptor_memattrs   result)) in
      (let (tmp_700 :: MemoryAttributes) =
        ((tmp_700 (|
          MemoryAttributes_outershareable :=
            ((((MemoryAttributes_outershareable  (AddressDescriptor_memattrs   s1desc)) \<or>(MemoryAttributes_outershareable  (AddressDescriptor_memattrs   s2desc)))))|))) in
      (let (result :: AddressDescriptor) = ((result (| AddressDescriptor_memattrs := tmp_700 |))) in
      return result)))))))))))))))))))))) \<bind> (\<lambda> (result :: AddressDescriptor) . 
   MemAttrDefaults(AddressDescriptor_memattrs   result) \<bind> (\<lambda> (w__4 :: MemoryAttributes) . 
   (let (result :: AddressDescriptor) = ((result (| AddressDescriptor_memattrs := w__4 |))) in
   return result))))))"


(*val IsExternalSyncAbort__0 : Fault -> M bool*)

(*val IsExternalSyncAbort__1 : FaultRecord -> M bool*)

definition IsExternalSyncAbort__0  :: " Fault \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " IsExternalSyncAbort__0 typ1 = (
   assert_exp (((typ1 \<noteq> Fault_None))) ('''') \<then>
   return ((((((typ1 = Fault_SyncExternal))) \<or> ((((((typ1 = Fault_SyncParity))) \<or> ((((((typ1 = Fault_SyncExternalOnWalk))) \<or> (((typ1 = Fault_SyncParityOnWalk)))))))))))))"


definition IsExternalSyncAbort__1  :: " FaultRecord \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " IsExternalSyncAbort__1 fault = ( IsExternalSyncAbort__0(FaultRecord_typ   fault))"


(*val IsExternalAbort__0 : Fault -> M bool*)

(*val IsExternalAbort__1 : FaultRecord -> M bool*)

definition IsExternalAbort__0  :: " Fault \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " IsExternalAbort__0 typ1 = (
   assert_exp (((typ1 \<noteq> Fault_None))) ('''') \<then>
   return ((((((typ1 = Fault_SyncExternal))) \<or> ((((((typ1 = Fault_SyncParity))) \<or> ((((((typ1 = Fault_SyncExternalOnWalk))) \<or> ((((((typ1 = Fault_SyncParityOnWalk))) \<or> ((((((typ1 = Fault_AsyncExternal))) \<or> (((typ1 = Fault_AsyncParity)))))))))))))))))))"


definition IsExternalAbort__1  :: " FaultRecord \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " IsExternalAbort__1 fault = ( IsExternalAbort__0(FaultRecord_typ   fault))"


(*val IsDebugException : FaultRecord -> M bool*)

definition IsDebugException  :: " FaultRecord \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " IsDebugException fault = (
   assert_exp ((((FaultRecord_typ   fault) \<noteq> Fault_None))) (''((fault).type != Fault_None)'') \<then>
   return ((((FaultRecord_typ   fault) = Fault_Debug))))"


(*val IPAValid : FaultRecord -> M bool*)

definition IPAValid  :: " FaultRecord \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " IPAValid fault = (
   assert_exp ((((FaultRecord_typ   fault) \<noteq> Fault_None))) (''((fault).type != Fault_None)'') \<then>
   return (if(FaultRecord_s2fs1walk   fault) then
             (((((FaultRecord_typ   fault) = Fault_AccessFlag))) \<or> (((((((FaultRecord_typ   fault) = Fault_Permission))) \<or> (((((((FaultRecord_typ   fault) = Fault_Translation))) \<or> ((((FaultRecord_typ   fault) = Fault_AddressSize))))))))))
           else if(FaultRecord_secondstage   fault) then
             (((((FaultRecord_typ   fault) = Fault_AccessFlag))) \<or> (((((((FaultRecord_typ   fault) = Fault_Translation))) \<or> ((((FaultRecord_typ   fault) = Fault_AddressSize)))))))
           else False))"


(*val aarch64_integer_logical_immediate : forall 'datasize. Size 'datasize => ii -> itself 'datasize -> mword 'datasize -> ii -> LogicalOp -> bool -> M unit*)

definition aarch64_integer_logical_immediate  :: " int \<Rightarrow>('datasize::len)itself \<Rightarrow>('datasize::len)Word.word \<Rightarrow> int \<Rightarrow> LogicalOp \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_logical_immediate d datasize imm n op1 setflags = (
   (let datasize = (size_itself_int datasize) in
   (let dbytes = (ex_int ((datasize div (( 8 :: int)::ii)))) in
   ((assert_exp True (''datasize constraint'') \<then>
   assert_exp True (''dbytes constraint'')) \<then>
   (undefined_bitvector datasize  :: (( 'datasize::len)Word.word) M)) \<bind> (\<lambda> result . 
   (aget_X datasize n  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> operand1 . 
   (let operand2 = imm in
   (let result =
     ((case  op1 of
       LogicalOp_AND => (and_vec operand1 operand2  :: ( 'datasize::len)Word.word)
     | LogicalOp_ORR => (or_vec operand1 operand2  :: ( 'datasize::len)Word.word)
     | LogicalOp_EOR => (xor_vec operand1 operand2  :: ( 'datasize::len)Word.word)
     )) in
   (if setflags then
      (let split_vec =
        ((concat_vec
           ((concat_vec
               (vec_of_bits [access_vec_dec result ((datasize - (( 1 :: int)::ii)))]  ::  1 Word.word)
               ((IsZeroBit result  ::  1 Word.word))
              ::  2 Word.word)) (vec_of_bits [B0,B0]  ::  2 Word.word)
          ::  4 Word.word)) in
      (let (tup__0, tup__1, tup__2, tup__3) =
        ((subrange_vec_dec split_vec (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
      read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) . 
      (write_reg PSTATE_ref (w__0 (| ProcState_N := tup__0 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__1 :: ProcState) . 
      (write_reg PSTATE_ref (w__1 (| ProcState_Z := tup__1 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__2 :: ProcState) . 
      (write_reg PSTATE_ref (w__2 (| ProcState_C := tup__2 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__3 :: ProcState) . 
      write_reg PSTATE_ref (w__3 (| ProcState_V := tup__3 |))))))))
    else return () ) \<then>
   (if ((((((d = (( 31 :: int)::ii)))) \<and> ((\<not> setflags))))) then aset_SP result
   else aset_X d result))))))))"


(*val aarch64_integer_arithmetic_addsub_immediate : forall 'datasize. Size 'datasize => ii -> itself 'datasize -> mword 'datasize -> ii -> bool -> bool -> M unit*)

definition aarch64_integer_arithmetic_addsub_immediate  :: " int \<Rightarrow>('datasize::len)itself \<Rightarrow>('datasize::len)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_arithmetic_addsub_immediate d datasize imm n setflags sub_op = (
   (let datasize = (size_itself_int datasize) in
   (let dbytes = (ex_int ((datasize div (( 8 :: int)::ii)))) in
   ((assert_exp True (''datasize constraint'') \<then>
   assert_exp True (''dbytes constraint'')) \<then>
   (undefined_bitvector datasize  :: (( 'datasize::len)Word.word) M)) \<bind> (\<lambda> result . 
   (if (((n = (( 31 :: int)::ii)))) then (aget_SP datasize ()   :: (( 'datasize::len)Word.word) M)
    else (aget_X datasize n  :: (( 'datasize::len)Word.word) M)) \<bind> (\<lambda> operand1 . 
   (let operand2 = imm in
   (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (nzcv :: 4 bits) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (carry_in :: 1 bits) . 
   (let ((carry_in :: 1 bits), operand2) =
     (if sub_op then
       (let operand2 = ((not_vec operand2  :: ( 'datasize::len)Word.word)) in
       (let (carry_in :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
       (carry_in, operand2)))
     else
       (let (carry_in :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
       (carry_in, operand2))) in
   (let (tup__0, tup__1) = (AddWithCarry operand1 operand2 carry_in ) in
   (let result = tup__0 in
   (let nzcv = tup__1 in
   (if setflags then
      (let (tup__0, tup__1, tup__2, tup__3) =
        ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
      read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) . 
      (write_reg PSTATE_ref (w__2 (| ProcState_N := tup__0 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__3 :: ProcState) . 
      (write_reg PSTATE_ref (w__3 (| ProcState_Z := tup__1 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__4 :: ProcState) . 
      (write_reg PSTATE_ref (w__4 (| ProcState_C := tup__2 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__5 :: ProcState) . 
      write_reg PSTATE_ref (w__5 (| ProcState_V := tup__3 |)))))))
    else return () ) \<then>
   (if ((((((d = (( 31 :: int)::ii)))) \<and> ((\<not> setflags))))) then aset_SP result
   else aset_X d result)))))))))))))"


(*val aarch64_integer_arithmetic_addsub_extendedreg : ii -> ii -> ExtendType -> ii -> ii -> bool -> ii -> bool -> M unit*)

definition aarch64_integer_arithmetic_addsub_extendedreg  :: " int \<Rightarrow> int \<Rightarrow> ExtendType \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_arithmetic_addsub_extendedreg d l__158 extend_type m n setflags shift sub_op = (
   if (((l__158 = (( 8 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M)) \<bind> (\<lambda> (result :: 8 bits) . 
     (if (((n = (( 31 :: int)::ii)))) then (aget_SP (( 8 :: int)::ii) ()   :: ( 8 Word.word) M)
      else (aget_X (( 8 :: int)::ii) n  :: ( 8 Word.word) M)) \<bind> (\<lambda> (operand1 :: 8 bits) . 
     (ExtendReg (( 8 :: int)::ii) m extend_type shift  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand2 :: 8 bits) . 
     (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (nzcv :: 4 bits) . 
     (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (carry_in :: 1 bits) . 
     (let ((carry_in :: 1 bits), (operand2 :: 8 bits)) =
       (if sub_op then
         (let (operand2 :: 8 bits) = ((not_vec operand2  ::  8 Word.word)) in
         (let (carry_in :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
         (carry_in, operand2)))
       else
         (let (carry_in :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
         (carry_in, operand2))) in
     (let (tup__0, tup__1) = ((AddWithCarry operand1 operand2 carry_in  :: ( 8 Word.word *  4 Word.word))) in
     (let result = tup__0 in
     (let nzcv = tup__1 in
     (if setflags then
        (let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) . 
        (write_reg PSTATE_ref (w__2 (| ProcState_N := tup__0 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__3 :: ProcState) . 
        (write_reg PSTATE_ref (w__3 (| ProcState_Z := tup__1 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__4 :: ProcState) . 
        (write_reg PSTATE_ref (w__4 (| ProcState_C := tup__2 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__5 :: ProcState) . 
        write_reg PSTATE_ref (w__5 (| ProcState_V := tup__3 |)))))))
      else return () ) \<then>
     (if ((((((d = (( 31 :: int)::ii)))) \<and> ((\<not> setflags))))) then aset_SP result
     else aset_X d result)))))))))))
   else if (((l__158 = (( 16 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M)) \<bind> (\<lambda> (result :: 16 bits) . 
     (if (((n = (( 31 :: int)::ii)))) then (aget_SP (( 16 :: int)::ii) ()   :: ( 16 Word.word) M)
      else (aget_X (( 16 :: int)::ii) n  :: ( 16 Word.word) M)) \<bind> (\<lambda> (operand1 :: 16 bits) . 
     (ExtendReg (( 16 :: int)::ii) m extend_type shift  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand2 :: 16 bits) . 
     (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (nzcv :: 4 bits) . 
     (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (carry_in :: 1 bits) . 
     (let ((carry_in :: 1 bits), (operand2 :: 16 bits)) =
       (if sub_op then
         (let (operand2 :: 16 bits) = ((not_vec operand2  ::  16 Word.word)) in
         (let (carry_in :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
         (carry_in, operand2)))
       else
         (let (carry_in :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
         (carry_in, operand2))) in
     (let (tup__0, tup__1) = ((AddWithCarry operand1 operand2 carry_in  :: ( 16 Word.word *  4 Word.word))) in
     (let result = tup__0 in
     (let nzcv = tup__1 in
     (if setflags then
        (let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        read_reg PSTATE_ref \<bind> (\<lambda> (w__8 :: ProcState) . 
        (write_reg PSTATE_ref (w__8 (| ProcState_N := tup__0 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__9 :: ProcState) . 
        (write_reg PSTATE_ref (w__9 (| ProcState_Z := tup__1 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__10 :: ProcState) . 
        (write_reg PSTATE_ref (w__10 (| ProcState_C := tup__2 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__11 :: ProcState) . 
        write_reg PSTATE_ref (w__11 (| ProcState_V := tup__3 |)))))))
      else return () ) \<then>
     (if ((((((d = (( 31 :: int)::ii)))) \<and> ((\<not> setflags))))) then aset_SP result
     else aset_X d result)))))))))))
   else if (((l__158 = (( 32 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (result :: 32 bits) . 
     (if (((n = (( 31 :: int)::ii)))) then (aget_SP (( 32 :: int)::ii) ()   :: ( 32 Word.word) M)
      else (aget_X (( 32 :: int)::ii) n  :: ( 32 Word.word) M)) \<bind> (\<lambda> (operand1 :: 32 bits) . 
     (ExtendReg (( 32 :: int)::ii) m extend_type shift  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand2 :: 32 bits) . 
     (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (nzcv :: 4 bits) . 
     (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (carry_in :: 1 bits) . 
     (let ((carry_in :: 1 bits), (operand2 :: 32 bits)) =
       (if sub_op then
         (let (operand2 :: 32 bits) = ((not_vec operand2  ::  32 Word.word)) in
         (let (carry_in :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
         (carry_in, operand2)))
       else
         (let (carry_in :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
         (carry_in, operand2))) in
     (let (tup__0, tup__1) = ((AddWithCarry operand1 operand2 carry_in  :: ( 32 Word.word *  4 Word.word))) in
     (let result = tup__0 in
     (let nzcv = tup__1 in
     (if setflags then
        (let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        read_reg PSTATE_ref \<bind> (\<lambda> (w__14 :: ProcState) . 
        (write_reg PSTATE_ref (w__14 (| ProcState_N := tup__0 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__15 :: ProcState) . 
        (write_reg PSTATE_ref (w__15 (| ProcState_Z := tup__1 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__16 :: ProcState) . 
        (write_reg PSTATE_ref (w__16 (| ProcState_C := tup__2 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__17 :: ProcState) . 
        write_reg PSTATE_ref (w__17 (| ProcState_V := tup__3 |)))))))
      else return () ) \<then>
     (if ((((((d = (( 31 :: int)::ii)))) \<and> ((\<not> setflags))))) then aset_SP result
     else aset_X d result)))))))))))
   else if (((l__158 = (( 64 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (result :: 64 bits) . 
     (if (((n = (( 31 :: int)::ii)))) then (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (operand1 :: 64 bits) . 
     (ExtendReg (( 64 :: int)::ii) m extend_type shift  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand2 :: 64 bits) . 
     (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (nzcv :: 4 bits) . 
     (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (carry_in :: 1 bits) . 
     (let ((carry_in :: 1 bits), (operand2 :: 64 bits)) =
       (if sub_op then
         (let (operand2 :: 64 bits) = ((not_vec operand2  ::  64 Word.word)) in
         (let (carry_in :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
         (carry_in, operand2)))
       else
         (let (carry_in :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
         (carry_in, operand2))) in
     (let (tup__0, tup__1) = ((AddWithCarry operand1 operand2 carry_in  :: ( 64 Word.word *  4 Word.word))) in
     (let result = tup__0 in
     (let nzcv = tup__1 in
     (if setflags then
        (let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        read_reg PSTATE_ref \<bind> (\<lambda> (w__20 :: ProcState) . 
        (write_reg PSTATE_ref (w__20 (| ProcState_N := tup__0 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__21 :: ProcState) . 
        (write_reg PSTATE_ref (w__21 (| ProcState_Z := tup__1 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__22 :: ProcState) . 
        (write_reg PSTATE_ref (w__22 (| ProcState_C := tup__2 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__23 :: ProcState) . 
        write_reg PSTATE_ref (w__23 (| ProcState_V := tup__3 |)))))))
      else return () ) \<then>
     (if ((((((d = (( 31 :: int)::ii)))) \<and> ((\<not> setflags))))) then aset_SP result
     else aset_X d result)))))))))))
   else if (((l__158 = (( 128 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M)) \<bind> (\<lambda> (result :: 128 bits) . 
     (if (((n = (( 31 :: int)::ii)))) then (aget_SP (( 128 :: int)::ii) ()   :: ( 128 Word.word) M)
      else (aget_X (( 128 :: int)::ii) n  :: ( 128 Word.word) M)) \<bind> (\<lambda> (operand1 :: 128 bits) . 
     (ExtendReg (( 128 :: int)::ii) m extend_type shift  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand2 :: 128 bits) . 
     (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (nzcv :: 4 bits) . 
     (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (carry_in :: 1 bits) . 
     (let ((carry_in :: 1 bits), (operand2 :: 128 bits)) =
       (if sub_op then
         (let (operand2 :: 128 bits) = ((not_vec operand2  ::  128 Word.word)) in
         (let (carry_in :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
         (carry_in, operand2)))
       else
         (let (carry_in :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
         (carry_in, operand2))) in
     (let (tup__0, tup__1) = ((AddWithCarry operand1 operand2 carry_in  :: ( 128 Word.word *  4 Word.word))) in
     (let result = tup__0 in
     (let nzcv = tup__1 in
     (if setflags then
        (let (tup__0, tup__1, tup__2, tup__3) =
          ((subrange_vec_dec nzcv (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
           (subrange_vec_dec nzcv (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        read_reg PSTATE_ref \<bind> (\<lambda> (w__26 :: ProcState) . 
        (write_reg PSTATE_ref (w__26 (| ProcState_N := tup__0 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__27 :: ProcState) . 
        (write_reg PSTATE_ref (w__27 (| ProcState_Z := tup__1 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__28 :: ProcState) . 
        (write_reg PSTATE_ref (w__28 (| ProcState_C := tup__2 |)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__29 :: ProcState) . 
        write_reg PSTATE_ref (w__29 (| ProcState_V := tup__3 |)))))))
      else return () ) \<then>
     (if ((((((d = (( 31 :: int)::ii)))) \<and> ((\<not> setflags))))) then aset_SP result
     else aset_X d result)))))))))))
   else
     (let dbytes = (ex_int ((l__158 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))"


(*val RestoredITBits : mword ty32 -> M (mword ty8)*)

definition RestoredITBits  :: "(32)Word.word \<Rightarrow>((register_value),((8)Word.word),(exception))monad "  where 
     " RestoredITBits spsr = (
   (let (it :: 8 bits) =
     ((concat_vec ((subrange_vec_dec spsr (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word))
        ((subrange_vec_dec spsr (( 26 :: int)::ii) (( 25 :: int)::ii)  ::  2 Word.word))
       ::  8 Word.word)) in
   read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) . 
   if ((((ProcState_IL   w__0) = (vec_of_bits [B1]  ::  1 Word.word)))) then
     ConstrainUnpredictableBool Unpredictable_ILZEROIT \<bind> (\<lambda> (w__1 :: bool) . 
     return (if w__1 then (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word)
             else it))
   else if (((((\<not> ((IsZero ((subrange_vec_dec it (( 7 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)))))) \<and> ((IsZero ((subrange_vec_dec it (( 3 :: int)::ii) (( 0 :: int)::ii)  ::  4 Word.word))))))) then
     return (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word)
   else
     read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) . 
     (if ((((ProcState_EL   w__2) = EL2))) then
        (read_reg HSCTLR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__3 :: 32 bits) . 
        return (vec_of_bits [access_vec_dec w__3 (( 7 :: int)::ii)]  ::  1 Word.word))
      else
        (read_reg SCTLR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__4 :: 32 bits) . 
        return (vec_of_bits [access_vec_dec w__4 (( 7 :: int)::ii)]  ::  1 Word.word))) \<bind> (\<lambda> (itd :: 1 bits) . 
     return (if ((((((((((vec_of_bits [access_vec_dec spsr (( 5 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((\<not> ((IsZero it))))))) \<or> ((((((itd = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((\<not> ((IsZero ((subrange_vec_dec it (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))))))))))))
             then
               (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word)
             else it))))))"


(*val IsEL1TransRegimeRegs : unit -> M bool*)

definition IsEL1TransRegimeRegs  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " IsEL1TransRegimeRegs _ = (
   or_boolM
     (or_boolM (return ((\<not> ((HaveEL EL2)))))
        (read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) .  return ((((ProcState_EL   w__0) = EL1))))))
     (and_boolM
        (read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) .  return ((((ProcState_EL   w__2) = EL0)))))
        (or_boolM
           ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 :: 64 bits) . 
            return ((((vec_of_bits [access_vec_dec w__3 (( 34 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))
           ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 :: 64 bits) . 
            return ((((vec_of_bits [access_vec_dec w__4 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))))))"


(*val CalculateTBI : mword ty64 -> bool -> M bool*)

definition CalculateTBI  :: "(64)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " CalculateTBI ptr data = (
   (let (tbi :: bool) = False in
   PtrHasUpperAndLowerAddRanges ()  \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then
     IsEL1TransRegimeRegs ()  \<bind> (\<lambda> (w__1 :: bool) . 
     if w__1 then
       if data then
         if ((((vec_of_bits [access_vec_dec ptr (( 55 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
           (read_reg TCR_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 :: 64 bits) . 
           return ((((vec_of_bits [access_vec_dec w__2 (( 38 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))
         else
           (read_reg TCR_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 :: 64 bits) . 
           return ((((vec_of_bits [access_vec_dec w__3 (( 37 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))
       else if ((((vec_of_bits [access_vec_dec ptr (( 55 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
         and_boolM
           ((read_reg TCR_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 :: 64 bits) . 
            return ((((vec_of_bits [access_vec_dec w__5 (( 38 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))
           ((read_reg TCR_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__6 :: 64 bits) . 
            return ((((vec_of_bits [access_vec_dec w__6 (( 52 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))
       else
         and_boolM
           ((read_reg TCR_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__8 :: 64 bits) . 
            return ((((vec_of_bits [access_vec_dec w__8 (( 37 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))
           ((read_reg TCR_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__9 :: 64 bits) . 
            return ((((vec_of_bits [access_vec_dec w__9 (( 51 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))
     else if data then
       if ((((vec_of_bits [access_vec_dec ptr (( 55 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
         (read_reg TCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__11 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__11 (( 38 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))
       else
         (read_reg TCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__12 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__12 (( 37 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))
     else if ((((vec_of_bits [access_vec_dec ptr (( 55 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
       and_boolM
         ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__14 :: 64 bits) . 
          return ((((vec_of_bits [access_vec_dec w__14 (( 38 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))
         ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__15 :: 64 bits) . 
          return ((((vec_of_bits [access_vec_dec w__15 (( 52 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))
     else
       and_boolM
         ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__17 :: 64 bits) . 
          return ((((vec_of_bits [access_vec_dec w__17 (( 37 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))
         ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__18 :: 64 bits) . 
          return ((((vec_of_bits [access_vec_dec w__18 (( 51 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))))
   else
     read_reg PSTATE_ref \<bind> (\<lambda> (w__20 :: ProcState) . 
     if ((((ProcState_EL   w__20) = EL2))) then
       if data then
         (read_reg TCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__21 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__21 (( 20 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))
       else
         and_boolM
           ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__22 :: 64 bits) . 
            return ((((vec_of_bits [access_vec_dec w__22 (( 20 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))
           ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__23 :: 64 bits) . 
            return ((((vec_of_bits [access_vec_dec w__23 (( 29 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))
     else
       read_reg PSTATE_ref \<bind> (\<lambda> (w__26 :: ProcState) . 
       if ((((ProcState_EL   w__26) = EL3))) then
         if data then
           (read_reg TCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__27 :: 32 bits) . 
           return ((((vec_of_bits [access_vec_dec w__27 (( 20 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))
         else
           and_boolM
             ((read_reg TCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__28 :: 32 bits) . 
              return ((((vec_of_bits [access_vec_dec w__28 (( 20 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))
             ((read_reg TCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__29 :: 32 bits) . 
              return ((((vec_of_bits [access_vec_dec w__29 (( 29 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))
       else return tbi)))))"


(*val CalculateBottomPACBit : mword ty64 -> mword ty1 -> M ii*)

definition CalculateBottomPACBit  :: "(64)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(int),(exception))monad "  where 
     " CalculateBottomPACBit ptr top_bit = (
   undefined_int ()  \<bind> (\<lambda> (tsz_field :: ii) . 
   undefined_bool ()  \<bind> (\<lambda> (using64k :: bool) . 
   PtrHasUpperAndLowerAddRanges ()  \<bind> (\<lambda> (w__0 :: bool) . 
   (if w__0 then
      IsEL1TransRegimeRegs ()  \<bind> (\<lambda> (w__1 :: bool) . 
      if w__1 then
        (if (((top_bit = (vec_of_bits [B1]  ::  1 Word.word)))) then
           (read_reg TCR_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 :: 64 bits) . 
           return ((Word.uint ((slice w__2 (( 16 :: int)::ii) (( 6 :: int)::ii)  ::  6 Word.word)))))
         else
           (read_reg TCR_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 :: 64 bits) . 
           return ((Word.uint ((slice w__3 (( 0 :: int)::ii) (( 6 :: int)::ii)  ::  6 Word.word)))))) \<bind> (\<lambda> (w__4 :: ii) . 
        (let tsz_field = w__4 in
        (if (((top_bit = (vec_of_bits [B1]  ::  1 Word.word)))) then
           (read_reg TCR_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 :: 64 bits) . 
           return (((((slice w__5 (( 30 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B1]  ::  2 Word.word)))))
         else
           (read_reg TCR_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__6 :: 64 bits) . 
           return (((((slice w__6 (( 14 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B1]  ::  2 Word.word)))))) \<bind> (\<lambda> (w__7 :: bool) . 
        (let (using64k :: bool) = w__7 in
        return (tsz_field, using64k)))))
      else
        (assert_exp ((HaveEL EL2)) (''HaveEL(EL2)'') \<then>
        (if (((top_bit = (vec_of_bits [B1]  ::  1 Word.word)))) then
           (read_reg TCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__8 :: 64 bits) . 
           return ((Word.uint ((slice w__8 (( 16 :: int)::ii) (( 6 :: int)::ii)  ::  6 Word.word)))))
         else
           (read_reg TCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__9 :: 64 bits) . 
           return ((Word.uint ((slice w__9 (( 0 :: int)::ii) (( 6 :: int)::ii)  ::  6 Word.word))))))) \<bind> (\<lambda> (w__10 :: ii) . 
        (let tsz_field = w__10 in
        (if (((top_bit = (vec_of_bits [B1]  ::  1 Word.word)))) then
           (read_reg TCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__11 :: 64 bits) . 
           return (((((slice w__11 (( 30 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B1]  ::  2 Word.word)))))
         else
           (read_reg TCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__12 :: 64 bits) . 
           return (((((slice w__12 (( 14 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B1]  ::  2 Word.word)))))) \<bind> (\<lambda> (w__13 :: bool) . 
        (let (using64k :: bool) = w__13 in
        return (tsz_field, using64k))))))
    else
      read_reg PSTATE_ref \<bind> (\<lambda> (w__14 :: ProcState) . 
      (if ((((ProcState_EL   w__14) = EL2))) then
         (read_reg TCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__15 :: 64 bits) . 
         return ((Word.uint ((slice w__15 (( 0 :: int)::ii) (( 6 :: int)::ii)  ::  6 Word.word)))))
       else
         (read_reg TCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__16 :: 32 bits) . 
         return ((Word.uint ((slice w__16 (( 0 :: int)::ii) (( 6 :: int)::ii)  ::  6 Word.word)))))) \<bind> (\<lambda> (w__17 :: ii) . 
      (let tsz_field = w__17 in
      read_reg PSTATE_ref \<bind> (\<lambda> (w__18 :: ProcState) . 
      (if ((((ProcState_EL   w__18) = EL2))) then
         (read_reg TCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__19 :: 64 bits) . 
         return (((((slice w__19 (( 14 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B1]  ::  2 Word.word)))))
       else
         (read_reg TCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__20 :: 32 bits) . 
         return (((((slice w__20 (( 14 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B1]  ::  2 Word.word)))))) \<bind> (\<lambda> (w__21 :: bool) . 
      (let (using64k :: bool) = w__21 in
      return (tsz_field, using64k)))))))) \<bind> (\<lambda> varstup .  (let ((tsz_field :: ii), (using64k :: bool)) = varstup in
   (let (max_limit_tsz_field :: ii) = ((( 39 :: int)::ii)) in
   undefined_Constraint ()  \<bind> (\<lambda> (c :: Constraint) . 
   (if ((((ex_int tsz_field)) > ((ex_int max_limit_tsz_field)))) then
      (let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in
      assert_exp ((((((c = Constraint_FORCE))) \<or> (((c = Constraint_NONE)))))) (''((c == Constraint_FORCE) || (c == Constraint_NONE))'') \<then>
      ((let (tsz_field :: ii) = (if (((c = Constraint_FORCE))) then max_limit_tsz_field else tsz_field) in
      return (c, tsz_field))))
    else return (c, tsz_field)) \<bind> (\<lambda> varstup .  (let ((c :: Constraint), (tsz_field :: ii)) = varstup in
   (let (tszmin :: ii) =
     (if (((using64k \<and> (((((ex_int ((VAMax () )))) = (( 52 :: int)::ii))))))) then (( 12 :: int)::ii)
     else (( 16 :: int)::ii)) in
   (if ((((ex_int tsz_field)) < ((ex_int tszmin)))) then
      (let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in
      assert_exp ((((((c = Constraint_FORCE))) \<or> (((c = Constraint_NONE)))))) (''((c == Constraint_FORCE) || (c == Constraint_NONE))'') \<then>
      ((let (tsz_field :: ii) = (if (((c = Constraint_FORCE))) then tszmin else tsz_field) in
      return tsz_field)))
    else return tsz_field) \<bind> (\<lambda> (tsz_field :: ii) . 
   return (((( 64 :: int)::ii) - ((ex_int tsz_field))))))))))))))))"


(*val Auth : mword ty64 -> mword ty64 -> mword ty128 -> bool -> mword ty1 -> M (mword ty64)*)

definition Auth  :: "(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>(128)Word.word \<Rightarrow> bool \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " Auth ptr modifier K data keynumber = (
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (PAC :: 64 bits) . 
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (result :: 64 bits) . 
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (original_ptr :: 64 bits) . 
   (undefined_bitvector (( 2 :: int)::ii)  :: ( 2 Word.word) M) \<bind> (\<lambda> (error_code :: 2 bits) . 
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (extfield :: 64 bits) . 
   CalculateTBI ptr data \<bind> (\<lambda> (tbi :: bool) . 
   CalculateBottomPACBit ptr (vec_of_bits [access_vec_dec ptr (( 55 :: int)::ii)]  ::  1 Word.word) \<bind> (\<lambda> (w__0 ::
     ii) . 
   (let bottom_PAC_bit = (ex_int w__0) in
   assert_exp True ('''') \<then>
   ((let extfield =
     ((replicate_bits (vec_of_bits [access_vec_dec ptr (( 55 :: int)::ii)]  ::  1 Word.word) (( 64 :: int)::ii)  ::  64 Word.word)) in
   (let (original_ptr :: 64 bits) =
     (if tbi then
       (concat_vec ((subrange_vec_dec ptr (( 63 :: int)::ii) (( 56 :: int)::ii)  ::  8 Word.word))
          ((subrange_subrange_concat
              ((((((((((((- bottom_PAC_bit)) + (( 56 :: int)::ii))) -
                              (( 1 :: int)::ii)))
                          - (((( 0 :: int)::ii) - (( 1 :: int)::ii)))))
                      +
                      ((bottom_PAC_bit - (( 1 :: int)::ii)))))
                  - (((( 0 :: int)::ii) - (( 1 :: int)::ii)))))
              extfield
              ((((((- bottom_PAC_bit)) + (( 56 :: int)::ii))) - (( 1 :: int)::ii))) (( 0 :: int)::ii)
              ptr ((bottom_PAC_bit - (( 1 :: int)::ii))) (( 0 :: int)::ii)
             ::  56 Word.word))
         ::  64 Word.word)
     else
       (subrange_subrange_concat ((int (size PAC))) extfield
          ((((((- bottom_PAC_bit)) + (( 64 :: int)::ii))) - (( 1 :: int)::ii))) (( 0 :: int)::ii) ptr
          ((bottom_PAC_bit - (( 1 :: int)::ii))) (( 0 :: int)::ii)
         ::  64 Word.word)) in
   (ComputePAC original_ptr modifier ((subrange_vec_dec K (( 127 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))
      ((subrange_vec_dec K (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
     :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   (let (PAC :: 64 bits) = w__1 in
   (let (result :: 64 bits) =
     (if tbi then
       if ((subrange_subrange_eq PAC
              ((((((((- bottom_PAC_bit)) + (( 55 :: int)::ii))) - (( 1 :: int)::ii)))
                  +
                  bottom_PAC_bit)) bottom_PAC_bit ptr
              ((((((((- bottom_PAC_bit)) + (( 55 :: int)::ii))) - (( 1 :: int)::ii)))
                  +
                  bottom_PAC_bit)) bottom_PAC_bit)) then
         original_ptr
       else
         (let (error_code :: 2 bits) =
           ((concat_vec keynumber ((not_vec keynumber  ::  1 Word.word))  ::  2 Word.word)) in
         (concat_vec
            ((concat_vec ((subrange_vec_dec original_ptr (( 63 :: int)::ii) (( 55 :: int)::ii)  ::  9 Word.word)) error_code
               ::  11 Word.word)) ((subrange_vec_dec original_ptr (( 52 :: int)::ii) (( 0 :: int)::ii)  ::  53 Word.word))
           ::  64 Word.word))
     else if (((((subrange_subrange_eq PAC
                     ((((((((- bottom_PAC_bit)) + (( 55 :: int)::ii))) -
                             (( 1 :: int)::ii)))
                         + bottom_PAC_bit)) bottom_PAC_bit ptr
                     ((((((((- bottom_PAC_bit)) + (( 55 :: int)::ii))) -
                             (( 1 :: int)::ii)))
                         + bottom_PAC_bit)) bottom_PAC_bit)) \<and> (((((subrange_vec_dec PAC (( 63 :: int)::ii) (( 56 :: int)::ii)  ::  8 Word.word)) = ((subrange_vec_dec ptr (( 63 :: int)::ii) (( 56 :: int)::ii)  ::  8 Word.word)))))))) then
       original_ptr
     else
       (let (error_code :: 2 bits) =
         ((concat_vec keynumber ((not_vec keynumber  ::  1 Word.word))  ::  2 Word.word)) in
       (concat_vec
          ((concat_vec (vec_of_bits [access_vec_dec original_ptr (( 63 :: int)::ii)]  ::  1 Word.word) error_code
             ::  3 Word.word)) ((subrange_vec_dec original_ptr (( 60 :: int)::ii) (( 0 :: int)::ii)  ::  61 Word.word))
         ::  64 Word.word))) in
   return result)))))))))))))))"


(*val HighestELUsingAArch32 : unit -> bool*)

definition HighestELUsingAArch32  :: " unit \<Rightarrow> bool "  where 
     " HighestELUsingAArch32 _ = ( if ((\<not> ((HaveAnyAArch32 () )))) then False else False )"


(*val aget_SCR_GEN : unit -> M (mword ty32)*)

definition aget_SCR_GEN  :: " unit \<Rightarrow>((register_value),((32)Word.word),(exception))monad "  where 
     " aget_SCR_GEN _ = (
   (assert_exp ((HaveEL EL3)) (''HaveEL(EL3)'') \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (r :: 32 bits) . 
   if ((HighestELUsingAArch32 () )) then (read_reg SCR_ref  :: ( 32 Word.word) M)
   else (read_reg SCR_EL3_ref  :: ( 32 Word.word) M)))"


(*val IsSecureBelowEL3 : unit -> M bool*)

definition IsSecureBelowEL3  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " IsSecureBelowEL3 _ = (
   if ((HaveEL EL3)) then
     (aget_SCR_GEN ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 ::  32 Word.word) . 
     return ((((vec_of_bits [access_vec_dec w__0 (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))
   else return (if ((HaveEL EL2)) then False else False))"


(*val UsingAArch32 : unit -> M bool*)

definition UsingAArch32  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " UsingAArch32 _ = (
   read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) . 
   (let (aarch32 :: bool) = ((ProcState_nRW   w__0) = (vec_of_bits [B1]  ::  1 Word.word)) in
   ((if ((\<not> ((HaveAnyAArch32 () )))) then assert_exp ((\<not> aarch32)) (''!(aarch32)'')
    else return () ) \<then>
   (if ((HighestELUsingAArch32 () )) then assert_exp aarch32 (''aarch32'')
    else return () )) \<then>
   return aarch32)))"


(*val aset_SPSR : mword ty32 -> M unit*)

definition aset_SPSR  :: "(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aset_SPSR value_name = (
   UsingAArch32 ()  \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then
     read_reg PSTATE_ref \<bind> (\<lambda> (w__1 :: ProcState) . 
     (let p__298 = ((ProcState_M   w__1)) in
     (let pat0 = p__298 in
     if (((pat0 = M32_FIQ))) then write_reg SPSR_fiq_ref value_name
     else if (((pat0 = M32_IRQ))) then write_reg SPSR_irq_ref value_name
     else if (((pat0 = M32_Svc))) then write_reg SPSR_svc_ref value_name
     else if (((pat0 = M32_Monitor))) then write_reg SPSR_mon_ref value_name
     else if (((pat0 = M32_Abort))) then write_reg SPSR_abt_ref value_name
     else if (((pat0 = M32_Hyp))) then write_reg SPSR_hyp_ref value_name
     else if (((pat0 = M32_Undef))) then write_reg SPSR_und_ref value_name
     else Unreachable () )))
   else
     read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) . 
     (let p__297 = ((ProcState_EL   w__2)) in
     (let pat0 = p__297 in
     if (((pat0 = EL1))) then write_reg SPSR_EL1_ref value_name
     else if (((pat0 = EL2))) then write_reg SPSR_EL2_ref value_name
     else if (((pat0 = EL3))) then write_reg SPSR_EL3_ref value_name
     else Unreachable () )))))"


(*val aget_SPSR : unit -> M (mword ty32)*)

definition aget_SPSR  :: " unit \<Rightarrow>((register_value),((32)Word.word),(exception))monad "  where 
     " aget_SPSR _ = (
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (result :: 32 bits) . 
   UsingAArch32 ()  \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then
     read_reg PSTATE_ref \<bind> (\<lambda> (w__1 :: ProcState) . 
     (let p__296 = ((ProcState_M   w__1)) in
     (let pat0 = p__296 in
     if (((pat0 = M32_FIQ))) then (read_reg SPSR_fiq_ref  :: ( 32 Word.word) M)
     else if (((pat0 = M32_IRQ))) then (read_reg SPSR_irq_ref  :: ( 32 Word.word) M)
     else if (((pat0 = M32_Svc))) then (read_reg SPSR_svc_ref  :: ( 32 Word.word) M)
     else if (((pat0 = M32_Monitor))) then (read_reg SPSR_mon_ref  :: ( 32 Word.word) M)
     else if (((pat0 = M32_Abort))) then (read_reg SPSR_abt_ref  :: ( 32 Word.word) M)
     else if (((pat0 = M32_Hyp))) then (read_reg SPSR_hyp_ref  :: ( 32 Word.word) M)
     else if (((pat0 = M32_Undef))) then (read_reg SPSR_und_ref  :: ( 32 Word.word) M)
     else Unreachable ()  \<then> return result)))
   else
     read_reg PSTATE_ref \<bind> (\<lambda> (w__9 :: ProcState) . 
     (let p__295 = ((ProcState_EL   w__9)) in
     (let pat0 = p__295 in
     if (((pat0 = EL1))) then (read_reg SPSR_EL1_ref  :: ( 32 Word.word) M)
     else if (((pat0 = EL2))) then (read_reg SPSR_EL2_ref  :: ( 32 Word.word) M)
     else if (((pat0 = EL3))) then (read_reg SPSR_EL3_ref  :: ( 32 Word.word) M)
     else Unreachable ()  \<then> return result))))))"


(*val IsSecure : unit -> M bool*)

definition IsSecure  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " IsSecure _ = (
   and_boolM
     (and_boolM (return ((HaveEL EL3)))
        (UsingAArch32 ()  \<bind> (\<lambda> (w__0 :: bool) .  return ((\<not> w__0)))))
     (read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) .  return ((((ProcState_EL   w__2) = EL3))))) \<bind> (\<lambda> (w__3 ::
     bool) . 
   if w__3 then return True
   else
     and_boolM (and_boolM (return ((HaveEL EL3))) ((UsingAArch32 () )))
       (read_reg PSTATE_ref \<bind> (\<lambda> (w__6 :: ProcState) . 
        return ((((ProcState_M   w__6) = M32_Monitor))))) \<bind> (\<lambda> (w__7 :: bool) . 
     if w__7 then return True
     else IsSecureBelowEL3 () )))"


(*val FPProcessException : FPExc -> mword ty32 -> M unit*)

definition FPProcessException  :: " FPExc \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " FPProcessException exception fpcr = (
   undefined_int ()  \<bind> (\<lambda> (cumul :: ii) . 
   (let (cumul :: ii) =
     ((case  exception of
       FPExc_InvalidOp => (( 0 :: int)::ii)
     | FPExc_DivideByZero => (( 1 :: int)::ii)
     | FPExc_Overflow => (( 2 :: int)::ii)
     | FPExc_Underflow => (( 3 :: int)::ii)
     | FPExc_Inexact => (( 4 :: int)::ii)
     | FPExc_InputDenorm => (( 7 :: int)::ii)
     )) in
   (let (enable :: ii) = (((ex_int cumul)) + (( 8 :: int)::ii)) in
   if ((((vec_of_bits [access_vec_dec fpcr enable]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
     throw (Error_Implementation_Defined (''floating-point trap handling''))
   else
     UsingAArch32 ()  \<bind> (\<lambda> (w__0 :: bool) . 
     if w__0 then
       (read_reg FPSCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 :: 32 bits) . 
       write_reg
         FPSCR_ref
         ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__1 cumul (vec_of_bits [B1]  ::  1 Word.word)  ::  32 Word.word)))
     else
       (read_reg FPSR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__2 :: 32 bits) . 
       write_reg
         FPSR_ref
         ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__2 cumul (vec_of_bits [B1]  ::  1 Word.word)  ::  32 Word.word))))))))"


(*val FPRoundBase : forall 'N . Size 'N => integer -> real -> mword ty32 -> FPRounding -> M (mword 'N)*)

definition FPRoundBase  :: " int \<Rightarrow> real \<Rightarrow>(32)Word.word \<Rightarrow> FPRounding \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " FPRoundBase (N__tv :: int) op1 fpcr rounding = (
   (let p00 = N__tv in
   if (((p00 = (( 16 :: int)::ii)))) then
     (((assert_exp True ('''') \<then>
     assert_exp (((op1 \<noteq> (realFromFrac(( 0 :: int))(( 10 :: int)))))) ('''')) \<then>
     assert_exp (((rounding \<noteq> FPRounding_TIEAWAY))) ('''')) \<then>
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M)) \<bind> (\<lambda> (result :: 16 bits) . 
     undefined_int ()  \<bind> (\<lambda> (F_mut :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (E_mut :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (minimum_exp :: ii) . 
     (let minimum_exp = (- (( 14 :: int)::ii)) in
     (let E_mut = ((( 5 :: int)::ii)) in
     (let F_mut = ((( 10 :: int)::ii)) in
     (assert_exp True ('''') \<then>
     undefined_real () ) \<bind> (\<lambda> (mantissa :: real) . 
     (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (sign :: 1 bits) . 
     (let ((mantissa :: real), (sign :: 1 bits)) =
       (if ((op1 < (realFromFrac(( 0 :: int))(( 10 :: int))))) then
         (let (sign :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
         (let (mantissa :: real) = (- op1) in
         (mantissa, sign)))
       else
         (let (sign :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
         (let (mantissa :: real) = op1 in
         (mantissa, sign)))) in
     (let (exponent :: ii) = ((( 0 :: int)::ii)) in
     (let ((exponent :: ii), (mantissa :: real)) =
       (while (exponent, mantissa)
         (\<lambda> varstup .  (let (exponent, mantissa) = varstup in mantissa < (realFromFrac(( 10 :: int))(( 10 :: int)))))
         (\<lambda> varstup .  (let (exponent, mantissa) = varstup in
           (let (mantissa :: real) = (mantissa * (realFromFrac(( 20 :: int))(( 10 :: int)))) in
           (let (exponent :: ii) = (((ex_int exponent)) - (( 1 :: int)::ii)) in
           (exponent, mantissa)))))) in
     (let ((exponent :: ii), (mantissa :: real)) =
       (while (exponent, mantissa)
         (\<lambda> varstup .  (let (exponent, mantissa) = varstup in mantissa \<ge> (realFromFrac(( 20 :: int))(( 10 :: int)))))
         (\<lambda> varstup .  (let (exponent, mantissa) = varstup in
           (let (mantissa :: real) = (mantissa div (realFromFrac(( 20 :: int))(( 10 :: int)))) in
           (let (exponent :: ii) = (((ex_int exponent)) + (( 1 :: int)::ii)) in
           (exponent, mantissa)))))) in
     if (((((((((((((vec_of_bits [access_vec_dec fpcr (( 24 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> False))) \<or> (((((((vec_of_bits [access_vec_dec fpcr (( 19 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> True)))))) \<and> ((((ex_int exponent)) < ((ex_int minimum_exp))))))) then
       UsingAArch32 ()  \<bind> (\<lambda> (w__0 :: bool) . 
       ((if w__0 then
          (read_reg FPSCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 :: 32 bits) . 
          write_reg
            FPSCR_ref
            ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__1 (( 3 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)  ::  32 Word.word)))
        else
          (read_reg FPSR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__2 :: 32 bits) . 
          write_reg
            FPSR_ref
            ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__2 (( 3 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)  ::  32 Word.word)))) \<then>
       (FPZero (( 16 :: int)::ii) sign  :: ( 16 Word.word) M)) \<bind> (\<lambda> (w__3 ::  16 Word.word) . 
       return ((Word.ucast w__3  :: ( 'N::len)Word.word))))
     else
       (let (biased_exp :: ii) =
         (max ((((((ex_int exponent)) - ((ex_int minimum_exp)))) + (( 1 :: int)::ii)))
           (( 0 :: int)::ii)) in
       (let (mantissa :: real) =
         (if (((((ex_int biased_exp)) = (( 0 :: int)::ii)))) then
           mantissa div
             ((realPowInteger (realFromFrac(( 20 :: int))(( 10 :: int)))
                 ((((ex_int minimum_exp)) - ((ex_int exponent))))))
         else mantissa) in
       (let (int_mant :: ii) =
         (floor ((mantissa * ((realPowInteger (realFromFrac(( 20 :: int))(( 10 :: int))) (( 10 :: int)::ii)))))) in
       (let (error :: real) =
         (((mantissa * ((realPowInteger (realFromFrac(( 20 :: int))(( 10 :: int))) (( 10 :: int)::ii))))) -
           (((real_of_int int_mant)))) in
       ((if ((((((((ex_int biased_exp)) = (( 0 :: int)::ii)))) \<and> ((((((error \<noteq> (realFromFrac(( 0 :: int))(( 10 :: int)))))) \<or> ((((vec_of_bits [access_vec_dec fpcr (( 11 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))))) then
          FPProcessException FPExc_Underflow fpcr
        else return () ) \<then>
       undefined_bool () ) \<bind> (\<lambda> (overflow_to_inf :: bool) . 
       undefined_bool ()  \<bind> (\<lambda> (round_up :: bool) . 
       (let ((overflow_to_inf :: bool), (round_up :: bool)) =
         ((case  rounding of
           FPRounding_TIEEVEN =>
            (let (round_up :: bool) =
              (((error > (realFromFrac(( 5 :: int))(( 10 :: int))))) \<or> ((((((error = (realFromFrac(( 5 :: int))(( 10 :: int)))))) \<and> (((((GetSlice_int ((make_the_value (( 1 :: int)::ii)  ::  1 itself)) int_mant (( 0 :: int)::ii)
                           ::  1 Word.word)) = (vec_of_bits [B1]  ::  1 Word.word)))))))) in
            (let (overflow_to_inf :: bool) = True in
            (overflow_to_inf, round_up)))
         | FPRounding_POSINF =>
            (let (round_up :: bool) =
              ((((error \<noteq> (realFromFrac(( 0 :: int))(( 10 :: int)))))) \<and> (((sign = (vec_of_bits [B0]  ::  1 Word.word))))) in
            (let (overflow_to_inf :: bool) = (sign = (vec_of_bits [B0]  ::  1 Word.word)) in
            (overflow_to_inf, round_up)))
         | FPRounding_NEGINF =>
            (let (round_up :: bool) =
              ((((error \<noteq> (realFromFrac(( 0 :: int))(( 10 :: int)))))) \<and> (((sign = (vec_of_bits [B1]  ::  1 Word.word))))) in
            (let (overflow_to_inf :: bool) = (sign = (vec_of_bits [B1]  ::  1 Word.word)) in
            (overflow_to_inf, round_up)))
         | FPRounding_ZERO =>
            (let (round_up :: bool) = False in
            (let (overflow_to_inf :: bool) = False in
            (overflow_to_inf, round_up)))
         | FPRounding_ODD =>
            (let (round_up :: bool) = False in
            (let (overflow_to_inf :: bool) = False in
            (overflow_to_inf, round_up)))
         )) in
       (let ((biased_exp :: ii), (int_mant :: ii)) =
         (if round_up then
           (let (int_mant :: ii) = (((ex_int int_mant)) + (( 1 :: int)::ii)) in
           (let (biased_exp :: ii) =
             (if (((((ex_int int_mant)) = ((pow2 (( 10 :: int)::ii)))))) then (( 1 :: int)::ii)
             else biased_exp) in
           (let ((biased_exp :: ii), (int_mant :: ii)) =
             (if (((((ex_int int_mant)) = ((pow2 (( 11 :: int)::ii)))))) then
               (let (biased_exp :: ii) = (((ex_int biased_exp)) + (( 1 :: int)::ii)) in
               (let (int_mant :: ii) = (((ex_int int_mant)) div (( 2 :: int)::ii)) in
               (biased_exp, int_mant)))
             else (biased_exp, int_mant)) in
           (biased_exp, int_mant))))
         else (biased_exp, int_mant)) in
       (let (int_mant :: ii) =
         (if ((((((error \<noteq> (realFromFrac(( 0 :: int))(( 10 :: int)))))) \<and> (((rounding = FPRounding_ODD)))))) then
           set_slice_int (( 1 :: int)::ii) int_mant (( 0 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)
         else int_mant) in
       (if (((False \<or> ((((vec_of_bits [access_vec_dec fpcr (( 26 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))) then
          if ((((ex_int biased_exp)) \<ge> ((((pow2 (( 5 :: int)::ii))) - (( 1 :: int)::ii))))) then
            (if overflow_to_inf then (FPInfinity (( 16 :: int)::ii) sign  :: ( 16 Word.word) M)
             else (FPMaxNormal (( 16 :: int)::ii) sign  :: ( 16 Word.word) M)) \<bind> (\<lambda> (w__6 ::  16 Word.word) . 
            (let result = w__6 in
            FPProcessException FPExc_Overflow fpcr \<then>
            ((let (error :: real) = (realFromFrac(( 10 :: int))(( 10 :: int))) in
            return (error, result)))))
          else
            (let (result :: 16 bits) =
              ((concat_vec
                 ((concat_vec sign
                     ((GetSlice_int
                         ((make_the_value (((((( 16 :: int)::ii) - (( 10 :: int)::ii))) - (( 1 :: int)::ii)))
                            ::  5 itself)) biased_exp (( 0 :: int)::ii)
                        ::  5 Word.word))
                    ::  6 Word.word))
                 ((GetSlice_int ((make_the_value (( 10 :: int)::ii)  ::  10 itself)) int_mant (( 0 :: int)::ii)
                    ::  10 Word.word))
                ::  16 Word.word)) in
            return (error, result))
        else if ((((ex_int biased_exp)) \<ge> ((pow2 (( 5 :: int)::ii))))) then
          (let result =
            ((concat_vec sign
               ((Ones__0 ((make_the_value (((( 16 :: int)::ii) - (( 1 :: int)::ii)))  ::  15 itself))
                  ::  15 Word.word))
              ::  16 Word.word)) in
          FPProcessException FPExc_InvalidOp fpcr \<then>
          ((let (error :: real) = (realFromFrac(( 0 :: int))(( 10 :: int))) in
          return (error, result))))
        else
          (let (result :: 16 bits) =
            ((concat_vec
               ((concat_vec sign
                   ((GetSlice_int
                       ((make_the_value (((((( 16 :: int)::ii) - (( 10 :: int)::ii))) - (( 1 :: int)::ii)))
                          ::  5 itself)) biased_exp (( 0 :: int)::ii)
                      ::  5 Word.word))
                  ::  6 Word.word))
               ((GetSlice_int ((make_the_value (( 10 :: int)::ii)  ::  10 itself)) int_mant (( 0 :: int)::ii)
                  ::  10 Word.word))
              ::  16 Word.word)) in
          return (error, result))) \<bind> (\<lambda> varstup .  (let ((error :: real), (result :: 16 bits)) = varstup in
       (if (((error \<noteq> (realFromFrac(( 0 :: int))(( 10 :: int)))))) then FPProcessException FPExc_Inexact fpcr
        else return () ) \<then>
       return ((Word.ucast result  :: ( 'N::len)Word.word))))))))))))))))))))))))))
   else if (((p00 = (( 32 :: int)::ii)))) then
     (((assert_exp True ('''') \<then>
     assert_exp (((op1 \<noteq> (realFromFrac(( 0 :: int))(( 10 :: int)))))) ('''')) \<then>
     assert_exp (((rounding \<noteq> FPRounding_TIEAWAY))) ('''')) \<then>
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (result :: 32 bits) . 
     undefined_int ()  \<bind> (\<lambda> (F_mut :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (E_mut :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (minimum_exp :: ii) . 
     (let minimum_exp = (- (( 126 :: int)::ii)) in
     (let E_mut = ((( 8 :: int)::ii)) in
     (let F_mut = ((( 23 :: int)::ii)) in
     (assert_exp True ('''') \<then>
     undefined_real () ) \<bind> (\<lambda> (mantissa :: real) . 
     (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (sign :: 1 bits) . 
     (let ((mantissa :: real), (sign :: 1 bits)) =
       (if ((op1 < (realFromFrac(( 0 :: int))(( 10 :: int))))) then
         (let (sign :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
         (let (mantissa :: real) = (- op1) in
         (mantissa, sign)))
       else
         (let (sign :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
         (let (mantissa :: real) = op1 in
         (mantissa, sign)))) in
     (let (exponent :: ii) = ((( 0 :: int)::ii)) in
     (let ((exponent :: ii), (mantissa :: real)) =
       (while (exponent, mantissa)
         (\<lambda> varstup .  (let (exponent, mantissa) = varstup in mantissa < (realFromFrac(( 10 :: int))(( 10 :: int)))))
         (\<lambda> varstup .  (let (exponent, mantissa) = varstup in
           (let (mantissa :: real) = (mantissa * (realFromFrac(( 20 :: int))(( 10 :: int)))) in
           (let (exponent :: ii) = (((ex_int exponent)) - (( 1 :: int)::ii)) in
           (exponent, mantissa)))))) in
     (let ((exponent :: ii), (mantissa :: real)) =
       (while (exponent, mantissa)
         (\<lambda> varstup .  (let (exponent, mantissa) = varstup in mantissa \<ge> (realFromFrac(( 20 :: int))(( 10 :: int)))))
         (\<lambda> varstup .  (let (exponent, mantissa) = varstup in
           (let (mantissa :: real) = (mantissa div (realFromFrac(( 20 :: int))(( 10 :: int)))) in
           (let (exponent :: ii) = (((ex_int exponent)) + (( 1 :: int)::ii)) in
           (exponent, mantissa)))))) in
     if (((((((((((((vec_of_bits [access_vec_dec fpcr (( 24 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> True))) \<or> (((((((vec_of_bits [access_vec_dec fpcr (( 19 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> False)))))) \<and> ((((ex_int exponent)) < ((ex_int minimum_exp))))))) then
       UsingAArch32 ()  \<bind> (\<lambda> (w__8 :: bool) . 
       ((if w__8 then
          (read_reg FPSCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__9 :: 32 bits) . 
          write_reg
            FPSCR_ref
            ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__9 (( 3 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)  ::  32 Word.word)))
        else
          (read_reg FPSR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__10 :: 32 bits) . 
          write_reg
            FPSR_ref
            ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__10 (( 3 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)  ::  32 Word.word)))) \<then>
       (FPZero (( 32 :: int)::ii) sign  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__11 ::  32 Word.word) . 
       return ((Word.ucast w__11  :: ( 'N::len)Word.word))))
     else
       (let (biased_exp :: ii) =
         (max ((((((ex_int exponent)) - ((ex_int minimum_exp)))) + (( 1 :: int)::ii)))
           (( 0 :: int)::ii)) in
       (let (mantissa :: real) =
         (if (((((ex_int biased_exp)) = (( 0 :: int)::ii)))) then
           mantissa div
             ((realPowInteger (realFromFrac(( 20 :: int))(( 10 :: int)))
                 ((((ex_int minimum_exp)) - ((ex_int exponent))))))
         else mantissa) in
       (let (int_mant :: ii) =
         (floor ((mantissa * ((realPowInteger (realFromFrac(( 20 :: int))(( 10 :: int))) (( 23 :: int)::ii)))))) in
       (let (error :: real) =
         (((mantissa * ((realPowInteger (realFromFrac(( 20 :: int))(( 10 :: int))) (( 23 :: int)::ii))))) -
           (((real_of_int int_mant)))) in
       ((if ((((((((ex_int biased_exp)) = (( 0 :: int)::ii)))) \<and> ((((((error \<noteq> (realFromFrac(( 0 :: int))(( 10 :: int)))))) \<or> ((((vec_of_bits [access_vec_dec fpcr (( 11 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))))) then
          FPProcessException FPExc_Underflow fpcr
        else return () ) \<then>
       undefined_bool () ) \<bind> (\<lambda> (overflow_to_inf :: bool) . 
       undefined_bool ()  \<bind> (\<lambda> (round_up :: bool) . 
       (let ((overflow_to_inf :: bool), (round_up :: bool)) =
         ((case  rounding of
           FPRounding_TIEEVEN =>
            (let (round_up :: bool) =
              (((error > (realFromFrac(( 5 :: int))(( 10 :: int))))) \<or> ((((((error = (realFromFrac(( 5 :: int))(( 10 :: int)))))) \<and> (((((GetSlice_int ((make_the_value (( 1 :: int)::ii)  ::  1 itself)) int_mant (( 0 :: int)::ii)
                           ::  1 Word.word)) = (vec_of_bits [B1]  ::  1 Word.word)))))))) in
            (let (overflow_to_inf :: bool) = True in
            (overflow_to_inf, round_up)))
         | FPRounding_POSINF =>
            (let (round_up :: bool) =
              ((((error \<noteq> (realFromFrac(( 0 :: int))(( 10 :: int)))))) \<and> (((sign = (vec_of_bits [B0]  ::  1 Word.word))))) in
            (let (overflow_to_inf :: bool) = (sign = (vec_of_bits [B0]  ::  1 Word.word)) in
            (overflow_to_inf, round_up)))
         | FPRounding_NEGINF =>
            (let (round_up :: bool) =
              ((((error \<noteq> (realFromFrac(( 0 :: int))(( 10 :: int)))))) \<and> (((sign = (vec_of_bits [B1]  ::  1 Word.word))))) in
            (let (overflow_to_inf :: bool) = (sign = (vec_of_bits [B1]  ::  1 Word.word)) in
            (overflow_to_inf, round_up)))
         | FPRounding_ZERO =>
            (let (round_up :: bool) = False in
            (let (overflow_to_inf :: bool) = False in
            (overflow_to_inf, round_up)))
         | FPRounding_ODD =>
            (let (round_up :: bool) = False in
            (let (overflow_to_inf :: bool) = False in
            (overflow_to_inf, round_up)))
         )) in
       (let ((biased_exp :: ii), (int_mant :: ii)) =
         (if round_up then
           (let (int_mant :: ii) = (((ex_int int_mant)) + (( 1 :: int)::ii)) in
           (let (biased_exp :: ii) =
             (if (((((ex_int int_mant)) = ((pow2 (( 23 :: int)::ii)))))) then (( 1 :: int)::ii)
             else biased_exp) in
           (let ((biased_exp :: ii), (int_mant :: ii)) =
             (if (((((ex_int int_mant)) = ((pow2 (( 24 :: int)::ii)))))) then
               (let (biased_exp :: ii) = (((ex_int biased_exp)) + (( 1 :: int)::ii)) in
               (let (int_mant :: ii) = (((ex_int int_mant)) div (( 2 :: int)::ii)) in
               (biased_exp, int_mant)))
             else (biased_exp, int_mant)) in
           (biased_exp, int_mant))))
         else (biased_exp, int_mant)) in
       (let (int_mant :: ii) =
         (if ((((((error \<noteq> (realFromFrac(( 0 :: int))(( 10 :: int)))))) \<and> (((rounding = FPRounding_ODD)))))) then
           set_slice_int (( 1 :: int)::ii) int_mant (( 0 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)
         else int_mant) in
       (if ((((ex_int biased_exp)) \<ge> ((((pow2 (( 8 :: int)::ii))) - (( 1 :: int)::ii))))) then
          (if overflow_to_inf then (FPInfinity (( 32 :: int)::ii) sign  :: ( 32 Word.word) M)
           else (FPMaxNormal (( 32 :: int)::ii) sign  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__14 ::  32 Word.word) . 
          (let result = w__14 in
          FPProcessException FPExc_Overflow fpcr \<then>
          ((let (error :: real) = (realFromFrac(( 10 :: int))(( 10 :: int))) in
          return (error, result)))))
        else
          (let (result :: 32 bits) =
            ((concat_vec
               ((concat_vec sign
                   ((GetSlice_int
                       ((make_the_value (((((( 32 :: int)::ii) - (( 23 :: int)::ii))) - (( 1 :: int)::ii)))
                          ::  8 itself)) biased_exp (( 0 :: int)::ii)
                      ::  8 Word.word))
                  ::  9 Word.word))
               ((GetSlice_int ((make_the_value (( 23 :: int)::ii)  ::  23 itself)) int_mant (( 0 :: int)::ii)
                  ::  23 Word.word))
              ::  32 Word.word)) in
          return (error, result))) \<bind> (\<lambda> varstup .  (let ((error :: real), (result :: 32 bits)) = varstup in
       (if (((error \<noteq> (realFromFrac(( 0 :: int))(( 10 :: int)))))) then FPProcessException FPExc_Inexact fpcr
        else return () ) \<then>
       return ((Word.ucast result  :: ( 'N::len)Word.word))))))))))))))))))))))))))
   else if (((p00 = (( 64 :: int)::ii)))) then
     (((assert_exp True ('''') \<then>
     assert_exp (((op1 \<noteq> (realFromFrac(( 0 :: int))(( 10 :: int)))))) ('''')) \<then>
     assert_exp (((rounding \<noteq> FPRounding_TIEAWAY))) ('''')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (result :: 64 bits) . 
     undefined_int ()  \<bind> (\<lambda> (F_mut :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (E_mut :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (minimum_exp :: ii) . 
     (let minimum_exp = (- (( 1022 :: int)::ii)) in
     (let E_mut = ((( 11 :: int)::ii)) in
     (let F_mut = ((( 52 :: int)::ii)) in
     (assert_exp True ('''') \<then>
     undefined_real () ) \<bind> (\<lambda> (mantissa :: real) . 
     (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (sign :: 1 bits) . 
     (let ((mantissa :: real), (sign :: 1 bits)) =
       (if ((op1 < (realFromFrac(( 0 :: int))(( 10 :: int))))) then
         (let (sign :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
         (let (mantissa :: real) = (- op1) in
         (mantissa, sign)))
       else
         (let (sign :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
         (let (mantissa :: real) = op1 in
         (mantissa, sign)))) in
     (let (exponent :: ii) = ((( 0 :: int)::ii)) in
     (let ((exponent :: ii), (mantissa :: real)) =
       (while (exponent, mantissa)
         (\<lambda> varstup .  (let (exponent, mantissa) = varstup in mantissa < (realFromFrac(( 10 :: int))(( 10 :: int)))))
         (\<lambda> varstup .  (let (exponent, mantissa) = varstup in
           (let (mantissa :: real) = (mantissa * (realFromFrac(( 20 :: int))(( 10 :: int)))) in
           (let (exponent :: ii) = (((ex_int exponent)) - (( 1 :: int)::ii)) in
           (exponent, mantissa)))))) in
     (let ((exponent :: ii), (mantissa :: real)) =
       (while (exponent, mantissa)
         (\<lambda> varstup .  (let (exponent, mantissa) = varstup in mantissa \<ge> (realFromFrac(( 20 :: int))(( 10 :: int)))))
         (\<lambda> varstup .  (let (exponent, mantissa) = varstup in
           (let (mantissa :: real) = (mantissa div (realFromFrac(( 20 :: int))(( 10 :: int)))) in
           (let (exponent :: ii) = (((ex_int exponent)) + (( 1 :: int)::ii)) in
           (exponent, mantissa)))))) in
     if (((((((((((((vec_of_bits [access_vec_dec fpcr (( 24 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> True))) \<or> (((((((vec_of_bits [access_vec_dec fpcr (( 19 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> False)))))) \<and> ((((ex_int exponent)) < ((ex_int minimum_exp))))))) then
       UsingAArch32 ()  \<bind> (\<lambda> (w__16 :: bool) . 
       ((if w__16 then
          (read_reg FPSCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__17 :: 32 bits) . 
          write_reg
            FPSCR_ref
            ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__17 (( 3 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)  ::  32 Word.word)))
        else
          (read_reg FPSR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__18 :: 32 bits) . 
          write_reg
            FPSR_ref
            ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__18 (( 3 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)  ::  32 Word.word)))) \<then>
       (FPZero (( 64 :: int)::ii) sign  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__19 ::  64 Word.word) . 
       return ((Word.ucast w__19  :: ( 'N::len)Word.word))))
     else
       (let (biased_exp :: ii) =
         (max ((((((ex_int exponent)) - ((ex_int minimum_exp)))) + (( 1 :: int)::ii)))
           (( 0 :: int)::ii)) in
       (let (mantissa :: real) =
         (if (((((ex_int biased_exp)) = (( 0 :: int)::ii)))) then
           mantissa div
             ((realPowInteger (realFromFrac(( 20 :: int))(( 10 :: int)))
                 ((((ex_int minimum_exp)) - ((ex_int exponent))))))
         else mantissa) in
       (let (int_mant :: ii) =
         (floor ((mantissa * ((realPowInteger (realFromFrac(( 20 :: int))(( 10 :: int))) (( 52 :: int)::ii)))))) in
       (let (error :: real) =
         (((mantissa * ((realPowInteger (realFromFrac(( 20 :: int))(( 10 :: int))) (( 52 :: int)::ii))))) -
           (((real_of_int int_mant)))) in
       ((if ((((((((ex_int biased_exp)) = (( 0 :: int)::ii)))) \<and> ((((((error \<noteq> (realFromFrac(( 0 :: int))(( 10 :: int)))))) \<or> ((((vec_of_bits [access_vec_dec fpcr (( 11 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))))) then
          FPProcessException FPExc_Underflow fpcr
        else return () ) \<then>
       undefined_bool () ) \<bind> (\<lambda> (overflow_to_inf :: bool) . 
       undefined_bool ()  \<bind> (\<lambda> (round_up :: bool) . 
       (let ((overflow_to_inf :: bool), (round_up :: bool)) =
         ((case  rounding of
           FPRounding_TIEEVEN =>
            (let (round_up :: bool) =
              (((error > (realFromFrac(( 5 :: int))(( 10 :: int))))) \<or> ((((((error = (realFromFrac(( 5 :: int))(( 10 :: int)))))) \<and> (((((GetSlice_int ((make_the_value (( 1 :: int)::ii)  ::  1 itself)) int_mant (( 0 :: int)::ii)
                           ::  1 Word.word)) = (vec_of_bits [B1]  ::  1 Word.word)))))))) in
            (let (overflow_to_inf :: bool) = True in
            (overflow_to_inf, round_up)))
         | FPRounding_POSINF =>
            (let (round_up :: bool) =
              ((((error \<noteq> (realFromFrac(( 0 :: int))(( 10 :: int)))))) \<and> (((sign = (vec_of_bits [B0]  ::  1 Word.word))))) in
            (let (overflow_to_inf :: bool) = (sign = (vec_of_bits [B0]  ::  1 Word.word)) in
            (overflow_to_inf, round_up)))
         | FPRounding_NEGINF =>
            (let (round_up :: bool) =
              ((((error \<noteq> (realFromFrac(( 0 :: int))(( 10 :: int)))))) \<and> (((sign = (vec_of_bits [B1]  ::  1 Word.word))))) in
            (let (overflow_to_inf :: bool) = (sign = (vec_of_bits [B1]  ::  1 Word.word)) in
            (overflow_to_inf, round_up)))
         | FPRounding_ZERO =>
            (let (round_up :: bool) = False in
            (let (overflow_to_inf :: bool) = False in
            (overflow_to_inf, round_up)))
         | FPRounding_ODD =>
            (let (round_up :: bool) = False in
            (let (overflow_to_inf :: bool) = False in
            (overflow_to_inf, round_up)))
         )) in
       (let ((biased_exp :: ii), (int_mant :: ii)) =
         (if round_up then
           (let (int_mant :: ii) = (((ex_int int_mant)) + (( 1 :: int)::ii)) in
           (let (biased_exp :: ii) =
             (if (((((ex_int int_mant)) = ((pow2 (( 52 :: int)::ii)))))) then (( 1 :: int)::ii)
             else biased_exp) in
           (let ((biased_exp :: ii), (int_mant :: ii)) =
             (if (((((ex_int int_mant)) = ((pow2 (( 53 :: int)::ii)))))) then
               (let (biased_exp :: ii) = (((ex_int biased_exp)) + (( 1 :: int)::ii)) in
               (let (int_mant :: ii) = (((ex_int int_mant)) div (( 2 :: int)::ii)) in
               (biased_exp, int_mant)))
             else (biased_exp, int_mant)) in
           (biased_exp, int_mant))))
         else (biased_exp, int_mant)) in
       (let (int_mant :: ii) =
         (if ((((((error \<noteq> (realFromFrac(( 0 :: int))(( 10 :: int)))))) \<and> (((rounding = FPRounding_ODD)))))) then
           set_slice_int (( 1 :: int)::ii) int_mant (( 0 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)
         else int_mant) in
       (if ((((ex_int biased_exp)) \<ge> ((((pow2 (( 11 :: int)::ii))) - (( 1 :: int)::ii))))) then
          (if overflow_to_inf then (FPInfinity (( 64 :: int)::ii) sign  :: ( 64 Word.word) M)
           else (FPMaxNormal (( 64 :: int)::ii) sign  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__22 ::  64 Word.word) . 
          (let result = w__22 in
          FPProcessException FPExc_Overflow fpcr \<then>
          ((let (error :: real) = (realFromFrac(( 10 :: int))(( 10 :: int))) in
          return (error, result)))))
        else
          (let (result :: 64 bits) =
            ((concat_vec
               ((concat_vec sign
                   ((GetSlice_int
                       ((make_the_value (((((( 64 :: int)::ii) - (( 52 :: int)::ii))) - (( 1 :: int)::ii)))
                          ::  11 itself)) biased_exp (( 0 :: int)::ii)
                      ::  11 Word.word))
                  ::  12 Word.word))
               ((GetSlice_int ((make_the_value (( 52 :: int)::ii)  ::  52 itself)) int_mant (( 0 :: int)::ii)
                  ::  52 Word.word))
              ::  64 Word.word)) in
          return (error, result))) \<bind> (\<lambda> varstup .  (let ((error :: real), (result :: 64 bits)) = varstup in
       (if (((error \<noteq> (realFromFrac(( 0 :: int))(( 10 :: int)))))) then FPProcessException FPExc_Inexact fpcr
        else return () ) \<then>
       return ((Word.ucast result  :: ( 'N::len)Word.word))))))))))))))))))))))))))
   else assert_exp False ('''') \<then> exit0 () ))"


(*val FPRoundCV : forall 'N . Size 'N => integer -> real -> mword ty32 -> FPRounding -> M (mword 'N)*)

definition FPRoundCV  :: " int \<Rightarrow> real \<Rightarrow>(32)Word.word \<Rightarrow> FPRounding \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " FPRoundCV (N__tv :: int) op1 fpcr__arg rounding = (
   (let fpcr = fpcr__arg in
   (let fpcr = ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) fpcr (( 19 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word)) in
   (FPRoundBase N__tv op1 fpcr rounding  :: (( 'N::len)Word.word) M))))"


(*val FPRound__0 : forall 'N . Size 'N => integer -> real -> mword ty32 -> FPRounding -> M (mword 'N)*)

(*val FPRound__1 : forall 'N . Size 'N => integer -> real -> mword ty32 -> M (mword 'N)*)

definition FPRound__0  :: " int \<Rightarrow> real \<Rightarrow>(32)Word.word \<Rightarrow> FPRounding \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " FPRound__0 (N__tv :: int) op1 fpcr__arg rounding = (
   (let fpcr = fpcr__arg in
   (let fpcr = ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) fpcr (( 26 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word)) in
   (FPRoundBase N__tv op1 fpcr rounding  :: (( 'N::len)Word.word) M))))"


definition FPRound__1  :: " int \<Rightarrow> real \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " FPRound__1 (N__tv :: int) op1 fpcr = (
   (FPRound__0 N__tv op1 fpcr ((FPRoundingMode fpcr))  :: (( 'N::len)Word.word) M))"


(*val FixedToFP : forall 'M 'N . Size 'M, Size 'N => integer -> mword 'M -> ii -> bool -> mword ty32 -> FPRounding -> M (mword 'N)*)

definition FixedToFP  :: " int \<Rightarrow>('M::len)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>(32)Word.word \<Rightarrow> FPRounding \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " FixedToFP (N__tv :: int) op1 fbits unsigned fpcr rounding = (
   ((assert_exp ((((((N__tv = (( 16 :: int)::ii)))) \<or> ((((((N__tv = (( 32 :: int)::ii)))) \<or> (((N__tv = (( 64 :: int)::ii)))))))))) ('''') \<then>
   assert_exp ((((((((int (size op1))) = (( 16 :: int)::ii)))) \<or> ((((((((int (size op1))) = (( 32 :: int)::ii)))) \<or> (((((int (size op1))) = (( 64 :: int)::ii)))))))))) ('''')) \<then>
   (undefined_bitvector N__tv  :: (( 'N::len)Word.word) M)) \<bind> (\<lambda> result . 
   (assert_exp ((fbits \<ge> (( 0 :: int)::ii))) ('''') \<then>
   assert_exp (((rounding \<noteq> FPRounding_ODD))) ('''')) \<then>
   ((let (int_operand :: ii) = (asl_Int op1 unsigned) in
   (let (real_operand :: real) =
     ((((real_of_int int_operand))) div ((realPowInteger (realFromFrac(( 20 :: int))(( 10 :: int))) fbits))) in
   if (((real_operand = (realFromFrac(( 0 :: int))(( 10 :: int)))))) then
     (FPZero ((int (size result))) (vec_of_bits [B0]  ::  1 Word.word)  :: (( 'N::len)Word.word) M)
   else (FPRound__0 ((int (size result))) real_operand fpcr rounding  :: (( 'N::len)Word.word) M))))))"


(*val FPProcessNaN : forall 'N . Size 'N => FPType -> mword 'N -> mword ty32 -> M (mword 'N)*)

definition FPProcessNaN  :: " FPType \<Rightarrow>('N::len)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " FPProcessNaN typ1 op1 fpcr = (
   ((assert_exp ((((((((int (size op1))) = (( 16 :: int)::ii)))) \<or> ((((((((int (size op1))) = (( 32 :: int)::ii)))) \<or> (((((int (size op1))) = (( 64 :: int)::ii)))))))))) (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
   assert_exp ((((((typ1 = FPType_QNaN))) \<or> (((typ1 = FPType_SNaN)))))) (''((type == FPType_QNaN) || (type == FPType_SNaN))'')) \<then>
   undefined_int () ) \<bind> (\<lambda> (topfrac :: ii) . 
   (let p00 = (int (size op1)) in
   (let (topfrac :: ii) =
     (if (((p00 = (( 16 :: int)::ii)))) then
       (let (op1 ::  16 Word.word) = ((Word.ucast op1  ::  16 Word.word)) in
       (( 9 :: int)::ii))
     else if (((p00 = (( 32 :: int)::ii)))) then
       (let (op1 ::  32 Word.word) = ((Word.ucast op1  ::  32 Word.word)) in
       (( 22 :: int)::ii))
     else
       (let (op1 ::  64 Word.word) = ((Word.ucast op1  ::  64 Word.word)) in
       (( 51 :: int)::ii))) in
   (let result = op1 in
   (if (((typ1 = FPType_SNaN))) then
      (let result =
        ((set_slice ((int (size op1))) (( 1 :: int)::ii) result topfrac (vec_of_bits [B1]  ::  1 Word.word)  :: ( 'N::len)Word.word)) in
      FPProcessException FPExc_InvalidOp fpcr \<then> return result)
    else return result) \<bind> (\<lambda> result . 
   if ((((vec_of_bits [access_vec_dec fpcr (( 25 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
     (FPDefaultNaN ((int (size op1))) ()   :: (( 'N::len)Word.word) M)
   else return result))))))"


(*val FPProcessNaNs3 : forall 'N . Size 'N => FPType -> FPType -> FPType -> mword 'N -> mword 'N -> mword 'N -> mword ty32 -> M (bool * mword 'N)*)

definition FPProcessNaNs3  :: " FPType \<Rightarrow> FPType \<Rightarrow> FPType \<Rightarrow>('N::len)Word.word \<Rightarrow>('N::len)Word.word \<Rightarrow>('N::len)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(bool*('N::len)Word.word),(exception))monad "  where 
     " FPProcessNaNs3 type1 type2 type3 op1 op2 op3 fpcr = (
   (assert_exp ((((((((int (size op1))) = (( 16 :: int)::ii)))) \<or> ((((((((int (size op1))) = (( 32 :: int)::ii)))) \<or> (((((int (size op1))) = (( 64 :: int)::ii)))))))))) (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
   (undefined_bitvector ((int (size op1)))  :: (( 'N::len)Word.word) M)) \<bind> (\<lambda> result . 
   undefined_bool ()  \<bind> (\<lambda> (done1 :: bool) . 
   if (((type1 = FPType_SNaN))) then
     (let done1 = True in
     (FPProcessNaN type1 op1 fpcr  :: (( 'N::len)Word.word) M) \<bind> (\<lambda> (w__0 :: ( 'N::len)Word.word) . 
     (let result = w__0 in
     return (done1, result))))
   else if (((type2 = FPType_SNaN))) then
     (let done1 = True in
     (FPProcessNaN type2 op2 fpcr  :: (( 'N::len)Word.word) M) \<bind> (\<lambda> (w__1 :: ( 'N::len)Word.word) . 
     (let result = w__1 in
     return (done1, result))))
   else if (((type3 = FPType_SNaN))) then
     (let done1 = True in
     (FPProcessNaN type3 op3 fpcr  :: (( 'N::len)Word.word) M) \<bind> (\<lambda> (w__2 :: ( 'N::len)Word.word) . 
     (let result = w__2 in
     return (done1, result))))
   else if (((type1 = FPType_QNaN))) then
     (let done1 = True in
     (FPProcessNaN type1 op1 fpcr  :: (( 'N::len)Word.word) M) \<bind> (\<lambda> (w__3 :: ( 'N::len)Word.word) . 
     (let result = w__3 in
     return (done1, result))))
   else if (((type2 = FPType_QNaN))) then
     (let done1 = True in
     (FPProcessNaN type2 op2 fpcr  :: (( 'N::len)Word.word) M) \<bind> (\<lambda> (w__4 :: ( 'N::len)Word.word) . 
     (let result = w__4 in
     return (done1, result))))
   else if (((type3 = FPType_QNaN))) then
     (let done1 = True in
     (FPProcessNaN type3 op3 fpcr  :: (( 'N::len)Word.word) M) \<bind> (\<lambda> (w__5 :: ( 'N::len)Word.word) . 
     (let result = w__5 in
     return (done1, result))))
   else
     (let (done1 :: bool) = False in
     (let result = ((Zeros__1 ((int (size op1))) ()   :: ( 'N::len)Word.word)) in
     return (done1, result))))))"


(*val FPProcessNaNs : forall 'N . Size 'N => FPType -> FPType -> mword 'N -> mword 'N -> mword ty32 -> M (bool * mword 'N)*)

definition FPProcessNaNs  :: " FPType \<Rightarrow> FPType \<Rightarrow>('N::len)Word.word \<Rightarrow>('N::len)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(bool*('N::len)Word.word),(exception))monad "  where 
     " FPProcessNaNs type1 type2 op1 op2 fpcr = (
   (assert_exp ((((((((int (size op1))) = (( 16 :: int)::ii)))) \<or> ((((((((int (size op1))) = (( 32 :: int)::ii)))) \<or> (((((int (size op1))) = (( 64 :: int)::ii)))))))))) (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
   (undefined_bitvector ((int (size op1)))  :: (( 'N::len)Word.word) M)) \<bind> (\<lambda> result . 
   undefined_bool ()  \<bind> (\<lambda> (done1 :: bool) . 
   if (((type1 = FPType_SNaN))) then
     (let done1 = True in
     (FPProcessNaN type1 op1 fpcr  :: (( 'N::len)Word.word) M) \<bind> (\<lambda> (w__0 :: ( 'N::len)Word.word) . 
     (let result = w__0 in
     return (done1, result))))
   else if (((type2 = FPType_SNaN))) then
     (let done1 = True in
     (FPProcessNaN type2 op2 fpcr  :: (( 'N::len)Word.word) M) \<bind> (\<lambda> (w__1 :: ( 'N::len)Word.word) . 
     (let result = w__1 in
     return (done1, result))))
   else if (((type1 = FPType_QNaN))) then
     (let done1 = True in
     (FPProcessNaN type1 op1 fpcr  :: (( 'N::len)Word.word) M) \<bind> (\<lambda> (w__2 :: ( 'N::len)Word.word) . 
     (let result = w__2 in
     return (done1, result))))
   else if (((type2 = FPType_QNaN))) then
     (let done1 = True in
     (FPProcessNaN type2 op2 fpcr  :: (( 'N::len)Word.word) M) \<bind> (\<lambda> (w__3 :: ( 'N::len)Word.word) . 
     (let result = w__3 in
     return (done1, result))))
   else
     (let (done1 :: bool) = False in
     (let result = ((Zeros__1 ((int (size op1))) ()   :: ( 'N::len)Word.word)) in
     return (done1, result))))))"


(*val CurrentInstrSet : unit -> M InstrSet*)

definition CurrentInstrSet  :: " unit \<Rightarrow>((register_value),(InstrSet),(exception))monad "  where 
     " CurrentInstrSet _ = (
   undefined_InstrSet ()  \<bind> (\<lambda> (result :: InstrSet) . 
   UsingAArch32 ()  \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then
     read_reg PSTATE_ref \<bind> (\<lambda> (w__1 :: ProcState) . 
     (let (result :: InstrSet) =
       (if ((((ProcState_T   w__1) = (vec_of_bits [B0]  ::  1 Word.word)))) then InstrSet_A32
       else InstrSet_T32) in
     return result))
   else return InstrSet_A64)))"


(*val AArch32_ExecutingLSMInstr : unit -> M bool*)

definition AArch32_ExecutingLSMInstr  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " AArch32_ExecutingLSMInstr _ = (
   (ThisInstr0 ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (instr :: 32 bits) . 
   CurrentInstrSet ()  \<bind> (\<lambda> (instr_set :: InstrSet) . 
   assert_exp ((((((instr_set = InstrSet_A32))) \<or> (((instr_set = InstrSet_T32)))))) (''((instr_set == InstrSet_A32) || (instr_set == InstrSet_T32))'') \<then>
   (if (((instr_set = InstrSet_A32))) then
     return ((((((((slice instr (( 28 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) \<noteq> (vec_of_bits [B1,B1,B1,B1]  ::  4 Word.word)))) \<and> (((((slice instr (( 25 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))))))
   else
     ThisInstrLength ()  \<bind> (\<lambda> (w__0 :: ii) . 
     return (if (((((ex_int w__0)) = (( 16 :: int)::ii)))) then
               (((slice instr (( 12 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) = (vec_of_bits [B1,B1,B0,B0]  ::  4 Word.word))
             else
               ((((((slice instr (( 25 :: int)::ii) (( 7 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B1,B0,B0]  ::  7 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec instr (( 22 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))))))))"


(*val AArch32_ExecutingCP10or11Instr : unit -> M bool*)

definition AArch32_ExecutingCP10or11Instr  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " AArch32_ExecutingCP10or11Instr _ = (
   (ThisInstr0 ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (instr :: 32 bits) . 
   CurrentInstrSet ()  \<bind> (\<lambda> (instr_set :: InstrSet) . 
   assert_exp ((((((instr_set = InstrSet_A32))) \<or> (((instr_set = InstrSet_T32)))))) (''((instr_set == InstrSet_A32) || (instr_set == InstrSet_T32))'') \<then>
   return (if (((instr_set = InstrSet_A32))) then
             (((((((((slice instr (( 24 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) = (vec_of_bits [B1,B1,B1,B0]  ::  4 Word.word)))) \<or> (((((slice instr (( 25 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B0]  ::  3 Word.word))))))) \<and> (((((and_vec ((slice instr (( 8 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
                       (vec_of_bits [B1,B1,B1,B0]  ::  4 Word.word)
                      ::  4 Word.word)) = (vec_of_bits [B1,B0,B1,B0]  ::  4 Word.word)))))
           else
             (((((((((and_vec ((slice instr (( 28 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
                           (vec_of_bits [B1,B1,B1,B0]  ::  4 Word.word)
                          ::  4 Word.word)) = (vec_of_bits [B1,B1,B1,B0]  ::  4 Word.word)))) \<and> ((((((((slice instr (( 24 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) = (vec_of_bits [B1,B1,B1,B0]  ::  4 Word.word)))) \<or> (((((slice instr (( 25 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))))))))) \<and> (((((and_vec ((slice instr (( 8 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
                       (vec_of_bits [B1,B1,B1,B0]  ::  4 Word.word)
                      ::  4 Word.word)) = (vec_of_bits [B1,B0,B1,B0]  ::  4 Word.word)))))))))"


(*val HaveAnyAArch64 : unit -> bool*)

definition HaveAnyAArch64  :: " unit \<Rightarrow> bool "  where 
     " HaveAnyAArch64 _ = ( \<not> ((HighestELUsingAArch32 () )))"


(*val AArch32_ReportDeferredSError : mword ty2 -> mword ty1 -> M (mword ty32)*)

definition AArch32_ReportDeferredSError  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),((32)Word.word),(exception))monad "  where 
     " AArch32_ReportDeferredSError AET ExT = (
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (target :: 32 bits) . 
   (let (target :: 32 bits) =
     ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) target (( 31 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)  ::  32 Word.word)) in
   (let (syndrome :: 16 bits) = ((Zeros__0 ((make_the_value (( 16 :: int)::ii)  ::  16 itself))  ::  16 Word.word)) in
   read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) . 
   (if ((((ProcState_EL   w__0) = EL2))) then
      (let (syndrome :: 16 bits) =
        ((update_subrange_vec_dec syndrome (( 11 :: int)::ii) (( 10 :: int)::ii) AET  ::  16 Word.word)) in
      (let (syndrome :: 16 bits) =
        ((update_subrange_vec_dec syndrome (( 9 :: int)::ii) (( 9 :: int)::ii) ExT  ::  16 Word.word)) in
      (let (syndrome :: 16 bits) =
        ((update_subrange_vec_dec syndrome (( 5 :: int)::ii) (( 0 :: int)::ii)
           (vec_of_bits [B0,B1,B0,B0,B0,B1]  ::  6 Word.word)
          ::  16 Word.word)) in
      return syndrome)))
    else
      (let syndrome = ((update_subrange_vec_dec syndrome (( 15 :: int)::ii) (( 14 :: int)::ii) AET  ::  16 Word.word)) in
      (let syndrome = ((update_subrange_vec_dec syndrome (( 12 :: int)::ii) (( 12 :: int)::ii) ExT  ::  16 Word.word)) in
      (read_reg TTBCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 :: 32 bits) . 
      (let syndrome =
        ((update_subrange_vec_dec syndrome (( 9 :: int)::ii) (( 9 :: int)::ii)
           (vec_of_bits [access_vec_dec w__1 (( 31 :: int)::ii)]  ::  1 Word.word)
          ::  16 Word.word)) in
      (read_reg TTBCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__2 :: 32 bits) . 
      (let (syndrome :: 16 bits) =
        (if ((((vec_of_bits [access_vec_dec w__2 (( 31 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
          (update_subrange_vec_dec syndrome (( 5 :: int)::ii) (( 0 :: int)::ii)
             (vec_of_bits [B0,B1,B0,B0,B0,B1]  ::  6 Word.word)
            ::  16 Word.word)
        else
          (let (tup__0, tup__1) =
            ((vec_of_bits [B1]  ::  1 Word.word), (vec_of_bits [B0,B1,B1,B0]  ::  4 Word.word)) in
          (let (syndrome :: 16 bits) =
            ((update_subrange_vec_dec syndrome (( 10 :: int)::ii) (( 10 :: int)::ii) tup__0  ::  16 Word.word)) in
          (update_subrange_vec_dec syndrome (( 3 :: int)::ii) (( 0 :: int)::ii) tup__1  ::  16 Word.word)))) in
      return syndrome))))))) \<bind> (\<lambda> (syndrome :: 16 bits) . 
   if ((HaveAnyAArch64 () )) then
     (ZeroExtend__0 syndrome ((make_the_value (( 25 :: int)::ii)  ::  25 itself))  :: ( 25 Word.word) M) \<bind> (\<lambda> (w__3 ::
        25 Word.word) . 
     (let (target :: 32 bits) = ((update_subrange_vec_dec target (( 24 :: int)::ii) (( 0 :: int)::ii) w__3  ::  32 Word.word)) in
     return target))
   else
     (let (target :: 32 bits) =
       ((update_subrange_vec_dec target (( 15 :: int)::ii) (( 0 :: int)::ii) syndrome  ::  32 Word.word)) in
     return target)))))))"


(*val HaveAArch32EL : mword ty2 -> bool*)

definition HaveAArch32EL  :: "(2)Word.word \<Rightarrow> bool "  where 
     " HaveAArch32EL el = (
   if ((\<not> ((HaveEL el)))) then False
   else if ((\<not> ((HaveAnyAArch32 () )))) then False
   else if ((HighestELUsingAArch32 () )) then True
   else if (((el = ((HighestEL ()   ::  2 Word.word))))) then False
   else if (((el = EL0))) then True
   else True )"


(*val AArch64_ResetSpecialRegisters : unit -> M unit*)

definition AArch64_ResetSpecialRegisters  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_ResetSpecialRegisters _ = (
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (write_reg SP_EL0_ref w__0 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   (write_reg SP_EL1_ref w__1 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__2 ::  32 Word.word) . 
   (write_reg SPSR_EL1_ref w__2 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__3 ::  64 Word.word) . 
   ((((write_reg ELR_EL1_ref w__3 \<then>
   (if ((HaveEL EL2)) then
      (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 ::  64 Word.word) . 
      (write_reg SP_EL2_ref w__4 \<then>
      (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__5 ::  32 Word.word) . 
      (write_reg SPSR_EL2_ref w__5 \<then>
      (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__6 ::  64 Word.word) . 
      write_reg ELR_EL2_ref w__6)))
    else return () )) \<then>
   (if ((HaveEL EL3)) then
      (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__7 ::  64 Word.word) . 
      (write_reg SP_EL3_ref w__7 \<then>
      (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__8 ::  32 Word.word) . 
      (write_reg SPSR_EL3_ref w__8 \<then>
      (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__9 ::  64 Word.word) . 
      write_reg ELR_EL3_ref w__9)))
    else return () )) \<then>
   (if ((HaveAArch32EL EL1)) then
      (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__10 ::  32 Word.word) . 
      (write_reg SPSR_fiq_ref w__10 \<then>
      (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__11 ::  32 Word.word) . 
      (write_reg SPSR_irq_ref w__11 \<then>
      (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__12 ::  32 Word.word) . 
      (write_reg SPSR_abt_ref w__12 \<then>
      (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__13 ::  32 Word.word) . 
      write_reg SPSR_und_ref w__13))))
    else return () )) \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__14 ::  64 Word.word) . 
   (write_reg DLR_EL0_ref w__14 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__15 ::  32 Word.word) . 
   write_reg DSPSR_EL0_ref w__15)))))))"


(*val Halted : unit -> M bool*)

definition Halted  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " Halted _ = (
   or_boolM
     ((read_reg EDSCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 :: 32 bits) . 
      return (((((slice w__0 (( 0 :: int)::ii) (( 6 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1]  ::  6 Word.word))))))
     ((read_reg EDSCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 :: 32 bits) . 
      return (((((slice w__1 (( 0 :: int)::ii) (( 6 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B1,B0]  ::  6 Word.word)))))) \<bind> (\<lambda> (w__2 :: bool) . 
   return ((\<not> w__2))))"


(*val FPUnpackBase : forall 'N . Size 'N => mword 'N -> mword ty32 -> M (FPType * mword ty1 * real)*)

definition FPUnpackBase  :: "('N::len)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(FPType*(1)Word.word*real),(exception))monad "  where 
     " FPUnpackBase fpval fpcr = (
   (assert_exp ((((((((int (size fpval))) = (( 16 :: int)::ii)))) \<or> ((((((((int (size fpval))) = (( 32 :: int)::ii)))) \<or> (((((int (size fpval))) = (( 64 :: int)::ii)))))))))) (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
   (undefined_bitvector (( 52 :: int)::ii)  :: ( 52 Word.word) M)) \<bind> (\<lambda> (frac64 :: 52 bits) . 
   (undefined_bitvector (( 11 :: int)::ii)  :: ( 11 Word.word) M) \<bind> (\<lambda> (exp64 :: 11 bits) . 
   (undefined_bitvector (( 23 :: int)::ii)  :: ( 23 Word.word) M) \<bind> (\<lambda> (frac32 :: 23 bits) . 
   (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> (\<lambda> (exp32 :: 8 bits) . 
   undefined_real ()  \<bind> (\<lambda> (value_name :: real) . 
   undefined_FPType ()  \<bind> (\<lambda> (typ1 :: FPType) . 
   (undefined_bitvector (( 10 :: int)::ii)  :: ( 10 Word.word) M) \<bind> (\<lambda> (frac16 :: 10 bits) . 
   (undefined_bitvector (( 5 :: int)::ii)  :: ( 5 Word.word) M) \<bind> (\<lambda> (exp16 :: 5 bits) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (sign :: 1 bits) . 
   (if (((((int (size fpval))) = (( 16 :: int)::ii)))) then
      (let (fpval ::  16 Word.word) = ((Word.ucast fpval  ::  16 Word.word)) in
      (let (sign :: 1 bits) = ((vec_of_bits [access_vec_dec fpval (( 15 :: int)::ii)]  ::  1 Word.word)) in
      (let (exp16 :: 5 bits) = ((slice fpval (( 10 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
      (let (frac16 :: 10 bits) = ((slice fpval (( 0 :: int)::ii) (( 10 :: int)::ii)  ::  10 Word.word)) in
      (let ((typ1 :: FPType), (value_name :: real)) =
        (if ((IsZero exp16)) then
          (let ((typ1 :: FPType), (value_name :: real)) =
            (if (((((IsZero frac16)) \<or> ((((vec_of_bits [access_vec_dec fpcr (( 19 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))) then
              (let (typ1 :: FPType) = FPType_Zero in
              (let (value_name :: real) = (realFromFrac(( 0 :: int))(( 10 :: int))) in
              (typ1, value_name)))
            else
              (let (typ1 :: FPType) = FPType_Nonzero in
              (let (value_name :: real) =
                (((realPowInteger (realFromFrac(( 20 :: int))(( 10 :: int))) ((- (( 14 :: int)::ii))))) *
                  (((((real_of_int ((Word.uint frac16))))) *
                      ((realPowInteger (realFromFrac(( 20 :: int))(( 10 :: int))) ((- (( 10 :: int)::ii)))))))) in
              (typ1, value_name)))) in
          (typ1, value_name))
        else
          (let ((typ1 :: FPType), (value_name :: real)) =
            (if (((((IsOnes exp16)) \<and> ((((vec_of_bits [access_vec_dec fpcr (( 26 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))) then
              (let ((typ1 :: FPType), (value_name :: real)) =
                (if ((IsZero frac16)) then
                  (let (typ1 :: FPType) = FPType_Infinity in
                  (let (value_name :: real) = (realPowInteger (realFromFrac(( 20 :: int))(( 10 :: int))) (( 1000000 :: int)::ii)) in
                  (typ1, value_name)))
                else
                  (let (typ1 :: FPType) =
                    (if ((((vec_of_bits [access_vec_dec frac16 (( 9 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
                      FPType_QNaN
                    else FPType_SNaN) in
                  (let (value_name :: real) = (realFromFrac(( 0 :: int))(( 10 :: int))) in
                  (typ1, value_name)))) in
              (typ1, value_name))
            else
              (let (typ1 :: FPType) = FPType_Nonzero in
              (let (value_name :: real) =
                (((realPowInteger (realFromFrac(( 20 :: int))(( 10 :: int))) ((((Word.uint exp16)) - (( 15 :: int)::ii)))))
                  *
                  (((realFromFrac(( 10 :: int))(( 10 :: int))) +
                      (((((real_of_int ((Word.uint frac16))))) *
                          ((realPowInteger (realFromFrac(( 20 :: int))(( 10 :: int))) ((- (( 10 :: int)::ii)))))))))) in
              (typ1, value_name)))) in
          (typ1, value_name))) in
      return (sign, typ1, value_name))))))
    else if (((((int (size fpval))) = (( 32 :: int)::ii)))) then
      (let (fpval ::  32 Word.word) = ((Word.ucast fpval  ::  32 Word.word)) in
      (let sign = ((vec_of_bits [access_vec_dec fpval (( 31 :: int)::ii)]  ::  1 Word.word)) in
      (let exp32 = ((slice fpval (( 23 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word)) in
      (let frac32 = ((slice fpval (( 0 :: int)::ii) (( 23 :: int)::ii)  ::  23 Word.word)) in
      (if ((IsZero exp32)) then
         if (((((IsZero frac32)) \<or> ((((vec_of_bits [access_vec_dec fpcr (( 24 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))) then
           (let typ1 = FPType_Zero in
           (let value_name = (realFromFrac(( 0 :: int))(( 10 :: int))) in
           (if ((\<not> ((IsZero frac32)))) then FPProcessException FPExc_InputDenorm fpcr
            else return () ) \<then>
           return (typ1, value_name)))
         else
           (let (typ1 :: FPType) = FPType_Nonzero in
           (let (value_name :: real) =
             (((realPowInteger (realFromFrac(( 20 :: int))(( 10 :: int))) ((- (( 126 :: int)::ii))))) *
               (((((real_of_int ((Word.uint frac32))))) *
                   ((realPowInteger (realFromFrac(( 20 :: int))(( 10 :: int))) ((- (( 23 :: int)::ii)))))))) in
           return (typ1, value_name)))
       else
         (let ((typ1 :: FPType), (value_name :: real)) =
           (if ((IsOnes exp32)) then
             (let ((typ1 :: FPType), (value_name :: real)) =
               (if ((IsZero frac32)) then
                 (let (typ1 :: FPType) = FPType_Infinity in
                 (let (value_name :: real) = (realPowInteger (realFromFrac(( 20 :: int))(( 10 :: int))) (( 1000000 :: int)::ii)) in
                 (typ1, value_name)))
               else
                 (let (typ1 :: FPType) =
                   (if ((((vec_of_bits [access_vec_dec frac32 (( 22 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
                     FPType_QNaN
                   else FPType_SNaN) in
                 (let (value_name :: real) = (realFromFrac(( 0 :: int))(( 10 :: int))) in
                 (typ1, value_name)))) in
             (typ1, value_name))
           else
             (let (typ1 :: FPType) = FPType_Nonzero in
             (let (value_name :: real) =
               (((realPowInteger (realFromFrac(( 20 :: int))(( 10 :: int))) ((((Word.uint exp32)) - (( 127 :: int)::ii)))))
                 *
                 (((realFromFrac(( 10 :: int))(( 10 :: int))) +
                     (((((real_of_int ((Word.uint frac32))))) *
                         ((realPowInteger (realFromFrac(( 20 :: int))(( 10 :: int))) ((- (( 23 :: int)::ii)))))))))) in
             (typ1, value_name)))) in
         return (typ1, value_name))) \<bind> (\<lambda> varstup .  (let ((typ1 :: FPType), (value_name :: real)) = varstup in
      return (sign, typ1, value_name)))))))
    else
      (let sign = ((vec_of_bits [access_vec_dec fpval (( 63 :: int)::ii)]  ::  1 Word.word)) in
      (let exp64 = ((slice fpval (( 52 :: int)::ii) (( 11 :: int)::ii)  ::  11 Word.word)) in
      (let frac64 = ((slice fpval (( 0 :: int)::ii) (( 52 :: int)::ii)  ::  52 Word.word)) in
      (if ((IsZero exp64)) then
         if (((((IsZero frac64)) \<or> ((((vec_of_bits [access_vec_dec fpcr (( 24 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))) then
           (let typ1 = FPType_Zero in
           (let value_name = (realFromFrac(( 0 :: int))(( 10 :: int))) in
           (if ((\<not> ((IsZero frac64)))) then FPProcessException FPExc_InputDenorm fpcr
            else return () ) \<then>
           return (typ1, value_name)))
         else
           (let (typ1 :: FPType) = FPType_Nonzero in
           (let (value_name :: real) =
             (((realPowInteger (realFromFrac(( 20 :: int))(( 10 :: int))) ((- (( 1022 :: int)::ii))))) *
               (((((real_of_int ((Word.uint frac64))))) *
                   ((realPowInteger (realFromFrac(( 20 :: int))(( 10 :: int))) ((- (( 52 :: int)::ii)))))))) in
           return (typ1, value_name)))
       else
         (let ((typ1 :: FPType), (value_name :: real)) =
           (if ((IsOnes exp64)) then
             (let ((typ1 :: FPType), (value_name :: real)) =
               (if ((IsZero frac64)) then
                 (let (typ1 :: FPType) = FPType_Infinity in
                 (let (value_name :: real) = (realPowInteger (realFromFrac(( 20 :: int))(( 10 :: int))) (( 1000000 :: int)::ii)) in
                 (typ1, value_name)))
               else
                 (let (typ1 :: FPType) =
                   (if ((((vec_of_bits [access_vec_dec frac64 (( 51 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
                     FPType_QNaN
                   else FPType_SNaN) in
                 (let (value_name :: real) = (realFromFrac(( 0 :: int))(( 10 :: int))) in
                 (typ1, value_name)))) in
             (typ1, value_name))
           else
             (let (typ1 :: FPType) = FPType_Nonzero in
             (let (value_name :: real) =
               (((realPowInteger (realFromFrac(( 20 :: int))(( 10 :: int))) ((((Word.uint exp64)) - (( 1023 :: int)::ii)))))
                 *
                 (((realFromFrac(( 10 :: int))(( 10 :: int))) +
                     (((((real_of_int ((Word.uint frac64))))) *
                         ((realPowInteger (realFromFrac(( 20 :: int))(( 10 :: int))) ((- (( 52 :: int)::ii)))))))))) in
             (typ1, value_name)))) in
         return (typ1, value_name))) \<bind> (\<lambda> varstup .  (let ((typ1 :: FPType), (value_name :: real)) = varstup in
      return (sign, typ1, value_name))))))) \<bind> (\<lambda> varstup .  (let ((sign :: 1 bits), (typ1 :: FPType), (value_name ::
     real)) = varstup in
   (let (value_name :: real) =
     (if (((sign = (vec_of_bits [B1]  ::  1 Word.word)))) then - value_name
     else value_name) in
   return (typ1, sign, value_name))))))))))))))"


(*val FPUnpackCV : forall 'N . Size 'N => mword 'N -> mword ty32 -> M (FPType * mword ty1 * real)*)

definition FPUnpackCV  :: "('N::len)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(FPType*(1)Word.word*real),(exception))monad "  where 
     " FPUnpackCV fpval fpcr__arg = (
   (let fpcr = fpcr__arg in
   (let fpcr = ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) fpcr (( 19 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word)) in
   undefined_real ()  \<bind> (\<lambda> (value_name :: real) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (sign :: 1 bits) . 
   undefined_FPType ()  \<bind> (\<lambda> (fp_type :: FPType) . 
   (FPUnpackBase fpval fpcr  :: ((FPType *  1 Word.word * real)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1, tup__2) = varstup in
   (let (fp_type :: FPType) = tup__0 in
   (let (sign :: 1 bits) = tup__1 in
   (let (value_name :: real) = tup__2 in
   return (fp_type, sign, value_name))))))))))))"


(*val FPConvert__0 : forall 'N 'M . Size 'M, Size 'N => integer -> mword 'N -> mword ty32 -> FPRounding -> M (mword 'M)*)

(*val FPConvert__1 : forall 'N 'M . Size 'M, Size 'N => integer -> mword 'N -> mword ty32 -> M (mword 'M)*)

definition FPConvert__0  :: " int \<Rightarrow>('N::len)Word.word \<Rightarrow>(32)Word.word \<Rightarrow> FPRounding \<Rightarrow>((register_value),(('M::len)Word.word),(exception))monad "  where 
     " FPConvert__0 (M__tv :: int) op1 fpcr rounding = (
   (let p00 = M__tv in
   if (((p00 = (( 16 :: int)::ii)))) then
     ((assert_exp True ('''') \<then>
     assert_exp ((((((((int (size op1))) = (( 16 :: int)::ii)))) \<or> ((((((((int (size op1))) = (( 32 :: int)::ii)))) \<or> (((((int (size op1))) = (( 64 :: int)::ii)))))))))) ('''')) \<then>
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M)) \<bind> (\<lambda> (result :: 16 bits) . 
     undefined_real ()  \<bind> (\<lambda> (value_name :: real) . 
     (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (sign :: 1 bits) . 
     undefined_FPType ()  \<bind> (\<lambda> (typ1 :: FPType) . 
     (FPUnpackCV op1 fpcr  :: ((FPType *  1 Word.word * real)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1, tup__2) = varstup in
     (let typ1 = tup__0 in
     (let sign = tup__1 in
     (let value_name = tup__2 in
     (let (alt_hp :: bool) =
       (True \<and> ((((vec_of_bits [access_vec_dec fpcr (( 26 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))) in
     (if ((((((typ1 = FPType_SNaN))) \<or> (((typ1 = FPType_QNaN)))))) then
        (if alt_hp then (FPZero (( 16 :: int)::ii) sign  :: ( 16 Word.word) M)
         else if ((((vec_of_bits [access_vec_dec fpcr (( 25 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
           (FPDefaultNaN (( 16 :: int)::ii) ()   :: ( 16 Word.word) M)
         else (FPConvertNaN (( 16 :: int)::ii) op1  :: ( 16 Word.word) M)) \<bind> (\<lambda> (result :: 16 bits) . 
        (if ((((((typ1 = FPType_SNaN))) \<or> alt_hp))) then FPProcessException FPExc_InvalidOp fpcr
         else return () ) \<then>
        return result)
      else if (((typ1 = FPType_Infinity))) then
        if alt_hp then
          (let result =
            ((concat_vec sign
               ((Ones__0 ((make_the_value (((( 16 :: int)::ii) - (( 1 :: int)::ii)))  ::  15 itself))
                  ::  15 Word.word))
              ::  16 Word.word)) in
          FPProcessException FPExc_InvalidOp fpcr \<then> return result)
        else (FPInfinity (( 16 :: int)::ii) sign  :: ( 16 Word.word) M)
      else if (((typ1 = FPType_Zero))) then (FPZero (( 16 :: int)::ii) sign  :: ( 16 Word.word) M)
      else (FPRoundCV (( 16 :: int)::ii) value_name fpcr rounding  :: ( 16 Word.word) M)) \<bind> (\<lambda> (result :: 16
       bits) . 
     return ((Word.ucast result  :: ( 'M::len)Word.word)))))))))))))
   else if (((p00 = (( 32 :: int)::ii)))) then
     ((assert_exp True ('''') \<then>
     assert_exp ((((((((int (size op1))) = (( 16 :: int)::ii)))) \<or> ((((((((int (size op1))) = (( 32 :: int)::ii)))) \<or> (((((int (size op1))) = (( 64 :: int)::ii)))))))))) ('''')) \<then>
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (result :: 32 bits) . 
     undefined_real ()  \<bind> (\<lambda> (value_name :: real) . 
     (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (sign :: 1 bits) . 
     undefined_FPType ()  \<bind> (\<lambda> (typ1 :: FPType) . 
     (FPUnpackCV op1 fpcr  :: ((FPType *  1 Word.word * real)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1, tup__2) = varstup in
     (let typ1 = tup__0 in
     (let sign = tup__1 in
     (let value_name = tup__2 in
     (let (alt_hp :: bool) =
       (False \<and> ((((vec_of_bits [access_vec_dec fpcr (( 26 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))) in
     (if ((((((typ1 = FPType_SNaN))) \<or> (((typ1 = FPType_QNaN)))))) then
        (if alt_hp then (FPZero (( 32 :: int)::ii) sign  :: ( 32 Word.word) M)
         else if ((((vec_of_bits [access_vec_dec fpcr (( 25 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
           (FPDefaultNaN (( 32 :: int)::ii) ()   :: ( 32 Word.word) M)
         else (FPConvertNaN (( 32 :: int)::ii) op1  :: ( 32 Word.word) M)) \<bind> (\<lambda> (result :: 32 bits) . 
        (if ((((((typ1 = FPType_SNaN))) \<or> alt_hp))) then FPProcessException FPExc_InvalidOp fpcr
         else return () ) \<then>
        return result)
      else if (((typ1 = FPType_Infinity))) then
        if alt_hp then
          (let result =
            ((concat_vec sign
               ((Ones__0 ((make_the_value (((( 32 :: int)::ii) - (( 1 :: int)::ii)))  ::  31 itself))
                  ::  31 Word.word))
              ::  32 Word.word)) in
          FPProcessException FPExc_InvalidOp fpcr \<then> return result)
        else (FPInfinity (( 32 :: int)::ii) sign  :: ( 32 Word.word) M)
      else if (((typ1 = FPType_Zero))) then (FPZero (( 32 :: int)::ii) sign  :: ( 32 Word.word) M)
      else (FPRoundCV (( 32 :: int)::ii) value_name fpcr rounding  :: ( 32 Word.word) M)) \<bind> (\<lambda> (result :: 32
       bits) . 
     return ((Word.ucast result  :: ( 'M::len)Word.word)))))))))))))
   else if (((p00 = (( 64 :: int)::ii)))) then
     ((assert_exp True ('''') \<then>
     assert_exp ((((((((int (size op1))) = (( 16 :: int)::ii)))) \<or> ((((((((int (size op1))) = (( 32 :: int)::ii)))) \<or> (((((int (size op1))) = (( 64 :: int)::ii)))))))))) ('''')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (result :: 64 bits) . 
     undefined_real ()  \<bind> (\<lambda> (value_name :: real) . 
     (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (sign :: 1 bits) . 
     undefined_FPType ()  \<bind> (\<lambda> (typ1 :: FPType) . 
     (FPUnpackCV op1 fpcr  :: ((FPType *  1 Word.word * real)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1, tup__2) = varstup in
     (let typ1 = tup__0 in
     (let sign = tup__1 in
     (let value_name = tup__2 in
     (let (alt_hp :: bool) =
       (False \<and> ((((vec_of_bits [access_vec_dec fpcr (( 26 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))) in
     (if ((((((typ1 = FPType_SNaN))) \<or> (((typ1 = FPType_QNaN)))))) then
        (if alt_hp then (FPZero (( 64 :: int)::ii) sign  :: ( 64 Word.word) M)
         else if ((((vec_of_bits [access_vec_dec fpcr (( 25 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
           (FPDefaultNaN (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
         else (FPConvertNaN (( 64 :: int)::ii) op1  :: ( 64 Word.word) M)) \<bind> (\<lambda> (result :: 64 bits) . 
        (if ((((((typ1 = FPType_SNaN))) \<or> alt_hp))) then FPProcessException FPExc_InvalidOp fpcr
         else return () ) \<then>
        return result)
      else if (((typ1 = FPType_Infinity))) then
        if alt_hp then
          (let result =
            ((concat_vec sign
               ((Ones__0 ((make_the_value (((( 64 :: int)::ii) - (( 1 :: int)::ii)))  ::  63 itself))
                  ::  63 Word.word))
              ::  64 Word.word)) in
          FPProcessException FPExc_InvalidOp fpcr \<then> return result)
        else (FPInfinity (( 64 :: int)::ii) sign  :: ( 64 Word.word) M)
      else if (((typ1 = FPType_Zero))) then (FPZero (( 64 :: int)::ii) sign  :: ( 64 Word.word) M)
      else (FPRoundCV (( 64 :: int)::ii) value_name fpcr rounding  :: ( 64 Word.word) M)) \<bind> (\<lambda> (result :: 64
       bits) . 
     return ((Word.ucast result  :: ( 'M::len)Word.word)))))))))))))
   else assert_exp False ('''') \<then> exit0 () ))"


definition FPConvert__1  :: " int \<Rightarrow>('N::len)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(('M::len)Word.word),(exception))monad "  where 
     " FPConvert__1 (M__tv :: int) op1 fpcr = (
   (FPConvert__0 M__tv op1 fpcr ((FPRoundingMode fpcr))  :: (( 'M::len)Word.word) M))"


(*val FPUnpack : forall 'N . Size 'N => mword 'N -> mword ty32 -> M (FPType * mword ty1 * real)*)

definition FPUnpack  :: "('N::len)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(FPType*(1)Word.word*real),(exception))monad "  where 
     " FPUnpack fpval fpcr__arg = (
   (let fpcr = fpcr__arg in
   (let fpcr = ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) fpcr (( 26 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word)) in
   undefined_real ()  \<bind> (\<lambda> (value_name :: real) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (sign :: 1 bits) . 
   undefined_FPType ()  \<bind> (\<lambda> (fp_type :: FPType) . 
   (FPUnpackBase fpval fpcr  :: ((FPType *  1 Word.word * real)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1, tup__2) = varstup in
   (let (fp_type :: FPType) = tup__0 in
   (let (sign :: 1 bits) = tup__1 in
   (let (value_name :: real) = tup__2 in
   return (fp_type, sign, value_name))))))))))))"


(*val FPToFixedJS : forall 'M 'N . Size 'M, Size 'N => integer -> mword 'M -> mword ty32 -> bool -> M (mword 'N)*)

definition FPToFixedJS  :: " int \<Rightarrow>('M::len)Word.word \<Rightarrow>(32)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " FPToFixedJS (N__tv :: int) op1 fpcr Is64 = (
   (assert_exp ((((((((int (size op1))) = (( 64 :: int)::ii)))) \<and> (((N__tv = (( 32 :: int)::ii))))))) (''((M == 64) && (N == 32))'') \<then>
   undefined_real () ) \<bind> (\<lambda> (value_name :: real) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (sign :: 1 bits) . 
   undefined_FPType ()  \<bind> (\<lambda> (typ1 :: FPType) . 
   (FPUnpack op1 fpcr  :: ((FPType *  1 Word.word * real)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1, tup__2) = varstup in
   (let typ1 = tup__0 in
   (let sign = tup__1 in
   (let value_name = tup__2 in
   (let (Z :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
   (if ((((((typ1 = FPType_SNaN))) \<or> (((typ1 = FPType_QNaN)))))) then
      FPProcessException FPExc_InvalidOp fpcr \<then>
      ((let (Z :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
      return Z))
    else return Z) \<bind> (\<lambda> (Z :: 1 bits) . 
   (let (int_result :: ii) = (floor value_name) in
   (let (error :: real) = (value_name - (((real_of_int int_result)))) in
   (let (round_it_up :: bool) =
     ((((error \<noteq> (realFromFrac(( 0 :: int))(( 10 :: int)))))) \<and> ((((ex_int int_result)) < (( 0 :: int)::ii)))) in
   (let (int_result :: ii) =
     (if round_it_up then ((ex_int int_result)) + (( 1 :: int)::ii)
     else int_result) in
   undefined_int ()  \<bind> (\<lambda> (result :: ii) . 
   (let (result :: ii) =
     (if ((((ex_int int_result)) < (( 0 :: int)::ii))) then
       ((ex_int int_result)) -
         ((((pow2 (( 32 :: int)::ii))) *
             ((ex_int
                 ((ceiling
                     (((((real_of_int int_result))) div (((real_of_int ((pow2 (( 32 :: int)::ii))))))))))))))
     else
       ((ex_int int_result)) -
         ((((pow2 (( 32 :: int)::ii))) *
             ((ex_int
                 ((floor
                     (((((real_of_int int_result))) div (((real_of_int ((pow2 (( 32 :: int)::ii))))))))))))))) in
   (if (((((((ex_int int_result)) < ((- ((pow2 (( 31 :: int)::ii))))))) \<or> ((((ex_int int_result)) > ((((pow2 (( 31 :: int)::ii))) - (( 1 :: int)::ii)))))))) then
      FPProcessException FPExc_InvalidOp fpcr \<then>
      ((let (Z :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
      return Z))
    else if (((error \<noteq> (realFromFrac(( 0 :: int))(( 10 :: int)))))) then
      FPProcessException FPExc_Inexact fpcr \<then>
      ((let (Z :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
      return Z))
    else return Z) \<bind> (\<lambda> (Z :: 1 bits) . 
   (let (Z :: 1 bits) =
     (if ((((((sign = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((value_name = (realFromFrac(( 0 :: int))(( 10 :: int))))))))) then
       (vec_of_bits [B0]  ::  1 Word.word)
     else Z) in
   (let (result :: ii) = (if (((typ1 = FPType_Infinity))) then (( 0 :: int)::ii) else result) in
   (if Is64 then
      (let split_vec =
        ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) Z  ::  2 Word.word))
           (vec_of_bits [B0,B0]  ::  2 Word.word)
          ::  4 Word.word)) in
      (let (tup__0, tup__1, tup__2, tup__3) =
        ((subrange_vec_dec split_vec (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
      read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) . 
      (write_reg PSTATE_ref (w__0 (| ProcState_N := tup__0 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__1 :: ProcState) . 
      (write_reg PSTATE_ref (w__1 (| ProcState_Z := tup__1 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__2 :: ProcState) . 
      (write_reg PSTATE_ref (w__2 (| ProcState_C := tup__2 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__3 :: ProcState) . 
      write_reg PSTATE_ref (w__3 (| ProcState_V := tup__3 |))))))))
    else
      (read_reg FPSCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__4 :: 32 bits) . 
      write_reg
        FPSCR_ref
        ((set_slice (( 32 :: int)::ii) (( 4 :: int)::ii) w__4 (( 28 :: int)::ii)
            ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) Z  ::  2 Word.word))
                (vec_of_bits [B0,B0]  ::  2 Word.word)
               ::  4 Word.word))
           ::  32 Word.word)))) \<then>
   return ((Word.ucast
              ((GetSlice_int ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) result (( 0 :: int)::ii)  ::  32 Word.word))
             :: ( 'N::len)Word.word))))))))))))))))))))))"


(*val FPToFixed : forall 'N 'M . Size 'M, Size 'N => integer -> mword 'N -> ii -> bool -> mword ty32 -> FPRounding -> M (mword 'M)*)

definition FPToFixed  :: " int \<Rightarrow>('N::len)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>(32)Word.word \<Rightarrow> FPRounding \<Rightarrow>((register_value),(('M::len)Word.word),(exception))monad "  where 
     " FPToFixed (M__tv :: int) op1 fbits unsigned fpcr rounding = (
   ((((assert_exp ((((((((int (size op1))) = (( 16 :: int)::ii)))) \<or> ((((((((int (size op1))) = (( 32 :: int)::ii)))) \<or> (((((int (size op1))) = (( 64 :: int)::ii)))))))))) (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
   assert_exp ((((((M__tv = (( 16 :: int)::ii)))) \<or> ((((((M__tv = (( 32 :: int)::ii)))) \<or> (((M__tv = (( 64 :: int)::ii)))))))))) (''((M == 16) || ((M == 32) || (M == 64)))'')) \<then>
   assert_exp ((fbits \<ge> (( 0 :: int)::ii))) (''(fbits >= 0)'')) \<then>
   assert_exp (((rounding \<noteq> FPRounding_ODD))) (''(rounding != FPRounding_ODD)'')) \<then>
   undefined_real () ) \<bind> (\<lambda> (value_name :: real) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (sign :: 1 bits) . 
   undefined_FPType ()  \<bind> (\<lambda> (typ1 :: FPType) . 
   (FPUnpack op1 fpcr  :: ((FPType *  1 Word.word * real)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1, tup__2) = varstup in
   (let typ1 = tup__0 in
   (let sign = tup__1 in
   (let value_name = tup__2 in
   (if ((((((typ1 = FPType_SNaN))) \<or> (((typ1 = FPType_QNaN)))))) then
      FPProcessException FPExc_InvalidOp fpcr
    else return () ) \<then>
   ((let value_name = (value_name * ((realPowInteger (realFromFrac(( 20 :: int))(( 10 :: int))) fbits))) in
   (let (int_result :: ii) = (floor value_name) in
   (let (error :: real) = (value_name - (((real_of_int int_result)))) in
   undefined_bool ()  \<bind> (\<lambda> (round_up :: bool) . 
   (let (round_up :: bool) =
     ((case  rounding of
       FPRounding_TIEEVEN =>
        (((error > (realFromFrac(( 5 :: int))(( 10 :: int))))) \<or> ((((((error = (realFromFrac(( 5 :: int))(( 10 :: int)))))) \<and> (((((GetSlice_int ((make_the_value (( 1 :: int)::ii)  ::  1 itself)) int_result (( 0 :: int)::ii)
                     ::  1 Word.word)) = (vec_of_bits [B1]  ::  1 Word.word))))))))
     | FPRounding_POSINF => (error \<noteq> (realFromFrac(( 0 :: int))(( 10 :: int))))
     | FPRounding_NEGINF => False
     | FPRounding_ZERO =>
        ((((error \<noteq> (realFromFrac(( 0 :: int))(( 10 :: int)))))) \<and> ((((ex_int int_result)) < (( 0 :: int)::ii))))
     | FPRounding_TIEAWAY =>
        (((error > (realFromFrac(( 5 :: int))(( 10 :: int))))) \<or> ((((((error = (realFromFrac(( 5 :: int))(( 10 :: int)))))) \<and> ((((ex_int int_result)) \<ge> (( 0 :: int)::ii)))))))
     )) in
   (let (int_result :: ii) = (if round_up then ((ex_int int_result)) + (( 1 :: int)::ii) else int_result) in
   undefined_bool ()  \<bind> (\<lambda> (overflow :: bool) . 
   (undefined_bitvector M__tv  :: (( 'M::len)Word.word) M) \<bind> (\<lambda> result . 
   (SatQ int_result ((make_the_value ((int (size result))) )) unsigned ) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1) = varstup in
   (let result = tup__0 in
   (let overflow = tup__1 in
   (if overflow then FPProcessException FPExc_InvalidOp fpcr
    else if (((error \<noteq> (realFromFrac(( 0 :: int))(( 10 :: int)))))) then FPProcessException FPExc_Inexact fpcr
    else return () ) \<then>
   return result))))))))))))))))))))))"


(*val FPSqrt : forall 'N . Size 'N => mword 'N -> mword ty32 -> M (mword 'N)*)

definition FPSqrt  :: "('N::len)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " FPSqrt op1 fpcr = (
   (assert_exp ((((((((int (size op1))) = (( 16 :: int)::ii)))) \<or> ((((((((int (size op1))) = (( 32 :: int)::ii)))) \<or> (((((int (size op1))) = (( 64 :: int)::ii)))))))))) (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
   undefined_real () ) \<bind> (\<lambda> (value_name :: real) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (sign :: 1 bits) . 
   undefined_FPType ()  \<bind> (\<lambda> (typ1 :: FPType) . 
   (FPUnpack op1 fpcr  :: ((FPType *  1 Word.word * real)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1, tup__2) = varstup in
   (let typ1 = tup__0 in
   (let sign = tup__1 in
   (let value_name = tup__2 in
   (undefined_bitvector ((int (size op1)))  :: (( 'N::len)Word.word) M) \<bind> (\<lambda> result . 
   if ((((((typ1 = FPType_SNaN))) \<or> (((typ1 = FPType_QNaN)))))) then
     (FPProcessNaN typ1 op1 fpcr  :: (( 'N::len)Word.word) M)
   else if (((typ1 = FPType_Zero))) then (FPZero ((int (size op1))) sign  :: (( 'N::len)Word.word) M)
   else if ((((((typ1 = FPType_Infinity))) \<and> (((sign = (vec_of_bits [B0]  ::  1 Word.word)))))))
   then
     (FPInfinity ((int (size op1))) sign  :: (( 'N::len)Word.word) M)
   else if (((sign = (vec_of_bits [B1]  ::  1 Word.word)))) then
     (FPDefaultNaN ((int (size op1))) ()   :: (( 'N::len)Word.word) M) \<bind> (\<lambda> (w__3 :: ( 'N::len)Word.word) . 
     (let result = w__3 in
     FPProcessException FPExc_InvalidOp fpcr \<then> return result))
   else (FPRound__1 ((int (size op1))) ((sqrt value_name)) fpcr  :: (( 'N::len)Word.word) M)))))))))))"


(*val FPRoundInt : forall 'N . Size 'N => mword 'N -> mword ty32 -> FPRounding -> bool -> M (mword 'N)*)

definition FPRoundInt  :: "('N::len)Word.word \<Rightarrow>(32)Word.word \<Rightarrow> FPRounding \<Rightarrow> bool \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " FPRoundInt op1 fpcr rounding exact = (
   ((assert_exp (((rounding \<noteq> FPRounding_ODD))) (''(rounding != FPRounding_ODD)'') \<then>
   assert_exp ((((((((int (size op1))) = (( 16 :: int)::ii)))) \<or> ((((((((int (size op1))) = (( 32 :: int)::ii)))) \<or> (((((int (size op1))) = (( 64 :: int)::ii)))))))))) (''((N == 16) || ((N == 32) || (N == 64)))'')) \<then>
   undefined_real () ) \<bind> (\<lambda> (value_name :: real) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (sign :: 1 bits) . 
   undefined_FPType ()  \<bind> (\<lambda> (typ1 :: FPType) . 
   (FPUnpack op1 fpcr  :: ((FPType *  1 Word.word * real)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1, tup__2) = varstup in
   (let typ1 = tup__0 in
   (let sign = tup__1 in
   (let value_name = tup__2 in
   undefined_real ()  \<bind> (\<lambda> (real_result :: real) . 
   undefined_bool ()  \<bind> (\<lambda> (round_up :: bool) . 
   undefined_real ()  \<bind> (\<lambda> (error :: real) . 
   undefined_int ()  \<bind> (\<lambda> (int_result :: ii) . 
   (undefined_bitvector ((int (size op1)))  :: (( 'N::len)Word.word) M) \<bind> (\<lambda> result . 
   if ((((((typ1 = FPType_SNaN))) \<or> (((typ1 = FPType_QNaN)))))) then
     (FPProcessNaN typ1 op1 fpcr  :: (( 'N::len)Word.word) M)
   else if (((typ1 = FPType_Infinity))) then (FPInfinity ((int (size op1))) sign  :: (( 'N::len)Word.word) M)
   else if (((typ1 = FPType_Zero))) then (FPZero ((int (size op1))) sign  :: (( 'N::len)Word.word) M)
   else
     (let int_result = (floor value_name) in
     (let error = (value_name - (((real_of_int int_result)))) in
     (let (round_up :: bool) =
       ((case  rounding of
         FPRounding_TIEEVEN =>
          (((error > (realFromFrac(( 5 :: int))(( 10 :: int))))) \<or> ((((((error = (realFromFrac(( 5 :: int))(( 10 :: int)))))) \<and> (((((GetSlice_int ((make_the_value (( 1 :: int)::ii)  ::  1 itself)) int_result (( 0 :: int)::ii)
                       ::  1 Word.word)) = (vec_of_bits [B1]  ::  1 Word.word))))))))
       | FPRounding_POSINF => (error \<noteq> (realFromFrac(( 0 :: int))(( 10 :: int))))
       | FPRounding_NEGINF => False
       | FPRounding_ZERO =>
          ((((error \<noteq> (realFromFrac(( 0 :: int))(( 10 :: int)))))) \<and> ((((ex_int int_result)) < (( 0 :: int)::ii))))
       | FPRounding_TIEAWAY =>
          (((error > (realFromFrac(( 5 :: int))(( 10 :: int))))) \<or> ((((((error = (realFromFrac(( 5 :: int))(( 10 :: int)))))) \<and> ((((ex_int int_result)) \<ge> (( 0 :: int)::ii)))))))
       )) in
     (let (int_result :: ii) =
       (if round_up then ((ex_int int_result)) + (( 1 :: int)::ii)
       else int_result) in
     (let real_result = ((real_of_int int_result)) in
     (if (((real_result = (realFromFrac(( 0 :: int))(( 10 :: int)))))) then (FPZero ((int (size op1))) sign  :: (( 'N::len)Word.word) M)
      else (FPRound__0 ((int (size op1))) real_result fpcr FPRounding_ZERO  :: (( 'N::len)Word.word) M)) \<bind> (\<lambda> result . 
     (if ((((((error \<noteq> (realFromFrac(( 0 :: int))(( 10 :: int)))))) \<and> exact))) then
        FPProcessException FPExc_Inexact fpcr
      else return () ) \<then>
     return result))))))))))))))))))))"


(*val FPCompare : forall 'N . Size 'N => mword 'N -> mword 'N -> bool -> mword ty32 -> M (mword ty4)*)

definition FPCompare  :: "('N::len)Word.word \<Rightarrow>('N::len)Word.word \<Rightarrow> bool \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),((4)Word.word),(exception))monad "  where 
     " FPCompare op1 op2 signal_nans fpcr = (
   (assert_exp ((((((((int (size op1))) = (( 16 :: int)::ii)))) \<or> ((((((((int (size op1))) = (( 32 :: int)::ii)))) \<or> (((((int (size op1))) = (( 64 :: int)::ii)))))))))) (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
   undefined_real () ) \<bind> (\<lambda> (value1_name :: real) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (sign1 :: 1 bits) . 
   undefined_FPType ()  \<bind> (\<lambda> (type1 :: FPType) . 
   (FPUnpack op1 fpcr  :: ((FPType *  1 Word.word * real)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1, tup__2) = varstup in
   (let type1 = tup__0 in
   (let sign1 = tup__1 in
   (let value1_name = tup__2 in
   undefined_real ()  \<bind> (\<lambda> (value2_name :: real) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (sign2 :: 1 bits) . 
   undefined_FPType ()  \<bind> (\<lambda> (type2 :: FPType) . 
   (FPUnpack op2 fpcr  :: ((FPType *  1 Word.word * real)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1, tup__2) = varstup in
   (let type2 = tup__0 in
   (let sign2 = tup__1 in
   (let value2_name = tup__2 in
   (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (result :: 4 bits) . 
   if ((((((((((((type1 = FPType_SNaN))) \<or> (((type1 = FPType_QNaN)))))) \<or> (((type2 = FPType_SNaN)))))) \<or> (((type2 = FPType_QNaN)))))) then
     (let result = ((vec_of_bits [B0,B0,B1,B1]  ::  4 Word.word)) in
     (if (((((((((type1 = FPType_SNaN))) \<or> (((type2 = FPType_SNaN)))))) \<or> signal_nans))) then
        FPProcessException FPExc_InvalidOp fpcr
      else return () ) \<then>
     return result)
   else
     (let (result :: 4 bits) =
       (if (((value1_name = value2_name))) then (vec_of_bits [B0,B1,B1,B0]  ::  4 Word.word)
       else if ((value1_name < value2_name)) then (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)
       else (vec_of_bits [B0,B0,B1,B0]  ::  4 Word.word)) in
     return result)))))))))))))))))))"


(*val FPSub : forall 'N . Size 'N => mword 'N -> mword 'N -> mword ty32 -> M (mword 'N)*)

definition FPSub  :: "('N::len)Word.word \<Rightarrow>('N::len)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " FPSub op1 op2 fpcr = (
   assert_exp ((((((((int (size op1))) = (( 16 :: int)::ii)))) \<or> ((((((((int (size op1))) = (( 32 :: int)::ii)))) \<or> (((((int (size op1))) = (( 64 :: int)::ii)))))))))) (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
   ((let (rounding :: FPRounding) = (FPRoundingMode fpcr) in
   undefined_real ()  \<bind> (\<lambda> (value1_name :: real) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (sign1 :: 1 bits) . 
   undefined_FPType ()  \<bind> (\<lambda> (type1 :: FPType) . 
   (FPUnpack op1 fpcr  :: ((FPType *  1 Word.word * real)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1, tup__2) = varstup in
   (let type1 = tup__0 in
   (let sign1 = tup__1 in
   (let value1_name = tup__2 in
   undefined_real ()  \<bind> (\<lambda> (value2_name :: real) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (sign2 :: 1 bits) . 
   undefined_FPType ()  \<bind> (\<lambda> (type2 :: FPType) . 
   (FPUnpack op2 fpcr  :: ((FPType *  1 Word.word * real)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1, tup__2) = varstup in
   (let type2 = tup__0 in
   (let sign2 = tup__1 in
   (let value2_name = tup__2 in
   (undefined_bitvector ((int (size op1)))  :: (( 'N::len)Word.word) M) \<bind> (\<lambda> result . 
   undefined_bool ()  \<bind> (\<lambda> (done1 :: bool) . 
   (FPProcessNaNs type1 type2 op1 op2 fpcr ) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1) = varstup in
   (let done1 = tup__0 in
   (let result = tup__1 in
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (result_sign :: 1 bits) . 
   undefined_real ()  \<bind> (\<lambda> (result_value :: real) . 
   undefined_bool ()  \<bind> (\<lambda> (zero2 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (zero1 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (inf2 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (inf1 :: bool) . 
   if ((\<not> done1)) then
     (let inf1 = (type1 = FPType_Infinity) in
     (let inf2 = (type2 = FPType_Infinity) in
     (let zero1 = (type1 = FPType_Zero) in
     (let zero2 = (type2 = FPType_Zero) in
     if ((((((inf1 \<and> inf2))) \<and> (((sign1 = sign2)))))) then
       (FPDefaultNaN ((int (size op1))) ()   :: (( 'N::len)Word.word) M) \<bind> (\<lambda> (w__0 :: ( 'N::len)Word.word) . 
       (let result = w__0 in
       FPProcessException FPExc_InvalidOp fpcr \<then> return result))
     else if ((((((inf1 \<and> (((sign1 = (vec_of_bits [B0]  ::  1 Word.word))))))) \<or> (((inf2 \<and> (((sign2 = (vec_of_bits [B1]  ::  1 Word.word)))))))))) then
       (FPInfinity ((int (size op1))) (vec_of_bits [B0]  ::  1 Word.word)  :: (( 'N::len)Word.word) M)
     else if ((((((inf1 \<and> (((sign1 = (vec_of_bits [B1]  ::  1 Word.word))))))) \<or> (((inf2 \<and> (((sign2 = (vec_of_bits [B0]  ::  1 Word.word)))))))))) then
       (FPInfinity ((int (size op1))) (vec_of_bits [B1]  ::  1 Word.word)  :: (( 'N::len)Word.word) M)
     else if ((((((zero1 \<and> zero2))) \<and> (((sign1 = ((not_vec sign2  ::  1 Word.word))))))))
     then
       (FPZero ((int (size op1))) sign1  :: (( 'N::len)Word.word) M)
     else
       (let result_value = (value1_name - value2_name) in
       if (((result_value = (realFromFrac(( 0 :: int))(( 10 :: int)))))) then
         (let result_sign =
           (if (((rounding = FPRounding_NEGINF))) then (vec_of_bits [B1]  ::  1 Word.word)
           else (vec_of_bits [B0]  ::  1 Word.word)) in
         (FPZero ((int (size op1))) result_sign  :: (( 'N::len)Word.word) M))
       else (FPRound__0 ((int (size op1))) result_value fpcr rounding  :: (( 'N::len)Word.word) M))))))
   else return result)))))))))))))))))))))))))))))))"


(*val FPMulAdd : forall 'N . Size 'N => mword 'N -> mword 'N -> mword 'N -> mword ty32 -> M (mword 'N)*)

definition FPMulAdd  :: "('N::len)Word.word \<Rightarrow>('N::len)Word.word \<Rightarrow>('N::len)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " FPMulAdd addend op1 op2 fpcr = (
   assert_exp ((((((((int (size addend))) = (( 16 :: int)::ii)))) \<or> ((((((((int (size addend))) = (( 32 :: int)::ii)))) \<or> (((((int (size addend))) = (( 64 :: int)::ii)))))))))) (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
   ((let (rounding :: FPRounding) = (FPRoundingMode fpcr) in
   undefined_real ()  \<bind> (\<lambda> (valueA_name :: real) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (signA :: 1 bits) . 
   undefined_FPType ()  \<bind> (\<lambda> (typeA :: FPType) . 
   (FPUnpack addend fpcr  :: ((FPType *  1 Word.word * real)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1, tup__2) = varstup in
   (let typeA = tup__0 in
   (let signA = tup__1 in
   (let valueA_name = tup__2 in
   undefined_real ()  \<bind> (\<lambda> (value1_name :: real) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (sign1 :: 1 bits) . 
   undefined_FPType ()  \<bind> (\<lambda> (type1 :: FPType) . 
   (FPUnpack op1 fpcr  :: ((FPType *  1 Word.word * real)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1, tup__2) = varstup in
   (let type1 = tup__0 in
   (let sign1 = tup__1 in
   (let value1_name = tup__2 in
   undefined_real ()  \<bind> (\<lambda> (value2_name :: real) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (sign2 :: 1 bits) . 
   undefined_FPType ()  \<bind> (\<lambda> (type2 :: FPType) . 
   (FPUnpack op2 fpcr  :: ((FPType *  1 Word.word * real)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1, tup__2) = varstup in
   (let type2 = tup__0 in
   (let sign2 = tup__1 in
   (let value2_name = tup__2 in
   (let (inf1 :: bool) = (type1 = FPType_Infinity) in
   (let (zero1 :: bool) = (type1 = FPType_Zero) in
   (let (inf2 :: bool) = (type2 = FPType_Infinity) in
   (let (zero2 :: bool) = (type2 = FPType_Zero) in
   (undefined_bitvector ((int (size addend)))  :: (( 'N::len)Word.word) M) \<bind> (\<lambda> result . 
   undefined_bool ()  \<bind> (\<lambda> (done1 :: bool) . 
   (FPProcessNaNs3 typeA type1 type2 addend op1 op2 fpcr ) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1) = varstup in
   (let done1 = tup__0 in
   (let result = tup__1 in
   (if ((((((typeA = FPType_QNaN))) \<and> ((((((inf1 \<and> zero2))) \<or> (((zero1 \<and> inf2))))))))) then
      (FPDefaultNaN ((int (size addend))) ()   :: (( 'N::len)Word.word) M) \<bind> (\<lambda> (w__0 :: ( 'N::len)Word.word) . 
      (let result = w__0 in
      FPProcessException FPExc_InvalidOp fpcr \<then> return result))
    else return result) \<bind> (\<lambda> result . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (result_sign :: 1 bits) . 
   undefined_real ()  \<bind> (\<lambda> (result_value :: real) . 
   undefined_bool ()  \<bind> (\<lambda> (zeroP :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (infP :: bool) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (signP :: 1 bits) . 
   undefined_bool ()  \<bind> (\<lambda> (zeroA :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (infA :: bool) . 
   if ((\<not> done1)) then
     (let infA = (typeA = FPType_Infinity) in
     (let zeroA = (typeA = FPType_Zero) in
     (let signP = ((xor_vec sign1 sign2  ::  1 Word.word)) in
     (let infP = (inf1 \<or> inf2) in
     (let zeroP = (zero1 \<or> zero2) in
     if (((((((((inf1 \<and> zero2))) \<or> (((zero1 \<and> inf2)))))) \<or> ((((((infA \<and> infP))) \<and> (((signA \<noteq> signP))))))))) then
       (FPDefaultNaN ((int (size addend))) ()   :: (( 'N::len)Word.word) M) \<bind> (\<lambda> (w__1 :: ( 'N::len)Word.word) . 
       (let result = w__1 in
       FPProcessException FPExc_InvalidOp fpcr \<then> return result))
     else if ((((((infA \<and> (((signA = (vec_of_bits [B0]  ::  1 Word.word))))))) \<or> (((infP \<and> (((signP = (vec_of_bits [B0]  ::  1 Word.word)))))))))) then
       (FPInfinity ((int (size addend))) (vec_of_bits [B0]  ::  1 Word.word)  :: (( 'N::len)Word.word) M)
     else if ((((((infA \<and> (((signA = (vec_of_bits [B1]  ::  1 Word.word))))))) \<or> (((infP \<and> (((signP = (vec_of_bits [B1]  ::  1 Word.word)))))))))) then
       (FPInfinity ((int (size addend))) (vec_of_bits [B1]  ::  1 Word.word)  :: (( 'N::len)Word.word) M)
     else if ((((((zeroA \<and> zeroP))) \<and> (((signA = signP)))))) then
       (FPZero ((int (size addend))) signA  :: (( 'N::len)Word.word) M)
     else
       (let result_value = (valueA_name + ((value1_name * value2_name))) in
       if (((result_value = (realFromFrac(( 0 :: int))(( 10 :: int)))))) then
         (let result_sign =
           (if (((rounding = FPRounding_NEGINF))) then (vec_of_bits [B1]  ::  1 Word.word)
           else (vec_of_bits [B0]  ::  1 Word.word)) in
         (FPZero ((int (size addend))) result_sign  :: (( 'N::len)Word.word) M))
       else (FPRound__1 ((int (size addend))) result_value fpcr  :: (( 'N::len)Word.word) M)))))))
   else return result)))))))))))))))))))))))))))))))))))))))))))))"


(*val FPMul : forall 'N . Size 'N => mword 'N -> mword 'N -> mword ty32 -> M (mword 'N)*)

definition FPMul  :: "('N::len)Word.word \<Rightarrow>('N::len)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " FPMul op1 op2 fpcr = (
   (assert_exp ((((((((int (size op1))) = (( 16 :: int)::ii)))) \<or> ((((((((int (size op1))) = (( 32 :: int)::ii)))) \<or> (((((int (size op1))) = (( 64 :: int)::ii)))))))))) (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
   undefined_real () ) \<bind> (\<lambda> (value1_name :: real) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (sign1 :: 1 bits) . 
   undefined_FPType ()  \<bind> (\<lambda> (type1 :: FPType) . 
   (FPUnpack op1 fpcr  :: ((FPType *  1 Word.word * real)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1, tup__2) = varstup in
   (let type1 = tup__0 in
   (let sign1 = tup__1 in
   (let value1_name = tup__2 in
   undefined_real ()  \<bind> (\<lambda> (value2_name :: real) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (sign2 :: 1 bits) . 
   undefined_FPType ()  \<bind> (\<lambda> (type2 :: FPType) . 
   (FPUnpack op2 fpcr  :: ((FPType *  1 Word.word * real)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1, tup__2) = varstup in
   (let type2 = tup__0 in
   (let sign2 = tup__1 in
   (let value2_name = tup__2 in
   (undefined_bitvector ((int (size op1)))  :: (( 'N::len)Word.word) M) \<bind> (\<lambda> result . 
   undefined_bool ()  \<bind> (\<lambda> (done1 :: bool) . 
   (FPProcessNaNs type1 type2 op1 op2 fpcr ) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1) = varstup in
   (let done1 = tup__0 in
   (let result = tup__1 in
   undefined_bool ()  \<bind> (\<lambda> (zero2 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (zero1 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (inf2 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (inf1 :: bool) . 
   if ((\<not> done1)) then
     (let inf1 = (type1 = FPType_Infinity) in
     (let inf2 = (type2 = FPType_Infinity) in
     (let zero1 = (type1 = FPType_Zero) in
     (let zero2 = (type2 = FPType_Zero) in
     if ((((((inf1 \<and> zero2))) \<or> (((zero1 \<and> inf2)))))) then
       (FPDefaultNaN ((int (size op1))) ()   :: (( 'N::len)Word.word) M) \<bind> (\<lambda> (w__0 :: ( 'N::len)Word.word) . 
       (let result = w__0 in
       FPProcessException FPExc_InvalidOp fpcr \<then> return result))
     else if (((inf1 \<or> inf2))) then
       (FPInfinity ((int (size op1))) ((xor_vec sign1 sign2  ::  1 Word.word))  :: (( 'N::len)Word.word) M)
     else if (((zero1 \<or> zero2))) then
       (FPZero ((int (size op1))) ((xor_vec sign1 sign2  ::  1 Word.word))  :: (( 'N::len)Word.word) M)
     else (FPRound__1 ((int (size op1))) ((value1_name * value2_name)) fpcr  :: (( 'N::len)Word.word) M)))))
   else return result)))))))))))))))))))))))))))"


(*val FPMin : forall 'N . Size 'N => mword 'N -> mword 'N -> mword ty32 -> M (mword 'N)*)

definition FPMin  :: "('N::len)Word.word \<Rightarrow>('N::len)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " FPMin op1 op2 fpcr = (
   (assert_exp ((((((((int (size op1))) = (( 16 :: int)::ii)))) \<or> ((((((((int (size op1))) = (( 32 :: int)::ii)))) \<or> (((((int (size op1))) = (( 64 :: int)::ii)))))))))) (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
   undefined_real () ) \<bind> (\<lambda> (value1_name :: real) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (sign1 :: 1 bits) . 
   undefined_FPType ()  \<bind> (\<lambda> (type1 :: FPType) . 
   (FPUnpack op1 fpcr  :: ((FPType *  1 Word.word * real)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1, tup__2) = varstup in
   (let type1 = tup__0 in
   (let sign1 = tup__1 in
   (let value1_name = tup__2 in
   undefined_real ()  \<bind> (\<lambda> (value2_name :: real) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (sign2 :: 1 bits) . 
   undefined_FPType ()  \<bind> (\<lambda> (type2 :: FPType) . 
   (FPUnpack op2 fpcr  :: ((FPType *  1 Word.word * real)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1, tup__2) = varstup in
   (let type2 = tup__0 in
   (let sign2 = tup__1 in
   (let value2_name = tup__2 in
   (undefined_bitvector ((int (size op1)))  :: (( 'N::len)Word.word) M) \<bind> (\<lambda> result . 
   undefined_bool ()  \<bind> (\<lambda> (done1 :: bool) . 
   (FPProcessNaNs type1 type2 op1 op2 fpcr ) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1) = varstup in
   (let done1 = tup__0 in
   (let result = tup__1 in
   undefined_real ()  \<bind> (\<lambda> (value_name :: real) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (sign :: 1 bits) . 
   undefined_FPType ()  \<bind> (\<lambda> (typ1 :: FPType) . 
   if ((\<not> done1)) then
     (let ((sign :: 1 bits), (typ1 :: FPType), (value_name :: real)) =
       (if ((value1_name < value2_name)) then
         (let (tup__0, tup__1, tup__2) = (type1, sign1, value1_name) in
         (let (typ1 :: FPType) = tup__0 in
         (let (sign :: 1 bits) = tup__1 in
         (let (value_name :: real) = tup__2 in
         (sign, typ1, value_name)))))
       else
         (let (tup__0, tup__1, tup__2) = (type2, sign2, value2_name) in
         (let (typ1 :: FPType) = tup__0 in
         (let (sign :: 1 bits) = tup__1 in
         (let (value_name :: real) = tup__2 in
         (sign, typ1, value_name)))))) in
     if (((typ1 = FPType_Infinity))) then (FPInfinity ((int (size op1))) sign  :: (( 'N::len)Word.word) M)
     else if (((typ1 = FPType_Zero))) then
       (let sign = ((or_vec sign1 sign2  ::  1 Word.word)) in
       (FPZero ((int (size op1))) sign  :: (( 'N::len)Word.word) M))
     else (FPRound__1 ((int (size op1))) value_name fpcr  :: (( 'N::len)Word.word) M))
   else return result))))))))))))))))))))))))))"


(*val FPMinNum : forall 'N . Size 'N => mword 'N -> mword 'N -> mword ty32 -> M (mword 'N)*)

definition FPMinNum  :: "('N::len)Word.word \<Rightarrow>('N::len)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " FPMinNum op1__arg op2__arg fpcr = (
   (let op1 = op1__arg in
   (let op2 = op2__arg in
   (assert_exp ((((((((int (size op1))) = (( 16 :: int)::ii)))) \<or> ((((((((int (size op1))) = (( 32 :: int)::ii)))) \<or> (((((int (size op1))) = (( 64 :: int)::ii)))))))))) (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
   undefined_real () ) \<bind> (\<lambda> (anon20 :: real) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (anon10 :: 1 bits) . 
   undefined_FPType ()  \<bind> (\<lambda> (type1 :: FPType) . 
   (FPUnpack op1 fpcr  :: ((FPType *  1 Word.word * real)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1, tup__2) = varstup in
   (let type1 = tup__0 in
   (let anon10 = tup__1 in
   (let anon20 = tup__2 in
   undefined_real ()  \<bind> (\<lambda> (anon40 :: real) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (anon30 :: 1 bits) . 
   undefined_FPType ()  \<bind> (\<lambda> (type2 :: FPType) . 
   (FPUnpack op2 fpcr  :: ((FPType *  1 Word.word * real)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1, tup__2) = varstup in
   (let type2 = tup__0 in
   (let anon30 = tup__1 in
   (let anon40 = tup__2 in
   (if ((((((type1 = FPType_QNaN))) \<and> (((type2 \<noteq> FPType_QNaN)))))) then
      (FPInfinity ((int (size op1))) (vec_of_bits [B0]  ::  1 Word.word)  :: (( 'N::len)Word.word) M) \<bind> (\<lambda> (w__0 ::
        ( 'N::len)Word.word) . 
      (let (op1 :: ( 'N::len)Word.word) = w__0 in
      return (op1, op2)))
    else
      (if ((((((type1 \<noteq> FPType_QNaN))) \<and> (((type2 = FPType_QNaN)))))) then
         (FPInfinity ((int (size op1))) (vec_of_bits [B0]  ::  1 Word.word)  :: (( 'N::len)Word.word) M)
       else return op2) \<bind> (\<lambda> (op2 :: ( 'N::len)Word.word) . 
      return (op1, op2))) \<bind> (\<lambda> varstup .  (let ((op1 :: ( 'N::len)Word.word), (op2 :: ( 'N::len)Word.word)) = varstup in
   (FPMin op1 op2 fpcr  :: (( 'N::len)Word.word) M))))))))))))))))))))))"


(*val FPMax : forall 'N . Size 'N => mword 'N -> mword 'N -> mword ty32 -> M (mword 'N)*)

definition FPMax  :: "('N::len)Word.word \<Rightarrow>('N::len)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " FPMax op1 op2 fpcr = (
   (assert_exp ((((((((int (size op1))) = (( 16 :: int)::ii)))) \<or> ((((((((int (size op1))) = (( 32 :: int)::ii)))) \<or> (((((int (size op1))) = (( 64 :: int)::ii)))))))))) (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
   undefined_real () ) \<bind> (\<lambda> (value1_name :: real) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (sign1 :: 1 bits) . 
   undefined_FPType ()  \<bind> (\<lambda> (type1 :: FPType) . 
   (FPUnpack op1 fpcr  :: ((FPType *  1 Word.word * real)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1, tup__2) = varstup in
   (let type1 = tup__0 in
   (let sign1 = tup__1 in
   (let value1_name = tup__2 in
   undefined_real ()  \<bind> (\<lambda> (value2_name :: real) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (sign2 :: 1 bits) . 
   undefined_FPType ()  \<bind> (\<lambda> (type2 :: FPType) . 
   (FPUnpack op2 fpcr  :: ((FPType *  1 Word.word * real)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1, tup__2) = varstup in
   (let type2 = tup__0 in
   (let sign2 = tup__1 in
   (let value2_name = tup__2 in
   (undefined_bitvector ((int (size op1)))  :: (( 'N::len)Word.word) M) \<bind> (\<lambda> result . 
   undefined_bool ()  \<bind> (\<lambda> (done1 :: bool) . 
   (FPProcessNaNs type1 type2 op1 op2 fpcr ) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1) = varstup in
   (let done1 = tup__0 in
   (let result = tup__1 in
   undefined_real ()  \<bind> (\<lambda> (value_name :: real) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (sign :: 1 bits) . 
   undefined_FPType ()  \<bind> (\<lambda> (typ1 :: FPType) . 
   if ((\<not> done1)) then
     (let ((sign :: 1 bits), (typ1 :: FPType), (value_name :: real)) =
       (if ((value1_name > value2_name)) then
         (let (tup__0, tup__1, tup__2) = (type1, sign1, value1_name) in
         (let (typ1 :: FPType) = tup__0 in
         (let (sign :: 1 bits) = tup__1 in
         (let (value_name :: real) = tup__2 in
         (sign, typ1, value_name)))))
       else
         (let (tup__0, tup__1, tup__2) = (type2, sign2, value2_name) in
         (let (typ1 :: FPType) = tup__0 in
         (let (sign :: 1 bits) = tup__1 in
         (let (value_name :: real) = tup__2 in
         (sign, typ1, value_name)))))) in
     if (((typ1 = FPType_Infinity))) then (FPInfinity ((int (size op1))) sign  :: (( 'N::len)Word.word) M)
     else if (((typ1 = FPType_Zero))) then
       (let sign = ((and_vec sign1 sign2  ::  1 Word.word)) in
       (FPZero ((int (size op1))) sign  :: (( 'N::len)Word.word) M))
     else (FPRound__1 ((int (size op1))) value_name fpcr  :: (( 'N::len)Word.word) M))
   else return result))))))))))))))))))))))))))"


(*val FPMaxNum : forall 'N . Size 'N => mword 'N -> mword 'N -> mword ty32 -> M (mword 'N)*)

definition FPMaxNum  :: "('N::len)Word.word \<Rightarrow>('N::len)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " FPMaxNum op1__arg op2__arg fpcr = (
   (let op1 = op1__arg in
   (let op2 = op2__arg in
   (assert_exp ((((((((int (size op1))) = (( 16 :: int)::ii)))) \<or> ((((((((int (size op1))) = (( 32 :: int)::ii)))) \<or> (((((int (size op1))) = (( 64 :: int)::ii)))))))))) (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
   undefined_real () ) \<bind> (\<lambda> (anon20 :: real) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (anon10 :: 1 bits) . 
   undefined_FPType ()  \<bind> (\<lambda> (type1 :: FPType) . 
   (FPUnpack op1 fpcr  :: ((FPType *  1 Word.word * real)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1, tup__2) = varstup in
   (let type1 = tup__0 in
   (let anon10 = tup__1 in
   (let anon20 = tup__2 in
   undefined_real ()  \<bind> (\<lambda> (anon40 :: real) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (anon30 :: 1 bits) . 
   undefined_FPType ()  \<bind> (\<lambda> (type2 :: FPType) . 
   (FPUnpack op2 fpcr  :: ((FPType *  1 Word.word * real)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1, tup__2) = varstup in
   (let type2 = tup__0 in
   (let anon30 = tup__1 in
   (let anon40 = tup__2 in
   (if ((((((type1 = FPType_QNaN))) \<and> (((type2 \<noteq> FPType_QNaN)))))) then
      (FPInfinity ((int (size op1))) (vec_of_bits [B1]  ::  1 Word.word)  :: (( 'N::len)Word.word) M) \<bind> (\<lambda> (w__0 ::
        ( 'N::len)Word.word) . 
      (let (op1 :: ( 'N::len)Word.word) = w__0 in
      return (op1, op2)))
    else
      (if ((((((type1 \<noteq> FPType_QNaN))) \<and> (((type2 = FPType_QNaN)))))) then
         (FPInfinity ((int (size op1))) (vec_of_bits [B1]  ::  1 Word.word)  :: (( 'N::len)Word.word) M)
       else return op2) \<bind> (\<lambda> (op2 :: ( 'N::len)Word.word) . 
      return (op1, op2))) \<bind> (\<lambda> varstup .  (let ((op1 :: ( 'N::len)Word.word), (op2 :: ( 'N::len)Word.word)) = varstup in
   (FPMax op1 op2 fpcr  :: (( 'N::len)Word.word) M))))))))))))))))))))))"


(*val FPDiv : forall 'N . Size 'N => mword 'N -> mword 'N -> mword ty32 -> M (mword 'N)*)

definition FPDiv  :: "('N::len)Word.word \<Rightarrow>('N::len)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " FPDiv op1 op2 fpcr = (
   (assert_exp ((((((((int (size op1))) = (( 16 :: int)::ii)))) \<or> ((((((((int (size op1))) = (( 32 :: int)::ii)))) \<or> (((((int (size op1))) = (( 64 :: int)::ii)))))))))) (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
   undefined_real () ) \<bind> (\<lambda> (value1_name :: real) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (sign1 :: 1 bits) . 
   undefined_FPType ()  \<bind> (\<lambda> (type1 :: FPType) . 
   (FPUnpack op1 fpcr  :: ((FPType *  1 Word.word * real)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1, tup__2) = varstup in
   (let type1 = tup__0 in
   (let sign1 = tup__1 in
   (let value1_name = tup__2 in
   undefined_real ()  \<bind> (\<lambda> (value2_name :: real) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (sign2 :: 1 bits) . 
   undefined_FPType ()  \<bind> (\<lambda> (type2 :: FPType) . 
   (FPUnpack op2 fpcr  :: ((FPType *  1 Word.word * real)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1, tup__2) = varstup in
   (let type2 = tup__0 in
   (let sign2 = tup__1 in
   (let value2_name = tup__2 in
   (undefined_bitvector ((int (size op1)))  :: (( 'N::len)Word.word) M) \<bind> (\<lambda> result . 
   undefined_bool ()  \<bind> (\<lambda> (done1 :: bool) . 
   (FPProcessNaNs type1 type2 op1 op2 fpcr ) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1) = varstup in
   (let done1 = tup__0 in
   (let result = tup__1 in
   undefined_bool ()  \<bind> (\<lambda> (zero2 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (zero1 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (inf2 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (inf1 :: bool) . 
   if ((\<not> done1)) then
     (let inf1 = (type1 = FPType_Infinity) in
     (let inf2 = (type2 = FPType_Infinity) in
     (let zero1 = (type1 = FPType_Zero) in
     (let zero2 = (type2 = FPType_Zero) in
     if ((((((inf1 \<and> inf2))) \<or> (((zero1 \<and> zero2)))))) then
       (FPDefaultNaN ((int (size op1))) ()   :: (( 'N::len)Word.word) M) \<bind> (\<lambda> (w__0 :: ( 'N::len)Word.word) . 
       (let result = w__0 in
       FPProcessException FPExc_InvalidOp fpcr \<then> return result))
     else if (((inf1 \<or> zero2))) then
       (FPInfinity ((int (size op1))) ((xor_vec sign1 sign2  ::  1 Word.word))  :: (( 'N::len)Word.word) M) \<bind> (\<lambda> (w__1 ::
         ( 'N::len)Word.word) . 
       (let result = w__1 in
       (if ((\<not> inf1)) then FPProcessException FPExc_DivideByZero fpcr
        else return () ) \<then>
       return result))
     else if (((zero1 \<or> inf2))) then
       (FPZero ((int (size op1))) ((xor_vec sign1 sign2  ::  1 Word.word))  :: (( 'N::len)Word.word) M)
     else (FPRound__1 ((int (size op1))) ((value1_name div value2_name)) fpcr  :: (( 'N::len)Word.word) M)))))
   else return result)))))))))))))))))))))))))))"


(*val FPAdd : forall 'N . Size 'N => mword 'N -> mword 'N -> mword ty32 -> M (mword 'N)*)

definition FPAdd  :: "('N::len)Word.word \<Rightarrow>('N::len)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(('N::len)Word.word),(exception))monad "  where 
     " FPAdd op1 op2 fpcr = (
   assert_exp ((((((((int (size op1))) = (( 16 :: int)::ii)))) \<or> ((((((((int (size op1))) = (( 32 :: int)::ii)))) \<or> (((((int (size op1))) = (( 64 :: int)::ii)))))))))) (''((N == 16) || ((N == 32) || (N == 64)))'') \<then>
   ((let (rounding :: FPRounding) = (FPRoundingMode fpcr) in
   undefined_real ()  \<bind> (\<lambda> (value1_name :: real) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (sign1 :: 1 bits) . 
   undefined_FPType ()  \<bind> (\<lambda> (type1 :: FPType) . 
   (FPUnpack op1 fpcr  :: ((FPType *  1 Word.word * real)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1, tup__2) = varstup in
   (let type1 = tup__0 in
   (let sign1 = tup__1 in
   (let value1_name = tup__2 in
   undefined_real ()  \<bind> (\<lambda> (value2_name :: real) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (sign2 :: 1 bits) . 
   undefined_FPType ()  \<bind> (\<lambda> (type2 :: FPType) . 
   (FPUnpack op2 fpcr  :: ((FPType *  1 Word.word * real)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1, tup__2) = varstup in
   (let type2 = tup__0 in
   (let sign2 = tup__1 in
   (let value2_name = tup__2 in
   (undefined_bitvector ((int (size op1)))  :: (( 'N::len)Word.word) M) \<bind> (\<lambda> result . 
   undefined_bool ()  \<bind> (\<lambda> (done1 :: bool) . 
   (FPProcessNaNs type1 type2 op1 op2 fpcr ) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1) = varstup in
   (let done1 = tup__0 in
   (let result = tup__1 in
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (result_sign :: 1 bits) . 
   undefined_real ()  \<bind> (\<lambda> (result_value :: real) . 
   undefined_bool ()  \<bind> (\<lambda> (zero2 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (zero1 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (inf2 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (inf1 :: bool) . 
   if ((\<not> done1)) then
     (let inf1 = (type1 = FPType_Infinity) in
     (let inf2 = (type2 = FPType_Infinity) in
     (let zero1 = (type1 = FPType_Zero) in
     (let zero2 = (type2 = FPType_Zero) in
     if ((((((inf1 \<and> inf2))) \<and> (((sign1 = ((not_vec sign2  ::  1 Word.word)))))))) then
       (FPDefaultNaN ((int (size op1))) ()   :: (( 'N::len)Word.word) M) \<bind> (\<lambda> (w__0 :: ( 'N::len)Word.word) . 
       (let result = w__0 in
       FPProcessException FPExc_InvalidOp fpcr \<then> return result))
     else if ((((((inf1 \<and> (((sign1 = (vec_of_bits [B0]  ::  1 Word.word))))))) \<or> (((inf2 \<and> (((sign2 = (vec_of_bits [B0]  ::  1 Word.word)))))))))) then
       (FPInfinity ((int (size op1))) (vec_of_bits [B0]  ::  1 Word.word)  :: (( 'N::len)Word.word) M)
     else if ((((((inf1 \<and> (((sign1 = (vec_of_bits [B1]  ::  1 Word.word))))))) \<or> (((inf2 \<and> (((sign2 = (vec_of_bits [B1]  ::  1 Word.word)))))))))) then
       (FPInfinity ((int (size op1))) (vec_of_bits [B1]  ::  1 Word.word)  :: (( 'N::len)Word.word) M)
     else if ((((((zero1 \<and> zero2))) \<and> (((sign1 = sign2)))))) then
       (FPZero ((int (size op1))) sign1  :: (( 'N::len)Word.word) M)
     else
       (let result_value = (value1_name + value2_name) in
       if (((result_value = (realFromFrac(( 0 :: int))(( 10 :: int)))))) then
         (let result_sign =
           (if (((rounding = FPRounding_NEGINF))) then (vec_of_bits [B1]  ::  1 Word.word)
           else (vec_of_bits [B0]  ::  1 Word.word)) in
         (FPZero ((int (size op1))) result_sign  :: (( 'N::len)Word.word) M))
       else (FPRound__0 ((int (size op1))) result_value fpcr rounding  :: (( 'N::len)Word.word) M))))))
   else return result)))))))))))))))))))))))))))))))"


(*val ExternalSecureInvasiveDebugEnabled : unit -> M bool*)

definition ExternalSecureInvasiveDebugEnabled  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " ExternalSecureInvasiveDebugEnabled _ = (
   and_boolM (return ((\<not> ((HaveEL EL3)))))
     (IsSecure ()  \<bind> (\<lambda> (w__0 :: bool) .  return ((\<not> w__0)))) \<bind> (\<lambda> (w__1 :: bool) . 
   if w__1 then return False
   else
     and_boolM ((ExternalInvasiveDebugEnabled () ))
       (read_reg SPIDEN_ref \<bind> (\<lambda> (w__3 :: signal) .  return (((w__3 = HIGH)))))))"


(*val ExternalDebugInterruptsDisabled : mword ty2 -> M bool*)

definition ExternalDebugInterruptsDisabled  :: "(2)Word.word \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " ExternalDebugInterruptsDisabled target = (
   undefined_bool ()  \<bind> (\<lambda> (int_dis :: bool) . 
   (let pat0 = target in
   if (((pat0 = EL3))) then
     and_boolM
       ((read_reg EDSCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 :: 32 bits) . 
        return (((((slice w__0 (( 22 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B1]  ::  2 Word.word)))))) ((ExternalSecureInvasiveDebugEnabled () ))
   else if (((pat0 = EL2))) then
     and_boolM
       ((read_reg EDSCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__3 :: 32 bits) . 
        return (((((and_vec ((slice w__3 (( 22 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))
                       (vec_of_bits [B1,B0]  ::  2 Word.word)
                      ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word))))))
       ((ExternalInvasiveDebugEnabled () ))
   else
     IsSecure ()  \<bind> (\<lambda> (w__6 :: bool) . 
     if w__6 then
       and_boolM
         ((read_reg EDSCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__7 :: 32 bits) . 
          return (((((and_vec ((slice w__7 (( 22 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))
                         (vec_of_bits [B1,B0]  ::  2 Word.word)
                        ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word))))))
         ((ExternalSecureInvasiveDebugEnabled () ))
     else
       and_boolM
         ((read_reg EDSCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__10 :: 32 bits) . 
          return (((((slice w__10 (( 22 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> (vec_of_bits [B0,B0]  ::  2 Word.word)))))) ((ExternalInvasiveDebugEnabled () ))))))"


(*val ELStateUsingAArch32K : mword ty2 -> bool -> M (bool * bool)*)

definition ELStateUsingAArch32K  :: "(2)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(bool*bool),(exception))monad "  where 
     " ELStateUsingAArch32K el secure = (
   undefined_bool ()  \<bind> (\<lambda> (aarch32 :: bool) . 
   (let (known :: bool) = True in
   undefined_bool ()  \<bind> (\<lambda> (aarch32_at_el1 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (aarch32_below_el3 :: bool) . 
   (if ((\<not> ((HaveAArch32EL el)))) then
      (let (aarch32 :: bool) = False in
      return (aarch32, known))
    else if ((HighestELUsingAArch32 () )) then
      (let (aarch32 :: bool) = True in
      return (aarch32, known))
    else
      and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__0 (( 10 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__1 :: bool) . 
      (let aarch32_below_el3 = w__1 in
      or_boolM (return aarch32_below_el3)
        (and_boolM
           (and_boolM (return (((((HaveEL EL2)) \<and> ((\<not> secure))))))
              ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 :: 64 bits) . 
               return ((((vec_of_bits [access_vec_dec w__2 (( 31 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))))
           (and_boolM
              (and_boolM
                 ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 :: 64 bits) . 
                  return ((((vec_of_bits [access_vec_dec w__4 (( 34 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))
                 ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 :: 64 bits) . 
                  return ((((vec_of_bits [access_vec_dec w__5 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))) (return ((HaveVirtHostExt () ))) \<bind> (\<lambda> (w__7 ::
              bool) . 
            return ((\<not> w__7))))) \<bind> (\<lambda> (w__9 :: bool) . 
      (let aarch32_at_el1 = w__9 in
      if ((((((el = EL0))) \<and> ((\<not> aarch32_at_el1))))) then
        read_reg PSTATE_ref \<bind> (\<lambda> (w__10 :: ProcState) . 
        if ((((ProcState_EL   w__10) = EL0))) then
          read_reg PSTATE_ref \<bind> (\<lambda> (w__11 :: ProcState) . 
          (let (aarch32 :: bool) = ((ProcState_nRW   w__11) = (vec_of_bits [B1]  ::  1 Word.word)) in
          return (aarch32, known)))
        else
          (let (known :: bool) = False in
          return (aarch32, known)))
      else
        (let (aarch32 :: bool) =
          ((((aarch32_below_el3 \<and> (((el \<noteq> EL3)))))) \<or> (((aarch32_at_el1 \<and> ((((((el = EL1))) \<or> (((el = EL0)))))))))) in
        return (aarch32, known))))))) \<bind> (\<lambda> varstup .  (let ((aarch32 :: bool), (known :: bool)) = varstup in
   (if ((\<not> known)) then undefined_bool () 
    else return aarch32) \<bind> (\<lambda> (aarch32 :: bool) . 
   return (known, aarch32)))))))))"


(*val ELUsingAArch32K : mword ty2 -> M (bool * bool)*)

definition ELUsingAArch32K  :: "(2)Word.word \<Rightarrow>((register_value),(bool*bool),(exception))monad "  where 
     " ELUsingAArch32K el = ( IsSecureBelowEL3 ()  \<bind> (\<lambda> (w__0 :: bool) .  ELStateUsingAArch32K el w__0))"


(*val ELStateUsingAArch32 : mword ty2 -> bool -> M bool*)

definition ELStateUsingAArch32  :: "(2)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " ELStateUsingAArch32 el secure = (
   undefined_bool ()  \<bind> (\<lambda> (aarch32 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (known :: bool) . 
   ELStateUsingAArch32K el secure \<bind> (\<lambda> varstup .  (let (tup__0, tup__1) = varstup in
   (let known = tup__0 in
   (let aarch32 = tup__1 in
   assert_exp known (''known'') \<then> return aarch32)))))))"


(*val ELUsingAArch32 : mword ty2 -> M bool*)

definition ELUsingAArch32  :: "(2)Word.word \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " ELUsingAArch32 el = ( IsSecureBelowEL3 ()  \<bind> (\<lambda> (w__0 :: bool) .  ELStateUsingAArch32 el w__0))"


(*val UpdateEDSCRFields : unit -> M unit*)

definition UpdateEDSCRFields  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " UpdateEDSCRFields _ = (
   Halted ()  \<bind> (\<lambda> (w__0 :: bool) . 
   if ((\<not> w__0)) then
     (read_reg EDSCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 :: 32 bits) . 
     (write_reg
       EDSCR_ref
       ((set_slice (( 32 :: int)::ii) (( 2 :: int)::ii) w__1 (( 8 :: int)::ii) (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  32 Word.word)) \<then>
     (read_reg EDSCR_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__2 :: 32 bits) . 
     (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__3 ::  1 Word.word) . 
     (write_reg EDSCR_ref ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__2 (( 18 :: int)::ii) w__3  ::  32 Word.word)) \<then>
     (read_reg EDSCR_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__4 :: 32 bits) . 
     write_reg
       EDSCR_ref
       ((set_slice (( 32 :: int)::ii) (( 4 :: int)::ii) w__4 (( 10 :: int)::ii) (vec_of_bits [B1,B1,B1,B1]  ::  4 Word.word)
          ::  32 Word.word))))))
   else
     (read_reg EDSCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__5 :: 32 bits) . 
     read_reg PSTATE_ref \<bind> (\<lambda> (w__6 :: ProcState) . 
     (write_reg EDSCR_ref ((set_slice (( 32 :: int)::ii) (( 2 :: int)::ii) w__5 (( 8 :: int)::ii)(ProcState_EL   w__6)  ::  32 Word.word)) \<then>
     (read_reg EDSCR_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__7 :: 32 bits) . 
     IsSecure ()  \<bind> (\<lambda> (w__8 :: bool) . 
     (write_reg
       EDSCR_ref
       ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__7 (( 18 :: int)::ii)
           (if w__8 then (vec_of_bits [B0]  ::  1 Word.word)
            else (vec_of_bits [B1]  ::  1 Word.word))
          ::  32 Word.word)) \<then>
     (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M)) \<bind> (\<lambda> (RW :: 4 bits) . 
     ELUsingAArch32 EL1 \<bind> (\<lambda> (w__9 :: bool) . 
     (let (RW :: 4 bits) =
       ((set_slice (( 4 :: int)::ii) (( 1 :: int)::ii) RW (( 1 :: int)::ii)
          (if w__9 then (vec_of_bits [B0]  ::  1 Word.word)
           else (vec_of_bits [B1]  ::  1 Word.word))
         ::  4 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__10 :: ProcState) . 
     (if ((((ProcState_EL   w__10) \<noteq> EL0))) then
        (let (RW :: 4 bits) =
          ((set_slice (( 4 :: int)::ii) (( 1 :: int)::ii) RW (( 0 :: int)::ii) (vec_of_bits [access_vec_dec RW (( 1 :: int)::ii)]  ::  1 Word.word)
            ::  4 Word.word)) in
        return RW)
      else
        UsingAArch32 ()  \<bind> (\<lambda> (w__11 :: bool) . 
        (let (RW :: 4 bits) =
          ((set_slice (( 4 :: int)::ii) (( 1 :: int)::ii) RW (( 0 :: int)::ii)
             (if w__11 then (vec_of_bits [B0]  ::  1 Word.word)
              else (vec_of_bits [B1]  ::  1 Word.word))
            ::  4 Word.word)) in
        return RW))) \<bind> (\<lambda> (RW :: 4 bits) . 
     or_boolM (return ((\<not> ((HaveEL EL2)))))
       (and_boolM (return ((HaveEL EL3)))
          ((aget_SCR_GEN ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__12 ::  32 Word.word) . 
           return ((((vec_of_bits [access_vec_dec w__12 (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))) \<bind> (\<lambda> (w__14 :: bool) . 
     (if w__14 then
        (let (RW :: 4 bits) =
          ((set_slice (( 4 :: int)::ii) (( 1 :: int)::ii) RW (( 2 :: int)::ii) (vec_of_bits [access_vec_dec RW (( 1 :: int)::ii)]  ::  1 Word.word)
            ::  4 Word.word)) in
        return RW)
      else
        ELUsingAArch32 EL2 \<bind> (\<lambda> (w__15 :: bool) . 
        (let (RW :: 4 bits) =
          ((set_slice (( 4 :: int)::ii) (( 1 :: int)::ii) RW (( 2 :: int)::ii)
             (if w__15 then (vec_of_bits [B0]  ::  1 Word.word)
              else (vec_of_bits [B1]  ::  1 Word.word))
            ::  4 Word.word)) in
        return RW))) \<bind> (\<lambda> (RW :: 4 bits) . 
     (if ((\<not> ((HaveEL EL3)))) then
        (let (RW :: 4 bits) =
          ((set_slice (( 4 :: int)::ii) (( 1 :: int)::ii) RW (( 3 :: int)::ii) (vec_of_bits [access_vec_dec RW (( 2 :: int)::ii)]  ::  1 Word.word)
            ::  4 Word.word)) in
        return RW)
      else
        ELUsingAArch32 EL3 \<bind> (\<lambda> (w__16 :: bool) . 
        (let (RW :: 4 bits) =
          ((set_slice (( 4 :: int)::ii) (( 1 :: int)::ii) RW (( 3 :: int)::ii)
             (if w__16 then (vec_of_bits [B0]  ::  1 Word.word)
              else (vec_of_bits [B1]  ::  1 Word.word))
            ::  4 Word.word)) in
        return RW))) \<bind> (\<lambda> (RW :: 4 bits) . 
     (if ((((vec_of_bits [access_vec_dec RW (( 3 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))) then
        (undefined_bitvector (( 3 :: int)::ii)  :: ( 3 Word.word) M) \<bind> (\<lambda> (w__17 ::  3 Word.word) . 
        (let (RW :: 4 bits) = ((set_slice (( 4 :: int)::ii) (( 3 :: int)::ii) RW (( 0 :: int)::ii) w__17  ::  4 Word.word)) in
        return RW))
      else if ((((vec_of_bits [access_vec_dec RW (( 2 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))) then
        (undefined_bitvector (( 2 :: int)::ii)  :: ( 2 Word.word) M) \<bind> (\<lambda> (w__18 ::  2 Word.word) . 
        (let (RW :: 4 bits) = ((set_slice (( 4 :: int)::ii) (( 2 :: int)::ii) RW (( 0 :: int)::ii) w__18  ::  4 Word.word)) in
        return RW))
      else if ((((vec_of_bits [access_vec_dec RW (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))) then
        (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__19 ::  1 Word.word) . 
        (let (RW :: 4 bits) = ((set_slice (( 4 :: int)::ii) (( 1 :: int)::ii) RW (( 0 :: int)::ii) w__19  ::  4 Word.word)) in
        return RW))
      else return RW) \<bind> (\<lambda> (RW :: 4 bits) . 
     (read_reg EDSCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__20 :: 32 bits) . 
     write_reg EDSCR_ref ((set_slice (( 32 :: int)::ii) (( 4 :: int)::ii) w__20 (( 10 :: int)::ii) RW  ::  32 Word.word))))))))))))))))))"


(*val Halt : mword ty6 -> M unit*)

definition Halt  :: "(6)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " Halt reason = (
   (CTI_SignalEvent CrossTriggerIn_CrossHalt \<then>
   UsingAArch32 () ) \<bind> (\<lambda> (w__0 :: bool) . 
   ((if w__0 then
      (ThisInstrAddr (( 32 :: int)::ii) ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 ::  32 Word.word) . 
      (write_reg DLR_ref w__1 \<then>
      (GetPSRFromPSTATE ()   :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__2 ::  32 Word.word) . 
      (write_reg DSPSR_ref w__2 \<then>
      (read_reg DSPSR_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__3 :: 32 bits) . 
      read_reg PSTATE_ref \<bind> (\<lambda> (w__4 :: ProcState) . 
      write_reg
        DSPSR_ref
        ((update_subrange_vec_dec w__3 (( 21 :: int)::ii) (( 21 :: int)::ii)(ProcState_SS   w__4)  ::  32 Word.word))))))
    else
      (ThisInstrAddr (( 64 :: int)::ii) ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 ::  64 Word.word) . 
      (write_reg DLR_EL0_ref w__5 \<then>
      (GetPSRFromPSTATE ()   :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__6 ::  32 Word.word) . 
      (write_reg DSPSR_EL0_ref w__6 \<then>
      (read_reg DSPSR_EL0_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__7 :: 32 bits) . 
      read_reg PSTATE_ref \<bind> (\<lambda> (w__8 :: ProcState) . 
      write_reg
        DSPSR_EL0_ref
        ((update_subrange_vec_dec w__7 (( 21 :: int)::ii) (( 21 :: int)::ii)(ProcState_SS   w__8)  ::  32 Word.word))))))) \<then>
   (read_reg EDSCR_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__9 :: 32 bits) . 
   (write_reg
     EDSCR_ref
     ((update_subrange_vec_dec w__9 (( 24 :: int)::ii) (( 24 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)  ::  32 Word.word)) \<then>
   (read_reg EDSCR_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__10 :: 32 bits) . 
   (write_reg
     EDSCR_ref
     ((update_subrange_vec_dec w__10 (( 28 :: int)::ii) (( 28 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word)) \<then>
   IsSecure () ) \<bind> (\<lambda> (w__11 :: bool) . 
   ((if w__11 then
      (read_reg EDSCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__12 :: 32 bits) . 
      write_reg
        EDSCR_ref
        ((update_subrange_vec_dec w__12 (( 16 :: int)::ii) (( 16 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)
           ::  32 Word.word)))
    else if ((HaveEL EL3)) then
      (read_reg EDSCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__13 :: 32 bits) . 
      ExternalSecureInvasiveDebugEnabled ()  \<bind> (\<lambda> (w__14 :: bool) . 
      write_reg
        EDSCR_ref
        ((update_subrange_vec_dec w__13 (( 16 :: int)::ii) (( 16 :: int)::ii)
            (if w__14 then (vec_of_bits [B0]  ::  1 Word.word)
             else (vec_of_bits [B1]  ::  1 Word.word))
           ::  32 Word.word))))
    else
      (read_reg EDSCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__15 :: 32 bits) . 
      assert_exp ((((vec_of_bits [access_vec_dec w__15 (( 16 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) ([(CHR ''(''), (CHR ''(''), (CHR ''E''), (CHR ''D''), (CHR ''S''), (CHR ''C''), (CHR ''R''), (CHR '')''), (CHR ''.''), (CHR ''S''), (CHR ''D''), (CHR ''D''), (CHR '' ''), (CHR ''=''), (CHR ''=''), (CHR '' ''), (CHR 0x27), (CHR ''1''), (CHR 0x27), (CHR '')'')]))) \<then>
   (read_reg EDSCR_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__16 :: 32 bits) . 
   (write_reg
     EDSCR_ref
     ((update_subrange_vec_dec w__16 (( 20 :: int)::ii) (( 20 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word)) \<then>
   UsingAArch32 () ) \<bind> (\<lambda> (w__17 :: bool) . 
   ((if w__17 then
      (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (w__18 ::  4 Word.word) . 
      (let split_vec = w__18 in
      (let (tup__0, tup__1, tup__2, tup__3) =
        ((subrange_vec_dec split_vec (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
      read_reg PSTATE_ref \<bind> (\<lambda> (w__19 :: ProcState) . 
      (write_reg PSTATE_ref (w__19 (| ProcState_SS := tup__0 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__20 :: ProcState) . 
      (write_reg PSTATE_ref (w__20 (| ProcState_A := tup__1 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__21 :: ProcState) . 
      (write_reg PSTATE_ref (w__21 (| ProcState_I := tup__2 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__22 :: ProcState) . 
      (write_reg PSTATE_ref (w__22 (| ProcState_F := tup__3 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__23 :: ProcState) . 
      (write_reg
        PSTATE_ref
        (w__23 (| ProcState_IT := ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word))|)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__24 :: ProcState) . 
      write_reg PSTATE_ref (w__24 (| ProcState_T := ((vec_of_bits [B1]  ::  1 Word.word))|)))))))))))
    else
      (undefined_bitvector (( 5 :: int)::ii)  :: ( 5 Word.word) M) \<bind> (\<lambda> (w__25 ::  5 Word.word) . 
      (let split_vec = w__25 in
      (let (tup__0, tup__1, tup__2, tup__3, tup__4) =
        ((subrange_vec_dec split_vec (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
      read_reg PSTATE_ref \<bind> (\<lambda> (w__26 :: ProcState) . 
      (write_reg PSTATE_ref (w__26 (| ProcState_SS := tup__0 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__27 :: ProcState) . 
      (write_reg PSTATE_ref (w__27 (| ProcState_D := tup__1 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__28 :: ProcState) . 
      (write_reg PSTATE_ref (w__28 (| ProcState_A := tup__2 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__29 :: ProcState) . 
      (write_reg PSTATE_ref (w__29 (| ProcState_I := tup__3 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__30 :: ProcState) . 
      write_reg PSTATE_ref (w__30 (| ProcState_F := tup__4 |))))))))))) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__31 :: ProcState) . 
   ((write_reg PSTATE_ref (w__31 (| ProcState_IL := ((vec_of_bits [B0]  ::  1 Word.word))|)) \<then>
   StopInstructionPrefetchAndEnableITR () ) \<then>
   (read_reg EDSCR_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__32 :: 32 bits) . 
   write_reg EDSCR_ref ((update_subrange_vec_dec w__32 (( 5 :: int)::ii) (( 0 :: int)::ii) reason  ::  32 Word.word)) \<then>
   UpdateEDSCRFields () )))))))))"


(*val aarch64_system_exceptions_debug_halt : unit -> M unit*)

definition aarch64_system_exceptions_debug_halt  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_system_exceptions_debug_halt _ = ( Halt DebugHalt_HaltInstruction )"


(*val S2CacheDisabled : AccType -> M bool*)

definition S2CacheDisabled  :: " AccType \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " S2CacheDisabled acctype = (
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (disable :: 1 bits) . 
   ELUsingAArch32 EL2 \<bind> (\<lambda> (w__0 :: bool) . 
   (if w__0 then
      if (((acctype = AccType_IFETCH))) then
        (read_reg HCR2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 :: 32 bits) . 
        return (vec_of_bits [access_vec_dec w__1 (( 1 :: int)::ii)]  ::  1 Word.word))
      else
        (read_reg HCR2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__2 :: 32 bits) . 
        return (vec_of_bits [access_vec_dec w__2 (( 0 :: int)::ii)]  ::  1 Word.word))
    else if (((acctype = AccType_IFETCH))) then
      (read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 :: 64 bits) . 
      return (vec_of_bits [access_vec_dec w__4 (( 33 :: int)::ii)]  ::  1 Word.word))
    else
      (read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 :: 64 bits) . 
      return (vec_of_bits [access_vec_dec w__5 (( 32 :: int)::ii)]  ::  1 Word.word))) \<bind> (\<lambda> (disable :: 1 bits) . 
   return (((disable = (vec_of_bits [B1]  ::  1 Word.word))))))))"


(*val S2ConvertAttrsHints : mword ty2 -> AccType -> M MemAttrHints*)

definition S2ConvertAttrsHints  :: "(2)Word.word \<Rightarrow> AccType \<Rightarrow>((register_value),(MemAttrHints),(exception))monad "  where 
     " S2ConvertAttrsHints attr acctype = (
   (assert_exp ((\<not> ((IsZero attr)))) (''!(IsZero(attr))'') \<then>
   undefined_MemAttrHints () ) \<bind> (\<lambda> (result :: MemAttrHints) . 
   S2CacheDisabled acctype \<bind> (\<lambda> (w__0 :: bool) . 
   (let (result :: MemAttrHints) =
     (if w__0 then
       (let (result :: MemAttrHints) = ((result (| MemAttrHints_attrs := MemAttr_NC |))) in
       (result (| MemAttrHints_hints := MemHint_No |)))
     else
       (let b__0 = attr in
       if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
         (let (result :: MemAttrHints) = ((result (| MemAttrHints_attrs := MemAttr_NC |))) in
         (result (| MemAttrHints_hints := MemHint_No |)))
       else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
         (let (result :: MemAttrHints) = ((result (| MemAttrHints_attrs := MemAttr_WT |))) in
         (result (| MemAttrHints_hints := MemHint_RWA |)))
       else
         (let (result :: MemAttrHints) = ((result (| MemAttrHints_attrs := MemAttr_WB |))) in
         (result (| MemAttrHints_hints := MemHint_RWA |))))) in
   (let (result :: MemAttrHints) = ((result (| MemAttrHints_transient := False |))) in
   return result)))))"


(*val S2AttrDecode : mword ty2 -> mword ty4 -> AccType -> M MemoryAttributes*)

definition S2AttrDecode  :: "(2)Word.word \<Rightarrow>(4)Word.word \<Rightarrow> AccType \<Rightarrow>((register_value),(MemoryAttributes),(exception))monad "  where 
     " S2AttrDecode SH attr acctype = (
   undefined_MemoryAttributes ()  \<bind> (\<lambda> (memattrs :: MemoryAttributes) . 
   (if (((((slice attr (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
      (let (memattrs :: MemoryAttributes) = ((memattrs (| MemoryAttributes_typ := MemType_Device |))) in
      (let b__0 = ((slice attr (( 0 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) in
      (let (memattrs :: MemoryAttributes) =
        (if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
          (memattrs (| MemoryAttributes_device := DeviceType_nGnRnE |))
        else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
          (memattrs (| MemoryAttributes_device := DeviceType_nGnRE |))
        else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
          (memattrs (| MemoryAttributes_device := DeviceType_nGRE |))
        else (memattrs (| MemoryAttributes_device := DeviceType_GRE |))) in
      return memattrs)))
    else if (((((slice attr (( 0 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) \<noteq> (vec_of_bits [B0,B0]  ::  2 Word.word))))
    then
      (let memattrs = ((memattrs (| MemoryAttributes_typ := MemType_Normal |))) in
      S2ConvertAttrsHints ((slice attr (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) acctype \<bind> (\<lambda> (w__0 ::
        MemAttrHints) . 
      (let memattrs = ((memattrs (| MemoryAttributes_outer := w__0 |))) in
      S2ConvertAttrsHints ((slice attr (( 0 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) acctype \<bind> (\<lambda> (w__1 ::
        MemAttrHints) . 
      (let (memattrs :: MemoryAttributes) = ((memattrs (| MemoryAttributes_inner := w__1 |))) in
      (let (memattrs :: MemoryAttributes) =
        ((memattrs (|
          MemoryAttributes_shareable :=
            ((((vec_of_bits [access_vec_dec SH (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))|))) in
      (let (memattrs :: MemoryAttributes) =
        ((memattrs (|
          MemoryAttributes_outershareable := (((SH = (vec_of_bits [B1,B0]  ::  2 Word.word))))|))) in
      return memattrs)))))))
    else undefined_MemoryAttributes () ) \<bind> (\<lambda> (memattrs :: MemoryAttributes) . 
   MemAttrDefaults memattrs)))"


(*val ELIsInHost : mword ty2 -> M bool*)

definition ELIsInHost  :: "(2)Word.word \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " ELIsInHost el = (
   and_boolM
     (and_boolM
        (and_boolM
           (and_boolM (IsSecureBelowEL3 ()  \<bind> (\<lambda> (w__0 :: bool) .  return ((\<not> w__0))))
              (return ((HaveVirtHostExt () ))))
           (ELUsingAArch32 EL2 \<bind> (\<lambda> (w__2 :: bool) .  return ((\<not> w__2)))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__4 (( 34 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
     (or_boolM (return (((el = EL2))))
        (and_boolM (return (((el = EL0))))
           ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__6 :: 64 bits) . 
            return ((((vec_of_bits [access_vec_dec w__6 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))))"


(*val S1TranslationRegime__0 : mword ty2 -> M (mword ty2)*)

(*val S1TranslationRegime__1 : unit -> M (mword ty2)*)

definition S1TranslationRegime__0  :: "(2)Word.word \<Rightarrow>((register_value),((2)Word.word),(exception))monad "  where 
     " S1TranslationRegime__0 el = (
   if (((el \<noteq> EL0))) then return el
   else
     and_boolM (and_boolM (return ((HaveEL EL3))) ((ELUsingAArch32 EL3)))
       ((read_reg SCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__2 :: 32 bits) . 
        return ((((vec_of_bits [access_vec_dec w__2 (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__3 :: bool) . 
     if w__3 then return EL3
     else
       and_boolM (return ((HaveVirtHostExt () ))) ((ELIsInHost el)) \<bind> (\<lambda> (w__5 :: bool) . 
       return (if w__5 then EL2
               else EL1))))"


definition S1TranslationRegime__1  :: " unit \<Rightarrow>((register_value),((2)Word.word),(exception))monad "  where 
     " S1TranslationRegime__1 _ = (
   read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) . 
   (S1TranslationRegime__0(ProcState_EL   w__0)  :: ( 2 Word.word) M)))"


(*val aset_FAR__0 : mword ty2 -> mword ty64 -> M unit*)

(*val aset_FAR__1 : mword ty64 -> M unit*)

definition aset_FAR__0  :: "(2)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aset_FAR__0 regime value_name = (
   (let (r :: 64 bits) = value_name in
   (let pat0 = regime in
   if (((pat0 = EL1))) then write_reg FAR_EL1_ref r
   else if (((pat0 = EL2))) then write_reg FAR_EL2_ref r
   else if (((pat0 = EL3))) then write_reg FAR_EL3_ref r
   else Unreachable () )))"


definition aset_FAR__1  :: "(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aset_FAR__1 value_name = (
   (S1TranslationRegime__1 ()   :: ( 2 Word.word) M) \<bind> (\<lambda> (w__0 ::  2 Word.word) . 
   aset_FAR__0 w__0 value_name))"


(*val aset_ESR__0 : mword ty2 -> mword ty32 -> M unit*)

(*val aset_ESR__1 : mword ty32 -> M unit*)

definition aset_ESR__0  :: "(2)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aset_ESR__0 regime value_name = (
   (let (r :: 32 bits) = value_name in
   (let pat0 = regime in
   if (((pat0 = EL1))) then write_reg ESR_EL1_ref r
   else if (((pat0 = EL2))) then write_reg ESR_EL2_ref r
   else if (((pat0 = EL3))) then write_reg ESR_EL3_ref r
   else Unreachable () )))"


definition aset_ESR__1  :: "(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aset_ESR__1 value_name = (
   (S1TranslationRegime__1 ()   :: ( 2 Word.word) M) \<bind> (\<lambda> (w__0 ::  2 Word.word) . 
   aset_ESR__0 w__0 value_name))"


(*val aget_VBAR__0 : mword ty2 -> M (mword ty64)*)

(*val aget_VBAR__1 : unit -> M (mword ty64)*)

definition aget_VBAR__0  :: "(2)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " aget_VBAR__0 regime = (
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (r :: 64 bits) . 
   (let pat0 = regime in
   if (((pat0 = EL1))) then (read_reg VBAR_EL1_ref  :: ( 64 Word.word) M)
   else if (((pat0 = EL2))) then (read_reg VBAR_EL2_ref  :: ( 64 Word.word) M)
   else if (((pat0 = EL3))) then (read_reg VBAR_EL3_ref  :: ( 64 Word.word) M)
   else Unreachable ()  \<then> return r)))"


definition aget_VBAR__1  :: " unit \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " aget_VBAR__1 _ = (
   (S1TranslationRegime__1 ()   :: ( 2 Word.word) M) \<bind> (\<lambda> (w__0 ::  2 Word.word) . 
   (aget_VBAR__0 w__0  :: ( 64 Word.word) M)))"


(*val aget_SCTLR__0 : mword ty2 -> M (mword ty32)*)

(*val aget_SCTLR__1 : unit -> M (mword ty32)*)

definition aget_SCTLR__0  :: "(2)Word.word \<Rightarrow>((register_value),((32)Word.word),(exception))monad "  where 
     " aget_SCTLR__0 regime = (
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (r :: 32 bits) . 
   (let pat0 = regime in
   if (((pat0 = EL1))) then (read_reg SCTLR_EL1_ref  :: ( 32 Word.word) M)
   else if (((pat0 = EL2))) then (read_reg SCTLR_EL2_ref  :: ( 32 Word.word) M)
   else if (((pat0 = EL3))) then (read_reg SCTLR_EL3_ref  :: ( 32 Word.word) M)
   else Unreachable ()  \<then> return r)))"


definition aget_SCTLR__1  :: " unit \<Rightarrow>((register_value),((32)Word.word),(exception))monad "  where 
     " aget_SCTLR__1 _ = (
   (S1TranslationRegime__1 ()   :: ( 2 Word.word) M) \<bind> (\<lambda> (w__0 ::  2 Word.word) . 
   (aget_SCTLR__0 w__0  :: ( 32 Word.word) M)))"


(*val BigEndian : unit -> M bool*)

definition BigEndian  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " BigEndian _ = (
   undefined_bool ()  \<bind> (\<lambda> (bigend :: bool) . 
   UsingAArch32 ()  \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then
     read_reg PSTATE_ref \<bind> (\<lambda> (w__1 :: ProcState) . 
     (let (bigend :: bool) = ((ProcState_E   w__1) \<noteq> (vec_of_bits [B0]  ::  1 Word.word)) in
     return bigend))
   else
     read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) . 
     if ((((ProcState_EL   w__2) = EL0))) then
       (aget_SCTLR__1 ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__3 ::  32 Word.word) . 
       (let (bigend :: bool) =
         ((vec_of_bits [access_vec_dec w__3 (( 24 :: int)::ii)]  ::  1 Word.word) \<noteq> (vec_of_bits [B0]  ::  1 Word.word)) in
       return bigend))
     else
       (aget_SCTLR__1 ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__4 ::  32 Word.word) . 
       (let (bigend :: bool) =
         ((vec_of_bits [access_vec_dec w__4 (( 25 :: int)::ii)]  ::  1 Word.word) \<noteq> (vec_of_bits [B0]  ::  1 Word.word)) in
       return bigend))))))"


(*val aget_MAIR__0 : mword ty2 -> M (mword ty64)*)

(*val aget_MAIR__1 : unit -> M (mword ty64)*)

definition aget_MAIR__0  :: "(2)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " aget_MAIR__0 regime = (
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (r :: 64 bits) . 
   (let pat0 = regime in
   if (((pat0 = EL1))) then (read_reg MAIR_EL1_ref  :: ( 64 Word.word) M)
   else if (((pat0 = EL2))) then (read_reg MAIR_EL2_ref  :: ( 64 Word.word) M)
   else if (((pat0 = EL3))) then (read_reg MAIR_EL3_ref  :: ( 64 Word.word) M)
   else Unreachable ()  \<then> return r)))"


definition aget_MAIR__1  :: " unit \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " aget_MAIR__1 _ = (
   (S1TranslationRegime__1 ()   :: ( 2 Word.word) M) \<bind> (\<lambda> (w__0 ::  2 Word.word) . 
   (aget_MAIR__0 w__0  :: ( 64 Word.word) M)))"


(*val S1CacheDisabled : AccType -> M bool*)

definition S1CacheDisabled  :: " AccType \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " S1CacheDisabled acctype = (
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (enable :: 1 bits) . 
   (S1TranslationRegime__1 ()   :: ( 2 Word.word) M) \<bind> (\<lambda> (w__0 ::  2 Word.word) . 
   ELUsingAArch32 w__0 \<bind> (\<lambda> (w__1 :: bool) . 
   (if w__1 then
      read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) . 
      if ((((ProcState_EL   w__2) = EL2))) then
        if (((acctype = AccType_IFETCH))) then
          (read_reg HSCTLR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__3 :: 32 bits) . 
          return (vec_of_bits [access_vec_dec w__3 (( 12 :: int)::ii)]  ::  1 Word.word))
        else
          (read_reg HSCTLR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__4 :: 32 bits) . 
          return (vec_of_bits [access_vec_dec w__4 (( 2 :: int)::ii)]  ::  1 Word.word))
      else if (((acctype = AccType_IFETCH))) then
        (read_reg SCTLR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__6 :: 32 bits) . 
        return (vec_of_bits [access_vec_dec w__6 (( 12 :: int)::ii)]  ::  1 Word.word))
      else
        (read_reg SCTLR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__7 :: 32 bits) . 
        return (vec_of_bits [access_vec_dec w__7 (( 2 :: int)::ii)]  ::  1 Word.word)))
    else if (((acctype = AccType_IFETCH))) then
      (aget_SCTLR__1 ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__9 ::  32 Word.word) . 
      return (vec_of_bits [access_vec_dec w__9 (( 12 :: int)::ii)]  ::  1 Word.word))
    else
      (aget_SCTLR__1 ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__10 ::  32 Word.word) . 
      return (vec_of_bits [access_vec_dec w__10 (( 2 :: int)::ii)]  ::  1 Word.word))) \<bind> (\<lambda> (enable :: 1 bits) . 
   return (((enable = (vec_of_bits [B0]  ::  1 Word.word)))))))))"


(*val ShortConvertAttrsHints : mword ty2 -> AccType -> bool -> M MemAttrHints*)

definition ShortConvertAttrsHints  :: "(2)Word.word \<Rightarrow> AccType \<Rightarrow> bool \<Rightarrow>((register_value),(MemAttrHints),(exception))monad "  where 
     " ShortConvertAttrsHints RGN acctype secondstage = (
   undefined_MemAttrHints ()  \<bind> (\<lambda> (result :: MemAttrHints) . 
   or_boolM (and_boolM (return ((\<not> secondstage))) ((S1CacheDisabled acctype)))
     (and_boolM (return secondstage) ((S2CacheDisabled acctype))) \<bind> (\<lambda> (w__4 :: bool) . 
   (let (result :: MemAttrHints) =
     (if w__4 then
       (let (result :: MemAttrHints) = ((result (| MemAttrHints_attrs := MemAttr_NC |))) in
       (result (| MemAttrHints_hints := MemHint_No |)))
     else
       (let b__0 = RGN in
       if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
         (let (result :: MemAttrHints) = ((result (| MemAttrHints_attrs := MemAttr_NC |))) in
         (result (| MemAttrHints_hints := MemHint_No |)))
       else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
         (let (result :: MemAttrHints) = ((result (| MemAttrHints_attrs := MemAttr_WB |))) in
         (result (| MemAttrHints_hints := MemHint_RWA |)))
       else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
         (let (result :: MemAttrHints) = ((result (| MemAttrHints_attrs := MemAttr_WT |))) in
         (result (| MemAttrHints_hints := MemHint_RA |)))
       else
         (let (result :: MemAttrHints) = ((result (| MemAttrHints_attrs := MemAttr_WB |))) in
         (result (| MemAttrHints_hints := MemHint_RA |))))) in
   (let (result :: MemAttrHints) = ((result (| MemAttrHints_transient := False |))) in
   return result)))))"


(*val WalkAttrDecode : mword ty2 -> mword ty2 -> mword ty2 -> bool -> M MemoryAttributes*)

definition WalkAttrDecode  :: "(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(MemoryAttributes),(exception))monad "  where 
     " WalkAttrDecode SH ORGN IRGN secondstage = (
   undefined_MemoryAttributes ()  \<bind> (\<lambda> (memattrs :: MemoryAttributes) . 
   (let (acctype :: AccType) = AccType_NORMAL in
   (let memattrs = ((memattrs (| MemoryAttributes_typ := MemType_Normal |))) in
   ShortConvertAttrsHints IRGN acctype secondstage \<bind> (\<lambda> (w__0 :: MemAttrHints) . 
   (let memattrs = ((memattrs (| MemoryAttributes_inner := w__0 |))) in
   ShortConvertAttrsHints ORGN acctype secondstage \<bind> (\<lambda> (w__1 :: MemAttrHints) . 
   (let memattrs = ((memattrs (| MemoryAttributes_outer := w__1 |))) in
   (let memattrs =
     ((memattrs (|
       MemoryAttributes_shareable :=
         ((((vec_of_bits [access_vec_dec SH (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))|))) in
   (let memattrs =
     ((memattrs (|
       MemoryAttributes_outershareable := (((SH = (vec_of_bits [B1,B0]  ::  2 Word.word))))|))) in
   MemAttrDefaults memattrs))))))))))"


(*val LongConvertAttrsHints : mword ty4 -> AccType -> M MemAttrHints*)

definition LongConvertAttrsHints  :: "(4)Word.word \<Rightarrow> AccType \<Rightarrow>((register_value),(MemAttrHints),(exception))monad "  where 
     " LongConvertAttrsHints attrfield acctype = (
   (assert_exp ((\<not> ((IsZero attrfield)))) (''!(IsZero(attrfield))'') \<then>
   undefined_MemAttrHints () ) \<bind> (\<lambda> (result :: MemAttrHints) . 
   S1CacheDisabled acctype \<bind> (\<lambda> (w__0 :: bool) . 
   (let (result :: MemAttrHints) =
     (if w__0 then
       (let (result :: MemAttrHints) = ((result (| MemAttrHints_attrs := MemAttr_NC |))) in
       (result (| MemAttrHints_hints := MemHint_No |)))
     else if (((((slice attrfield (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
       (let (result :: MemAttrHints) = ((result (| MemAttrHints_attrs := MemAttr_WT |))) in
       (let (result :: MemAttrHints) =
         ((result (| MemAttrHints_hints := ((slice attrfield (( 0 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))|))) in
       (result (| MemAttrHints_transient := True |))))
     else if (((((slice attrfield (( 0 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) = (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)))) then
       (let (result :: MemAttrHints) = ((result (| MemAttrHints_attrs := MemAttr_NC |))) in
       (let (result :: MemAttrHints) = ((result (| MemAttrHints_hints := MemHint_No |))) in
       (result (| MemAttrHints_transient := False |))))
     else if (((((slice attrfield (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
       (let (result :: MemAttrHints) =
         ((result (| MemAttrHints_attrs := ((slice attrfield (( 0 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))|))) in
       (let (result :: MemAttrHints) = ((result (| MemAttrHints_hints := MemAttr_WB |))) in
       (result (| MemAttrHints_transient := True |))))
     else
       (let (result :: MemAttrHints) =
         ((result (| MemAttrHints_attrs := ((slice attrfield (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))|))) in
       (let (result :: MemAttrHints) =
         ((result (| MemAttrHints_hints := ((slice attrfield (( 0 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))|))) in
       (result (| MemAttrHints_transient := False |))))) in
   return result))))"


(*val AArch64_S1AttrDecode : mword ty2 -> mword ty3 -> AccType -> M MemoryAttributes*)

definition AArch64_S1AttrDecode  :: "(2)Word.word \<Rightarrow>(3)Word.word \<Rightarrow> AccType \<Rightarrow>((register_value),(MemoryAttributes),(exception))monad "  where 
     " AArch64_S1AttrDecode SH attr acctype = (
   (let uattr = (ex_nat ((Word.uint attr))) in
   undefined_MemoryAttributes ()  \<bind> (\<lambda> (memattrs :: MemoryAttributes) . 
   (aget_MAIR__1 ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (mair :: 64 bits) . 
   (let (index1 :: int) = ((( 8 :: int)::ii) * uattr) in
   (let (attrfield :: 8 bits) =
     ((subrange_vec_dec mair (((( 7 :: int)::ii) + index1)) index1  ::  8 Word.word)) in
   undefined_Constraint ()  \<bind> (\<lambda> (anon10 :: Constraint) . 
   (if (((((((((((subrange_vec_dec attrfield (( 7 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)))) \<and> (((((subrange_vec_dec attrfield (( 3 :: int)::ii) (( 0 :: int)::ii)  ::  4 Word.word)) = (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word))))))) \<or> ((((((((subrange_vec_dec attrfield (( 7 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) = (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)))) \<and> (((((and_vec ((subrange_vec_dec attrfield (( 3 :: int)::ii) (( 0 :: int)::ii)  ::  4 Word.word))
                       (vec_of_bits [B0,B0,B1,B1]  ::  4 Word.word)
                      ::  4 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)))))))))) then
      (ConstrainUnpredictableBits (( 8 :: int)::ii) Unpredictable_RESMAIR  :: ((Constraint *  8 Word.word)) M) \<bind> (\<lambda> (w__0 ::
        (Constraint *  8 Word.word)) . 
      (let (tup__0, tup__1) = w__0 in
      (let (anon10 :: Constraint) = tup__0 in
      return tup__1)))
    else return attrfield) \<bind> (\<lambda> (attrfield :: 8 bits) . 
   (if (((((subrange_vec_dec attrfield (( 7 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) = (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)))) then
      (let memattrs = ((memattrs (| MemoryAttributes_typ := MemType_Device |))) in
      (let b__0 = ((subrange_vec_dec attrfield (( 3 :: int)::ii) (( 0 :: int)::ii)  ::  4 Word.word)) in
      if (((b__0 = (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)))) then
        (let (memattrs :: MemoryAttributes) =
          ((memattrs (| MemoryAttributes_device := DeviceType_nGnRnE |))) in
        return memattrs)
      else if (((b__0 = (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)))) then
        (let (memattrs :: MemoryAttributes) =
          ((memattrs (| MemoryAttributes_device := DeviceType_nGnRE |))) in
        return memattrs)
      else if (((b__0 = (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)))) then
        (let (memattrs :: MemoryAttributes) =
          ((memattrs (| MemoryAttributes_device := DeviceType_nGRE |))) in
        return memattrs)
      else if (((b__0 = (vec_of_bits [B1,B1,B0,B0]  ::  4 Word.word)))) then
        (let (memattrs :: MemoryAttributes) =
          ((memattrs (| MemoryAttributes_device := DeviceType_GRE |))) in
        return memattrs)
      else Unreachable ()  \<then> return memattrs))
    else if (((((subrange_vec_dec attrfield (( 3 :: int)::ii) (( 0 :: int)::ii)  ::  4 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)))) then
      (let memattrs = ((memattrs (| MemoryAttributes_typ := MemType_Normal |))) in
      LongConvertAttrsHints ((subrange_vec_dec attrfield (( 7 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) acctype \<bind> (\<lambda> (w__1 ::
        MemAttrHints) . 
      (let memattrs = ((memattrs (| MemoryAttributes_outer := w__1 |))) in
      LongConvertAttrsHints ((subrange_vec_dec attrfield (( 3 :: int)::ii) (( 0 :: int)::ii)  ::  4 Word.word)) acctype \<bind> (\<lambda> (w__2 ::
        MemAttrHints) . 
      (let (memattrs :: MemoryAttributes) = ((memattrs (| MemoryAttributes_inner := w__2 |))) in
      (let (memattrs :: MemoryAttributes) =
        ((memattrs (|
          MemoryAttributes_shareable :=
            ((((vec_of_bits [access_vec_dec SH (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))|))) in
      (let (memattrs :: MemoryAttributes) =
        ((memattrs (|
          MemoryAttributes_outershareable := (((SH = (vec_of_bits [B1,B0]  ::  2 Word.word))))|))) in
      return memattrs)))))))
    else Unreachable ()  \<then> return memattrs) \<bind> (\<lambda> (memattrs :: MemoryAttributes) . 
   MemAttrDefaults memattrs)))))))))"


(*val IsInHost : unit -> M bool*)

definition IsInHost  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " IsInHost _ = ( read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) .  ELIsInHost(ProcState_EL   w__0)))"


(*val aget_CPACR : unit -> M (mword ty32)*)

definition aget_CPACR  :: " unit \<Rightarrow>((register_value),((32)Word.word),(exception))monad "  where 
     " aget_CPACR _ = (
   IsInHost ()  \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then (read_reg CPTR_EL2_ref  :: ( 32 Word.word) M)
   else (read_reg CPACR_EL1_ref  :: ( 32 Word.word) M)))"


(*val HasS2Translation : unit -> M bool*)

definition HasS2Translation  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " HasS2Translation _ = (
   and_boolM
     (and_boolM
        (and_boolM (return ((HaveEL EL2)))
           (IsSecure ()  \<bind> (\<lambda> (w__0 :: bool) .  return ((\<not> w__0)))))
        (IsInHost ()  \<bind> (\<lambda> (w__2 :: bool) .  return ((\<not> w__2)))))
     (or_boolM
        (read_reg PSTATE_ref \<bind> (\<lambda> (w__4 :: ProcState) .  return ((((ProcState_EL   w__4) = EL0)))))
        (read_reg PSTATE_ref \<bind> (\<lambda> (w__5 :: ProcState) .  return ((((ProcState_EL   w__5) = EL1)))))))"


(*val AArch64_SecondStageWalk : AddressDescriptor -> mword ty64 -> AccType -> bool -> ii -> bool -> M AddressDescriptor*)

definition AArch64_CheckAndUpdateDescriptor_SecondStage  :: " DescriptorUpdate \<Rightarrow> FaultRecord \<Rightarrow>(64)Word.word \<Rightarrow> AccType \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(FaultRecord),(exception))monad "  where 
     " AArch64_CheckAndUpdateDescriptor_SecondStage result fault vaddress acctype iswrite s2fs1walk hwupdatewalk__arg = (
   (let hwupdatewalk = hwupdatewalk__arg in
   undefined_bool ()  \<bind> (\<lambda> (hw_update_AF :: bool) . 
   (let (hw_update_AF :: bool) =
     (if(DescriptorUpdate_AF   result) then
       if ((((FaultRecord_typ   fault) = Fault_None))) then True
       else if (((((ConstrainUnpredictable Unpredictable_AFUPDATE)) = Constraint_TRUE))) then True
       else False
     else hw_update_AF) in
   undefined_bool ()  \<bind> (\<lambda> (hw_update_AP :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (write_perm_req :: bool) . 
   (let (hw_update_AP :: bool) =
     (if ((((DescriptorUpdate_AP   result) \<and> ((((FaultRecord_typ   fault) = Fault_None)))))) then
       (let (write_perm_req :: bool) =
         ((((iswrite \<or> ((((((acctype = AccType_ATOMICRW))) \<or> (((acctype = AccType_ORDEREDRW))))))))) \<and> ((\<not> s2fs1walk))) in
       ((((write_perm_req \<and> ((\<not> ((((((acctype = AccType_AT))) \<or> (((acctype = AccType_DC))))))))))) \<or> hwupdatewalk))
     else False) in
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (desc :: 64 bits) . 
   undefined_AccessDescriptor ()  \<bind> (\<lambda> (accdesc :: AccessDescriptor) . 
   undefined_AddressDescriptor ()  \<bind> (\<lambda> (descaddr2 :: AddressDescriptor) . 
   (if (((hw_update_AF \<or> hw_update_AP))) then
      (let descaddr2 = ((DescriptorUpdate_descaddr   result)) in
      CreateAccessDescriptor AccType_ATOMICRW \<bind> (\<lambda> (w__0 :: AccessDescriptor) . 
      (let accdesc = w__0 in
      (aget__Mem descaddr2 (( 8 :: int)::ii) accdesc  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
      (let desc = w__1 in
      (let (desc :: 64 bits) =
        (if hw_update_AF then
          (set_slice (( 64 :: int)::ii) (( 1 :: int)::ii) desc (( 10 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)  ::  64 Word.word)
        else desc) in
      (let (desc :: 64 bits) =
        (if hw_update_AP then
          (set_slice (( 64 :: int)::ii) (( 1 :: int)::ii) desc (( 7 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)  ::  64 Word.word)
        else desc) in
      aset__Mem descaddr2 (( 8 :: int)::ii) accdesc desc)))))))
    else return () ) \<then>
   return fault))))))))))"


(*val AArch64_CheckS2Permission : Permissions -> mword ty64 -> mword ty52 -> ii -> AccType -> bool -> bool -> bool -> M FaultRecord*)

definition AArch64_CheckS2Permission  :: " Permissions \<Rightarrow>(64)Word.word \<Rightarrow>(52)Word.word \<Rightarrow> int \<Rightarrow> AccType \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(FaultRecord),(exception))monad "  where 
     " AArch64_CheckS2Permission perms vaddress ipaddress level acctype iswrite s2fs1walk hwupdatewalk = (
   and_boolM
     (and_boolM
        (and_boolM (return ((HaveEL EL2)))
           (IsSecure ()  \<bind> (\<lambda> (w__0 :: bool) .  return ((\<not> w__0)))))
        (ELUsingAArch32 EL2 \<bind> (\<lambda> (w__2 :: bool) .  return ((\<not> w__2))))) ((HasS2Translation () )) \<bind> (\<lambda> (w__5 ::
     bool) . 
   assert_exp w__5 (''(((HaveEL(EL2) && !(IsSecure())) && !(ELUsingAArch32(EL2))) && HasS2Translation())'') \<then>
   ((let (r :: bool) =
     ((vec_of_bits [access_vec_dec(Permissions_ap   perms) (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
   (let (w :: bool) =
     ((vec_of_bits [access_vec_dec(Permissions_ap   perms) (( 2 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
   undefined_bool ()  \<bind> (\<lambda> (xn :: bool) . 
   (if ((HaveExtendedExecuteNeverExt () )) then
      (let b__0 = ((concat_vec(Permissions_xn   perms)(Permissions_xxn   perms)  ::  2 Word.word)) in
      if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then return False
      else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
        read_reg PSTATE_ref \<bind> (\<lambda> (w__6 :: ProcState) . 
        (let (xn :: bool) = ((ProcState_EL   w__6) = EL1) in
        return xn))
      else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then return True
      else
        read_reg PSTATE_ref \<bind> (\<lambda> (w__7 :: ProcState) . 
        (let (xn :: bool) = ((ProcState_EL   w__7) = EL0) in
        return xn)))
    else
      (let (xn :: bool) = ((Permissions_xn   perms) = (vec_of_bits [B1]  ::  1 Word.word)) in
      return xn)) \<bind> (\<lambda> (xn :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (failedread :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (fail1 :: bool) . 
   (let ((fail1 :: bool), (failedread :: bool)) =
     (if ((((((acctype = AccType_IFETCH))) \<and> ((\<not> s2fs1walk))))) then
       (let (fail1 :: bool) = xn in
       (let (failedread :: bool) = True in
       (fail1, failedread)))
     else
       (let ((fail1 :: bool), (failedread :: bool)) =
         (if (((((((((acctype = AccType_ATOMICRW))) \<or> (((acctype = AccType_ORDEREDRW)))))) \<and> ((\<not> s2fs1walk))))) then
           (let (fail1 :: bool) = (((\<not> r)) \<or> ((\<not> w))) in
           (let (failedread :: bool) = (\<not> r) in
           (fail1, failedread)))
         else
           (let ((fail1 :: bool), (failedread :: bool)) =
             (if (((iswrite \<and> ((\<not> s2fs1walk))))) then
               (let (fail1 :: bool) = (\<not> w) in
               (let (failedread :: bool) = False in
               (fail1, failedread)))
             else
               (let ((fail1 :: bool), (failedread :: bool)) =
                 (if hwupdatewalk then
                   (let (fail1 :: bool) = (\<not> w) in
                   (let (failedread :: bool) = (\<not> iswrite) in
                   (fail1, failedread)))
                 else
                   (let (fail1 :: bool) = (\<not> r) in
                   (let (failedread :: bool) = (\<not> iswrite) in
                   (fail1, failedread)))) in
               (fail1, failedread))) in
           (fail1, failedread))) in
       (fail1, failedread))) in
   undefined_bool ()  \<bind> (\<lambda> (secondstage :: bool) . 
   (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (domain1 :: 4 bits) . 
   if fail1 then
     (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (w__8 ::  4 Word.word) . 
     (let domain1 = w__8 in
     (let secondstage = True in
     AArch64_PermissionFault ipaddress level acctype ((\<not> failedread)) secondstage s2fs1walk)))
   else AArch64_NoFault () ))))))))))))"


(*val IsZero_slice : forall 'n . Size 'n => mword 'n -> ii -> ii -> M bool*)

definition IsZero_slice  :: "('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " IsZero_slice xs i l = (
   assert_exp True ('''') \<then>
   return ((IsZero ((and_vec xs ((slice_mask ((int (size xs))) i l  :: ( 'n::len)Word.word))  :: ( 'n::len)Word.word)))))"


(*val ZeroExtend_slice_append : forall 'n 'm 'o . Size 'm, Size 'n, Size 'o => integer -> mword 'n -> ii -> ii -> mword 'm -> M (mword 'o)*)

definition ZeroExtend_slice_append  :: " int \<Rightarrow>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('m::len)Word.word \<Rightarrow>((register_value),(('o::len)Word.word),(exception))monad "  where 
     " ZeroExtend_slice_append (o__tv :: int) xs i l ys = (
   assert_exp True ('''') \<then>
   ((let xs = ((and_vec xs ((slice_mask ((int (size xs))) i l  :: ( 'n::len)Word.word))  :: ( 'n::len)Word.word)) in
   (let xs =
     ((shiftl ((extzv o__tv ((shiftr xs i  :: ( 'n::len)Word.word))  :: ( 'o::len)Word.word)) ((int (size ys)))  :: ( 'o::len)Word.word)) in
   (let ys = ((extzv ((int (size xs))) ys  :: ( 'o::len)Word.word)) in
   return ((or_vec xs ys  :: ( 'o::len)Word.word)))))))"


definition AArch64_TranslationTableWalk_SecondStage  :: "(52)Word.word \<Rightarrow>(64)Word.word \<Rightarrow> AccType \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(TLBRecord),(exception))monad "  where 
     " AArch64_TranslationTableWalk_SecondStage ipaddress vaddress acctype iswrite s2fs1walk size1 = (
   catch_early_return
     (and_boolM
        (and_boolM
           (and_boolM (return ((HaveEL EL2)))
              (liftR (IsSecure () ) \<bind> (\<lambda> (w__0 :: bool) .  return ((\<not> w__0)))))
           (liftR (ELUsingAArch32 EL2) \<bind> (\<lambda> (w__2 :: bool) .  return ((\<not> w__2)))))
        (liftR ((HasS2Translation () ))) \<bind> (\<lambda> (w__5 :: bool) . 
      (liftR (assert_exp w__5 ('''')) \<then>
      liftR (undefined_TLBRecord () )) \<bind> (\<lambda> (result :: TLBRecord) . 
      liftR (undefined_AddressDescriptor () ) \<bind> (\<lambda> (descaddr :: AddressDescriptor) . 
      liftR ((undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (baseregister :: 64 bits) . 
      liftR ((undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (inputaddr :: 64 bits) . 
      (let (tmp_180 :: MemoryAttributes) = ((AddressDescriptor_memattrs   descaddr)) in
      (let tmp_180 = ((tmp_180 (| MemoryAttributes_typ := MemType_Normal |))) in
      (let descaddr = ((descaddr (| AddressDescriptor_memattrs := tmp_180 |))) in
      liftR (undefined_int () ) \<bind> (\<lambda> (startsizecheck :: ii) . 
      liftR (undefined_int () ) \<bind> (\<lambda> (inputsizecheck :: ii) . 
      liftR (undefined_int () ) \<bind> (\<lambda> (startlevel :: ii) . 
      liftR (undefined_int () ) \<bind> (\<lambda> (level :: ii) . 
      liftR (undefined_int () ) \<bind> (\<lambda> (stride :: ii) . 
      liftR (undefined_int () ) \<bind> (\<lambda> (firstblocklevel :: ii) . 
      liftR (undefined_int () ) \<bind> (\<lambda> (grainsize :: ii) . 
      liftR (undefined_bool () ) \<bind> (\<lambda> (hierattrsdisabled :: bool) . 
      liftR (undefined_bool () ) \<bind> (\<lambda> (update_AP :: bool) . 
      liftR (undefined_bool () ) \<bind> (\<lambda> (update_AF :: bool) . 
      liftR (undefined_bool () ) \<bind> (\<lambda> (singlepriv :: bool) . 
      liftR (undefined_bool () ) \<bind> (\<lambda> (lookupsecure :: bool) . 
      liftR (undefined_bool () ) \<bind> (\<lambda> (reversedescriptors :: bool) . 
      liftR (undefined_bool () ) \<bind> (\<lambda> (disabled :: bool) . 
      liftR (undefined_bool () ) \<bind> (\<lambda> (basefound :: bool) . 
      liftR ((undefined_bitvector (( 3 :: int)::ii)  :: ( 3 Word.word) M)) \<bind> (\<lambda> (ps :: 3 bits) . 
      liftR (undefined_int () ) \<bind> (\<lambda> (inputsize_min :: ii) . 
      liftR (undefined_Constraint () ) \<bind> (\<lambda> (c :: Constraint) . 
      liftR (undefined_int () ) \<bind> (\<lambda> (inputsize_max :: ii) . 
      liftR (undefined_int () ) \<bind> (\<lambda> (inputsize :: ii) . 
      liftR (undefined_bool () ) \<bind> (\<lambda> (midgrain :: bool) . 
      liftR (undefined_bool () ) \<bind> (\<lambda> (largegrain :: bool) . 
      liftR (undefined_int () ) \<bind> (\<lambda> (top1 :: ii) . 
      liftR ((ZeroExtend__1 (( 64 :: int)::ii) ipaddress  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__6 ::  64 Word.word) . 
      (let inputaddr = w__6 in
      liftR ((read_reg VTCR_EL2_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__7 :: 32 bits) . 
      (let inputsize = ((( 64 :: int)::ii) - ((Word.uint ((slice w__7 (( 0 :: int)::ii) (( 6 :: int)::ii)  ::  6 Word.word))))) in
      liftR ((read_reg VTCR_EL2_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__8 :: 32 bits) . 
      (let largegrain =
        (((slice w__8 (( 14 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)) in
      liftR ((read_reg VTCR_EL2_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__9 :: 32 bits) . 
      (let midgrain =
        (((slice w__9 (( 14 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)) in
      (let inputsize_max = (if (((((Have52BitVAExt () )) \<and> largegrain))) then (( 52 :: int)::ii) else (( 48 :: int)::ii)) in
      (if ((((ex_int inputsize)) > ((ex_int inputsize_max)))) then
         (let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in
         liftR (assert_exp ((((((c = Constraint_FORCE))) \<or> (((c = Constraint_FAULT)))))) ('''')) \<then>
         ((let (inputsize :: ii) = (if (((c = Constraint_FORCE))) then inputsize_max else inputsize) in
         return (c, inputsize))))
       else return (c, inputsize)) \<bind> (\<lambda> varstup .  (let ((c :: Constraint), (inputsize :: ii)) = varstup in
      (let inputsize_min = ((( 64 :: int)::ii) - (( 39 :: int)::ii)) in
      (if ((((ex_int inputsize)) < ((ex_int inputsize_min)))) then
         (let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in
         liftR (assert_exp ((((((c = Constraint_FORCE))) \<or> (((c = Constraint_FAULT)))))) ('''')) \<then>
         ((let (inputsize :: ii) = (if (((c = Constraint_FORCE))) then inputsize_min else inputsize) in
         return inputsize)))
       else return inputsize) \<bind> (\<lambda> (inputsize :: ii) . 
      liftR ((read_reg VTCR_EL2_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__10 :: 32 bits) . 
      (let ps = ((slice w__10 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) in
      and_boolM
        (return (((((((ex_int inputsize)) \<ge> ((ex_int inputsize_min)))) \<and> ((((ex_int inputsize)) \<le> ((ex_int inputsize_max))))))))
        (liftR ((IsZero_slice inputaddr inputsize
                   ((((- ((ex_int inputsize)))) + (( 64 :: int)::ii)))))) \<bind> (\<lambda> (w__12 ::
        bool) . 
      (let basefound = w__12 in
      (let disabled = False in
      liftR ((read_reg VTTBR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__13 :: 64 bits) . 
      (let baseregister = w__13 in
      liftR ((read_reg VTCR_EL2_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__14 :: 32 bits) . 
      liftR ((read_reg VTCR_EL2_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__15 :: 32 bits) . 
      liftR ((read_reg VTCR_EL2_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__16 :: 32 bits) . 
      liftR (WalkAttrDecode ((slice w__14 (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))
               ((slice w__15 (( 10 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))
               ((slice w__16 (( 12 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) True) \<bind> (\<lambda> (w__17 :: MemoryAttributes) . 
      (let descaddr = ((descaddr (| AddressDescriptor_memattrs := w__17 |))) in
      liftR ((read_reg SCTLR_EL2_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__18 :: 32 bits) . 
      (let reversedescriptors =
        ((vec_of_bits [access_vec_dec w__18 (( 25 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
      (let lookupsecure = False in
      (let singlepriv = True in
      and_boolM (return ((HaveAccessFlagUpdateExt () )))
        (liftR ((read_reg VTCR_EL2_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__19 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__19 (( 21 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__20 :: bool) . 
      (let update_AF = w__20 in
      and_boolM (return (((((HaveDirtyBitModifierExt () )) \<and> update_AF))))
        (liftR ((read_reg VTCR_EL2_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__21 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__21 (( 22 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__22 :: bool) . 
      (let update_AP = w__22 in
      liftR ((read_reg VTCR_EL2_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__23 :: 32 bits) . 
      (let startlevel = (Word.uint ((slice w__23 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))) in
      (let ((firstblocklevel :: ii), (grainsize :: ii), (level :: ii)) =
        (if largegrain then
          (let (grainsize :: ii) = ((( 16 :: int)::ii)) in
          (let (level :: ii) = ((( 3 :: int)::ii) - ((ex_int startlevel))) in
          (let (firstblocklevel :: ii) = (if ((Have52BitPAExt () )) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
          (firstblocklevel, grainsize, level))))
        else
          (let ((firstblocklevel :: ii), (grainsize :: ii), (level :: ii)) =
            (if midgrain then
              (let (grainsize :: ii) = ((( 14 :: int)::ii)) in
              (let (level :: ii) = ((( 3 :: int)::ii) - ((ex_int startlevel))) in
              (let (firstblocklevel :: ii) = ((( 2 :: int)::ii)) in
              (firstblocklevel, grainsize, level))))
            else
              (let (grainsize :: ii) = ((( 12 :: int)::ii)) in
              (let (level :: ii) = ((( 2 :: int)::ii) - ((ex_int startlevel))) in
              (let (firstblocklevel :: ii) = ((( 1 :: int)::ii)) in
              (firstblocklevel, grainsize, level))))) in
          (firstblocklevel, grainsize, level))) in
      (let stride = (((ex_int grainsize)) - (( 3 :: int)::ii)) in
      (let (basefound :: bool) =
        (if largegrain then
          if ((((((((ex_int level)) = (( 0 :: int)::ii)))) \<or> ((((((((ex_int level)) = (( 1 :: int)::ii)))) \<and> ((((ex_int ((PAMax () )))) \<le> (( 42 :: int)::ii)))))))))
          then
            False
          else basefound
        else if midgrain then
          if ((((((((ex_int level)) = (( 0 :: int)::ii)))) \<or> ((((((((ex_int level)) = (( 1 :: int)::ii)))) \<and> ((((ex_int ((PAMax () )))) \<le> (( 40 :: int)::ii)))))))))
          then
            False
          else basefound
        else if (((((((ex_int level)) < (( 0 :: int)::ii))) \<or> ((((((((ex_int level)) = (( 0 :: int)::ii)))) \<and> ((((ex_int ((PAMax () )))) \<le> (( 42 :: int)::ii))))))))) then
          False
        else basefound) in
      (let inputsizecheck = inputsize in
      and_boolM (return ((((ex_int inputsize)) > ((ex_int ((PAMax () )))))))
        (or_boolM (liftR (ELUsingAArch32 EL1) \<bind> (\<lambda> (w__24 :: bool) .  return ((\<not> w__24))))
           (return ((((ex_int inputsize)) > (( 40 :: int)::ii))))) \<bind> (\<lambda> (w__26 :: bool) . 
      (if w__26 then
         (case  ((ConstrainUnpredictable Unpredictable_LARGEIPA)) of
           Constraint_FORCE =>
            (let (inputsize :: ii) = (PAMax () ) in
            (let (inputsizecheck :: ii) = (PAMax () ) in
            return (basefound, inputsize, inputsizecheck)))
         | Constraint_FORCENOSLCHECK =>
            (let (inputsize :: ii) = (PAMax () ) in
            return (basefound, inputsize, inputsizecheck))
         | Constraint_FAULT =>
            (let (basefound :: bool) = False in
            return (basefound, inputsize, inputsizecheck))
         | _ => liftR (Unreachable () ) \<then> return (basefound, inputsize, inputsizecheck)
         )
       else return (basefound, inputsize, inputsizecheck)) \<bind> (\<lambda> varstup .  (let ((basefound :: bool), (inputsize ::
        ii), (inputsizecheck :: ii)) = varstup in
      (let startsizecheck =
        (((ex_int inputsizecheck)) -
          (((((((( 3 :: int)::ii) - ((ex_int level)))) * ((ex_int stride)))) +
              ((ex_int grainsize))))) in
      (let (basefound :: bool) =
        (if (((((((ex_int startsizecheck)) < (( 1 :: int)::ii))) \<or> ((((ex_int startsizecheck)) > ((((ex_int stride)) + (( 4 :: int)::ii)))))))) then
          False
        else basefound) in
      if (((((\<not> basefound)) \<or> disabled))) then
        (let level = ((( 0 :: int)::ii)) in
        (let (tmp_190 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
        liftR (AArch64_TranslationFault ipaddress level acctype iswrite True s2fs1walk) \<bind> (\<lambda> (w__27 ::
          FaultRecord) . 
        (let (tmp_190 :: AddressDescriptor) = ((tmp_190 (| AddressDescriptor_fault := w__27 |))) in
        (let (result :: TLBRecord) = ((result (| TLBRecord_addrdesc := tmp_190 |))) in
        return result)))))
      else
        liftR (undefined_int () ) \<bind> (\<lambda> (outputsize :: ii) . 
        (let b__0 = ps in
        (let (outputsize :: ii) =
          (if (((b__0 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) then (( 32 :: int)::ii)
          else if (((b__0 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) then (( 36 :: int)::ii)
          else if (((b__0 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) then (( 40 :: int)::ii)
          else if (((b__0 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) then (( 42 :: int)::ii)
          else if (((b__0 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) then (( 44 :: int)::ii)
          else if (((b__0 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) then (( 48 :: int)::ii)
          else if (((b__0 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) then
            if (((((Have52BitPAExt () )) \<and> largegrain))) then (( 52 :: int)::ii)
            else (( 48 :: int)::ii)
          else (( 48 :: int)::ii)) in
        (let (outputsize :: ii) =
          (if ((((ex_int outputsize)) > ((ex_int ((PAMax () )))))) then PAMax () 
          else outputsize) in
        and_boolM (return ((((ex_int outputsize)) < (( 48 :: int)::ii))))
          (liftR (IsZero_slice baseregister outputsize
                    ((((- ((ex_int outputsize)))) + (( 48 :: int)::ii)))) \<bind> (\<lambda> (w__28 ::
             bool) . 
           return ((\<not> w__28)))) \<bind> (\<lambda> (w__29 :: bool) . 
        if w__29 then
          (let level = ((( 0 :: int)::ii)) in
          (let (tmp_200 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
          liftR (AArch64_AddressSizeFault ipaddress level acctype iswrite True s2fs1walk) \<bind> (\<lambda> (w__30 ::
            FaultRecord) . 
          (let (tmp_200 :: AddressDescriptor) = ((tmp_200 (| AddressDescriptor_fault := w__30 |))) in
          (let (result :: TLBRecord) = ((result (| TLBRecord_addrdesc := tmp_200 |))) in
          return result)))))
        else
          (let baselowerbound =
            ((((( 3 :: int)::ii) + ((ex_int inputsize)))) -
              (((((((( 3 :: int)::ii) - ((ex_int level)))) * ((ex_int stride))))
                  +
                  ((ex_int grainsize))))) in
          (liftR (assert_exp True ('''')) \<then>
          liftR ((undefined_bitvector (( 52 :: int)::ii)  :: ( 52 Word.word) M))) \<bind> (\<lambda> (baseaddress :: 52 bits) . 
          (if (((((ex_int outputsize)) = (( 52 :: int)::ii)))) then
             (let z = (if ((baselowerbound < (( 6 :: int)::ii))) then (( 6 :: int)::ii) else baselowerbound) in
             liftR (assert_exp True ('''')) \<then>
             ((let (baseaddress :: 52 bits) =
               ((concat_vec ((slice baseregister (( 2 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
                  ((slice_zeros_concat ((((((- z)) + (( 48 :: int)::ii))) + z))
                      baseregister z ((((- z)) + (( 48 :: int)::ii))) z
                     ::  48 Word.word))
                 ::  52 Word.word)) in
             return baseaddress)))
           else
             (let (baseaddress :: 52 bits) =
               ((place_slice (( 52 :: int)::ii) baseregister baselowerbound
                  ((((- baselowerbound)) + (( 48 :: int)::ii))) baselowerbound
                 ::  52 Word.word)) in
             return baseaddress)) \<bind> (\<lambda> (baseaddress :: 52 bits) . 
          (let (ns_table :: 1 bits) =
            (if lookupsecure then (vec_of_bits [B0]  ::  1 Word.word)
            else (vec_of_bits [B1]  ::  1 Word.word)) in
          (let (ap_table :: 2 bits) = ((vec_of_bits [B0,B0]  ::  2 Word.word)) in
          (let (xn_table :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
          (let (pxn_table :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
          (let (addrselecttop :: ii) = (((ex_int inputsize)) - (( 1 :: int)::ii)) in
          and_boolM
            (and_boolM (return (((((HaveNVExt () )) \<and> ((HaveEL EL2))))))
               (liftR ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__31 :: 64 bits) . 
                return ((((vec_of_bits [access_vec_dec w__31 (( 42 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
            (liftR ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__33 :: 64 bits) . 
             return ((((vec_of_bits [access_vec_dec w__33 (( 43 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (apply_nvnv1_effect :: bool) . 
          liftR (undefined_bool () ) \<bind> (\<lambda> (blocktranslate :: bool) . 
          liftR ((undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (desc :: 64 bits) . 
          liftR (undefined_AccessDescriptor () ) \<bind> (\<lambda> (accdesc :: AccessDescriptor) . 
          liftR (undefined_bool () ) \<bind> (\<lambda> (hwupdatewalk :: bool) . 
          liftR (undefined_AddressDescriptor () ) \<bind> (\<lambda> (descaddr2 :: AddressDescriptor) . 
          liftR (undefined_int () ) \<bind> (\<lambda> (addrselectbottom :: ii) . 
          (untilM (accdesc,
                   addrselectbottom,
                   addrselecttop,
                   baseaddress,
                   blocktranslate,
                   desc,
                   descaddr,
                   descaddr2,
                   level,
                   result)
            (\<lambda> varstup . 
            (let (accdesc,
                 addrselectbottom,
                 addrselecttop,
                 baseaddress,
                 blocktranslate,
                 desc,
                 descaddr,
                 descaddr2,
                 level,
                 result) = varstup in
              return blocktranslate))
            (\<lambda> varstup . 
            (let (accdesc,
                 addrselectbottom,
                 addrselecttop,
                 baseaddress,
                 blocktranslate,
                 desc,
                 descaddr,
                 descaddr2,
                 level,
                 result) = varstup in
              (let addrselectbottom =
                ((((((( 3 :: int)::ii) - ((ex_int level)))) * ((ex_int stride))))
                  +
                  ((ex_int grainsize))) in
              liftR ((ZeroExtend_slice_append (( 52 :: int)::ii) inputaddr addrselectbottom
                        ((((((ex_int addrselecttop)) - ((ex_int addrselectbottom))))
                            +
                            (( 1 :: int)::ii))) (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                       :: ( 52 Word.word) M)) \<bind> (\<lambda> (index1 :: 52 bits) . 
              (let (tmp_210 :: FullAddress) = ((AddressDescriptor_paddress   descaddr)) in
              (let tmp_210 =
                ((tmp_210 (|
                  FullAddress_physicaladdress := ((or_vec baseaddress index1  ::  52 Word.word))|))) in
              (let descaddr = ((descaddr (| AddressDescriptor_paddress := tmp_210 |))) in
              (let (tmp_220 :: FullAddress) = ((AddressDescriptor_paddress   descaddr)) in
              (let tmp_220 = ((tmp_220 (| FullAddress_NS := ns_table |))) in
              (let descaddr = ((descaddr (| AddressDescriptor_paddress := tmp_220 |))) in
              (let descaddr2 = descaddr in
              liftR ((ZeroExtend__1 (( 64 :: int)::ii) vaddress  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__34 ::  64 Word.word) . 
              (let descaddr2 = ((descaddr2 (| AddressDescriptor_vaddress := w__34 |))) in
              liftR (CreateAccessDescriptorPTW acctype True s2fs1walk level) \<bind> (\<lambda> (w__35 ::
                AccessDescriptor) . 
              (let accdesc = w__35 in
              liftR ((aget__Mem descaddr2 (( 8 :: int)::ii) accdesc  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__36 ::
                 64 Word.word) . 
              (let desc = w__36 in
              (if reversedescriptors then liftR ((BigEndianReverse desc  :: ( 64 Word.word) M))
               else return desc) \<bind> (\<lambda> (desc :: 64 bits) . 
              (if (((((((vec_of_bits [access_vec_dec desc (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> ((((((((slice desc (( 0 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((((ex_int level)) = (( 3 :: int)::ii))))))))))
               then
                 (let (tmp_240 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
                 liftR (AArch64_TranslationFault ipaddress level acctype iswrite True s2fs1walk) \<bind> (\<lambda> (w__38 ::
                   FaultRecord) . 
                 (let tmp_240 = ((tmp_240 (| AddressDescriptor_fault := w__38 |))) in
                 (let result = ((result (| TLBRecord_addrdesc := tmp_240 |))) in
                 (early_return result :: (unit, TLBRecord) MR) \<then>
                 return (addrselecttop, baseaddress, blocktranslate, level, result)))))
               else if ((((((((slice desc (( 0 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<or> (((((ex_int level)) = (( 3 :: int)::ii)))))))
               then
                 (let (blocktranslate :: bool) = True in
                 return (addrselecttop, baseaddress, blocktranslate, level, result))
               else
                 or_boolM
                   (return ((((((((((ex_int outputsize)) < (( 52 :: int)::ii))) \<and> largegrain))) \<and> ((\<not> ((IsZero ((slice desc (( 12 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))))))))))
                   (and_boolM (return ((((ex_int outputsize)) < (( 48 :: int)::ii))))
                      (liftR (IsZero_slice desc outputsize
                                ((((- ((ex_int outputsize)))) + (( 48 :: int)::ii)))) \<bind> (\<lambda> (w__39 ::
                         bool) . 
                       return ((\<not> w__39))))) \<bind> (\<lambda> (w__41 :: bool) . 
                 if w__41 then
                   (let (tmp_250 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
                   liftR (AArch64_AddressSizeFault ipaddress level acctype iswrite True s2fs1walk) \<bind> (\<lambda> (w__42 ::
                     FaultRecord) . 
                   (let tmp_250 = ((tmp_250 (| AddressDescriptor_fault := w__42 |))) in
                   (let result = ((result (| TLBRecord_addrdesc := tmp_250 |))) in
                   (early_return result :: (unit, TLBRecord) MR) \<then>
                   return (addrselecttop, baseaddress, blocktranslate, level, result)))))
                 else
                   (let gsz = grainsize in
                   liftR (assert_exp True ('''')) \<then>
                   ((let (baseaddress :: 52 bits) =
                     (if (((((ex_int outputsize)) = (( 52 :: int)::ii)))) then
                       (concat_vec ((slice desc (( 12 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
                          ((slice_zeros_concat
                              ((((((- gsz)) + (( 48 :: int)::ii))) + gsz)) desc
                              gsz ((((- gsz)) + (( 48 :: int)::ii))) gsz
                             ::  48 Word.word))
                         ::  52 Word.word)
                     else
                       (place_slice (( 52 :: int)::ii) desc gsz ((((- gsz)) + (( 48 :: int)::ii)))
                          gsz
                         ::  52 Word.word)) in
                   (let (level :: ii) = (((ex_int level)) + (( 1 :: int)::ii)) in
                   (let (addrselecttop :: ii) = (((ex_int addrselectbottom)) - (( 1 :: int)::ii)) in
                   (let (blocktranslate :: bool) = False in
                   return (addrselecttop, baseaddress, blocktranslate, level, result))))))))) \<bind> (\<lambda> varstup .  (let ((addrselecttop ::
                ii), (baseaddress :: 52 bits), (blocktranslate :: bool), (level :: ii), (result ::
                TLBRecord)) = varstup in
              return (accdesc,
                      addrselectbottom,
                      addrselecttop,
                      baseaddress,
                      blocktranslate,
                      desc,
                      descaddr,
                      descaddr2,
                      level,
                      result)))))))))))))))))))))) \<bind> (\<lambda> varstup .  (let ((accdesc :: AccessDescriptor), (addrselectbottom ::
            ii), (addrselecttop :: ii), (baseaddress :: 52 bits), (blocktranslate :: bool), (desc :: 64
            bits), (descaddr :: AddressDescriptor), (descaddr2 :: AddressDescriptor), (level :: ii), (result ::
            TLBRecord)) = varstup in
          if ((((ex_int level)) < ((ex_int firstblocklevel)))) then
            (let (tmp_260 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
            liftR (AArch64_TranslationFault ipaddress level acctype iswrite True s2fs1walk) \<bind> (\<lambda> (w__43 ::
              FaultRecord) . 
            (let (tmp_260 :: AddressDescriptor) = ((tmp_260 (| AddressDescriptor_fault := w__43 |))) in
            (let (result :: TLBRecord) = ((result (| TLBRecord_addrdesc := tmp_260 |))) in
            return result))))
          else
            liftR (undefined_bool () ) \<bind> (\<lambda> (contiguousbitcheck :: bool) . 
            (let (contiguousbitcheck :: bool) =
              (if largegrain then
                ((((((ex_int level)) = (( 2 :: int)::ii)))) \<and> ((((ex_int inputsize)) < (( 34 :: int)::ii))))
              else if midgrain then
                ((((((ex_int level)) = (( 2 :: int)::ii)))) \<and> ((((ex_int inputsize)) < (( 30 :: int)::ii))))
              else ((((((ex_int level)) = (( 1 :: int)::ii)))) \<and> ((((ex_int inputsize)) < (( 34 :: int)::ii))))) in
            (if (((contiguousbitcheck \<and> ((((vec_of_bits [access_vec_dec desc (( 52 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))) then
               liftR (undefined_bool () ) \<bind> (\<lambda> (w__44 :: bool) . 
               if w__44 then
                 (let (tmp_270 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
                 liftR (AArch64_TranslationFault ipaddress level acctype iswrite True s2fs1walk) \<bind> (\<lambda> (w__45 ::
                   FaultRecord) . 
                 (let tmp_270 = ((tmp_270 (| AddressDescriptor_fault := w__45 |))) in
                 (let result = ((result (| TLBRecord_addrdesc := tmp_270 |))) in
                 (early_return result :: (unit, TLBRecord) MR) \<then> return result))))
               else return result)
             else return result) \<bind> (\<lambda> (result :: TLBRecord) . 
            or_boolM
              (return ((((((((((ex_int outputsize)) < (( 52 :: int)::ii))) \<and> largegrain))) \<and> ((\<not> ((IsZero ((slice desc (( 12 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))))))))))
              (and_boolM (return ((((ex_int outputsize)) < (( 48 :: int)::ii))))
                 (liftR (IsZero_slice desc outputsize
                           ((((- ((ex_int outputsize)))) + (( 48 :: int)::ii)))) \<bind> (\<lambda> (w__46 ::
                    bool) . 
                  return ((\<not> w__46))))) \<bind> (\<lambda> (w__48 :: bool) . 
            if w__48 then
              (let (tmp_280 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
              liftR (AArch64_AddressSizeFault ipaddress level acctype iswrite True s2fs1walk) \<bind> (\<lambda> (w__49 ::
                FaultRecord) . 
              (let (tmp_280 :: AddressDescriptor) = ((tmp_280 (| AddressDescriptor_fault := w__49 |))) in
              (let (result :: TLBRecord) = ((result (| TLBRecord_addrdesc := tmp_280 |))) in
              return result))))
            else
              liftR ((undefined_bitvector (( 52 :: int)::ii)  :: ( 52 Word.word) M)) \<bind> (\<lambda> (outputaddress :: 52
                bits) . 
              (let asb = addrselectbottom in
              liftR (assert_exp True ('''')) \<then>
              ((let (outputaddress :: 52 bits) =
                (if (((((ex_int outputsize)) = (( 52 :: int)::ii)))) then
                  (concat_vec ((slice desc (( 12 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
                     ((slice_slice_concat (( 48 :: int)::ii) desc asb
                         ((((- asb)) + (( 48 :: int)::ii))) inputaddr (( 0 :: int)::ii) asb
                        ::  48 Word.word))
                    ::  52 Word.word)
                else
                  (slice_slice_concat (( 52 :: int)::ii) desc asb ((((- asb)) + (( 48 :: int)::ii)))
                     inputaddr (( 0 :: int)::ii) asb
                    ::  52 Word.word)) in
              (if ((((vec_of_bits [access_vec_dec desc (( 10 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))) then
                 if ((\<not> update_AF)) then
                   (let (tmp_290 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
                   liftR (AArch64_AccessFlagFault ipaddress level acctype iswrite True s2fs1walk) \<bind> (\<lambda> (w__50 ::
                     FaultRecord) . 
                   (let tmp_290 = ((tmp_290 (| AddressDescriptor_fault := w__50 |))) in
                   (let result = ((result (| TLBRecord_addrdesc := tmp_290 |))) in
                   (early_return result :: (unit, TLBRecord) MR) \<then> return result))))
                 else
                   (let (tmp_300 :: DescriptorUpdate) = ((TLBRecord_descupdate   result)) in
                   (let (tmp_300 :: DescriptorUpdate) = ((tmp_300 (| DescriptorUpdate_AF := True |))) in
                   (let (result :: TLBRecord) = ((result (| TLBRecord_descupdate := tmp_300 |))) in
                   return result)))
               else return result) \<bind> (\<lambda> (result :: TLBRecord) . 
              (let ((desc :: 64 bits), (result :: TLBRecord)) =
                (if (((update_AP \<and> ((((vec_of_bits [access_vec_dec desc (( 51 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))) then
                  (let ((desc :: 64 bits), (result :: TLBRecord)) =
                    (if ((((vec_of_bits [access_vec_dec desc (( 7 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))) then
                      (let (desc :: 64 bits) =
                        ((set_slice (( 64 :: int)::ii) (( 1 :: int)::ii) desc (( 7 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)
                          ::  64 Word.word)) in
                      (let (tmp_320 :: DescriptorUpdate) = ((TLBRecord_descupdate   result)) in
                      (let (tmp_320 :: DescriptorUpdate) =
                        ((tmp_320 (| DescriptorUpdate_AP := True |))) in
                      (let (result :: TLBRecord) = ((result (| TLBRecord_descupdate := tmp_320 |))) in
                      (desc, result)))))
                    else (desc, result)) in
                  (desc, result))
                else (desc, result)) in
              (let (tmp_330 :: DescriptorUpdate) = ((TLBRecord_descupdate   result)) in
              (let tmp_330 = ((tmp_330 (| DescriptorUpdate_descaddr := descaddr |))) in
              (let result = ((result (| TLBRecord_descupdate := tmp_330 |))) in
              liftR ((undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> (\<lambda> (xn :: 1 bits) . 
              liftR ((undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> (\<lambda> (pxn :: 1 bits) . 
              (let (xn :: 1 bits) =
                (if apply_nvnv1_effect then
                  (let (pxn :: 1 bits) = ((vec_of_bits [access_vec_dec desc (( 54 :: int)::ii)]  ::  1 Word.word)) in
                  (vec_of_bits [B0]  ::  1 Word.word))
                else
                  (let (xn :: 1 bits) = ((vec_of_bits [access_vec_dec desc (( 54 :: int)::ii)]  ::  1 Word.word)) in
                  (let (pxn :: 1 bits) = ((vec_of_bits [access_vec_dec desc (( 53 :: int)::ii)]  ::  1 Word.word)) in
                  xn))) in
              (let (contiguousbit :: 1 bits) =
                ((vec_of_bits [access_vec_dec desc (( 52 :: int)::ii)]  ::  1 Word.word)) in
              (let (nG :: 1 bits) = ((vec_of_bits [access_vec_dec desc (( 11 :: int)::ii)]  ::  1 Word.word)) in
              (let (sh :: 2 bits) = ((slice desc (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) in
              liftR ((undefined_bitvector (( 3 :: int)::ii)  :: ( 3 Word.word) M)) \<bind> (\<lambda> (ap :: 3 bits) . 
              (let (ap :: 3 bits) =
                (if apply_nvnv1_effect then
                  (concat_vec (vec_of_bits [access_vec_dec desc (( 7 :: int)::ii)]  ::  1 Word.word)
                     (vec_of_bits [B0,B1]  ::  2 Word.word)
                    ::  3 Word.word)
                else
                  (concat_vec ((slice desc (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))
                     (vec_of_bits [B1]  ::  1 Word.word)
                    ::  3 Word.word)) in
              (let (memattr :: 4 bits) = ((slice desc (( 2 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) in
              liftR ((undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M)) \<bind> (\<lambda> (w__51 ::  4 Word.word) . 
              (let result = ((result (| TLBRecord_domain := w__51 |))) in
              (let result = ((result (| TLBRecord_level := level |))) in
              (let result =
                ((result (|
                  TLBRecord_blocksize :=
                    ((pow2
                        (((((((( 3 :: int)::ii) - ((ex_int level)))) * ((ex_int stride))))
                            +
                            ((ex_int grainsize))))))|))) in
              (let (tmp_480 :: 3 bits) = ((Permissions_ap  (TLBRecord_perms   result))) in
              (let tmp_480 =
                ((set_slice (( 3 :: int)::ii) (( 2 :: int)::ii) tmp_480 (( 1 :: int)::ii) ((slice ap (( 1 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))
                  ::  3 Word.word)) in
              (let (tmp_490 :: Permissions) = ((TLBRecord_perms   result)) in
              (let tmp_490 = ((tmp_490 (| Permissions_ap := tmp_480 |))) in
              (let result = ((result (| TLBRecord_perms := tmp_490 |))) in
              (let (tmp_500 :: 3 bits) = ((Permissions_ap  (TLBRecord_perms   result))) in
              (let tmp_500 =
                ((set_slice (( 3 :: int)::ii) (( 1 :: int)::ii) tmp_500 (( 0 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)
                  ::  3 Word.word)) in
              (let (tmp_510 :: Permissions) = ((TLBRecord_perms   result)) in
              (let tmp_510 = ((tmp_510 (| Permissions_ap := tmp_500 |))) in
              (let result = ((result (| TLBRecord_perms := tmp_510 |))) in
              (let (tmp_520 :: Permissions) = ((TLBRecord_perms   result)) in
              (let tmp_520 = ((tmp_520 (| Permissions_xn := xn |))) in
              (let result = ((result (| TLBRecord_perms := tmp_520 |))) in
              (let (result :: TLBRecord) =
                (if ((HaveExtendedExecuteNeverExt () )) then
                  (let (tmp_530 :: Permissions) = ((TLBRecord_perms   result)) in
                  (let (tmp_530 :: Permissions) =
                    ((tmp_530 (|
                      Permissions_xxn := ((vec_of_bits [access_vec_dec desc (( 53 :: int)::ii)]  ::  1 Word.word))|))) in
                  (result (| TLBRecord_perms := tmp_530 |))))
                else result) in
              (let (tmp_540 :: Permissions) = ((TLBRecord_perms   result)) in
              (let tmp_540 = ((tmp_540 (| Permissions_pxn := ((vec_of_bits [B0]  ::  1 Word.word))|))) in
              (let result = ((result (| TLBRecord_perms := tmp_540 |))) in
              (let result = ((result (| TLBRecord_nG := ((vec_of_bits [B0]  ::  1 Word.word))|))) in
              (let (tmp_550 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
              liftR (S2AttrDecode sh memattr acctype) \<bind> (\<lambda> (w__52 :: MemoryAttributes) . 
              (let tmp_550 = ((tmp_550 (| AddressDescriptor_memattrs := w__52 |))) in
              (let result = ((result (| TLBRecord_addrdesc := tmp_550 |))) in
              (let (tmp_560 :: FullAddress) = ((AddressDescriptor_paddress  (TLBRecord_addrdesc   result))) in
              (let tmp_560 = ((tmp_560 (| FullAddress_NS := ((vec_of_bits [B1]  ::  1 Word.word))|))) in
              (let (tmp_570 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
              (let tmp_570 = ((tmp_570 (| AddressDescriptor_paddress := tmp_560 |))) in
              (let result = ((result (| TLBRecord_addrdesc := tmp_570 |))) in
              (let (tmp_580 :: FullAddress) = ((AddressDescriptor_paddress  (TLBRecord_addrdesc   result))) in
              (let tmp_580 = ((tmp_580 (| FullAddress_physicaladdress := outputaddress |))) in
              (let (tmp_590 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
              (let tmp_590 = ((tmp_590 (| AddressDescriptor_paddress := tmp_580 |))) in
              (let result = ((result (| TLBRecord_addrdesc := tmp_590 |))) in
              (let (tmp_600 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
              liftR (AArch64_NoFault () ) \<bind> (\<lambda> (w__53 :: FaultRecord) . 
              (let (tmp_600 :: AddressDescriptor) = ((tmp_600 (| AddressDescriptor_fault := w__53 |))) in
              (let (result :: TLBRecord) = ((result (| TLBRecord_addrdesc := tmp_600 |))) in
              (let (result :: TLBRecord) =
                ((result (|
                  TLBRecord_contiguous := (((contiguousbit = (vec_of_bits [B1]  ::  1 Word.word))))|))) in
              (let (result :: TLBRecord) =
                (if ((HaveCommonNotPrivateTransExt () )) then
                  (result (|
                    TLBRecord_CnP := ((vec_of_bits [access_vec_dec baseregister (( 0 :: int)::ii)]  ::  1 Word.word))|))
                else result) in
              return result)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))"


definition AArch64_SecondStageTranslate  :: " AddressDescriptor \<Rightarrow>(64)Word.word \<Rightarrow> AccType \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(AddressDescriptor),(exception))monad "  where 
     " AArch64_SecondStageTranslate S1 vaddress acctype iswrite wasaligned s2fs1walk size1 hwupdatewalk = (
   HasS2Translation ()  \<bind> (\<lambda> (w__0 :: bool) . 
   (assert_exp w__0 (''HasS2Translation()'') \<then>
   or_boolM
     ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 :: 64 bits) . 
      return ((((vec_of_bits [access_vec_dec w__1 (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))
     ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 :: 64 bits) . 
      return ((((vec_of_bits [access_vec_dec w__2 (( 12 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))) \<bind> (\<lambda> (s2_enabled :: bool) . 
   (let (secondstage :: bool) = True in
   undefined_AddressDescriptor ()  \<bind> (\<lambda> (result :: AddressDescriptor) . 
   undefined_TLBRecord ()  \<bind> (\<lambda> (S2 :: TLBRecord) . 
   (undefined_bitvector (( 52 :: int)::ii)  :: ( 52 Word.word) M) \<bind> (\<lambda> (ipaddress :: 52 bits) . 
   if s2_enabled then
     (let ipaddress =
       ((slice(FullAddress_physicaladdress  (AddressDescriptor_paddress   S1)) (( 0 :: int)::ii) (( 52 :: int)::ii)  ::  52 Word.word)) in
     AArch64_TranslationTableWalk_SecondStage ipaddress vaddress acctype iswrite s2fs1walk size1 \<bind> (\<lambda> (w__3 ::
       TLBRecord) . 
     (let S2 = w__3 in
     (if ((((((((((((((\<not> wasaligned)) \<and> (((acctype \<noteq> AccType_IFETCH)))))) \<or> (((acctype = AccType_DCZVA)))))) \<and> ((((MemoryAttributes_typ  (AddressDescriptor_memattrs  (TLBRecord_addrdesc   S2))) = MemType_Device)))))) \<and> ((\<not> ((IsFault(TLBRecord_addrdesc   S2)))))))) then
        (let (tmp_710 :: AddressDescriptor) = ((TLBRecord_addrdesc   S2)) in
        AArch64_AlignmentFault acctype iswrite secondstage \<bind> (\<lambda> (w__4 :: FaultRecord) . 
        (let (tmp_710 :: AddressDescriptor) = ((tmp_710 (| AddressDescriptor_fault := w__4 |))) in
        (let (S2 :: TLBRecord) = ((S2 (| TLBRecord_addrdesc := tmp_710 |))) in
        return S2))))
      else return S2) \<bind> (\<lambda> (S2 :: TLBRecord) . 
     (if ((\<not> ((IsFault(TLBRecord_addrdesc   S2))))) then
        (let (tmp_720 :: AddressDescriptor) = ((TLBRecord_addrdesc   S2)) in
        AArch64_CheckS2Permission(TLBRecord_perms   S2) vaddress ipaddress(TLBRecord_level   S2) acctype
          iswrite s2fs1walk hwupdatewalk \<bind> (\<lambda> (w__5 :: FaultRecord) . 
        (let (tmp_720 :: AddressDescriptor) = ((tmp_720 (| AddressDescriptor_fault := w__5 |))) in
        (let (S2 :: TLBRecord) = ((S2 (| TLBRecord_addrdesc := tmp_720 |))) in
        return S2))))
      else return S2) \<bind> (\<lambda> (S2 :: TLBRecord) . 
     (if (((((((((((\<not> s2fs1walk)) \<and> ((\<not> ((IsFault(TLBRecord_addrdesc   S2)))))))) \<and> ((((MemoryAttributes_typ  (AddressDescriptor_memattrs  (TLBRecord_addrdesc   S2))) = MemType_Device)))))) \<and> (((acctype = AccType_IFETCH)))))) then
        AArch64_InstructionDevice(TLBRecord_addrdesc   S2) vaddress ipaddress(TLBRecord_level   S2)
          acctype iswrite secondstage s2fs1walk \<bind> (\<lambda> (w__6 :: AddressDescriptor) . 
        (let (S2 :: TLBRecord) = ((S2 (| TLBRecord_addrdesc := w__6 |))) in
        return S2))
      else return S2) \<bind> (\<lambda> (S2 :: TLBRecord) . 
     and_boolM
       (and_boolM (return (((s2fs1walk \<and> ((\<not> ((IsFault(TLBRecord_addrdesc   S2)))))))))
          ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__7 :: 64 bits) . 
           return ((((vec_of_bits [access_vec_dec w__7 (( 2 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
       (return ((((MemoryAttributes_typ  (AddressDescriptor_memattrs  (TLBRecord_addrdesc   S2))) = MemType_Device)))) \<bind> (\<lambda> (w__9 :: bool) . 
     (if w__9 then
        (let (tmp_730 :: AddressDescriptor) = ((TLBRecord_addrdesc   S2)) in
        AArch64_PermissionFault ipaddress(TLBRecord_level   S2) acctype iswrite secondstage s2fs1walk \<bind> (\<lambda> (w__10 ::
          FaultRecord) . 
        (let (tmp_730 :: AddressDescriptor) = ((tmp_730 (| AddressDescriptor_fault := w__10 |))) in
        (let (S2 :: TLBRecord) = ((S2 (| TLBRecord_addrdesc := tmp_730 |))) in
        return S2))))
      else return S2) \<bind> (\<lambda> (S2 :: TLBRecord) . 
     (let (tmp_740 :: AddressDescriptor) = ((TLBRecord_addrdesc   S2)) in
     AArch64_CheckAndUpdateDescriptor_SecondStage(TLBRecord_descupdate   S2)(AddressDescriptor_fault  (TLBRecord_addrdesc  
       S2)) vaddress acctype iswrite s2fs1walk hwupdatewalk \<bind> (\<lambda> (w__11 ::
       FaultRecord) . 
     (let tmp_740 = ((tmp_740 (| AddressDescriptor_fault := w__11 |))) in
     (let S2 = ((S2 (| TLBRecord_addrdesc := tmp_740 |))) in
     CombineS1S2Desc S1(TLBRecord_addrdesc   S2)))))))))))))
   else return S1)))))))"


definition AArch64_SecondStageWalk  :: " AddressDescriptor \<Rightarrow>(64)Word.word \<Rightarrow> AccType \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(AddressDescriptor),(exception))monad "  where 
     " AArch64_SecondStageWalk S1 vaddress acctype iswrite size1 hwupdatewalk = (
   HasS2Translation ()  \<bind> (\<lambda> (w__0 :: bool) . 
   assert_exp w__0 (''HasS2Translation()'') \<then>
   ((let (s2fs1walk :: bool) = True in
   (let (wasaligned :: bool) = True in
   AArch64_SecondStageTranslate S1 vaddress acctype iswrite wasaligned s2fs1walk size1 hwupdatewalk)))))"


(*val DoubleLockStatus : unit -> M bool*)

definition DoubleLockStatus  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " DoubleLockStatus _ = (
   ELUsingAArch32 EL1 \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then
     and_boolM
       (and_boolM
          ((read_reg DBGOSDLR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 :: 32 bits) . 
           return ((((vec_of_bits [access_vec_dec w__1 (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))
          ((read_reg DBGPRCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__2 :: 32 bits) . 
           return ((((vec_of_bits [access_vec_dec w__2 (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))))
       (Halted ()  \<bind> (\<lambda> (w__4 :: bool) .  return ((\<not> w__4))))
   else
     and_boolM
       (and_boolM
          ((read_reg OSDLR_EL1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__6 :: 32 bits) . 
           return ((((vec_of_bits [access_vec_dec w__6 (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))
          ((read_reg DBGPRCR_EL1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__7 :: 32 bits) . 
           return ((((vec_of_bits [access_vec_dec w__7 (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))))
       (Halted ()  \<bind> (\<lambda> (w__9 :: bool) .  return ((\<not> w__9))))))"


(*val HaltingAllowed : unit -> M bool*)

definition HaltingAllowed  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " HaltingAllowed _ = (
   or_boolM ((Halted () )) ((DoubleLockStatus () )) \<bind> (\<lambda> (w__2 :: bool) . 
   if w__2 then return False
   else
     IsSecure ()  \<bind> (\<lambda> (w__3 :: bool) . 
     if w__3 then ExternalSecureInvasiveDebugEnabled () 
     else ExternalInvasiveDebugEnabled () )))"


(*val system_exceptions_debug_halt_decode : mword ty3 -> mword ty16 -> mword ty3 -> mword ty2 -> M unit*)

definition system_exceptions_debug_halt_decode  :: "(3)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " system_exceptions_debug_halt_decode opc imm16 op2 LL = (
   (write_reg unconditional_ref True \<then>
   or_boolM
     ((read_reg EDSCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 :: 32 bits) . 
      return ((((vec_of_bits [access_vec_dec w__0 (( 14 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))
     (HaltingAllowed ()  \<bind> (\<lambda> (w__1 :: bool) .  return ((\<not> w__1))))) \<bind> (\<lambda> (w__2 :: bool) . 
   (if w__2 then UndefinedFault ()  else return () ) \<then> aarch64_system_exceptions_debug_halt () ))"


(*val HaltOnBreakpointOrWatchpoint : unit -> M bool*)

definition HaltOnBreakpointOrWatchpoint  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " HaltOnBreakpointOrWatchpoint _ = (
   and_boolM
     (and_boolM ((HaltingAllowed () ))
        ((read_reg EDSCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__1 (( 14 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
     ((read_reg OSLSR_EL1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__3 :: 32 bits) . 
      return ((((vec_of_bits [access_vec_dec w__3 (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))))"


(*val DebugTargetFrom : bool -> M (mword ty2)*)

definition DebugTargetFrom  :: " bool \<Rightarrow>((register_value),((2)Word.word),(exception))monad "  where 
     " DebugTargetFrom secure = (
   undefined_bool ()  \<bind> (\<lambda> (route_to_el2 :: bool) . 
   (if (((((HaveEL EL2)) \<and> ((\<not> secure))))) then
      ELUsingAArch32 EL2 \<bind> (\<lambda> (w__0 :: bool) . 
      if w__0 then
        or_boolM
          ((read_reg HDCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 :: 32 bits) . 
           return ((((vec_of_bits [access_vec_dec w__1 (( 8 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))
          ((read_reg HCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__2 :: 32 bits) . 
           return ((((vec_of_bits [access_vec_dec w__2 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))
      else
        or_boolM
          ((read_reg MDCR_EL2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__4 :: 32 bits) . 
           return ((((vec_of_bits [access_vec_dec w__4 (( 8 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))
          ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 :: 64 bits) . 
           return ((((vec_of_bits [access_vec_dec w__5 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
    else return False) \<bind> (\<lambda> (route_to_el2 :: bool) . 
   (undefined_bitvector (( 2 :: int)::ii)  :: ( 2 Word.word) M) \<bind> (\<lambda> (target :: 2 bits) . 
   (let (target :: 2 bits) =
     (if route_to_el2 then EL2
     else if ((((((((HaveEL EL3)) \<and> ((HighestELUsingAArch32 () ))))) \<and> secure))) then EL3
     else EL1) in
   return target)))))"


(*val DebugTarget : unit -> M (mword ty2)*)

definition DebugTarget  :: " unit \<Rightarrow>((register_value),((2)Word.word),(exception))monad "  where 
     " DebugTarget _ = (
   IsSecure ()  \<bind> (\<lambda> (secure :: bool) .  (DebugTargetFrom secure  :: ( 2 Word.word) M)))"


(*val SSAdvance : unit -> M unit*)

definition SSAdvance  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " SSAdvance _ = (
   (DebugTarget ()   :: ( 2 Word.word) M) \<bind> (\<lambda> (target :: 2 bits) . 
   and_boolM (ELUsingAArch32 target \<bind> (\<lambda> (w__0 :: bool) .  return ((\<not> w__0))))
     ((read_reg MDSCR_EL1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 :: 32 bits) . 
      return ((((vec_of_bits [access_vec_dec w__1 (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (step_enabled :: bool) . 
   and_boolM (return step_enabled)
     (read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) . 
      return ((((ProcState_SS   w__2) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (active_not_pending ::
     bool) . 
   if active_not_pending then
     read_reg PSTATE_ref \<bind> (\<lambda> (w__3 :: ProcState) . 
     write_reg PSTATE_ref (w__3 (| ProcState_SS := ((vec_of_bits [B0]  ::  1 Word.word))|)))
   else return () ))))"


(*val ConditionHolds : mword ty4 -> M bool*)

definition ConditionHolds  :: "(4)Word.word \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " ConditionHolds cond = (
   undefined_bool ()  \<bind> (\<lambda> (result :: bool) . 
   (let b__0 = ((slice cond (( 1 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) in
   (if (((b__0 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) then
      read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) . 
      (let (result :: bool) = ((ProcState_Z   w__0) = (vec_of_bits [B1]  ::  1 Word.word)) in
      return result))
    else if (((b__0 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) then
      read_reg PSTATE_ref \<bind> (\<lambda> (w__1 :: ProcState) . 
      (let (result :: bool) = ((ProcState_C   w__1) = (vec_of_bits [B1]  ::  1 Word.word)) in
      return result))
    else if (((b__0 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) then
      read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) . 
      (let (result :: bool) = ((ProcState_N   w__2) = (vec_of_bits [B1]  ::  1 Word.word)) in
      return result))
    else if (((b__0 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) then
      read_reg PSTATE_ref \<bind> (\<lambda> (w__3 :: ProcState) . 
      (let (result :: bool) = ((ProcState_V   w__3) = (vec_of_bits [B1]  ::  1 Word.word)) in
      return result))
    else if (((b__0 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) then
      and_boolM
        (read_reg PSTATE_ref \<bind> (\<lambda> (w__4 :: ProcState) . 
         return ((((ProcState_C   w__4) = (vec_of_bits [B1]  ::  1 Word.word))))))
        (read_reg PSTATE_ref \<bind> (\<lambda> (w__5 :: ProcState) . 
         return ((((ProcState_Z   w__5) = (vec_of_bits [B0]  ::  1 Word.word))))))
    else if (((b__0 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) then
      read_reg PSTATE_ref \<bind> (\<lambda> (w__7 :: ProcState) . 
      read_reg PSTATE_ref \<bind> (\<lambda> (w__8 :: ProcState) . 
      (let (result :: bool) = ((ProcState_N   w__7) =(ProcState_V   w__8)) in
      return result)))
    else if (((b__0 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) then
      and_boolM
        (read_reg PSTATE_ref \<bind> (\<lambda> (w__9 :: ProcState) . 
         read_reg PSTATE_ref \<bind> (\<lambda> (w__10 :: ProcState) . 
         return ((((ProcState_N   w__9) =(ProcState_V   w__10)))))))
        (read_reg PSTATE_ref \<bind> (\<lambda> (w__11 :: ProcState) . 
         return ((((ProcState_Z   w__11) = (vec_of_bits [B0]  ::  1 Word.word))))))
    else return True) \<bind> (\<lambda> (result :: bool) . 
   (let (result :: bool) =
     (if (((((((vec_of_bits [access_vec_dec cond (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((cond \<noteq> (vec_of_bits [B1,B1,B1,B1]  ::  4 Word.word))))))) then
       \<not> result
     else result) in
   return result)))))"


(*val aarch64_integer_conditional_select : mword ty4 -> ii -> ii -> bool -> bool -> ii -> ii -> M unit*)

definition aarch64_integer_conditional_select  :: "(4)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_conditional_select condition d l__153 else_inc else_inv m n = (
   if (((l__153 = (( 8 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M)) \<bind> (\<lambda> (result :: 8 bits) . 
     (aget_X (( 8 :: int)::ii) n  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand1 :: 8 bits) . 
     (aget_X (( 8 :: int)::ii) m  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand2 :: 8 bits) . 
     ConditionHolds condition \<bind> (\<lambda> (w__0 :: bool) . 
     (let (result :: 8 bits) =
       (if w__0 then operand1
       else
         (let (result :: 8 bits) = operand2 in
         (let (result :: 8 bits) = (if else_inv then (not_vec result  ::  8 Word.word) else result) in
         if else_inc then (add_vec_int result (( 1 :: int)::ii)  ::  8 Word.word)
         else result))) in
     aset_X d result))))))
   else if (((l__153 = (( 16 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M)) \<bind> (\<lambda> (result :: 16 bits) . 
     (aget_X (( 16 :: int)::ii) n  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand1 :: 16 bits) . 
     (aget_X (( 16 :: int)::ii) m  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand2 :: 16 bits) . 
     ConditionHolds condition \<bind> (\<lambda> (w__1 :: bool) . 
     (let (result :: 16 bits) =
       (if w__1 then operand1
       else
         (let (result :: 16 bits) = operand2 in
         (let (result :: 16 bits) = (if else_inv then (not_vec result  ::  16 Word.word) else result) in
         if else_inc then (add_vec_int result (( 1 :: int)::ii)  ::  16 Word.word)
         else result))) in
     aset_X d result))))))
   else if (((l__153 = (( 32 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (result :: 32 bits) . 
     (aget_X (( 32 :: int)::ii) n  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand1 :: 32 bits) . 
     (aget_X (( 32 :: int)::ii) m  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand2 :: 32 bits) . 
     ConditionHolds condition \<bind> (\<lambda> (w__2 :: bool) . 
     (let (result :: 32 bits) =
       (if w__2 then operand1
       else
         (let (result :: 32 bits) = operand2 in
         (let (result :: 32 bits) = (if else_inv then (not_vec result  ::  32 Word.word) else result) in
         if else_inc then (add_vec_int result (( 1 :: int)::ii)  ::  32 Word.word)
         else result))) in
     aset_X d result))))))
   else if (((l__153 = (( 64 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (result :: 64 bits) . 
     (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand1 :: 64 bits) . 
     (aget_X (( 64 :: int)::ii) m  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand2 :: 64 bits) . 
     ConditionHolds condition \<bind> (\<lambda> (w__3 :: bool) . 
     (let (result :: 64 bits) =
       (if w__3 then operand1
       else
         (let (result :: 64 bits) = operand2 in
         (let (result :: 64 bits) = (if else_inv then (not_vec result  ::  64 Word.word) else result) in
         if else_inc then (add_vec_int result (( 1 :: int)::ii)  ::  64 Word.word)
         else result))) in
     aset_X d result))))))
   else if (((l__153 = (( 128 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M)) \<bind> (\<lambda> (result :: 128 bits) . 
     (aget_X (( 128 :: int)::ii) n  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand1 :: 128 bits) . 
     (aget_X (( 128 :: int)::ii) m  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand2 :: 128 bits) . 
     ConditionHolds condition \<bind> (\<lambda> (w__4 :: bool) . 
     (let (result :: 128 bits) =
       (if w__4 then operand1
       else
         (let (result :: 128 bits) = operand2 in
         (let (result :: 128 bits) = (if else_inv then (not_vec result  ::  128 Word.word) else result) in
         if else_inc then (add_vec_int result (( 1 :: int)::ii)  ::  128 Word.word)
         else result))) in
     aset_X d result))))))
   else
     (let dbytes = (ex_int ((l__153 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))"


(*val integer_conditional_select_decode : mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty4 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

definition integer_conditional_select_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_conditional_select_decode sf op1 S Rm cond o2 Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   (let (m :: ii) = (Word.uint Rm) in
   (let (datasize :: int) =
     (if (((sf = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 64 :: int)::ii)
     else (( 32 :: int)::ii)) in
   (let (condition :: 4 bits) = cond in
   (let (else_inv :: bool) = (op1 = (vec_of_bits [B1]  ::  1 Word.word)) in
   (let (else_inc :: bool) = (o2 = (vec_of_bits [B1]  ::  1 Word.word)) in
   aarch64_integer_conditional_select condition d datasize else_inc else_inv m n)))))))))"


(*val aarch64_integer_conditional_compare_register : mword ty4 -> ii -> mword ty4 -> ii -> ii -> bool -> M unit*)

definition aarch64_integer_conditional_compare_register  :: "(4)Word.word \<Rightarrow> int \<Rightarrow>(4)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_conditional_compare_register condition l__148 flags__arg m n sub_op = (
   if (((l__148 = (( 8 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let flags = flags__arg in
     (aget_X (( 8 :: int)::ii) n  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand1 :: 8 bits) . 
     (aget_X (( 8 :: int)::ii) m  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand2 :: 8 bits) . 
     (let (carry_in :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> (\<lambda> (anon10 :: 8 bits) . 
     ConditionHolds condition \<bind> (\<lambda> (w__0 :: bool) . 
     (let (flags ::  4 Word.word) =
       (if w__0 then
         (let ((carry_in :: 1 bits), (operand2 :: 8 bits)) =
           (if sub_op then
             (let (operand2 :: 8 bits) = ((not_vec operand2  ::  8 Word.word)) in
             (let (carry_in :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
             (carry_in, operand2)))
           else (carry_in, operand2)) in
         (let (tup__0, tup__1) = ((AddWithCarry operand1 operand2 carry_in  :: ( 8 Word.word *  4 Word.word))) in
         (let (anon10 :: 8 bits) = tup__0 in
         tup__1)))
       else flags) in
     (let (tup__0, tup__1, tup__2, tup__3) =
       ((subrange_vec_dec flags (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec flags (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec flags (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec flags (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__1 :: ProcState) . 
     (write_reg PSTATE_ref (w__1 (| ProcState_N := tup__0 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__2 :: ProcState) . 
     (write_reg PSTATE_ref (w__2 (| ProcState_Z := tup__1 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__3 :: ProcState) . 
     (write_reg PSTATE_ref (w__3 (| ProcState_C := tup__2 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__4 :: ProcState) . 
     write_reg PSTATE_ref (w__4 (| ProcState_V := tup__3 |))))))))))))))))
   else if (((l__148 = (( 16 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let flags = flags__arg in
     (aget_X (( 16 :: int)::ii) n  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand1 :: 16 bits) . 
     (aget_X (( 16 :: int)::ii) m  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand2 :: 16 bits) . 
     (let (carry_in :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (anon10 :: 16 bits) . 
     ConditionHolds condition \<bind> (\<lambda> (w__5 :: bool) . 
     (let (flags ::  4 Word.word) =
       (if w__5 then
         (let ((carry_in :: 1 bits), (operand2 :: 16 bits)) =
           (if sub_op then
             (let (operand2 :: 16 bits) = ((not_vec operand2  ::  16 Word.word)) in
             (let (carry_in :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
             (carry_in, operand2)))
           else (carry_in, operand2)) in
         (let (tup__0, tup__1) =
           ((AddWithCarry operand1 operand2 carry_in  :: ( 16 Word.word *  4 Word.word))) in
         (let (anon10 :: 16 bits) = tup__0 in
         tup__1)))
       else flags) in
     (let (tup__0, tup__1, tup__2, tup__3) =
       ((subrange_vec_dec flags (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec flags (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec flags (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec flags (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__6 :: ProcState) . 
     (write_reg PSTATE_ref (w__6 (| ProcState_N := tup__0 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__7 :: ProcState) . 
     (write_reg PSTATE_ref (w__7 (| ProcState_Z := tup__1 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__8 :: ProcState) . 
     (write_reg PSTATE_ref (w__8 (| ProcState_C := tup__2 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__9 :: ProcState) . 
     write_reg PSTATE_ref (w__9 (| ProcState_V := tup__3 |))))))))))))))))
   else if (((l__148 = (( 32 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let flags = flags__arg in
     (aget_X (( 32 :: int)::ii) n  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand1 :: 32 bits) . 
     (aget_X (( 32 :: int)::ii) m  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand2 :: 32 bits) . 
     (let (carry_in :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (anon10 :: 32 bits) . 
     ConditionHolds condition \<bind> (\<lambda> (w__10 :: bool) . 
     (let (flags ::  4 Word.word) =
       (if w__10 then
         (let ((carry_in :: 1 bits), (operand2 :: 32 bits)) =
           (if sub_op then
             (let (operand2 :: 32 bits) = ((not_vec operand2  ::  32 Word.word)) in
             (let (carry_in :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
             (carry_in, operand2)))
           else (carry_in, operand2)) in
         (let (tup__0, tup__1) =
           ((AddWithCarry operand1 operand2 carry_in  :: ( 32 Word.word *  4 Word.word))) in
         (let (anon10 :: 32 bits) = tup__0 in
         tup__1)))
       else flags) in
     (let (tup__0, tup__1, tup__2, tup__3) =
       ((subrange_vec_dec flags (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec flags (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec flags (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec flags (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__11 :: ProcState) . 
     (write_reg PSTATE_ref (w__11 (| ProcState_N := tup__0 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__12 :: ProcState) . 
     (write_reg PSTATE_ref (w__12 (| ProcState_Z := tup__1 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__13 :: ProcState) . 
     (write_reg PSTATE_ref (w__13 (| ProcState_C := tup__2 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__14 :: ProcState) . 
     write_reg PSTATE_ref (w__14 (| ProcState_V := tup__3 |))))))))))))))))
   else if (((l__148 = (( 64 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let flags = flags__arg in
     (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand1 :: 64 bits) . 
     (aget_X (( 64 :: int)::ii) m  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand2 :: 64 bits) . 
     (let (carry_in :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (anon10 :: 64 bits) . 
     ConditionHolds condition \<bind> (\<lambda> (w__15 :: bool) . 
     (let (flags ::  4 Word.word) =
       (if w__15 then
         (let ((carry_in :: 1 bits), (operand2 :: 64 bits)) =
           (if sub_op then
             (let (operand2 :: 64 bits) = ((not_vec operand2  ::  64 Word.word)) in
             (let (carry_in :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
             (carry_in, operand2)))
           else (carry_in, operand2)) in
         (let (tup__0, tup__1) =
           ((AddWithCarry operand1 operand2 carry_in  :: ( 64 Word.word *  4 Word.word))) in
         (let (anon10 :: 64 bits) = tup__0 in
         tup__1)))
       else flags) in
     (let (tup__0, tup__1, tup__2, tup__3) =
       ((subrange_vec_dec flags (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec flags (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec flags (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec flags (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__16 :: ProcState) . 
     (write_reg PSTATE_ref (w__16 (| ProcState_N := tup__0 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__17 :: ProcState) . 
     (write_reg PSTATE_ref (w__17 (| ProcState_Z := tup__1 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__18 :: ProcState) . 
     (write_reg PSTATE_ref (w__18 (| ProcState_C := tup__2 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__19 :: ProcState) . 
     write_reg PSTATE_ref (w__19 (| ProcState_V := tup__3 |))))))))))))))))
   else if (((l__148 = (( 128 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let flags = flags__arg in
     (aget_X (( 128 :: int)::ii) n  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand1 :: 128 bits) . 
     (aget_X (( 128 :: int)::ii) m  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand2 :: 128 bits) . 
     (let (carry_in :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> (\<lambda> (anon10 :: 128 bits) . 
     ConditionHolds condition \<bind> (\<lambda> (w__20 :: bool) . 
     (let (flags ::  4 Word.word) =
       (if w__20 then
         (let ((carry_in :: 1 bits), (operand2 :: 128 bits)) =
           (if sub_op then
             (let (operand2 :: 128 bits) = ((not_vec operand2  ::  128 Word.word)) in
             (let (carry_in :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
             (carry_in, operand2)))
           else (carry_in, operand2)) in
         (let (tup__0, tup__1) =
           ((AddWithCarry operand1 operand2 carry_in  :: ( 128 Word.word *  4 Word.word))) in
         (let (anon10 :: 128 bits) = tup__0 in
         tup__1)))
       else flags) in
     (let (tup__0, tup__1, tup__2, tup__3) =
       ((subrange_vec_dec flags (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec flags (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec flags (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec flags (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__21 :: ProcState) . 
     (write_reg PSTATE_ref (w__21 (| ProcState_N := tup__0 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__22 :: ProcState) . 
     (write_reg PSTATE_ref (w__22 (| ProcState_Z := tup__1 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__23 :: ProcState) . 
     (write_reg PSTATE_ref (w__23 (| ProcState_C := tup__2 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__24 :: ProcState) . 
     write_reg PSTATE_ref (w__24 (| ProcState_V := tup__3 |))))))))))))))))
   else
     (let dbytes = (ex_int ((l__148 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))"


(*val integer_conditional_compare_register_decode : mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty4 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty4 -> M unit*)

definition integer_conditional_compare_register_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_conditional_compare_register_decode sf op1 S Rm cond o2 Rn o3 nzcv = (
   write_reg unconditional_ref True \<then>
   ((let (n :: ii) = (Word.uint Rn) in
   (let (m :: ii) = (Word.uint Rm) in
   (let (datasize :: int) =
     (if (((sf = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 64 :: int)::ii)
     else (( 32 :: int)::ii)) in
   (let (sub_op :: bool) = (op1 = (vec_of_bits [B1]  ::  1 Word.word)) in
   (let (condition :: 4 bits) = cond in
   (let (flags :: 4 bits) = nzcv in
   aarch64_integer_conditional_compare_register condition datasize flags m n sub_op))))))))"


(*val aarch64_integer_conditional_compare_immediate : forall 'datasize. Size 'datasize => mword ty4 -> itself 'datasize -> mword ty4 -> mword 'datasize -> ii -> bool -> M unit*)

definition aarch64_integer_conditional_compare_immediate  :: "(4)Word.word \<Rightarrow>('datasize::len)itself \<Rightarrow>(4)Word.word \<Rightarrow>('datasize::len)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_conditional_compare_immediate condition datasize flags__arg imm n sub_op = (
   (let datasize = (size_itself_int datasize) in
   (let dbytes = (ex_int ((datasize div (( 8 :: int)::ii)))) in
   (assert_exp True (''datasize constraint'') \<then>
   assert_exp True (''dbytes constraint'')) \<then>
   ((let flags = flags__arg in
   (aget_X datasize n  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> operand1 . 
   (let operand2 = imm in
   (let (carry_in :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
   (undefined_bitvector datasize  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> anon10 . 
   ConditionHolds condition \<bind> (\<lambda> (w__0 :: bool) . 
   (let (flags ::  4 Word.word) =
     (if w__0 then
       (let ((carry_in :: 1 bits), operand2) =
         (if sub_op then
           (let operand2 = ((not_vec operand2  :: ( 'datasize::len)Word.word)) in
           (let (carry_in :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
           (carry_in, operand2)))
         else (carry_in, operand2)) in
       (let (tup__0, tup__1) = (AddWithCarry operand1 operand2 carry_in ) in
       (let anon10 = tup__0 in
       tup__1)))
     else flags) in
   (let (tup__0, tup__1, tup__2, tup__3) =
     ((subrange_vec_dec flags (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
      (subrange_vec_dec flags (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
      (subrange_vec_dec flags (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
      (subrange_vec_dec flags (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
   read_reg PSTATE_ref \<bind> (\<lambda> (w__1 :: ProcState) . 
   (write_reg PSTATE_ref (w__1 (| ProcState_N := tup__0 |)) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__2 :: ProcState) . 
   (write_reg PSTATE_ref (w__2 (| ProcState_Z := tup__1 |)) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__3 :: ProcState) . 
   (write_reg PSTATE_ref (w__3 (| ProcState_C := tup__2 |)) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__4 :: ProcState) . 
   write_reg PSTATE_ref (w__4 (| ProcState_V := tup__3 |))))))))))))))))))"


(*val integer_conditional_compare_immediate_decode : mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty4 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty4 -> M unit*)

definition integer_conditional_compare_immediate_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_conditional_compare_immediate_decode b__0 op1 S imm5 cond o2 Rn o3 nzcv = (
   if (((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (n :: ii) = (Word.uint Rn) in
     (let (sub_op :: bool) = (op1 = (vec_of_bits [B1]  ::  1 Word.word)) in
     (let (condition :: 4 bits) = cond in
     (let (flags :: 4 bits) = nzcv in
     (ZeroExtend__0 imm5 ((make_the_value (( 32 :: int)::ii)  ::  32 itself))  :: ( 32 Word.word) M) \<bind> (\<lambda> (imm :: 32
       bits) . 
     aarch64_integer_conditional_compare_immediate condition
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) flags imm n sub_op))))))
   else
     write_reg unconditional_ref True \<then>
     ((let (n :: ii) = (Word.uint Rn) in
     (let (sub_op :: bool) = (op1 = (vec_of_bits [B1]  ::  1 Word.word)) in
     (let (condition :: 4 bits) = cond in
     (let (flags :: 4 bits) = nzcv in
     (ZeroExtend__0 imm5 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (imm :: 64
       bits) . 
     aarch64_integer_conditional_compare_immediate condition
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) flags imm n sub_op)))))))"


(*val ConditionSyndrome : unit -> M (mword ty5)*)

definition ConditionSyndrome  :: " unit \<Rightarrow>((register_value),((5)Word.word),(exception))monad "  where 
     " ConditionSyndrome _ = (
   (undefined_bitvector (( 5 :: int)::ii)  :: ( 5 Word.word) M) \<bind> (\<lambda> (syndrome :: 5 bits) . 
   (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (cond :: 4 bits) . 
   UsingAArch32 ()  \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then
     (AArch32_CurrentCond ()   :: ( 4 Word.word) M) \<bind> (\<lambda> (w__1 ::  4 Word.word) . 
     (let cond = w__1 in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) . 
     if ((((ProcState_T   w__2) = (vec_of_bits [B0]  ::  1 Word.word)))) then
       (let syndrome =
         ((set_slice (( 5 :: int)::ii) (( 1 :: int)::ii) syndrome (( 4 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)  ::  5 Word.word)) in
       and_boolM ((ConditionHolds cond)) ((ConstrainUnpredictableBool Unpredictable_ESRCONDPASS)) \<bind> (\<lambda> (w__5 ::
         bool) . 
       (let (syndrome :: 5 bits) =
         (if w__5 then
           (set_slice (( 5 :: int)::ii) (( 4 :: int)::ii) syndrome (( 0 :: int)::ii) (vec_of_bits [B1,B1,B1,B0]  ::  4 Word.word)
             ::  5 Word.word)
         else (set_slice (( 5 :: int)::ii) (( 4 :: int)::ii) syndrome (( 0 :: int)::ii) cond  ::  5 Word.word)) in
       return syndrome)))
     else if ((IMPDEF_boolean (''Condition valid for trapped T32''))) then
       (let (syndrome :: 5 bits) =
         ((set_slice (( 5 :: int)::ii) (( 1 :: int)::ii) syndrome (( 4 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)  ::  5 Word.word)) in
       (let (syndrome :: 5 bits) = ((set_slice (( 5 :: int)::ii) (( 4 :: int)::ii) syndrome (( 0 :: int)::ii) cond  ::  5 Word.word)) in
       return syndrome))
     else
       (let syndrome =
         ((set_slice (( 5 :: int)::ii) (( 1 :: int)::ii) syndrome (( 4 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  5 Word.word)) in
       (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (w__6 ::  4 Word.word) . 
       (let (syndrome :: 5 bits) = ((set_slice (( 5 :: int)::ii) (( 4 :: int)::ii) syndrome (( 0 :: int)::ii) w__6  ::  5 Word.word)) in
       return syndrome))))))
   else
     (let (syndrome :: 5 bits) =
       ((set_slice (( 5 :: int)::ii) (( 1 :: int)::ii) syndrome (( 4 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)  ::  5 Word.word)) in
     (let (syndrome :: 5 bits) =
       ((set_slice (( 5 :: int)::ii) (( 4 :: int)::ii) syndrome (( 0 :: int)::ii) (vec_of_bits [B1,B1,B1,B0]  ::  4 Word.word)
         ::  5 Word.word)) in
     return syndrome))))))"


(*val BranchToAddr : forall 'N . Size 'N => mword 'N -> BranchType -> M unit*)

definition BranchToAddr  :: "('N::len)Word.word \<Rightarrow> BranchType \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " BranchToAddr target branch_type = (
   write_reg BranchTaken_ref True \<then>
   ((let (_ :: unit) = (Hint_Branch branch_type) in
   if (((((int (size target))) = (( 32 :: int)::ii)))) then
     (let (target ::  32 Word.word) = ((Word.ucast target  ::  32 Word.word)) in
     UsingAArch32 ()  \<bind> (\<lambda> (w__0 :: bool) . 
     (assert_exp w__0 (''UsingAArch32()'') \<then>
     (ZeroExtend__1 (( 64 :: int)::ii) target  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
     write_reg PC_ref w__1)))
   else
     and_boolM (return (((((int (size target))) = (( 64 :: int)::ii)))))
       (UsingAArch32 ()  \<bind> (\<lambda> (w__2 :: bool) .  return ((\<not> w__2)))) \<bind> (\<lambda> (w__3 :: bool) . 
     assert_exp w__3 (''((N == 64) && !(UsingAArch32()))'') \<then>
     write_reg PC_ref ((slice target (( 0 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))))))"


(*val BadMode : mword ty5 -> M bool*)

definition BadMode  :: "(5)Word.word \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " BadMode mode = (
   undefined_bool ()  \<bind> (\<lambda> (valid_name :: bool) . 
   (let pat0 = mode in
   (let (valid_name :: bool) =
     (if (((pat0 = M32_Monitor))) then HaveAArch32EL EL3
     else if (((pat0 = M32_Hyp))) then HaveAArch32EL EL2
     else if (((pat0 = M32_FIQ))) then HaveAArch32EL EL1
     else if (((pat0 = M32_IRQ))) then HaveAArch32EL EL1
     else if (((pat0 = M32_Svc))) then HaveAArch32EL EL1
     else if (((pat0 = M32_Abort))) then HaveAArch32EL EL1
     else if (((pat0 = M32_Undef))) then HaveAArch32EL EL1
     else if (((pat0 = M32_System))) then HaveAArch32EL EL1
     else if (((pat0 = M32_User))) then HaveAArch32EL EL0
     else False) in
   return ((\<not> valid_name))))))"


(*val aset_Rmode : ii -> mword ty5 -> mword ty32 -> M unit*)

definition aset_Rmode  :: " int \<Rightarrow>(5)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aset_Rmode n mode value_name = (
   (assert_exp (((((n \<ge> (( 0 :: int)::ii))) \<and> ((n \<le> (( 14 :: int)::ii)))))) (''((n >= 0) && (n <= 14))'') \<then>
   IsSecure () ) \<bind> (\<lambda> (w__0 :: bool) . 
   ((if ((\<not> w__0)) then assert_exp (((mode \<noteq> M32_Monitor))) (''(mode != M32_Monitor)'')
    else return () ) \<then>
   BadMode mode) \<bind> (\<lambda> (w__1 :: bool) . 
   assert_exp ((\<not> w__1)) (''!(BadMode(mode))'') \<then>
   (if (((mode = M32_Monitor))) then
     if (((n = (( 13 :: int)::ii)))) then write_reg SP_mon_ref value_name
     else if (((n = (( 14 :: int)::ii)))) then write_reg LR_mon_ref value_name
     else
       read_reg R_ref \<bind> (\<lambda> (w__2 :: ( 64 bits) list) . 
       (let (tmp_10 :: 64 bits) = ((access_list_dec w__2 n  ::  64 Word.word)) in
       (let tmp_10 = ((update_subrange_vec_dec tmp_10 (( 31 :: int)::ii) (( 0 :: int)::ii) value_name  ::  64 Word.word)) in
       read_reg R_ref \<bind> (\<lambda> (w__3 :: ( 64 bits) list) . 
       write_reg R_ref ((update_list_dec w__3 n tmp_10  :: ( 64 Word.word) list))))))
   else
     and_boolM (return ((\<not> ((HighestELUsingAArch32 () )))))
       ((ConstrainUnpredictableBool Unpredictable_ZEROUPPER)) \<bind> (\<lambda> (w__5 :: bool) . 
     if w__5 then
       read_reg R_ref \<bind> (\<lambda> (w__6 :: ( 64 bits) list) . 
       LookUpRIndex n mode \<bind> (\<lambda> (w__7 :: ii) . 
       (ZeroExtend__0 value_name ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__8 ::
          64 Word.word) . 
       write_reg R_ref ((update_list_dec w__6 w__7 w__8  :: ( 64 Word.word) list)))))
     else
       read_reg R_ref \<bind> (\<lambda> (w__9 :: ( 64 bits) list) . 
       LookUpRIndex n mode \<bind> (\<lambda> (w__10 :: ii) . 
       (let (tmp_20 :: 64 bits) = ((access_list_dec w__9 w__10  ::  64 Word.word)) in
       (let tmp_20 = ((update_subrange_vec_dec tmp_20 (( 31 :: int)::ii) (( 0 :: int)::ii) value_name  ::  64 Word.word)) in
       read_reg R_ref \<bind> (\<lambda> (w__11 :: ( 64 bits) list) . 
       LookUpRIndex n mode \<bind> (\<lambda> (w__12 :: ii) . 
       write_reg R_ref ((update_list_dec w__11 w__12 tmp_20  :: ( 64 Word.word) list)))))))))))))"


(*val aset_R : ii -> mword ty32 -> M unit*)

definition aset_R  :: " int \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aset_R n value_name = (
   read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) .  aset_Rmode n(ProcState_M   w__0) value_name))"


(*val set_LR : mword ty32 -> M unit*)

definition set_LR  :: "(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_LR value_name = ( aset_R (( 14 :: int)::ii) value_name )"


(*val ELFromM32 : mword ty5 -> M (bool * mword ty2)*)

definition ELFromM32  :: "(5)Word.word \<Rightarrow>((register_value),(bool*(2)Word.word),(exception))monad "  where 
     " ELFromM32 mode = (
   (undefined_bitvector (( 2 :: int)::ii)  :: ( 2 Word.word) M) \<bind> (\<lambda> (el :: 2 bits) . 
   BadMode mode \<bind> (\<lambda> (w__0 :: bool) . 
   (let (valid_name :: bool) = (\<not> w__0) in
   (let pat0 = mode in
   (if (((pat0 = M32_Monitor))) then
      (let (el :: 2 bits) = EL3 in
      return (el, valid_name))
    else if (((pat0 = M32_Hyp))) then
      (let el = EL2 in
      and_boolM (return valid_name)
        (or_boolM (return ((\<not> ((HaveEL EL3)))))
           ((aget_SCR_GEN ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 ::  32 Word.word) . 
            return ((((vec_of_bits [access_vec_dec w__1 (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))) \<bind> (\<lambda> (w__3 :: bool) . 
      (let (valid_name :: bool) = w__3 in
      return (el, valid_name))))
    else if (((pat0 = M32_FIQ))) then
      and_boolM (return (((((HaveEL EL3)) \<and> ((HighestELUsingAArch32 () ))))))
        ((read_reg SCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__4 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__4 (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__5 :: bool) . 
      (let (el :: 2 bits) = (if w__5 then EL3 else EL1) in
      return (el, valid_name)))
    else if (((pat0 = M32_IRQ))) then
      and_boolM (return (((((HaveEL EL3)) \<and> ((HighestELUsingAArch32 () ))))))
        ((read_reg SCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__6 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__6 (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__7 :: bool) . 
      (let (el :: 2 bits) = (if w__7 then EL3 else EL1) in
      return (el, valid_name)))
    else if (((pat0 = M32_Svc))) then
      and_boolM (return (((((HaveEL EL3)) \<and> ((HighestELUsingAArch32 () ))))))
        ((read_reg SCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__8 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__8 (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__9 :: bool) . 
      (let (el :: 2 bits) = (if w__9 then EL3 else EL1) in
      return (el, valid_name)))
    else if (((pat0 = M32_Abort))) then
      and_boolM (return (((((HaveEL EL3)) \<and> ((HighestELUsingAArch32 () ))))))
        ((read_reg SCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__10 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__10 (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__11 :: bool) . 
      (let (el :: 2 bits) = (if w__11 then EL3 else EL1) in
      return (el, valid_name)))
    else if (((pat0 = M32_Undef))) then
      and_boolM (return (((((HaveEL EL3)) \<and> ((HighestELUsingAArch32 () ))))))
        ((read_reg SCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__12 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__12 (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__13 :: bool) . 
      (let (el :: 2 bits) = (if w__13 then EL3 else EL1) in
      return (el, valid_name)))
    else if (((pat0 = M32_System))) then
      and_boolM (return (((((HaveEL EL3)) \<and> ((HighestELUsingAArch32 () ))))))
        ((read_reg SCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__14 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__14 (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__15 :: bool) . 
      (let (el :: 2 bits) = (if w__15 then EL3 else EL1) in
      return (el, valid_name)))
    else
      (let ((el :: 2 bits), (valid_name :: bool)) =
        (if (((pat0 = M32_User))) then
          (let (el :: 2 bits) = EL0 in
          (el, valid_name))
        else
          (let (valid_name :: bool) = False in
          (el, valid_name))) in
      return (el, valid_name))) \<bind> (\<lambda> varstup .  (let ((el :: 2 bits), (valid_name :: bool)) = varstup in
   (if ((\<not> valid_name)) then (undefined_bitvector (( 2 :: int)::ii)  :: ( 2 Word.word) M)
    else return el) \<bind> (\<lambda> (el :: 2 bits) . 
   return (valid_name, el)))))))))"


(*val ELFromSPSR : mword ty32 -> M (bool * mword ty2)*)

definition ELFromSPSR  :: "(32)Word.word \<Rightarrow>((register_value),(bool*(2)Word.word),(exception))monad "  where 
     " ELFromSPSR spsr = (
   undefined_bool ()  \<bind> (\<lambda> (valid_name :: bool) . 
   (undefined_bitvector (( 2 :: int)::ii)  :: ( 2 Word.word) M) \<bind> (\<lambda> (el :: 2 bits) . 
   (if ((((vec_of_bits [access_vec_dec spsr (( 4 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))) then
      (let el = ((slice spsr (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) in
      (if ((HighestELUsingAArch32 () )) then return False
       else if ((\<not> ((HaveEL el)))) then return False
       else if ((((vec_of_bits [access_vec_dec spsr (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
         return False
       else if ((((((el = EL0))) \<and> ((((vec_of_bits [access_vec_dec spsr (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))) then
         return False
       else
         and_boolM (return ((((((el = EL2))) \<and> ((HaveEL EL3))))))
           ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 :: 32 bits) . 
            return ((((vec_of_bits [access_vec_dec w__0 (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__1 :: bool) . 
         (let (valid_name :: bool) = (if w__1 then False else True) in
         return valid_name))) \<bind> (\<lambda> (valid_name :: bool) . 
      return (el, valid_name)))
    else if ((\<not> ((HaveAnyAArch32 () )))) then
      (let (valid_name :: bool) = False in
      return (el, valid_name))
    else
      (ELFromM32 ((slice spsr (( 0 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word))  :: ((bool *  2 Word.word)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1) = varstup in
      (let (valid_name :: bool) = tup__0 in
      (let (el :: 2 bits) = tup__1 in
      return (el, valid_name)))))) \<bind> (\<lambda> varstup .  (let ((el :: 2 bits), (valid_name :: bool)) = varstup in
   (if ((\<not> valid_name)) then (undefined_bitvector (( 2 :: int)::ii)  :: ( 2 Word.word) M)
    else return el) \<bind> (\<lambda> (el :: 2 bits) . 
   return (valid_name, el)))))))"


(*val IllegalExceptionReturn : mword ty32 -> M bool*)

definition IllegalExceptionReturn  :: "(32)Word.word \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " IllegalExceptionReturn spsr = (
   (undefined_bitvector (( 2 :: int)::ii)  :: ( 2 Word.word) M) \<bind> (\<lambda> (target :: 2 bits) . 
   undefined_bool ()  \<bind> (\<lambda> (valid_name :: bool) . 
   (ELFromSPSR spsr  :: ((bool *  2 Word.word)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1) = varstup in
   (let valid_name = tup__0 in
   (let target = tup__1 in
   if ((\<not> valid_name)) then return True
   else
     read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) . 
     if ((((Word.uint target)) > ((Word.uint(ProcState_EL   w__0))))) then return True
     else
       (let (spsr_mode_is_aarch32 :: bool) =
         ((vec_of_bits [access_vec_dec spsr (( 4 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
       undefined_bool ()  \<bind> (\<lambda> (target_el_is_aarch32 :: bool) . 
       undefined_bool ()  \<bind> (\<lambda> (known :: bool) . 
       ELUsingAArch32K target \<bind> (\<lambda> varstup .  (let (tup__0, tup__1) = varstup in
       (let known = tup__0 in
       (let target_el_is_aarch32 = tup__1 in
       or_boolM (return known)
         (and_boolM (return (((target = EL0))))
            (ELUsingAArch32 EL1 \<bind> (\<lambda> (w__1 :: bool) .  return ((\<not> w__1))))) \<bind> (\<lambda> (w__3 :: bool) . 
       assert_exp w__3 (''(known || ((target == EL0) && !(ELUsingAArch32(EL1))))'') \<then>
       (if (((known \<and> ((neq_bool spsr_mode_is_aarch32 target_el_is_aarch32))))) then return True
       else
         and_boolM ((UsingAArch32 () )) (return ((\<not> spsr_mode_is_aarch32))) \<bind> (\<lambda> (w__5 :: bool) . 
         if w__5 then return True
         else
           and_boolM
             (and_boolM (return (((((HaveEL EL2)) \<and> (((target = EL1)))))))
                (IsSecureBelowEL3 ()  \<bind> (\<lambda> (w__6 :: bool) .  return ((\<not> w__6)))))
             ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__8 :: 64 bits) . 
              return ((((vec_of_bits [access_vec_dec w__8 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__9 :: bool) . 
           return (if w__9 then True
                   else False))))))))))))))))))))"


(*val AArch32_WriteMode : mword ty5 -> M unit*)

definition AArch32_WriteMode  :: "(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch32_WriteMode mode = (
   (undefined_bitvector (( 2 :: int)::ii)  :: ( 2 Word.word) M) \<bind> (\<lambda> (el :: 2 bits) . 
   undefined_bool ()  \<bind> (\<lambda> (valid_name :: bool) . 
   (ELFromM32 mode  :: ((bool *  2 Word.word)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1) = varstup in
   (let valid_name = tup__0 in
   (let el = tup__1 in
   (assert_exp valid_name (''valid'') \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__0 :: ProcState) . 
   (write_reg PSTATE_ref (w__0 (| ProcState_M := mode |)) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__1 :: ProcState) . 
   (write_reg PSTATE_ref (w__1 (| ProcState_EL := el |)) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__2 :: ProcState) . 
   (write_reg PSTATE_ref (w__2 (| ProcState_nRW := ((vec_of_bits [B1]  ::  1 Word.word))|)) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__3 :: ProcState) . 
   write_reg
     PSTATE_ref
     (w__3 (|
       ProcState_SP :=
         (if ((((((mode = M32_User))) \<or> (((mode = M32_System)))))) then
            (vec_of_bits [B0]  ::  1 Word.word)
          else (vec_of_bits [B1]  ::  1 Word.word))|)))))))))))))"


(*val AddrTop : mword ty64 -> bool -> mword ty2 -> M ii*)

definition AddrTop  :: "(64)Word.word \<Rightarrow> bool \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(int),(exception))monad "  where 
     " AddrTop address IsInstr el = (
   (assert_exp ((HaveEL el)) (''HaveEL(el)'') \<then>
   (S1TranslationRegime__0 el  :: ( 2 Word.word) M)) \<bind> (\<lambda> (regime :: 2 bits) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (tbid :: 1 bits) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (tbi :: 1 bits) . 
   ELUsingAArch32 regime \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then return (( 31 :: int)::ii)
   else
     (let pat0 = regime in
     (if (((pat0 = EL1))) then
        (if ((((vec_of_bits [access_vec_dec address (( 55 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
           (read_reg TCR_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 :: 64 bits) . 
           return (vec_of_bits [access_vec_dec w__1 (( 38 :: int)::ii)]  ::  1 Word.word))
         else
           (read_reg TCR_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 :: 64 bits) . 
           return (vec_of_bits [access_vec_dec w__2 (( 37 :: int)::ii)]  ::  1 Word.word))) \<bind> (\<lambda> (w__3 ::
           1 Word.word) . 
        (let tbi = w__3 in
        (if ((HavePACExt () )) then
           if ((((vec_of_bits [access_vec_dec address (( 55 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
             (read_reg TCR_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 :: 64 bits) . 
             return (vec_of_bits [access_vec_dec w__4 (( 52 :: int)::ii)]  ::  1 Word.word))
           else
             (read_reg TCR_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 :: 64 bits) . 
             return (vec_of_bits [access_vec_dec w__5 (( 51 :: int)::ii)]  ::  1 Word.word))
         else return tbid) \<bind> (\<lambda> (tbid :: 1 bits) . 
        return (tbi, tbid))))
      else if (((pat0 = EL2))) then
        and_boolM (return ((HaveVirtHostExt () ))) ((ELIsInHost el)) \<bind> (\<lambda> (w__8 :: bool) . 
        if w__8 then
          (if ((((vec_of_bits [access_vec_dec address (( 55 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
             (read_reg TCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__9 :: 64 bits) . 
             return (vec_of_bits [access_vec_dec w__9 (( 38 :: int)::ii)]  ::  1 Word.word))
           else
             (read_reg TCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__10 :: 64 bits) . 
             return (vec_of_bits [access_vec_dec w__10 (( 37 :: int)::ii)]  ::  1 Word.word))) \<bind> (\<lambda> (w__11 ::
             1 Word.word) . 
          (let tbi = w__11 in
          (if ((HavePACExt () )) then
             if ((((vec_of_bits [access_vec_dec address (( 55 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
               (read_reg TCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__12 :: 64 bits) . 
               return (vec_of_bits [access_vec_dec w__12 (( 52 :: int)::ii)]  ::  1 Word.word))
             else
               (read_reg TCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__13 :: 64 bits) . 
               return (vec_of_bits [access_vec_dec w__13 (( 51 :: int)::ii)]  ::  1 Word.word))
           else return tbid) \<bind> (\<lambda> (tbid :: 1 bits) . 
          return (tbi, tbid))))
        else
          (read_reg TCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__15 :: 64 bits) . 
          (let tbi = ((vec_of_bits [access_vec_dec w__15 (( 20 :: int)::ii)]  ::  1 Word.word)) in
          (if ((HavePACExt () )) then
             (read_reg TCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__16 :: 64 bits) . 
             (let (tbid :: 1 bits) = ((vec_of_bits [access_vec_dec w__16 (( 29 :: int)::ii)]  ::  1 Word.word)) in
             return tbid))
           else return tbid) \<bind> (\<lambda> (tbid :: 1 bits) . 
          return (tbi, tbid)))))
      else
        (read_reg TCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__17 :: 32 bits) . 
        (let tbi = ((vec_of_bits [access_vec_dec w__17 (( 20 :: int)::ii)]  ::  1 Word.word)) in
        (if ((HavePACExt () )) then
           (read_reg TCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__18 :: 32 bits) . 
           (let (tbid :: 1 bits) = ((vec_of_bits [access_vec_dec w__18 (( 29 :: int)::ii)]  ::  1 Word.word)) in
           return tbid))
         else return tbid) \<bind> (\<lambda> (tbid :: 1 bits) . 
        return (tbi, tbid))))) \<bind> (\<lambda> varstup .  (let ((tbi :: 1 bits), (tbid :: 1 bits)) = varstup in
     return (if ((((((tbi = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((((\<not> ((HavePACExt () )))) \<or> (((tbid = (vec_of_bits [B0]  ::  1 Word.word))))))) \<or> ((\<not> IsInstr))))))))
             then
               (( 55 :: int)::ii)
             else (( 63 :: int)::ii))))))))))"


(*val AddPAC : mword ty64 -> mword ty64 -> mword ty128 -> bool -> M (mword ty64)*)

definition AddPAC  :: "(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>(128)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " AddPAC ptr modifier K data = (
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (PAC :: 64 bits) . 
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (result :: 64 bits) . 
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (ext_ptr :: 64 bits) . 
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (extfield :: 64 bits) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (selbit :: 1 bits) . 
   CalculateTBI ptr data \<bind> (\<lambda> (tbi :: bool) . 
   (let (top_bit :: int) = (if tbi then (( 55 :: int)::ii) else (( 63 :: int)::ii)) in
   PtrHasUpperAndLowerAddRanges ()  \<bind> (\<lambda> (w__0 :: bool) . 
   (if w__0 then
      IsEL1TransRegimeRegs ()  \<bind> (\<lambda> (w__1 :: bool) . 
      if w__1 then
        if data then
          or_boolM
            ((read_reg TCR_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 :: 64 bits) . 
             return ((((vec_of_bits [access_vec_dec w__2 (( 38 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))
            ((read_reg TCR_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 :: 64 bits) . 
             return ((((vec_of_bits [access_vec_dec w__3 (( 37 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__4 :: bool) . 
          (let (selbit :: 1 bits) =
            (if w__4 then (vec_of_bits [access_vec_dec ptr (( 55 :: int)::ii)]  ::  1 Word.word)
            else (vec_of_bits [access_vec_dec ptr (( 63 :: int)::ii)]  ::  1 Word.word)) in
          return selbit))
        else
          or_boolM
            (and_boolM
               ((read_reg TCR_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 :: 64 bits) . 
                return ((((vec_of_bits [access_vec_dec w__5 (( 38 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))
               ((read_reg TCR_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__6 :: 64 bits) . 
                return ((((vec_of_bits [access_vec_dec w__6 (( 52 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))))
            (and_boolM
               ((read_reg TCR_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__8 :: 64 bits) . 
                return ((((vec_of_bits [access_vec_dec w__8 (( 37 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))
               ((read_reg TCR_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__9 :: 64 bits) . 
                return ((((vec_of_bits [access_vec_dec w__9 (( 51 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))) \<bind> (\<lambda> (w__11 :: bool) . 
          (let (selbit :: 1 bits) =
            (if w__11 then (vec_of_bits [access_vec_dec ptr (( 55 :: int)::ii)]  ::  1 Word.word)
            else (vec_of_bits [access_vec_dec ptr (( 63 :: int)::ii)]  ::  1 Word.word)) in
          return selbit))
      else if data then
        or_boolM
          (and_boolM (return ((HaveEL EL2)))
             ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__12 :: 64 bits) . 
              return ((((vec_of_bits [access_vec_dec w__12 (( 38 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
          (and_boolM (return ((HaveEL EL2)))
             ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__14 :: 64 bits) . 
              return ((((vec_of_bits [access_vec_dec w__14 (( 37 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))) \<bind> (\<lambda> (w__16 :: bool) . 
        (let (selbit :: 1 bits) =
          (if w__16 then (vec_of_bits [access_vec_dec ptr (( 55 :: int)::ii)]  ::  1 Word.word)
          else (vec_of_bits [access_vec_dec ptr (( 63 :: int)::ii)]  ::  1 Word.word)) in
        return selbit))
      else
        or_boolM
          (and_boolM
             (and_boolM (return ((HaveEL EL2)))
                ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__17 :: 64 bits) . 
                 return ((((vec_of_bits [access_vec_dec w__17 (( 38 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
             ((read_reg TCR_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__19 :: 64 bits) . 
              return ((((vec_of_bits [access_vec_dec w__19 (( 52 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))))
          (and_boolM
             (and_boolM (return ((HaveEL EL2)))
                ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__21 :: 64 bits) . 
                 return ((((vec_of_bits [access_vec_dec w__21 (( 37 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
             ((read_reg TCR_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__23 :: 64 bits) . 
              return ((((vec_of_bits [access_vec_dec w__23 (( 51 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))) \<bind> (\<lambda> (w__25 :: bool) . 
        (let (selbit :: 1 bits) =
          (if w__25 then (vec_of_bits [access_vec_dec ptr (( 55 :: int)::ii)]  ::  1 Word.word)
          else (vec_of_bits [access_vec_dec ptr (( 63 :: int)::ii)]  ::  1 Word.word)) in
        return selbit)))
    else
      (let (selbit :: 1 bits) =
        (if tbi then (vec_of_bits [access_vec_dec ptr (( 55 :: int)::ii)]  ::  1 Word.word)
        else (vec_of_bits [access_vec_dec ptr (( 63 :: int)::ii)]  ::  1 Word.word)) in
      return selbit)) \<bind> (\<lambda> (selbit :: 1 bits) . 
   CalculateBottomPACBit ptr selbit \<bind> (\<lambda> (w__26 :: ii) . 
   (let (bottom_PAC_bit :: int) = (ex_int w__26) in
   assert_exp True ('''') \<then>
   ((let extfield = ((replicate_bits selbit (( 64 :: int)::ii)  ::  64 Word.word)) in
   (let (ext_ptr :: 64 bits) =
     (if tbi then
       (concat_vec ((subrange_vec_dec ptr (( 63 :: int)::ii) (( 56 :: int)::ii)  ::  8 Word.word))
          ((subrange_subrange_concat
              ((((((((((((- bottom_PAC_bit)) + (( 56 :: int)::ii))) -
                              (( 1 :: int)::ii)))
                          - (((( 0 :: int)::ii) - (( 1 :: int)::ii)))))
                      +
                      ((bottom_PAC_bit - (( 1 :: int)::ii)))))
                  - (((( 0 :: int)::ii) - (( 1 :: int)::ii)))))
              extfield
              ((((((- bottom_PAC_bit)) + (( 56 :: int)::ii))) - (( 1 :: int)::ii))) (( 0 :: int)::ii)
              ptr ((bottom_PAC_bit - (( 1 :: int)::ii))) (( 0 :: int)::ii)
             ::  56 Word.word))
         ::  64 Word.word)
     else
       (subrange_subrange_concat ((int (size PAC))) extfield
          ((((((- bottom_PAC_bit)) + (( 64 :: int)::ii))) - (( 1 :: int)::ii))) (( 0 :: int)::ii) ptr
          ((bottom_PAC_bit - (( 1 :: int)::ii))) (( 0 :: int)::ii)
         ::  64 Word.word)) in
   (ComputePAC ext_ptr modifier ((subrange_vec_dec K (( 127 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))
      ((subrange_vec_dec K (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
     :: ( 64 Word.word) M) \<bind> (\<lambda> (w__27 ::  64 Word.word) . 
   (let (PAC :: 64 bits) = w__27 in
   (let (PAC :: 64 bits) =
     (if (((((\<not> ((is_zero_subrange ptr
                    ((((((((top_bit - bottom_PAC_bit)) + (( 1 :: int)::ii))) -
                            (( 1 :: int)::ii)))
                        + bottom_PAC_bit)) bottom_PAC_bit)))) \<and> ((\<not> ((is_ones_subrange ptr
                    ((((((((top_bit - bottom_PAC_bit)) + (( 1 :: int)::ii))) -
                            (( 1 :: int)::ii)))
                        + bottom_PAC_bit)) bottom_PAC_bit))))))) then
       (update_subrange_vec_dec PAC ((top_bit - (( 1 :: int)::ii))) ((top_bit - (( 1 :: int)::ii)))
          ((not_vec (vec_of_bits [access_vec_dec PAC ((top_bit - (( 1 :: int)::ii)))]  ::  1 Word.word)
             ::  1 Word.word))
         ::  64 Word.word)
     else PAC) in
   (let (result :: 64 bits) =
     (if tbi then
       (concat_vec
          ((concat_vec ((subrange_vec_dec ptr (( 63 :: int)::ii) (( 56 :: int)::ii)  ::  8 Word.word)) selbit  ::  9 Word.word))
          ((subrange_subrange_concat
              ((((((((((((((- bottom_PAC_bit)) + (( 55 :: int)::ii))) -
                                  (( 1 :: int)::ii)))
                              + bottom_PAC_bit))
                          - ((bottom_PAC_bit - (( 1 :: int)::ii)))))
                      +
                      ((bottom_PAC_bit - (( 1 :: int)::ii)))))
                  - (((( 0 :: int)::ii) - (( 1 :: int)::ii))))) PAC
              ((((((((- bottom_PAC_bit)) + (( 55 :: int)::ii))) - (( 1 :: int)::ii)))
                  +
                  bottom_PAC_bit)) bottom_PAC_bit ptr ((bottom_PAC_bit - (( 1 :: int)::ii))) (( 0 :: int)::ii)
             ::  55 Word.word))
         ::  64 Word.word)
     else
       (concat_vec
          ((concat_vec ((subrange_vec_dec PAC (( 63 :: int)::ii) (( 56 :: int)::ii)  ::  8 Word.word)) selbit  ::  9 Word.word))
          ((subrange_subrange_concat
              ((((((((((((((- bottom_PAC_bit)) + (( 55 :: int)::ii))) -
                                  (( 1 :: int)::ii)))
                              + bottom_PAC_bit))
                          - ((bottom_PAC_bit - (( 1 :: int)::ii)))))
                      +
                      ((bottom_PAC_bit - (( 1 :: int)::ii)))))
                  - (((( 0 :: int)::ii) - (( 1 :: int)::ii))))) PAC
              ((((((((- bottom_PAC_bit)) + (( 55 :: int)::ii))) - (( 1 :: int)::ii)))
                  +
                  bottom_PAC_bit)) bottom_PAC_bit ptr ((bottom_PAC_bit - (( 1 :: int)::ii))) (( 0 :: int)::ii)
             ::  55 Word.word))
         ::  64 Word.word)) in
   return result)))))))))))))))))))"


(*val AArch64_vESBOperation : unit -> M unit*)

definition AArch64_vESBOperation  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_vESBOperation _ = (
   and_boolM
     (and_boolM (return ((HaveEL EL2))) (IsSecure ()  \<bind> (\<lambda> (w__0 :: bool) .  return ((\<not> w__0)))))
     (or_boolM
        (read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) .  return ((((ProcState_EL   w__2) = EL0)))))
        (read_reg PSTATE_ref \<bind> (\<lambda> (w__3 :: ProcState) .  return ((((ProcState_EL   w__3) = EL1)))))) \<bind> (\<lambda> (w__5 ::
     bool) . 
   (assert_exp w__5 (''((HaveEL(EL2) && !(IsSecure())) && (((PSTATE).EL == EL0) || ((PSTATE).EL == EL1)))'') \<then>
   and_boolM
     ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__6 :: 64 bits) . 
      return ((((vec_of_bits [access_vec_dec w__6 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))
     ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__7 :: 64 bits) . 
      return ((((vec_of_bits [access_vec_dec w__7 (( 5 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))) \<bind> (\<lambda> (vSEI_enabled :: bool) . 
   and_boolM (return vSEI_enabled)
     ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__8 :: 64 bits) . 
      return ((((vec_of_bits [access_vec_dec w__8 (( 8 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (vSEI_pending :: bool) . 
   or_boolM ((Halted () )) ((ExternalDebugInterruptsDisabled EL1)) \<bind> (\<lambda> (vintdis :: bool) . 
   or_boolM (return vintdis)
     (read_reg PSTATE_ref \<bind> (\<lambda> (w__11 :: ProcState) . 
      return ((((ProcState_A   w__11) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (vmasked :: bool) . 
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (VDISR_EL2 :: 64 bits) . 
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (VDISR :: 32 bits) . 
   if (((vSEI_pending \<and> vmasked))) then
     ELUsingAArch32 EL1 \<bind> (\<lambda> (w__12 :: bool) . 
     ((if w__12 then
        (read_reg VDFSR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__13 :: 32 bits) . 
        (read_reg VDFSR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__14 :: 32 bits) . 
        (AArch32_ReportDeferredSError ((slice w__13 (( 14 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))
           (vec_of_bits [access_vec_dec w__14 (( 12 :: int)::ii)]  ::  1 Word.word)
          :: ( 32 Word.word) M) \<bind> (\<lambda> (w__15 ::  32 Word.word) . 
        (let (VDISR :: 32 bits) = w__15 in
        return () ))))
      else
        (read_reg VSESR_EL2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__16 :: 32 bits) . 
        (AArch64_ReportDeferredSError ((slice w__16 (( 0 :: int)::ii) (( 25 :: int)::ii)  ::  25 Word.word))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__17 ::
           64 Word.word) . 
        (let (VDISR_EL2 :: 64 bits) = w__17 in
        return () )))) \<then>
     (read_reg HCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__18 :: 64 bits) . 
     write_reg
       HCR_EL2_ref
       ((set_slice (( 64 :: int)::ii) (( 1 :: int)::ii) w__18 (( 8 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  64 Word.word))))
   else return () ))))))))"


(*val AArch64_WatchpointByteMatch : ii -> mword ty64 -> M bool*)

definition AArch64_WatchpointByteMatch  :: " int \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " AArch64_WatchpointByteMatch n vaddress = (
   catch_early_return
     (liftR (read_reg PSTATE_ref) \<bind> (\<lambda> (w__0 :: ProcState) . 
      liftR (AddrTop vaddress False(ProcState_EL   w__0)) \<bind> (\<lambda> (top1 :: int) . 
      liftR (read_reg DBGWVR_EL1_ref) \<bind> (\<lambda> (w__1 :: ( 64 bits) list) . 
      (let (bottom :: ii) =
        (if ((((vec_of_bits [access_vec_dec ((access_list_dec w__1 n  ::  64 Word.word)) (( 2 :: int)::ii)]
                 ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
          (( 2 :: int)::ii)
        else (( 3 :: int)::ii)) in
      liftR (read_reg DBGWCR_EL1_ref) \<bind> (\<lambda> (w__2 :: ( 32 bits) list) . 
      (let (byte_select_match :: bool) =
        ((vec_of_bits [access_vec_dec
                          ((subrange_vec_dec ((access_list_dec w__2 n  ::  32 Word.word)) (( 12 :: int)::ii) (( 5 :: int)::ii)
                             ::  8 Word.word))
                          ((unsigned_subrange vaddress ((((ex_int bottom)) - (( 1 :: int)::ii)))
                              (( 0 :: int)::ii)))]
            ::  1 Word.word) \<noteq> (vec_of_bits [B0]  ::  1 Word.word)) in
      liftR (read_reg DBGWCR_EL1_ref) \<bind> (\<lambda> (w__3 :: ( 32 bits) list) . 
      (let (mask1 :: ii) =
        (Word.uint ((subrange_vec_dec ((access_list_dec w__3 n  ::  32 Word.word)) (( 28 :: int)::ii) (( 24 :: int)::ii)  ::  5 Word.word))) in
      liftR ((undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M)) \<bind> (\<lambda> (MSB :: 8 bits) . 
      liftR ((undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M)) \<bind> (\<lambda> (LSB :: 8 bits) . 
      and_boolM (return ((((ex_int mask1)) > (( 0 :: int)::ii))))
        (liftR (read_reg DBGWCR_EL1_ref) \<bind> (\<lambda> (w__4 :: ( 32 bits) list) . 
         return ((\<not> ((IsOnes
                        ((subrange_vec_dec ((access_list_dec w__4 n  ::  32 Word.word)) (( 12 :: int)::ii) (( 5 :: int)::ii)
                           ::  8 Word.word)))))))) \<bind> (\<lambda> (w__5 :: bool) . 
      (if w__5 then
         liftR (ConstrainUnpredictableBool Unpredictable_WPMASKANDBAS) \<bind> (\<lambda> (w__6 :: bool) . 
         (let (byte_select_match :: bool) = w__6 in
         return (bottom, byte_select_match)))
       else
         liftR (read_reg DBGWCR_EL1_ref) \<bind> (\<lambda> (w__7 :: ( 32 bits) list) . 
         liftR (read_reg DBGWCR_EL1_ref) \<bind> (\<lambda> (w__8 :: ( 32 bits) list) . 
         (let LSB =
           ((and_vec
              ((subrange_vec_dec ((access_list_dec w__7 n  ::  32 Word.word)) (( 12 :: int)::ii) (( 5 :: int)::ii)
                 ::  8 Word.word))
              ((not_vec
                  ((sub_vec_int
                      ((subrange_vec_dec ((access_list_dec w__8 n  ::  32 Word.word)) (( 12 :: int)::ii) (( 5 :: int)::ii)
                         ::  8 Word.word)) (( 1 :: int)::ii)
                     ::  8 Word.word))
                 ::  8 Word.word))
             ::  8 Word.word)) in
         liftR (read_reg DBGWCR_EL1_ref) \<bind> (\<lambda> (w__9 :: ( 32 bits) list) . 
         (let MSB =
           ((add_vec
              ((subrange_vec_dec ((access_list_dec w__9 n  ::  32 Word.word)) (( 12 :: int)::ii) (( 5 :: int)::ii)
                 ::  8 Word.word)) LSB
             ::  8 Word.word)) in
         if ((\<not> ((IsZero ((and_vec MSB ((sub_vec_int MSB (( 1 :: int)::ii)  ::  8 Word.word))  ::  8 Word.word))))))
         then
           liftR (ConstrainUnpredictableBool Unpredictable_WPBASCONTIGUOUS) \<bind> (\<lambda> (w__10 :: bool) . 
           (let (byte_select_match :: bool) = w__10 in
           (let (bottom :: ii) = ((( 3 :: int)::ii)) in
           return (bottom, byte_select_match))))
         else return (bottom, byte_select_match))))))) \<bind> (\<lambda> varstup .  (let ((bottom :: ii), (byte_select_match ::
        bool)) = varstup in
      liftR (undefined_Constraint () ) \<bind> (\<lambda> (c :: Constraint) . 
      (if (((((((ex_int mask1)) > (( 0 :: int)::ii))) \<and> ((((ex_int mask1)) \<le> (( 2 :: int)::ii)))))) then
         liftR (ConstrainUnpredictableInteger (( 3 :: int)::ii) (( 31 :: int)::ii) Unpredictable_RESWPMASK) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1) = varstup in
         (let c = tup__0 in
         (let mask1 = tup__1 in
         liftR (assert_exp ((((((c = Constraint_DISABLED))) \<or> ((((((c = Constraint_NONE))) \<or> (((c = Constraint_UNKNOWN))))))))) (''((c == Constraint_DISABLED) || ((c == Constraint_NONE) || (c == Constraint_UNKNOWN)))'')) \<then>
         (case  c of
           Constraint_DISABLED => (early_return False :: (unit, bool) MR) \<then> return mask1
         | Constraint_NONE => return (( 0 :: int)::ii)
         )))))
       else return mask1) \<bind> (\<lambda> (mask1 :: ii) . 
      liftR (undefined_bool () ) \<bind> (\<lambda> (WVR_match :: bool) . 
      (let (mask2 :: int) = (ex_int mask1) in
      (let (bottom2 :: int) = (ex_int bottom) in
      (if ((((ex_int mask1)) > ((ex_int bottom)))) then
         (liftR (assert_exp True ('''')) \<then>
         liftR (read_reg DBGWVR_EL1_ref)) \<bind> (\<lambda> (w__11 :: ( 64 bits) list) . 
         (let WVR_match =
           (subrange_subrange_eq vaddress
             ((((((((top1 - mask2)) + (( 1 :: int)::ii))) - (( 1 :: int)::ii))) +
                 mask2)) mask2 ((access_list_dec w__11 n  ::  64 Word.word))
             ((((((((top1 - mask2)) + (( 1 :: int)::ii))) - (( 1 :: int)::ii))) +
                 mask2)) mask2) in
         and_boolM (return WVR_match)
           (liftR (read_reg DBGWVR_EL1_ref) \<bind> (\<lambda> (w__12 :: ( 64 bits) list) . 
            return ((\<not> ((is_zero_subrange ((access_list_dec w__12 n  ::  64 Word.word))
                           ((((((mask2 - bottom2)) - (( 1 :: int)::ii))) +
                               bottom2)) bottom2)))))) \<bind> (\<lambda> (w__13 :: bool) . 
         if w__13 then liftR (ConstrainUnpredictableBool Unpredictable_WPMASKEDBITS)
         else return WVR_match)))
       else
         liftR (read_reg DBGWVR_EL1_ref) \<bind> (\<lambda> (w__15 :: ( 64 bits) list) . 
         (let (WVR_match :: bool) =
           (subrange_subrange_eq vaddress
             ((((((((top1 - bottom2)) + (( 1 :: int)::ii))) - (( 1 :: int)::ii))) +
                 bottom2)) bottom2 ((access_list_dec w__15 n  ::  64 Word.word))
             ((((((((top1 - bottom2)) + (( 1 :: int)::ii))) - (( 1 :: int)::ii))) +
                 bottom2)) bottom2) in
         return WVR_match))) \<bind> (\<lambda> (WVR_match :: bool) . 
      return (((WVR_match \<and> byte_select_match))))))))))))))))))))))))"


(*val IsOnes_slice : forall 'n . Size 'n => mword 'n -> ii -> ii -> M bool*)

definition IsOnes_slice  :: "('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " IsOnes_slice xs i l = (
   assert_exp True ('''') \<then>
   ((let m = ((slice_mask ((int (size xs))) i l  :: ( 'n::len)Word.word)) in
   return (((((and_vec xs m  :: ( 'n::len)Word.word)) = m))))))"


(*val AArch64_TranslationTableWalk : mword ty52 -> mword ty64 -> AccType -> bool -> bool -> bool -> ii -> M TLBRecord*)

definition AArch64_TranslationTableWalk  :: "(52)Word.word \<Rightarrow>(64)Word.word \<Rightarrow> AccType \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(TLBRecord),(exception))monad "  where 
     " AArch64_TranslationTableWalk ipaddress vaddress acctype iswrite secondstage s2fs1walk size1 = (
   catch_early_return
     (((if ((\<not> secondstage)) then
         liftR ((S1TranslationRegime__1 ()   :: ( 2 Word.word) M)) \<bind> (\<lambda> (w__0 ::  2 Word.word) . 
         liftR (ELUsingAArch32 w__0) \<bind> (\<lambda> (w__1 :: bool) .  liftR (assert_exp ((\<not> w__1)) (''''))))
       else
         and_boolM
           (and_boolM
              (and_boolM (return ((HaveEL EL2)))
                 (liftR (IsSecure () ) \<bind> (\<lambda> (w__2 :: bool) .  return ((\<not> w__2)))))
              (liftR (ELUsingAArch32 EL2) \<bind> (\<lambda> (w__4 :: bool) .  return ((\<not> w__4)))))
           (liftR ((HasS2Translation () ))) \<bind> (\<lambda> (w__7 :: bool) . 
         liftR (assert_exp w__7 ('''')))) \<then>
      liftR (undefined_TLBRecord () )) \<bind> (\<lambda> (result :: TLBRecord) . 
      liftR (undefined_AddressDescriptor () ) \<bind> (\<lambda> (descaddr :: AddressDescriptor) . 
      liftR ((undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (baseregister :: 64 bits) . 
      liftR ((undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (inputaddr :: 64 bits) . 
      (let (tmp_170 :: FaultRecord) = ((AddressDescriptor_fault   descaddr)) in
      (let tmp_170 = ((tmp_170 (| FaultRecord_typ := Fault_None |))) in
      (let descaddr = ((descaddr (| AddressDescriptor_fault := tmp_170 |))) in
      (let (tmp_180 :: MemoryAttributes) = ((AddressDescriptor_memattrs   descaddr)) in
      (let tmp_180 = ((tmp_180 (| MemoryAttributes_typ := MemType_Normal |))) in
      (let descaddr = ((descaddr (| AddressDescriptor_memattrs := tmp_180 |))) in
      liftR (undefined_int () ) \<bind> (\<lambda> (startsizecheck :: ii) . 
      liftR (undefined_int () ) \<bind> (\<lambda> (inputsizecheck :: ii) . 
      liftR (undefined_int () ) \<bind> (\<lambda> (startlevel :: ii) . 
      liftR (undefined_int () ) \<bind> (\<lambda> (level :: ii) . 
      liftR (undefined_int () ) \<bind> (\<lambda> (stride :: ii) . 
      liftR (undefined_int () ) \<bind> (\<lambda> (firstblocklevel :: ii) . 
      liftR (undefined_int () ) \<bind> (\<lambda> (grainsize :: ii) . 
      liftR (undefined_bool () ) \<bind> (\<lambda> (hierattrsdisabled :: bool) . 
      liftR (undefined_bool () ) \<bind> (\<lambda> (update_AP :: bool) . 
      liftR (undefined_bool () ) \<bind> (\<lambda> (update_AF :: bool) . 
      liftR (undefined_bool () ) \<bind> (\<lambda> (singlepriv :: bool) . 
      liftR (undefined_bool () ) \<bind> (\<lambda> (lookupsecure :: bool) . 
      liftR (undefined_bool () ) \<bind> (\<lambda> (reversedescriptors :: bool) . 
      liftR (undefined_bool () ) \<bind> (\<lambda> (disabled :: bool) . 
      liftR (undefined_bool () ) \<bind> (\<lambda> (basefound :: bool) . 
      liftR ((undefined_bitvector (( 3 :: int)::ii)  :: ( 3 Word.word) M)) \<bind> (\<lambda> (ps :: 3 bits) . 
      liftR (undefined_int () ) \<bind> (\<lambda> (inputsize_min :: ii) . 
      liftR (undefined_Constraint () ) \<bind> (\<lambda> (c :: Constraint) . 
      liftR (undefined_int () ) \<bind> (\<lambda> (inputsize_max :: ii) . 
      liftR (undefined_int () ) \<bind> (\<lambda> (inputsize :: ii) . 
      liftR (undefined_bool () ) \<bind> (\<lambda> (midgrain :: bool) . 
      liftR (undefined_bool () ) \<bind> (\<lambda> (largegrain :: bool) . 
      liftR (undefined_int () ) \<bind> (\<lambda> (top1 :: ii) . 
      (if ((\<not> secondstage)) then
         liftR ((ZeroExtend__1 (( 64 :: int)::ii) vaddress  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__8 ::  64 Word.word) . 
         (let inputaddr = w__8 in
         liftR (read_reg PSTATE_ref) \<bind> (\<lambda> (w__9 :: ProcState) . 
         liftR (AddrTop inputaddr (((acctype = AccType_IFETCH)))(ProcState_EL   w__9)) \<bind> (\<lambda> (w__10 ::
           ii) . 
         (let top1 = w__10 in
         liftR (read_reg PSTATE_ref) \<bind> (\<lambda> (w__11 :: ProcState) . 
         (if ((((ProcState_EL   w__11) = EL3))) then
            liftR ((read_reg TCR_EL3_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__12 :: 32 bits) . 
            (let largegrain =
              (((slice w__12 (( 14 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)) in
            liftR ((read_reg TCR_EL3_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__13 :: 32 bits) . 
            (let midgrain =
              (((slice w__13 (( 14 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)) in
            liftR ((read_reg TCR_EL3_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__14 :: 32 bits) . 
            (let inputsize = ((( 64 :: int)::ii) - ((Word.uint ((slice w__14 (( 0 :: int)::ii) (( 6 :: int)::ii)  ::  6 Word.word))))) in
            (let inputsize_max =
              (if (((((Have52BitVAExt () )) \<and> largegrain))) then (( 52 :: int)::ii)
              else (( 48 :: int)::ii)) in
            (if ((((ex_int inputsize)) > ((ex_int inputsize_max)))) then
               (let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in
               liftR (assert_exp ((((((c = Constraint_FORCE))) \<or> (((c = Constraint_FAULT)))))) ('''')) \<then>
               ((let (inputsize :: ii) = (if (((c = Constraint_FORCE))) then inputsize_max else inputsize) in
               return (c, inputsize))))
             else return (c, inputsize)) \<bind> (\<lambda> varstup .  (let ((c :: Constraint), (inputsize :: ii)) = varstup in
            (let inputsize_min = ((( 64 :: int)::ii) - (( 39 :: int)::ii)) in
            (if ((((ex_int inputsize)) < ((ex_int inputsize_min)))) then
               (let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in
               liftR (assert_exp ((((((c = Constraint_FORCE))) \<or> (((c = Constraint_FAULT)))))) ('''')) \<then>
               ((let (inputsize :: ii) = (if (((c = Constraint_FORCE))) then inputsize_min else inputsize) in
               return inputsize)))
             else return inputsize) \<bind> (\<lambda> (inputsize :: ii) . 
            liftR ((read_reg TCR_EL3_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__15 :: 32 bits) . 
            (let ps = ((slice w__15 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) in
            and_boolM
              (return (((((((ex_int inputsize)) \<ge> ((ex_int inputsize_min)))) \<and> ((((ex_int inputsize)) \<le> ((ex_int inputsize_max))))))))
              (liftR ((IsZero_slice inputaddr inputsize
                         ((((((ex_int top1)) - ((ex_int inputsize)))) + (( 1 :: int)::ii)))))) \<bind> (\<lambda> (w__17 ::
              bool) . 
            (let basefound = w__17 in
            (let disabled = False in
            liftR ((read_reg TTBR0_EL3_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__18 :: 64 bits) . 
            (let baseregister = w__18 in
            liftR ((read_reg TCR_EL3_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__19 :: 32 bits) . 
            liftR ((read_reg TCR_EL3_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__20 :: 32 bits) . 
            liftR ((read_reg TCR_EL3_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__21 :: 32 bits) . 
            liftR (WalkAttrDecode ((slice w__19 (( 12 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))
                     ((slice w__20 (( 10 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))
                     ((slice w__21 (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) secondstage) \<bind> (\<lambda> (w__22 ::
              MemoryAttributes) . 
            (let descaddr = ((descaddr (| AddressDescriptor_memattrs := w__22 |))) in
            liftR ((read_reg SCTLR_EL3_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__23 :: 32 bits) . 
            (let reversedescriptors =
              ((vec_of_bits [access_vec_dec w__23 (( 25 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
            (let lookupsecure = True in
            (let singlepriv = True in
            and_boolM (return ((HaveAccessFlagUpdateExt () )))
              (liftR ((read_reg TCR_EL3_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__24 :: 32 bits) . 
               return ((((vec_of_bits [access_vec_dec w__24 (( 21 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__25 :: bool) . 
            (let update_AF = w__25 in
            and_boolM (return (((((HaveDirtyBitModifierExt () )) \<and> update_AF))))
              (liftR ((read_reg TCR_EL3_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__26 :: 32 bits) . 
               return ((((vec_of_bits [access_vec_dec w__26 (( 22 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__27 :: bool) . 
            (let update_AP = w__27 in
            and_boolM (return ((AArch64_HaveHPDExt () )))
              (liftR ((read_reg TCR_EL3_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__28 :: 32 bits) . 
               return ((((vec_of_bits [access_vec_dec w__28 (( 24 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__29 :: bool) . 
            (let (hierattrsdisabled :: bool) = w__29 in
            return (basefound,
                    baseregister,
                    descaddr,
                    disabled,
                    hierattrsdisabled,
                    inputsize,
                    largegrain,
                    lookupsecure,
                    midgrain,
                    ps,
                    reversedescriptors,
                    singlepriv,
                    update_AF,
                    update_AP))))))))))))))))))))))))))))))))))
          else
            liftR (IsInHost () ) \<bind> (\<lambda> (w__30 :: bool) . 
            if w__30 then
              (if ((((vec_of_bits [access_vec_dec inputaddr top1]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))) then
                 liftR ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__31 :: 64 bits) . 
                 (let largegrain =
                   (((slice w__31 (( 14 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)) in
                 liftR ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__32 :: 64 bits) . 
                 (let midgrain =
                   (((slice w__32 (( 14 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)) in
                 liftR ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__33 :: 64 bits) . 
                 (let inputsize =
                   ((( 64 :: int)::ii) - ((Word.uint ((slice w__33 (( 0 :: int)::ii) (( 6 :: int)::ii)  ::  6 Word.word))))) in
                 (let inputsize_max =
                   (if (((((Have52BitVAExt () )) \<and> largegrain))) then (( 52 :: int)::ii)
                   else (( 48 :: int)::ii)) in
                 (if ((((ex_int inputsize)) > ((ex_int inputsize_max)))) then
                    (let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in
                    liftR (assert_exp ((((((c = Constraint_FORCE))) \<or> (((c = Constraint_FAULT)))))) ('''')) \<then>
                    ((let (inputsize :: ii) =
                      (if (((c = Constraint_FORCE))) then inputsize_max
                      else inputsize) in
                    return (c, inputsize))))
                  else return (c, inputsize)) \<bind> (\<lambda> varstup .  (let ((c :: Constraint), (inputsize ::
                   ii)) = varstup in
                 (let inputsize_min = ((( 64 :: int)::ii) - (( 39 :: int)::ii)) in
                 (if ((((ex_int inputsize)) < ((ex_int inputsize_min)))) then
                    (let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in
                    liftR (assert_exp ((((((c = Constraint_FORCE))) \<or> (((c = Constraint_FAULT)))))) ('''')) \<then>
                    ((let (inputsize :: ii) =
                      (if (((c = Constraint_FORCE))) then inputsize_min
                      else inputsize) in
                    return inputsize)))
                  else return inputsize) \<bind> (\<lambda> (inputsize :: ii) . 
                 and_boolM
                   (return (((((((ex_int inputsize)) \<ge> ((ex_int inputsize_min)))) \<and> ((((ex_int inputsize)) \<le> ((ex_int inputsize_max))))))))
                   (liftR ((IsZero_slice inputaddr inputsize
                              ((((((ex_int top1)) - ((ex_int inputsize)))) +
                                  (( 1 :: int)::ii)))))) \<bind> (\<lambda> (w__35 :: bool) . 
                 (let basefound = w__35 in
                 liftR ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__36 :: 64 bits) . 
                 (let disabled =
                   ((vec_of_bits [access_vec_dec w__36 (( 7 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
                 liftR ((read_reg TTBR0_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__37 :: 64 bits) . 
                 (let baseregister = w__37 in
                 liftR ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__38 :: 64 bits) . 
                 liftR ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__39 :: 64 bits) . 
                 liftR ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__40 :: 64 bits) . 
                 liftR (WalkAttrDecode ((slice w__38 (( 12 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))
                          ((slice w__39 (( 10 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))
                          ((slice w__40 (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) secondstage) \<bind> (\<lambda> (w__41 ::
                   MemoryAttributes) . 
                 (let descaddr = ((descaddr (| AddressDescriptor_memattrs := w__41 |))) in
                 and_boolM (return ((AArch64_HaveHPDExt () )))
                   (liftR ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__42 :: 64 bits) . 
                    return ((((vec_of_bits [access_vec_dec w__42 (( 41 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__43 :: bool) . 
                 (let (hierattrsdisabled :: bool) = w__43 in
                 return (basefound,
                         baseregister,
                         descaddr,
                         disabled,
                         hierattrsdisabled,
                         inputsize,
                         largegrain,
                         midgrain)))))))))))))))))))))))))
               else
                 liftR ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__44 :: 64 bits) . 
                 (let inputsize =
                   ((( 64 :: int)::ii) - ((Word.uint ((slice w__44 (( 16 :: int)::ii) (( 6 :: int)::ii)  ::  6 Word.word))))) in
                 liftR ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__45 :: 64 bits) . 
                 (let largegrain =
                   (((slice w__45 (( 30 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B1]  ::  2 Word.word)) in
                 liftR ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__46 :: 64 bits) . 
                 (let midgrain =
                   (((slice w__46 (( 30 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)) in
                 (let inputsize_max =
                   (if (((((Have52BitVAExt () )) \<and> largegrain))) then (( 52 :: int)::ii)
                   else (( 48 :: int)::ii)) in
                 (if ((((ex_int inputsize)) > ((ex_int inputsize_max)))) then
                    (let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in
                    liftR (assert_exp ((((((c = Constraint_FORCE))) \<or> (((c = Constraint_FAULT)))))) ('''')) \<then>
                    ((let (inputsize :: ii) =
                      (if (((c = Constraint_FORCE))) then inputsize_max
                      else inputsize) in
                    return (c, inputsize))))
                  else return (c, inputsize)) \<bind> (\<lambda> varstup .  (let ((c :: Constraint), (inputsize ::
                   ii)) = varstup in
                 (let inputsize_min = ((( 64 :: int)::ii) - (( 39 :: int)::ii)) in
                 (if ((((ex_int inputsize)) < ((ex_int inputsize_min)))) then
                    (let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in
                    liftR (assert_exp ((((((c = Constraint_FORCE))) \<or> (((c = Constraint_FAULT)))))) ('''')) \<then>
                    ((let (inputsize :: ii) =
                      (if (((c = Constraint_FORCE))) then inputsize_min
                      else inputsize) in
                    return inputsize)))
                  else return inputsize) \<bind> (\<lambda> (inputsize :: ii) . 
                 and_boolM
                   (return (((((((ex_int inputsize)) \<ge> ((ex_int inputsize_min)))) \<and> ((((ex_int inputsize)) \<le> ((ex_int inputsize_max))))))))
                   (liftR ((IsOnes_slice inputaddr inputsize
                              ((((((ex_int top1)) - ((ex_int inputsize)))) +
                                  (( 1 :: int)::ii)))))) \<bind> (\<lambda> (w__48 :: bool) . 
                 (let basefound = w__48 in
                 liftR ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__49 :: 64 bits) . 
                 (let disabled =
                   ((vec_of_bits [access_vec_dec w__49 (( 23 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
                 liftR ((read_reg TTBR1_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__50 :: 64 bits) . 
                 (let baseregister = w__50 in
                 liftR ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__51 :: 64 bits) . 
                 liftR ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__52 :: 64 bits) . 
                 liftR ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__53 :: 64 bits) . 
                 liftR (WalkAttrDecode ((slice w__51 (( 28 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))
                          ((slice w__52 (( 26 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))
                          ((slice w__53 (( 24 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) secondstage) \<bind> (\<lambda> (w__54 ::
                   MemoryAttributes) . 
                 (let descaddr = ((descaddr (| AddressDescriptor_memattrs := w__54 |))) in
                 and_boolM (return ((AArch64_HaveHPDExt () )))
                   (liftR ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__55 :: 64 bits) . 
                    return ((((vec_of_bits [access_vec_dec w__55 (( 42 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__56 :: bool) . 
                 (let (hierattrsdisabled :: bool) = w__56 in
                 return (basefound,
                         baseregister,
                         descaddr,
                         disabled,
                         hierattrsdisabled,
                         inputsize,
                         largegrain,
                         midgrain)))))))))))))))))))))))))) \<bind> (\<lambda> varstup .  (let ((basefound :: bool), (baseregister :: 64
                bits), (descaddr :: AddressDescriptor), (disabled :: bool), (hierattrsdisabled ::
                bool), (inputsize :: ii), (largegrain :: bool), (midgrain :: bool)) = varstup in
              liftR ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__57 :: 64 bits) . 
              (let ps = ((slice w__57 (( 32 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) in
              liftR ((read_reg SCTLR_EL2_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__58 :: 32 bits) . 
              (let reversedescriptors =
                ((vec_of_bits [access_vec_dec w__58 (( 25 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
              (let lookupsecure = False in
              (let singlepriv = False in
              and_boolM (return ((HaveAccessFlagUpdateExt () )))
                (liftR ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__59 :: 64 bits) . 
                 return ((((vec_of_bits [access_vec_dec w__59 (( 39 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__60 :: bool) . 
              (let update_AF = w__60 in
              and_boolM (return (((((HaveDirtyBitModifierExt () )) \<and> update_AF))))
                (liftR ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__61 :: 64 bits) . 
                 return ((((vec_of_bits [access_vec_dec w__61 (( 40 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__62 :: bool) . 
              (let (update_AP :: bool) = w__62 in
              return (basefound,
                      baseregister,
                      descaddr,
                      disabled,
                      hierattrsdisabled,
                      inputsize,
                      largegrain,
                      lookupsecure,
                      midgrain,
                      ps,
                      reversedescriptors,
                      singlepriv,
                      update_AF,
                      update_AP)))))))))))))
            else
              liftR (read_reg PSTATE_ref) \<bind> (\<lambda> (w__63 :: ProcState) . 
              if ((((ProcState_EL   w__63) = EL2))) then
                liftR ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__64 :: 64 bits) . 
                (let inputsize =
                  ((( 64 :: int)::ii) - ((Word.uint ((slice w__64 (( 0 :: int)::ii) (( 6 :: int)::ii)  ::  6 Word.word))))) in
                liftR ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__65 :: 64 bits) . 
                (let largegrain =
                  (((slice w__65 (( 14 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)) in
                liftR ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__66 :: 64 bits) . 
                (let midgrain =
                  (((slice w__66 (( 14 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)) in
                (let inputsize_max =
                  (if (((((Have52BitVAExt () )) \<and> largegrain))) then (( 52 :: int)::ii)
                  else (( 48 :: int)::ii)) in
                (if ((((ex_int inputsize)) > ((ex_int inputsize_max)))) then
                   (let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in
                   liftR (assert_exp ((((((c = Constraint_FORCE))) \<or> (((c = Constraint_FAULT)))))) ('''')) \<then>
                   ((let (inputsize :: ii) =
                     (if (((c = Constraint_FORCE))) then inputsize_max
                     else inputsize) in
                   return (c, inputsize))))
                 else return (c, inputsize)) \<bind> (\<lambda> varstup .  (let ((c :: Constraint), (inputsize ::
                  ii)) = varstup in
                (let inputsize_min = ((( 64 :: int)::ii) - (( 39 :: int)::ii)) in
                (if ((((ex_int inputsize)) < ((ex_int inputsize_min)))) then
                   (let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in
                   liftR (assert_exp ((((((c = Constraint_FORCE))) \<or> (((c = Constraint_FAULT)))))) ('''')) \<then>
                   ((let (inputsize :: ii) =
                     (if (((c = Constraint_FORCE))) then inputsize_min
                     else inputsize) in
                   return inputsize)))
                 else return inputsize) \<bind> (\<lambda> (inputsize :: ii) . 
                liftR ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__67 :: 64 bits) . 
                (let ps = ((slice w__67 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) in
                and_boolM
                  (return (((((((ex_int inputsize)) \<ge> ((ex_int inputsize_min)))) \<and> ((((ex_int inputsize)) \<le> ((ex_int inputsize_max))))))))
                  (liftR ((IsZero_slice inputaddr inputsize
                             ((((((ex_int top1)) - ((ex_int inputsize)))) +
                                 (( 1 :: int)::ii)))))) \<bind> (\<lambda> (w__69 :: bool) . 
                (let basefound = w__69 in
                (let disabled = False in
                liftR ((read_reg TTBR0_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__70 :: 64 bits) . 
                (let baseregister = w__70 in
                liftR ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__71 :: 64 bits) . 
                liftR ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__72 :: 64 bits) . 
                liftR ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__73 :: 64 bits) . 
                liftR (WalkAttrDecode ((slice w__71 (( 12 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))
                         ((slice w__72 (( 10 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))
                         ((slice w__73 (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) secondstage) \<bind> (\<lambda> (w__74 ::
                  MemoryAttributes) . 
                (let descaddr = ((descaddr (| AddressDescriptor_memattrs := w__74 |))) in
                liftR ((read_reg SCTLR_EL2_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__75 :: 32 bits) . 
                (let reversedescriptors =
                  ((vec_of_bits [access_vec_dec w__75 (( 25 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
                (let lookupsecure = False in
                (let singlepriv = True in
                and_boolM (return ((HaveAccessFlagUpdateExt () )))
                  (liftR ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__76 :: 64 bits) . 
                   return ((((vec_of_bits [access_vec_dec w__76 (( 39 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__77 :: bool) . 
                (let update_AF = w__77 in
                and_boolM (return (((((HaveDirtyBitModifierExt () )) \<and> update_AF))))
                  (liftR ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__78 :: 64 bits) . 
                   return ((((vec_of_bits [access_vec_dec w__78 (( 40 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__79 :: bool) . 
                (let update_AP = w__79 in
                and_boolM (return ((AArch64_HaveHPDExt () )))
                  (liftR ((read_reg TCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__80 :: 64 bits) . 
                   return ((((vec_of_bits [access_vec_dec w__80 (( 24 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__81 :: bool) . 
                (let (hierattrsdisabled :: bool) = w__81 in
                return (basefound,
                        baseregister,
                        descaddr,
                        disabled,
                        hierattrsdisabled,
                        inputsize,
                        largegrain,
                        lookupsecure,
                        midgrain,
                        ps,
                        reversedescriptors,
                        singlepriv,
                        update_AF,
                        update_AP))))))))))))))))))))))))))))))))))
              else
                (if ((((vec_of_bits [access_vec_dec inputaddr top1]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))) then
                   liftR ((read_reg TCR_EL1_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__82 :: 64 bits) . 
                   (let inputsize =
                     ((( 64 :: int)::ii) - ((Word.uint ((slice w__82 (( 0 :: int)::ii) (( 6 :: int)::ii)  ::  6 Word.word))))) in
                   liftR ((read_reg TCR_EL1_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__83 :: 64 bits) . 
                   (let largegrain =
                     (((slice w__83 (( 14 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)) in
                   liftR ((read_reg TCR_EL1_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__84 :: 64 bits) . 
                   (let midgrain =
                     (((slice w__84 (( 14 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)) in
                   (let inputsize_max =
                     (if (((((Have52BitVAExt () )) \<and> largegrain))) then (( 52 :: int)::ii)
                     else (( 48 :: int)::ii)) in
                   (if ((((ex_int inputsize)) > ((ex_int inputsize_max)))) then
                      (let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in
                      liftR (assert_exp ((((((c = Constraint_FORCE))) \<or> (((c = Constraint_FAULT)))))) ('''')) \<then>
                      ((let (inputsize :: ii) =
                        (if (((c = Constraint_FORCE))) then inputsize_max
                        else inputsize) in
                      return (c, inputsize))))
                    else return (c, inputsize)) \<bind> (\<lambda> varstup .  (let ((c :: Constraint), (inputsize ::
                     ii)) = varstup in
                   (let inputsize_min = ((( 64 :: int)::ii) - (( 39 :: int)::ii)) in
                   (if ((((ex_int inputsize)) < ((ex_int inputsize_min)))) then
                      (let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in
                      liftR (assert_exp ((((((c = Constraint_FORCE))) \<or> (((c = Constraint_FAULT)))))) ('''')) \<then>
                      ((let (inputsize :: ii) =
                        (if (((c = Constraint_FORCE))) then inputsize_min
                        else inputsize) in
                      return inputsize)))
                    else return inputsize) \<bind> (\<lambda> (inputsize :: ii) . 
                   and_boolM
                     (return (((((((ex_int inputsize)) \<ge> ((ex_int inputsize_min)))) \<and> ((((ex_int inputsize)) \<le> ((ex_int inputsize_max))))))))
                     (liftR ((IsZero_slice inputaddr inputsize
                                ((((((ex_int top1)) - ((ex_int inputsize)))) +
                                    (( 1 :: int)::ii)))))) \<bind> (\<lambda> (w__86 :: bool) . 
                   (let basefound = w__86 in
                   liftR ((read_reg TCR_EL1_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__87 :: 64 bits) . 
                   (let disabled =
                     ((vec_of_bits [access_vec_dec w__87 (( 7 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
                   liftR ((read_reg TTBR0_EL1_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__88 :: 64 bits) . 
                   (let baseregister = w__88 in
                   liftR ((read_reg TCR_EL1_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__89 :: 64 bits) . 
                   liftR ((read_reg TCR_EL1_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__90 :: 64 bits) . 
                   liftR ((read_reg TCR_EL1_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__91 :: 64 bits) . 
                   liftR (WalkAttrDecode ((slice w__89 (( 12 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))
                            ((slice w__90 (( 10 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))
                            ((slice w__91 (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) secondstage) \<bind> (\<lambda> (w__92 ::
                     MemoryAttributes) . 
                   (let descaddr = ((descaddr (| AddressDescriptor_memattrs := w__92 |))) in
                   and_boolM (return ((AArch64_HaveHPDExt () )))
                     (liftR ((read_reg TCR_EL1_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__93 :: 64 bits) . 
                      return ((((vec_of_bits [access_vec_dec w__93 (( 41 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__94 :: bool) . 
                   (let (hierattrsdisabled :: bool) = w__94 in
                   return (basefound,
                           baseregister,
                           descaddr,
                           disabled,
                           hierattrsdisabled,
                           inputsize,
                           largegrain,
                           midgrain)))))))))))))))))))))))))
                 else
                   liftR ((read_reg TCR_EL1_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__95 :: 64 bits) . 
                   (let inputsize =
                     ((( 64 :: int)::ii) - ((Word.uint ((slice w__95 (( 16 :: int)::ii) (( 6 :: int)::ii)  ::  6 Word.word))))) in
                   liftR ((read_reg TCR_EL1_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__96 :: 64 bits) . 
                   (let largegrain =
                     (((slice w__96 (( 30 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B1]  ::  2 Word.word)) in
                   liftR ((read_reg TCR_EL1_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__97 :: 64 bits) . 
                   (let midgrain =
                     (((slice w__97 (( 30 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)) in
                   (let inputsize_max =
                     (if (((((Have52BitVAExt () )) \<and> largegrain))) then (( 52 :: int)::ii)
                     else (( 48 :: int)::ii)) in
                   (if ((((ex_int inputsize)) > ((ex_int inputsize_max)))) then
                      (let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in
                      liftR (assert_exp ((((((c = Constraint_FORCE))) \<or> (((c = Constraint_FAULT)))))) ('''')) \<then>
                      ((let (inputsize :: ii) =
                        (if (((c = Constraint_FORCE))) then inputsize_max
                        else inputsize) in
                      return (c, inputsize))))
                    else return (c, inputsize)) \<bind> (\<lambda> varstup .  (let ((c :: Constraint), (inputsize ::
                     ii)) = varstup in
                   (let inputsize_min = ((( 64 :: int)::ii) - (( 39 :: int)::ii)) in
                   (if ((((ex_int inputsize)) < ((ex_int inputsize_min)))) then
                      (let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in
                      liftR (assert_exp ((((((c = Constraint_FORCE))) \<or> (((c = Constraint_FAULT)))))) ('''')) \<then>
                      ((let (inputsize :: ii) =
                        (if (((c = Constraint_FORCE))) then inputsize_min
                        else inputsize) in
                      return inputsize)))
                    else return inputsize) \<bind> (\<lambda> (inputsize :: ii) . 
                   and_boolM
                     (return (((((((ex_int inputsize)) \<ge> ((ex_int inputsize_min)))) \<and> ((((ex_int inputsize)) \<le> ((ex_int inputsize_max))))))))
                     (liftR ((IsOnes_slice inputaddr inputsize
                                ((((((ex_int top1)) - ((ex_int inputsize)))) +
                                    (( 1 :: int)::ii)))))) \<bind> (\<lambda> (w__99 :: bool) . 
                   (let basefound = w__99 in
                   liftR ((read_reg TCR_EL1_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__100 :: 64 bits) . 
                   (let disabled =
                     ((vec_of_bits [access_vec_dec w__100 (( 23 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
                   liftR ((read_reg TTBR1_EL1_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__101 :: 64 bits) . 
                   (let baseregister = w__101 in
                   liftR ((read_reg TCR_EL1_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__102 :: 64 bits) . 
                   liftR ((read_reg TCR_EL1_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__103 :: 64 bits) . 
                   liftR ((read_reg TCR_EL1_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__104 :: 64 bits) . 
                   liftR (WalkAttrDecode ((slice w__102 (( 28 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))
                            ((slice w__103 (( 26 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))
                            ((slice w__104 (( 24 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) secondstage) \<bind> (\<lambda> (w__105 ::
                     MemoryAttributes) . 
                   (let descaddr = ((descaddr (| AddressDescriptor_memattrs := w__105 |))) in
                   and_boolM (return ((AArch64_HaveHPDExt () )))
                     (liftR ((read_reg TCR_EL1_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__106 :: 64 bits) . 
                      return ((((vec_of_bits [access_vec_dec w__106 (( 42 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__107 :: bool) . 
                   (let (hierattrsdisabled :: bool) = w__107 in
                   return (basefound,
                           baseregister,
                           descaddr,
                           disabled,
                           hierattrsdisabled,
                           inputsize,
                           largegrain,
                           midgrain)))))))))))))))))))))))))) \<bind> (\<lambda> varstup .  (let ((basefound :: bool), (baseregister :: 64
                  bits), (descaddr :: AddressDescriptor), (disabled :: bool), (hierattrsdisabled ::
                  bool), (inputsize :: ii), (largegrain :: bool), (midgrain :: bool)) = varstup in
                liftR ((read_reg TCR_EL1_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__108 :: 64 bits) . 
                (let ps = ((slice w__108 (( 32 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) in
                liftR ((read_reg SCTLR_EL1_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__109 :: 32 bits) . 
                (let reversedescriptors =
                  ((vec_of_bits [access_vec_dec w__109 (( 25 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
                liftR (IsSecure () ) \<bind> (\<lambda> (w__110 :: bool) . 
                (let lookupsecure = w__110 in
                (let singlepriv = False in
                and_boolM (return ((HaveAccessFlagUpdateExt () )))
                  (liftR ((read_reg TCR_EL1_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__111 :: 64 bits) . 
                   return ((((vec_of_bits [access_vec_dec w__111 (( 39 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__112 :: bool) . 
                (let update_AF = w__112 in
                and_boolM (return (((((HaveDirtyBitModifierExt () )) \<and> update_AF))))
                  (liftR ((read_reg TCR_EL1_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__113 :: 64 bits) . 
                   return ((((vec_of_bits [access_vec_dec w__113 (( 40 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__114 :: bool) . 
                (let (update_AP :: bool) = w__114 in
                return (basefound,
                        baseregister,
                        descaddr,
                        disabled,
                        hierattrsdisabled,
                        inputsize,
                        largegrain,
                        lookupsecure,
                        midgrain,
                        ps,
                        reversedescriptors,
                        singlepriv,
                        update_AF,
                        update_AP))))))))))))))))) \<bind> (\<lambda> varstup .  (let ((basefound :: bool), (baseregister :: 64
           bits), (descaddr :: AddressDescriptor), (disabled :: bool), (hierattrsdisabled :: bool), (inputsize ::
           ii), (largegrain :: bool), (lookupsecure :: bool), (midgrain :: bool), (ps :: 3 bits), (reversedescriptors ::
           bool), (singlepriv :: bool), (update_AF :: bool), (update_AP :: bool)) = varstup in
         (let ((firstblocklevel :: ii), (grainsize :: ii)) =
           (if largegrain then
             (let (grainsize :: ii) = ((( 16 :: int)::ii)) in
             (let (firstblocklevel :: ii) = (if ((Have52BitPAExt () )) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
             (firstblocklevel, grainsize)))
           else
             (let ((firstblocklevel :: ii), (grainsize :: ii)) =
               (if midgrain then
                 (let (grainsize :: ii) = ((( 14 :: int)::ii)) in
                 (let (firstblocklevel :: ii) = ((( 2 :: int)::ii)) in
                 (firstblocklevel, grainsize)))
               else
                 (let (grainsize :: ii) = ((( 12 :: int)::ii)) in
                 (let (firstblocklevel :: ii) = ((( 1 :: int)::ii)) in
                 (firstblocklevel, grainsize)))) in
             (firstblocklevel, grainsize))) in
         (let (stride :: ii) = (((ex_int grainsize)) - (( 3 :: int)::ii)) in
         (let (level :: ii) =
           ((( 4 :: int)::ii) -
             ((ex_int
                 ((ceiling
                     (((((real_of_int ((((ex_int inputsize)) - ((ex_int grainsize)))))))
                         div
                         (((real_of_int stride)))))))))) in
         return (basefound,
                 baseregister,
                 descaddr,
                 disabled,
                 firstblocklevel,
                 grainsize,
                 hierattrsdisabled,
                 inputaddr,
                 inputsize,
                 largegrain,
                 level,
                 lookupsecure,
                 midgrain,
                 ps,
                 reversedescriptors,
                 singlepriv,
                 stride,
                 update_AF,
                 update_AP))))))))))))
       else
         liftR ((ZeroExtend__1 (( 64 :: int)::ii) ipaddress  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__115 ::  64 Word.word) . 
         (let inputaddr = w__115 in
         liftR ((read_reg VTCR_EL2_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__116 :: 32 bits) . 
         (let inputsize = ((( 64 :: int)::ii) - ((Word.uint ((slice w__116 (( 0 :: int)::ii) (( 6 :: int)::ii)  ::  6 Word.word))))) in
         liftR ((read_reg VTCR_EL2_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__117 :: 32 bits) . 
         (let largegrain =
           (((slice w__117 (( 14 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)) in
         liftR ((read_reg VTCR_EL2_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__118 :: 32 bits) . 
         (let midgrain =
           (((slice w__118 (( 14 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)) in
         (let inputsize_max =
           (if (((((Have52BitVAExt () )) \<and> largegrain))) then (( 52 :: int)::ii)
           else (( 48 :: int)::ii)) in
         (if ((((ex_int inputsize)) > ((ex_int inputsize_max)))) then
            (let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in
            liftR (assert_exp ((((((c = Constraint_FORCE))) \<or> (((c = Constraint_FAULT)))))) ('''')) \<then>
            ((let (inputsize :: ii) = (if (((c = Constraint_FORCE))) then inputsize_max else inputsize) in
            return (c, inputsize))))
          else return (c, inputsize)) \<bind> (\<lambda> varstup .  (let ((c :: Constraint), (inputsize :: ii)) = varstup in
         (let inputsize_min = ((( 64 :: int)::ii) - (( 39 :: int)::ii)) in
         (if ((((ex_int inputsize)) < ((ex_int inputsize_min)))) then
            (let c = (ConstrainUnpredictable Unpredictable_RESTnSZ) in
            liftR (assert_exp ((((((c = Constraint_FORCE))) \<or> (((c = Constraint_FAULT)))))) ('''')) \<then>
            ((let (inputsize :: ii) = (if (((c = Constraint_FORCE))) then inputsize_min else inputsize) in
            return inputsize)))
          else return inputsize) \<bind> (\<lambda> (inputsize :: ii) . 
         liftR ((read_reg VTCR_EL2_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__119 :: 32 bits) . 
         (let ps = ((slice w__119 (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) in
         and_boolM
           (return (((((((ex_int inputsize)) \<ge> ((ex_int inputsize_min)))) \<and> ((((ex_int inputsize)) \<le> ((ex_int inputsize_max))))))))
           (liftR ((IsZero_slice inputaddr inputsize
                      ((((- ((ex_int inputsize)))) + (( 64 :: int)::ii)))))) \<bind> (\<lambda> (w__121 ::
           bool) . 
         (let basefound = w__121 in
         (let disabled = False in
         liftR ((read_reg VTTBR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__122 :: 64 bits) . 
         (let baseregister = w__122 in
         liftR ((read_reg VTCR_EL2_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__123 :: 32 bits) . 
         liftR ((read_reg VTCR_EL2_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__124 :: 32 bits) . 
         liftR ((read_reg VTCR_EL2_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__125 :: 32 bits) . 
         liftR (WalkAttrDecode ((slice w__123 (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))
                  ((slice w__124 (( 10 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))
                  ((slice w__125 (( 12 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) secondstage) \<bind> (\<lambda> (w__126 ::
           MemoryAttributes) . 
         (let descaddr = ((descaddr (| AddressDescriptor_memattrs := w__126 |))) in
         liftR ((read_reg SCTLR_EL2_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__127 :: 32 bits) . 
         (let reversedescriptors =
           ((vec_of_bits [access_vec_dec w__127 (( 25 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
         (let lookupsecure = False in
         (let singlepriv = True in
         and_boolM (return ((HaveAccessFlagUpdateExt () )))
           (liftR ((read_reg VTCR_EL2_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__128 :: 32 bits) . 
            return ((((vec_of_bits [access_vec_dec w__128 (( 21 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__129 :: bool) . 
         (let update_AF = w__129 in
         and_boolM (return (((((HaveDirtyBitModifierExt () )) \<and> update_AF))))
           (liftR ((read_reg VTCR_EL2_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__130 :: 32 bits) . 
            return ((((vec_of_bits [access_vec_dec w__130 (( 22 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__131 :: bool) . 
         (let update_AP = w__131 in
         liftR ((read_reg VTCR_EL2_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__132 :: 32 bits) . 
         (let startlevel = (Word.uint ((slice w__132 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))) in
         (let ((firstblocklevel :: ii), (grainsize :: ii), (level :: ii)) =
           (if largegrain then
             (let (grainsize :: ii) = ((( 16 :: int)::ii)) in
             (let (level :: ii) = ((( 3 :: int)::ii) - ((ex_int startlevel))) in
             (let (firstblocklevel :: ii) = (if ((Have52BitPAExt () )) then (( 1 :: int)::ii) else (( 2 :: int)::ii)) in
             (firstblocklevel, grainsize, level))))
           else
             (let ((firstblocklevel :: ii), (grainsize :: ii), (level :: ii)) =
               (if midgrain then
                 (let (grainsize :: ii) = ((( 14 :: int)::ii)) in
                 (let (level :: ii) = ((( 3 :: int)::ii) - ((ex_int startlevel))) in
                 (let (firstblocklevel :: ii) = ((( 2 :: int)::ii)) in
                 (firstblocklevel, grainsize, level))))
               else
                 (let (grainsize :: ii) = ((( 12 :: int)::ii)) in
                 (let (level :: ii) = ((( 2 :: int)::ii) - ((ex_int startlevel))) in
                 (let (firstblocklevel :: ii) = ((( 1 :: int)::ii)) in
                 (firstblocklevel, grainsize, level))))) in
             (firstblocklevel, grainsize, level))) in
         (let stride = (((ex_int grainsize)) - (( 3 :: int)::ii)) in
         (let (basefound :: bool) =
           (if largegrain then
             if ((((((((ex_int level)) = (( 0 :: int)::ii)))) \<or> ((((((((ex_int level)) = (( 1 :: int)::ii)))) \<and> ((((ex_int ((PAMax () )))) \<le> (( 42 :: int)::ii))))))))) then
               False
             else basefound
           else if midgrain then
             if ((((((((ex_int level)) = (( 0 :: int)::ii)))) \<or> ((((((((ex_int level)) = (( 1 :: int)::ii)))) \<and> ((((ex_int ((PAMax () )))) \<le> (( 40 :: int)::ii))))))))) then
               False
             else basefound
           else if (((((((ex_int level)) < (( 0 :: int)::ii))) \<or> ((((((((ex_int level)) = (( 0 :: int)::ii)))) \<and> ((((ex_int ((PAMax () )))) \<le> (( 42 :: int)::ii))))))))) then
             False
           else basefound) in
         (let inputsizecheck = inputsize in
         and_boolM (return ((((ex_int inputsize)) > ((ex_int ((PAMax () )))))))
           (or_boolM (liftR (ELUsingAArch32 EL1) \<bind> (\<lambda> (w__133 :: bool) .  return ((\<not> w__133))))
              (return ((((ex_int inputsize)) > (( 40 :: int)::ii))))) \<bind> (\<lambda> (w__135 :: bool) . 
         (if w__135 then
            (case  ((ConstrainUnpredictable Unpredictable_LARGEIPA)) of
              Constraint_FORCE =>
               (let (inputsize :: ii) = (PAMax () ) in
               (let (inputsizecheck :: ii) = (PAMax () ) in
               return (basefound, inputsize, inputsizecheck)))
            | Constraint_FORCENOSLCHECK =>
               (let (inputsize :: ii) = (PAMax () ) in
               return (basefound, inputsize, inputsizecheck))
            | Constraint_FAULT =>
               (let (basefound :: bool) = False in
               return (basefound, inputsize, inputsizecheck))
            | _ => liftR (Unreachable () ) \<then> return (basefound, inputsize, inputsizecheck)
            )
          else return (basefound, inputsize, inputsizecheck)) \<bind> (\<lambda> varstup .  (let ((basefound ::
           bool), (inputsize :: ii), (inputsizecheck :: ii)) = varstup in
         (let (startsizecheck :: ii) =
           (((ex_int inputsizecheck)) -
             (((((((( 3 :: int)::ii) - ((ex_int level)))) * ((ex_int stride)))) +
                 ((ex_int grainsize))))) in
         (let (basefound :: bool) =
           (if (((((((ex_int startsizecheck)) < (( 1 :: int)::ii))) \<or> ((((ex_int startsizecheck)) > ((((ex_int stride)) + (( 4 :: int)::ii)))))))) then
             False
           else basefound) in
         return (basefound,
                 baseregister,
                 descaddr,
                 disabled,
                 firstblocklevel,
                 grainsize,
                 hierattrsdisabled,
                 inputaddr,
                 inputsize,
                 largegrain,
                 level,
                 lookupsecure,
                 midgrain,
                 ps,
                 reversedescriptors,
                 singlepriv,
                 stride,
                 update_AF,
                 update_AP)))))))))))))))))))))))))))))))))))))))))))))) \<bind> (\<lambda> varstup .  (let ((basefound :: bool), (baseregister :: 64 bits), (descaddr ::
        AddressDescriptor), (disabled :: bool), (firstblocklevel :: ii), (grainsize :: ii), (hierattrsdisabled ::
        bool), (inputaddr :: 64 bits), (inputsize :: ii), (largegrain :: bool), (level :: ii), (lookupsecure ::
        bool), (midgrain :: bool), (ps :: 3 bits), (reversedescriptors :: bool), (singlepriv :: bool), (stride ::
        ii), (update_AF :: bool), (update_AP :: bool)) = varstup in
      if (((((\<not> basefound)) \<or> disabled))) then
        (let level = ((( 0 :: int)::ii)) in
        (let (tmp_190 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
        liftR (AArch64_TranslationFault ipaddress level acctype iswrite secondstage s2fs1walk) \<bind> (\<lambda> (w__136 ::
          FaultRecord) . 
        (let (tmp_190 :: AddressDescriptor) = ((tmp_190 (| AddressDescriptor_fault := w__136 |))) in
        (let (result :: TLBRecord) = ((result (| TLBRecord_addrdesc := tmp_190 |))) in
        return result)))))
      else
        liftR (undefined_int () ) \<bind> (\<lambda> (outputsize :: ii) . 
        (let b__0 = ps in
        (let (outputsize :: ii) =
          (if (((b__0 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) then (( 32 :: int)::ii)
          else if (((b__0 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) then (( 36 :: int)::ii)
          else if (((b__0 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) then (( 40 :: int)::ii)
          else if (((b__0 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) then (( 42 :: int)::ii)
          else if (((b__0 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) then (( 44 :: int)::ii)
          else if (((b__0 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) then (( 48 :: int)::ii)
          else if (((b__0 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) then
            if (((((Have52BitPAExt () )) \<and> largegrain))) then (( 52 :: int)::ii)
            else (( 48 :: int)::ii)
          else (( 48 :: int)::ii)) in
        (let (outputsize :: ii) =
          (if ((((ex_int outputsize)) > ((ex_int ((PAMax () )))))) then PAMax () 
          else outputsize) in
        and_boolM (return ((((ex_int outputsize)) < (( 48 :: int)::ii))))
          (liftR (IsZero_slice baseregister outputsize
                    ((((- ((ex_int outputsize)))) + (( 48 :: int)::ii)))) \<bind> (\<lambda> (w__137 ::
             bool) . 
           return ((\<not> w__137)))) \<bind> (\<lambda> (w__138 :: bool) . 
        if w__138 then
          (let level = ((( 0 :: int)::ii)) in
          (let (tmp_200 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
          liftR (AArch64_AddressSizeFault ipaddress level acctype iswrite secondstage s2fs1walk) \<bind> (\<lambda> (w__139 ::
            FaultRecord) . 
          (let (tmp_200 :: AddressDescriptor) = ((tmp_200 (| AddressDescriptor_fault := w__139 |))) in
          (let (result :: TLBRecord) = ((result (| TLBRecord_addrdesc := tmp_200 |))) in
          return result)))))
        else
          (let baselowerbound =
            ((((( 3 :: int)::ii) + ((ex_int inputsize)))) -
              (((((((( 3 :: int)::ii) - ((ex_int level)))) * ((ex_int stride))))
                  +
                  ((ex_int grainsize))))) in
          (liftR (assert_exp True ('''')) \<then>
          liftR ((undefined_bitvector (( 52 :: int)::ii)  :: ( 52 Word.word) M))) \<bind> (\<lambda> (baseaddress :: 52 bits) . 
          (if (((((ex_int outputsize)) = (( 52 :: int)::ii)))) then
             (let z = (if ((baselowerbound < (( 6 :: int)::ii))) then (( 6 :: int)::ii) else baselowerbound) in
             liftR (assert_exp True ('''')) \<then>
             ((let (baseaddress :: 52 bits) =
               ((concat_vec ((slice baseregister (( 2 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
                  ((slice_zeros_concat ((((((- z)) + (( 48 :: int)::ii))) + z))
                      baseregister z ((((- z)) + (( 48 :: int)::ii))) z
                     ::  48 Word.word))
                 ::  52 Word.word)) in
             return baseaddress)))
           else
             (let (baseaddress :: 52 bits) =
               ((place_slice (( 52 :: int)::ii) baseregister baselowerbound
                  ((((- baselowerbound)) + (( 48 :: int)::ii))) baselowerbound
                 ::  52 Word.word)) in
             return baseaddress)) \<bind> (\<lambda> (baseaddress :: 52 bits) . 
          (let (ns_table :: 1 bits) =
            (if lookupsecure then (vec_of_bits [B0]  ::  1 Word.word)
            else (vec_of_bits [B1]  ::  1 Word.word)) in
          (let (ap_table :: 2 bits) = ((vec_of_bits [B0,B0]  ::  2 Word.word)) in
          (let (xn_table :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
          (let (pxn_table :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
          (let (addrselecttop :: ii) = (((ex_int inputsize)) - (( 1 :: int)::ii)) in
          and_boolM
            (and_boolM (return (((((HaveNVExt () )) \<and> ((HaveEL EL2))))))
               (liftR ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__140 :: 64 bits) . 
                return ((((vec_of_bits [access_vec_dec w__140 (( 42 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
            (liftR ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__142 :: 64 bits) . 
             return ((((vec_of_bits [access_vec_dec w__142 (( 43 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (apply_nvnv1_effect :: bool) . 
          liftR (undefined_bool () ) \<bind> (\<lambda> (blocktranslate :: bool) . 
          liftR ((undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (desc :: 64 bits) . 
          liftR (undefined_AccessDescriptor () ) \<bind> (\<lambda> (accdesc :: AccessDescriptor) . 
          liftR (undefined_bool () ) \<bind> (\<lambda> (hwupdatewalk :: bool) . 
          liftR (undefined_AddressDescriptor () ) \<bind> (\<lambda> (descaddr2 :: AddressDescriptor) . 
          liftR (undefined_int () ) \<bind> (\<lambda> (addrselectbottom :: ii) . 
          (untilM (accdesc,
                   addrselectbottom,
                   addrselecttop,
                   ap_table,
                   baseaddress,
                   blocktranslate,
                   desc,
                   descaddr,
                   descaddr2,
                   hwupdatewalk,
                   level,
                   ns_table,
                   pxn_table,
                   result,
                   xn_table)
            (\<lambda> varstup . 
            (let (accdesc,
                 addrselectbottom,
                 addrselecttop,
                 ap_table,
                 baseaddress,
                 blocktranslate,
                 desc,
                 descaddr,
                 descaddr2,
                 hwupdatewalk,
                 level,
                 ns_table,
                 pxn_table,
                 result,
                 xn_table) = varstup in
              return blocktranslate))
            (\<lambda> varstup . 
            (let (accdesc,
                 addrselectbottom,
                 addrselecttop,
                 ap_table,
                 baseaddress,
                 blocktranslate,
                 desc,
                 descaddr,
                 descaddr2,
                 hwupdatewalk,
                 level,
                 ns_table,
                 pxn_table,
                 result,
                 xn_table) = varstup in
              (let addrselectbottom =
                ((((((( 3 :: int)::ii) - ((ex_int level)))) * ((ex_int stride))))
                  +
                  ((ex_int grainsize))) in
              liftR ((ZeroExtend_slice_append (( 52 :: int)::ii) inputaddr addrselectbottom
                        ((((((ex_int addrselecttop)) - ((ex_int addrselectbottom))))
                            +
                            (( 1 :: int)::ii))) (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                       :: ( 52 Word.word) M)) \<bind> (\<lambda> (index1 :: 52 bits) . 
              (let (tmp_210 :: FullAddress) = ((AddressDescriptor_paddress   descaddr)) in
              (let tmp_210 =
                ((tmp_210 (|
                  FullAddress_physicaladdress := ((or_vec baseaddress index1  ::  52 Word.word))|))) in
              (let descaddr = ((descaddr (| AddressDescriptor_paddress := tmp_210 |))) in
              (let (tmp_220 :: FullAddress) = ((AddressDescriptor_paddress   descaddr)) in
              (let tmp_220 = ((tmp_220 (| FullAddress_NS := ns_table |))) in
              (let descaddr = ((descaddr (| AddressDescriptor_paddress := tmp_220 |))) in
              or_boolM (return secondstage)
                (liftR (HasS2Translation () ) \<bind> (\<lambda> (w__143 :: bool) .  return ((\<not> w__143)))) \<bind> (\<lambda> (w__144 ::
                bool) . 
              (if w__144 then
                 (let (descaddr2 :: AddressDescriptor) = descaddr in
                 return (descaddr2, hwupdatewalk, result))
               else
                 (let hwupdatewalk = False in
                 liftR (AArch64_SecondStageWalk descaddr vaddress acctype iswrite (( 8 :: int)::ii)
                          hwupdatewalk) \<bind> (\<lambda> (w__145 :: AddressDescriptor) . 
                 (let descaddr2 = w__145 in
                 (if ((IsFault descaddr2)) then
                    (let (tmp_230 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
                    (let tmp_230 =
                      ((tmp_230 (| AddressDescriptor_fault := ((AddressDescriptor_fault   descaddr2))|))) in
                    (let result = ((result (| TLBRecord_addrdesc := tmp_230 |))) in
                    (early_return result :: (unit, TLBRecord) MR) \<then> return result)))
                  else return result) \<bind> (\<lambda> (result :: TLBRecord) . 
                 return (descaddr2, hwupdatewalk, result)))))) \<bind> (\<lambda> varstup .  (let ((descaddr2 ::
                AddressDescriptor), (hwupdatewalk :: bool), (result :: TLBRecord)) = varstup in
              liftR ((ZeroExtend__1 (( 64 :: int)::ii) vaddress  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__146 ::
                 64 Word.word) . 
              (let descaddr2 = ((descaddr2 (| AddressDescriptor_vaddress := w__146 |))) in
              liftR (CreateAccessDescriptorPTW acctype secondstage s2fs1walk level) \<bind> (\<lambda> (w__147 ::
                AccessDescriptor) . 
              (let accdesc = w__147 in
              liftR ((aget__Mem descaddr2 (( 8 :: int)::ii) accdesc  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__148 ::
                 64 Word.word) . 
              (let desc = w__148 in
              (if reversedescriptors then liftR ((BigEndianReverse desc  :: ( 64 Word.word) M))
               else return desc) \<bind> (\<lambda> (desc :: 64 bits) . 
              (if (((((((vec_of_bits [access_vec_dec desc (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> ((((((((slice desc (( 0 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((((ex_int level)) = (( 3 :: int)::ii))))))))))
               then
                 (let (tmp_240 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
                 liftR (AArch64_TranslationFault ipaddress level acctype iswrite secondstage
                          s2fs1walk) \<bind> (\<lambda> (w__150 :: FaultRecord) . 
                 (let tmp_240 = ((tmp_240 (| AddressDescriptor_fault := w__150 |))) in
                 (let result = ((result (| TLBRecord_addrdesc := tmp_240 |))) in
                 (early_return result :: (unit, TLBRecord) MR) \<then>
                 return (addrselecttop,
                         ap_table,
                         baseaddress,
                         blocktranslate,
                         level,
                         ns_table,
                         pxn_table,
                         result,
                         xn_table)))))
               else if ((((((((slice desc (( 0 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<or> (((((ex_int level)) = (( 3 :: int)::ii)))))))
               then
                 (let (blocktranslate :: bool) = True in
                 return (addrselecttop,
                         ap_table,
                         baseaddress,
                         blocktranslate,
                         level,
                         ns_table,
                         pxn_table,
                         result,
                         xn_table))
               else
                 or_boolM
                   (return ((((((((((ex_int outputsize)) < (( 52 :: int)::ii))) \<and> largegrain))) \<and> ((\<not> ((IsZero ((slice desc (( 12 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))))))))))
                   (and_boolM (return ((((ex_int outputsize)) < (( 48 :: int)::ii))))
                      (liftR (IsZero_slice desc outputsize
                                ((((- ((ex_int outputsize)))) + (( 48 :: int)::ii)))) \<bind> (\<lambda> (w__151 ::
                         bool) . 
                       return ((\<not> w__151))))) \<bind> (\<lambda> (w__153 :: bool) . 
                 if w__153 then
                   (let (tmp_250 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
                   liftR (AArch64_AddressSizeFault ipaddress level acctype iswrite secondstage
                            s2fs1walk) \<bind> (\<lambda> (w__154 :: FaultRecord) . 
                   (let tmp_250 = ((tmp_250 (| AddressDescriptor_fault := w__154 |))) in
                   (let result = ((result (| TLBRecord_addrdesc := tmp_250 |))) in
                   (early_return result :: (unit, TLBRecord) MR) \<then>
                   return (addrselecttop,
                           ap_table,
                           baseaddress,
                           blocktranslate,
                           level,
                           ns_table,
                           pxn_table,
                           result,
                           xn_table)))))
                 else
                   (let gsz = grainsize in
                   liftR (assert_exp True ('''')) \<then>
                   ((let (baseaddress :: 52 bits) =
                     (if (((((ex_int outputsize)) = (( 52 :: int)::ii)))) then
                       (concat_vec ((slice desc (( 12 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
                          ((slice_zeros_concat
                              ((((((- gsz)) + (( 48 :: int)::ii))) + gsz)) desc
                              gsz ((((- gsz)) + (( 48 :: int)::ii))) gsz
                             ::  48 Word.word))
                         ::  52 Word.word)
                     else
                       (place_slice (( 52 :: int)::ii) desc gsz ((((- gsz)) + (( 48 :: int)::ii)))
                          gsz
                         ::  52 Word.word)) in
                   (let (ns_table :: 1 bits) =
                     (if ((\<not> secondstage)) then
                       (or_vec ns_table (vec_of_bits [access_vec_dec desc (( 63 :: int)::ii)]  ::  1 Word.word)
                         ::  1 Word.word)
                     else ns_table) in
                   (let ((ap_table :: 2 bits), (pxn_table :: 1 bits), (xn_table :: 1 bits)) =
                     (if (((((\<not> secondstage)) \<and> ((\<not> hierattrsdisabled))))) then
                       (let (ap_table :: 2 bits) =
                         ((set_slice (( 2 :: int)::ii) (( 1 :: int)::ii) ap_table (( 1 :: int)::ii)
                            ((or_vec (vec_of_bits [access_vec_dec ap_table (( 1 :: int)::ii)]  ::  1 Word.word)
                                (vec_of_bits [access_vec_dec desc (( 62 :: int)::ii)]  ::  1 Word.word)
                               ::  1 Word.word))
                           ::  2 Word.word)) in
                       (let ((pxn_table :: 1 bits), (xn_table :: 1 bits)) =
                         (if apply_nvnv1_effect then
                           (let (pxn_table :: 1 bits) =
                             ((or_vec pxn_table
                                (vec_of_bits [access_vec_dec desc (( 60 :: int)::ii)]  ::  1 Word.word)
                               ::  1 Word.word)) in
                           (pxn_table, xn_table))
                         else
                           (let (xn_table :: 1 bits) =
                             ((or_vec xn_table
                                (vec_of_bits [access_vec_dec desc (( 60 :: int)::ii)]  ::  1 Word.word)
                               ::  1 Word.word)) in
                           (pxn_table, xn_table))) in
                       (let ((ap_table :: 2 bits), (pxn_table :: 1 bits)) =
                         (if ((\<not> singlepriv)) then
                           (let ((ap_table :: 2 bits), (pxn_table :: 1 bits)) =
                             (if ((\<not> apply_nvnv1_effect)) then
                               (let (pxn_table :: 1 bits) =
                                 ((or_vec pxn_table
                                    (vec_of_bits [access_vec_dec desc (( 59 :: int)::ii)]  ::  1 Word.word)
                                   ::  1 Word.word)) in
                               (let (ap_table :: 2 bits) =
                                 ((set_slice (( 2 :: int)::ii) (( 1 :: int)::ii) ap_table (( 0 :: int)::ii)
                                    ((or_vec
                                        (vec_of_bits [access_vec_dec ap_table (( 0 :: int)::ii)]  ::  1 Word.word)
                                        (vec_of_bits [access_vec_dec desc (( 61 :: int)::ii)]  ::  1 Word.word)
                                       ::  1 Word.word))
                                   ::  2 Word.word)) in
                               (ap_table, pxn_table)))
                             else (ap_table, pxn_table)) in
                           (ap_table, pxn_table))
                         else (ap_table, pxn_table)) in
                       (ap_table, pxn_table, xn_table))))
                     else (ap_table, pxn_table, xn_table)) in
                   (let (level :: ii) = (((ex_int level)) + (( 1 :: int)::ii)) in
                   (let (addrselecttop :: ii) = (((ex_int addrselectbottom)) - (( 1 :: int)::ii)) in
                   (let (blocktranslate :: bool) = False in
                   return (addrselecttop,
                           ap_table,
                           baseaddress,
                           blocktranslate,
                           level,
                           ns_table,
                           pxn_table,
                           result,
                           xn_table))))))))))) \<bind> (\<lambda> varstup .  (let ((addrselecttop :: ii), (ap_table :: 2
                bits), (baseaddress :: 52 bits), (blocktranslate :: bool), (level :: ii), (ns_table :: 1
                bits), (pxn_table :: 1 bits), (result :: TLBRecord), (xn_table :: 1 bits)) = varstup in
              return (accdesc,
                      addrselectbottom,
                      addrselecttop,
                      ap_table,
                      baseaddress,
                      blocktranslate,
                      desc,
                      descaddr,
                      descaddr2,
                      hwupdatewalk,
                      level,
                      ns_table,
                      pxn_table,
                      result,
                      xn_table)))))))))))))))))))))))) \<bind> (\<lambda> varstup .  (let ((accdesc :: AccessDescriptor), (addrselectbottom ::
            ii), (addrselecttop :: ii), (ap_table :: 2 bits), (baseaddress :: 52 bits), (blocktranslate ::
            bool), (desc :: 64 bits), (descaddr :: AddressDescriptor), (descaddr2 ::
            AddressDescriptor), (hwupdatewalk :: bool), (level :: ii), (ns_table :: 1 bits), (pxn_table :: 1
            bits), (result :: TLBRecord), (xn_table :: 1 bits)) = varstup in
          if ((((ex_int level)) < ((ex_int firstblocklevel)))) then
            (let (tmp_260 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
            liftR (AArch64_TranslationFault ipaddress level acctype iswrite secondstage s2fs1walk) \<bind> (\<lambda> (w__155 ::
              FaultRecord) . 
            (let (tmp_260 :: AddressDescriptor) = ((tmp_260 (| AddressDescriptor_fault := w__155 |))) in
            (let (result :: TLBRecord) = ((result (| TLBRecord_addrdesc := tmp_260 |))) in
            return result))))
          else
            liftR (undefined_bool () ) \<bind> (\<lambda> (contiguousbitcheck :: bool) . 
            (let (contiguousbitcheck :: bool) =
              (if largegrain then
                ((((((ex_int level)) = (( 2 :: int)::ii)))) \<and> ((((ex_int inputsize)) < (( 34 :: int)::ii))))
              else if midgrain then
                ((((((ex_int level)) = (( 2 :: int)::ii)))) \<and> ((((ex_int inputsize)) < (( 30 :: int)::ii))))
              else ((((((ex_int level)) = (( 1 :: int)::ii)))) \<and> ((((ex_int inputsize)) < (( 34 :: int)::ii))))) in
            (if (((contiguousbitcheck \<and> ((((vec_of_bits [access_vec_dec desc (( 52 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))) then
               liftR (undefined_bool () ) \<bind> (\<lambda> (w__156 :: bool) . 
               if w__156 then
                 (let (tmp_270 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
                 liftR (AArch64_TranslationFault ipaddress level acctype iswrite secondstage
                          s2fs1walk) \<bind> (\<lambda> (w__157 :: FaultRecord) . 
                 (let tmp_270 = ((tmp_270 (| AddressDescriptor_fault := w__157 |))) in
                 (let result = ((result (| TLBRecord_addrdesc := tmp_270 |))) in
                 (early_return result :: (unit, TLBRecord) MR) \<then> return result))))
               else return result)
             else return result) \<bind> (\<lambda> (result :: TLBRecord) . 
            or_boolM
              (return ((((((((((ex_int outputsize)) < (( 52 :: int)::ii))) \<and> largegrain))) \<and> ((\<not> ((IsZero ((slice desc (( 12 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))))))))))
              (and_boolM (return ((((ex_int outputsize)) < (( 48 :: int)::ii))))
                 (liftR (IsZero_slice desc outputsize
                           ((((- ((ex_int outputsize)))) + (( 48 :: int)::ii)))) \<bind> (\<lambda> (w__158 ::
                    bool) . 
                  return ((\<not> w__158))))) \<bind> (\<lambda> (w__160 :: bool) . 
            if w__160 then
              (let (tmp_280 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
              liftR (AArch64_AddressSizeFault ipaddress level acctype iswrite secondstage s2fs1walk) \<bind> (\<lambda> (w__161 ::
                FaultRecord) . 
              (let (tmp_280 :: AddressDescriptor) =
                ((tmp_280 (| AddressDescriptor_fault := w__161 |))) in
              (let (result :: TLBRecord) = ((result (| TLBRecord_addrdesc := tmp_280 |))) in
              return result))))
            else
              liftR ((undefined_bitvector (( 52 :: int)::ii)  :: ( 52 Word.word) M)) \<bind> (\<lambda> (outputaddress :: 52
                bits) . 
              (let asb = addrselectbottom in
              liftR (assert_exp True ('''')) \<then>
              ((let (outputaddress :: 52 bits) =
                (if (((((ex_int outputsize)) = (( 52 :: int)::ii)))) then
                  (concat_vec ((slice desc (( 12 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
                     ((slice_slice_concat (( 48 :: int)::ii) desc asb
                         ((((- asb)) + (( 48 :: int)::ii))) inputaddr (( 0 :: int)::ii) asb
                        ::  48 Word.word))
                    ::  52 Word.word)
                else
                  (slice_slice_concat (( 52 :: int)::ii) desc asb ((((- asb)) + (( 48 :: int)::ii)))
                     inputaddr (( 0 :: int)::ii) asb
                    ::  52 Word.word)) in
              (let (tmp_330 :: DescriptorUpdate) = ((TLBRecord_descupdate   result)) in
              (let tmp_330 = ((tmp_330 (| DescriptorUpdate_AF := False |))) in
              (let tmp_330 = ((tmp_330 (| DescriptorUpdate_AP := False |))) in
              (let tmp_330 = ((tmp_330 (| DescriptorUpdate_descaddr := descaddr |))) in
              (let result = ((result (| TLBRecord_descupdate := tmp_330 |))) in
              (if ((((vec_of_bits [access_vec_dec desc (( 10 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))) then
                 if ((\<not> update_AF)) then
                   (let (tmp_290 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
                   liftR (AArch64_AccessFlagFault ipaddress level acctype iswrite secondstage
                            s2fs1walk) \<bind> (\<lambda> (w__162 :: FaultRecord) . 
                   (let tmp_290 = ((tmp_290 (| AddressDescriptor_fault := w__162 |))) in
                   (let result = ((result (| TLBRecord_addrdesc := tmp_290 |))) in
                   (early_return result :: (unit, TLBRecord) MR) \<then> return result))))
                 else
                   (let (tmp_300 :: DescriptorUpdate) = ((TLBRecord_descupdate   result)) in
                   (let (tmp_300 :: DescriptorUpdate) = ((tmp_300 (| DescriptorUpdate_AF := True |))) in
                   (let (result :: TLBRecord) = ((result (| TLBRecord_descupdate := tmp_300 |))) in
                   return result)))
               else return result) \<bind> (\<lambda> (result :: TLBRecord) . 
              (let ((desc :: 64 bits), (result :: TLBRecord)) =
                (if (((update_AP \<and> ((((vec_of_bits [access_vec_dec desc (( 51 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))) then
                  (let ((desc :: 64 bits), (result :: TLBRecord)) =
                    (if (((((\<not> secondstage)) \<and> ((((vec_of_bits [access_vec_dec desc (( 7 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))) then
                      (let (desc :: 64 bits) =
                        ((set_slice (( 64 :: int)::ii) (( 1 :: int)::ii) desc (( 7 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)
                          ::  64 Word.word)) in
                      (let (tmp_310 :: DescriptorUpdate) = ((TLBRecord_descupdate   result)) in
                      (let (tmp_310 :: DescriptorUpdate) =
                        ((tmp_310 (| DescriptorUpdate_AP := True |))) in
                      (let (result :: TLBRecord) = ((result (| TLBRecord_descupdate := tmp_310 |))) in
                      (desc, result)))))
                    else
                      (let ((desc :: 64 bits), (result :: TLBRecord)) =
                        (if (((secondstage \<and> ((((vec_of_bits [access_vec_dec desc (( 7 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))) then
                          (let (desc :: 64 bits) =
                            ((set_slice (( 64 :: int)::ii) (( 1 :: int)::ii) desc (( 7 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)
                              ::  64 Word.word)) in
                          (let (tmp_320 :: DescriptorUpdate) = ((TLBRecord_descupdate   result)) in
                          (let (tmp_320 :: DescriptorUpdate) =
                            ((tmp_320 (| DescriptorUpdate_AP := True |))) in
                          (let (result :: TLBRecord) = ((result (| TLBRecord_descupdate := tmp_320 |))) in
                          (desc, result)))))
                        else (desc, result)) in
                      (desc, result))) in
                  (desc, result))
                else (desc, result)) in
              liftR ((undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> (\<lambda> (xn :: 1 bits) . 
              liftR ((undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> (\<lambda> (pxn :: 1 bits) . 
              (let ((pxn :: 1 bits), (xn :: 1 bits)) =
                (if apply_nvnv1_effect then
                  (let (pxn :: 1 bits) = ((vec_of_bits [access_vec_dec desc (( 54 :: int)::ii)]  ::  1 Word.word)) in
                  (let (xn :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
                  (pxn, xn)))
                else
                  (let (xn :: 1 bits) = ((vec_of_bits [access_vec_dec desc (( 54 :: int)::ii)]  ::  1 Word.word)) in
                  (let (pxn :: 1 bits) = ((vec_of_bits [access_vec_dec desc (( 53 :: int)::ii)]  ::  1 Word.word)) in
                  (pxn, xn)))) in
              (let (contiguousbit :: 1 bits) =
                ((vec_of_bits [access_vec_dec desc (( 52 :: int)::ii)]  ::  1 Word.word)) in
              (let (nG :: 1 bits) = ((vec_of_bits [access_vec_dec desc (( 11 :: int)::ii)]  ::  1 Word.word)) in
              (let (sh :: 2 bits) = ((slice desc (( 8 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) in
              liftR ((undefined_bitvector (( 3 :: int)::ii)  :: ( 3 Word.word) M)) \<bind> (\<lambda> (ap :: 3 bits) . 
              (let (ap :: 3 bits) =
                (if apply_nvnv1_effect then
                  (concat_vec (vec_of_bits [access_vec_dec desc (( 7 :: int)::ii)]  ::  1 Word.word)
                     (vec_of_bits [B0,B1]  ::  2 Word.word)
                    ::  3 Word.word)
                else
                  (concat_vec ((slice desc (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))
                     (vec_of_bits [B1]  ::  1 Word.word)
                    ::  3 Word.word)) in
              (let (memattr :: 4 bits) = ((slice desc (( 2 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) in
              liftR ((undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M)) \<bind> (\<lambda> (w__163 ::  4 Word.word) . 
              (let result = ((result (| TLBRecord_domain := w__163 |))) in
              (let result = ((result (| TLBRecord_level := level |))) in
              (let result =
                ((result (|
                  TLBRecord_blocksize :=
                    ((pow2
                        (((((((( 3 :: int)::ii) - ((ex_int level)))) * ((ex_int stride))))
                            +
                            ((ex_int grainsize))))))|))) in
              (if ((\<not> secondstage)) then
                 (let (tmp_340 :: Permissions) = ((TLBRecord_perms   result)) in
                 (let tmp_340 =
                   ((tmp_340 (| Permissions_xn := ((or_vec xn xn_table  ::  1 Word.word))|))) in
                 (let result = ((result (| TLBRecord_perms := tmp_340 |))) in
                 (let (tmp_350 :: 3 bits) = ((Permissions_ap  (TLBRecord_perms   result))) in
                 (let tmp_350 =
                   ((set_slice (( 3 :: int)::ii) (( 1 :: int)::ii) tmp_350 (( 2 :: int)::ii)
                      ((or_vec (vec_of_bits [access_vec_dec ap (( 2 :: int)::ii)]  ::  1 Word.word)
                          (vec_of_bits [access_vec_dec ap_table (( 1 :: int)::ii)]  ::  1 Word.word)
                         ::  1 Word.word))
                     ::  3 Word.word)) in
                 (let (tmp_360 :: Permissions) = ((TLBRecord_perms   result)) in
                 (let tmp_360 = ((tmp_360 (| Permissions_ap := tmp_350 |))) in
                 (let result = ((result (| TLBRecord_perms := tmp_360 |))) in
                 (if ((\<not> singlepriv)) then
                    (let (tmp_370 :: 3 bits) = ((Permissions_ap  (TLBRecord_perms   result))) in
                    (let tmp_370 =
                      ((set_slice (( 3 :: int)::ii) (( 1 :: int)::ii) tmp_370 (( 1 :: int)::ii)
                         ((and_vec (vec_of_bits [access_vec_dec ap (( 1 :: int)::ii)]  ::  1 Word.word)
                             ((not_vec (vec_of_bits [access_vec_dec ap_table (( 0 :: int)::ii)]  ::  1 Word.word)
                                ::  1 Word.word))
                            ::  1 Word.word))
                        ::  3 Word.word)) in
                    (let (tmp_380 :: Permissions) = ((TLBRecord_perms   result)) in
                    (let tmp_380 = ((tmp_380 (| Permissions_ap := tmp_370 |))) in
                    (let result = ((result (| TLBRecord_perms := tmp_380 |))) in
                    (let (tmp_390 :: Permissions) = ((TLBRecord_perms   result)) in
                    (let tmp_390 =
                      ((tmp_390 (| Permissions_pxn := ((or_vec pxn pxn_table  ::  1 Word.word))|))) in
                    (let result = ((result (| TLBRecord_perms := tmp_390 |))) in
                    liftR (IsSecure () ) \<bind> (\<lambda> (w__164 :: bool) . 
                    (let (result :: TLBRecord) =
                      (if w__164 then
                        (result (| TLBRecord_nG := ((or_vec nG ns_table  ::  1 Word.word))|))
                      else (result (| TLBRecord_nG := nG |))) in
                    return result))))))))))
                  else
                    (let (tmp_400 :: 3 bits) = ((Permissions_ap  (TLBRecord_perms   result))) in
                    (let (tmp_400 :: 3 bits) =
                      ((set_slice (( 3 :: int)::ii) (( 1 :: int)::ii) tmp_400 (( 1 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)
                        ::  3 Word.word)) in
                    (let (tmp_410 :: Permissions) = ((TLBRecord_perms   result)) in
                    (let (tmp_410 :: Permissions) = ((tmp_410 (| Permissions_ap := tmp_400 |))) in
                    (let (result :: TLBRecord) = ((result (| TLBRecord_perms := tmp_410 |))) in
                    (let (tmp_420 :: Permissions) = ((TLBRecord_perms   result)) in
                    (let (tmp_420 :: Permissions) =
                      ((tmp_420 (| Permissions_pxn := ((vec_of_bits [B0]  ::  1 Word.word))|))) in
                    (let (result :: TLBRecord) = ((result (| TLBRecord_perms := tmp_420 |))) in
                    (let (result :: TLBRecord) =
                      ((result (| TLBRecord_nG := ((vec_of_bits [B0]  ::  1 Word.word))|))) in
                    return result)))))))))) \<bind> (\<lambda> (result :: TLBRecord) . 
                 (let (tmp_430 :: 3 bits) = ((Permissions_ap  (TLBRecord_perms   result))) in
                 (let tmp_430 =
                   ((set_slice (( 3 :: int)::ii) (( 1 :: int)::ii) tmp_430 (( 0 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)
                     ::  3 Word.word)) in
                 (let (tmp_440 :: Permissions) = ((TLBRecord_perms   result)) in
                 (let tmp_440 = ((tmp_440 (| Permissions_ap := tmp_430 |))) in
                 (let result = ((result (| TLBRecord_perms := tmp_440 |))) in
                 (let (tmp_450 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
                 liftR (AArch64_S1AttrDecode sh ((slice memattr (( 0 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) acctype) \<bind> (\<lambda> (w__165 ::
                   MemoryAttributes) . 
                 (let (tmp_450 :: AddressDescriptor) =
                   ((tmp_450 (| AddressDescriptor_memattrs := w__165 |))) in
                 (let (result :: TLBRecord) = ((result (| TLBRecord_addrdesc := tmp_450 |))) in
                 (let (tmp_460 :: FullAddress) = ((AddressDescriptor_paddress  (TLBRecord_addrdesc   result))) in
                 (let (tmp_460 :: FullAddress) =
                   ((tmp_460 (|
                     FullAddress_NS :=
                       ((or_vec (vec_of_bits [access_vec_dec memattr (( 3 :: int)::ii)]  ::  1 Word.word) ns_table
                          ::  1 Word.word))|))) in
                 (let (tmp_470 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
                 (let (tmp_470 :: AddressDescriptor) =
                   ((tmp_470 (| AddressDescriptor_paddress := tmp_460 |))) in
                 (let (result :: TLBRecord) = ((result (| TLBRecord_addrdesc := tmp_470 |))) in
                 return result)))))))))))))))))))))))
               else
                 (let (tmp_480 :: 3 bits) = ((Permissions_ap  (TLBRecord_perms   result))) in
                 (let tmp_480 =
                   ((set_slice (( 3 :: int)::ii) (( 2 :: int)::ii) tmp_480 (( 1 :: int)::ii) ((slice ap (( 1 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))
                     ::  3 Word.word)) in
                 (let (tmp_490 :: Permissions) = ((TLBRecord_perms   result)) in
                 (let tmp_490 = ((tmp_490 (| Permissions_ap := tmp_480 |))) in
                 (let result = ((result (| TLBRecord_perms := tmp_490 |))) in
                 (let (tmp_500 :: 3 bits) = ((Permissions_ap  (TLBRecord_perms   result))) in
                 (let tmp_500 =
                   ((set_slice (( 3 :: int)::ii) (( 1 :: int)::ii) tmp_500 (( 0 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)
                     ::  3 Word.word)) in
                 (let (tmp_510 :: Permissions) = ((TLBRecord_perms   result)) in
                 (let tmp_510 = ((tmp_510 (| Permissions_ap := tmp_500 |))) in
                 (let result = ((result (| TLBRecord_perms := tmp_510 |))) in
                 (let (tmp_520 :: Permissions) = ((TLBRecord_perms   result)) in
                 (let tmp_520 = ((tmp_520 (| Permissions_xn := xn |))) in
                 (let result = ((result (| TLBRecord_perms := tmp_520 |))) in
                 (let (result :: TLBRecord) =
                   (if ((HaveExtendedExecuteNeverExt () )) then
                     (let (tmp_530 :: Permissions) = ((TLBRecord_perms   result)) in
                     (let (tmp_530 :: Permissions) =
                       ((tmp_530 (|
                         Permissions_xxn := ((vec_of_bits [access_vec_dec desc (( 53 :: int)::ii)]  ::  1 Word.word))|))) in
                     (result (| TLBRecord_perms := tmp_530 |))))
                   else result) in
                 (let (tmp_540 :: Permissions) = ((TLBRecord_perms   result)) in
                 (let tmp_540 = ((tmp_540 (| Permissions_pxn := ((vec_of_bits [B0]  ::  1 Word.word))|))) in
                 (let result = ((result (| TLBRecord_perms := tmp_540 |))) in
                 (let result = ((result (| TLBRecord_nG := ((vec_of_bits [B0]  ::  1 Word.word))|))) in
                 (let (tmp_550 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
                 liftR (S2AttrDecode sh memattr acctype) \<bind> (\<lambda> (w__166 :: MemoryAttributes) . 
                 (let (tmp_550 :: AddressDescriptor) =
                   ((tmp_550 (| AddressDescriptor_memattrs := w__166 |))) in
                 (let (result :: TLBRecord) = ((result (| TLBRecord_addrdesc := tmp_550 |))) in
                 (let (tmp_560 :: FullAddress) = ((AddressDescriptor_paddress  (TLBRecord_addrdesc   result))) in
                 (let (tmp_560 :: FullAddress) =
                   ((tmp_560 (| FullAddress_NS := ((vec_of_bits [B1]  ::  1 Word.word))|))) in
                 (let (tmp_570 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
                 (let (tmp_570 :: AddressDescriptor) =
                   ((tmp_570 (| AddressDescriptor_paddress := tmp_560 |))) in
                 (let (result :: TLBRecord) = ((result (| TLBRecord_addrdesc := tmp_570 |))) in
                 return result)))))))))))))))))))))))))))) \<bind> (\<lambda> (result :: TLBRecord) . 
              (let (tmp_580 :: FullAddress) = ((AddressDescriptor_paddress  (TLBRecord_addrdesc   result))) in
              (let tmp_580 = ((tmp_580 (| FullAddress_physicaladdress := outputaddress |))) in
              (let (tmp_590 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
              (let tmp_590 = ((tmp_590 (| AddressDescriptor_paddress := tmp_580 |))) in
              (let result = ((result (| TLBRecord_addrdesc := tmp_590 |))) in
              (let (tmp_600 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
              liftR (AArch64_NoFault () ) \<bind> (\<lambda> (w__167 :: FaultRecord) . 
              (let (tmp_600 :: AddressDescriptor) =
                ((tmp_600 (| AddressDescriptor_fault := w__167 |))) in
              (let (result :: TLBRecord) = ((result (| TLBRecord_addrdesc := tmp_600 |))) in
              (let (result :: TLBRecord) =
                ((result (|
                  TLBRecord_contiguous := (((contiguousbit = (vec_of_bits [B1]  ::  1 Word.word))))|))) in
              (let (result :: TLBRecord) =
                (if ((HaveCommonNotPrivateTransExt () )) then
                  (result (|
                    TLBRecord_CnP := ((vec_of_bits [access_vec_dec baseregister (( 0 :: int)::ii)]  ::  1 Word.word))|))
                else result) in
              return result)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))"


(*val IsZero_slice2 : forall 'n . Size 'n => mword 'n -> ii -> ii -> M bool*)

definition IsZero_slice2  :: "('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " IsZero_slice2 xs i l = (
   assert_exp True ('''') \<then>
   return ((IsZero ((and_vec xs ((slice_mask ((int (size xs))) i l  :: ( 'n::len)Word.word))  :: ( 'n::len)Word.word)))))"


(*val AArch64_TranslateAddressS1Off : mword ty64 -> AccType -> bool -> M TLBRecord*)

definition AArch64_TranslateAddressS1Off  :: "(64)Word.word \<Rightarrow> AccType \<Rightarrow> bool \<Rightarrow>((register_value),(TLBRecord),(exception))monad "  where 
     " AArch64_TranslateAddressS1Off vaddress acctype iswrite = (
   (S1TranslationRegime__1 ()   :: ( 2 Word.word) M) \<bind> (\<lambda> (w__0 ::  2 Word.word) . 
   ELUsingAArch32 w__0 \<bind> (\<lambda> (w__1 :: bool) . 
   (assert_exp ((\<not> w__1)) ('''') \<then>
   undefined_TLBRecord () ) \<bind> (\<lambda> (result :: TLBRecord) . 
   read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) . 
   AddrTop vaddress False(ProcState_EL   w__2) \<bind> (\<lambda> (Top :: ii) . 
   undefined_bool ()  \<bind> (\<lambda> (s2fs1walk :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (secondstage :: bool) . 
   (undefined_bitvector (( 52 :: int)::ii)  :: ( 52 Word.word) M) \<bind> (\<lambda> (ipaddress :: 52 bits) . 
   undefined_int ()  \<bind> (\<lambda> (level :: ii) . 
   IsZero_slice2 vaddress ((PAMax () ))
     ((((((ex_int Top)) + (( 1 :: int)::ii))) - ((ex_int ((PAMax () )))))) \<bind> (\<lambda> (w__3 ::
     bool) . 
   if ((\<not> w__3)) then
     (let level = ((( 0 :: int)::ii)) in
     (undefined_bitvector (( 52 :: int)::ii)  :: ( 52 Word.word) M) \<bind> (\<lambda> (w__4 ::  52 Word.word) . 
     (let ipaddress = w__4 in
     (let secondstage = False in
     (let s2fs1walk = False in
     (let (tmp_1980 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
     AArch64_AddressSizeFault ipaddress level acctype iswrite secondstage s2fs1walk \<bind> (\<lambda> (w__5 ::
       FaultRecord) . 
     (let (tmp_1980 :: AddressDescriptor) = ((tmp_1980 (| AddressDescriptor_fault := w__5 |))) in
     (let (result :: TLBRecord) = ((result (| TLBRecord_addrdesc := tmp_1980 |))) in
     return result)))))))))
   else
     and_boolM ((HasS2Translation () ))
       ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__7 :: 64 bits) . 
        return ((((vec_of_bits [access_vec_dec w__7 (( 12 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (default_cacheable :: bool) . 
     undefined_bool ()  \<bind> (\<lambda> (cacheable :: bool) . 
     (if default_cacheable then
        (let (tmp_1990 :: MemoryAttributes) = ((AddressDescriptor_memattrs  (TLBRecord_addrdesc   result))) in
        (let (tmp_1990 :: MemoryAttributes) =
          ((tmp_1990 (| MemoryAttributes_typ := MemType_Normal |))) in
        (let (tmp_2000 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
        (let (tmp_2000 :: AddressDescriptor) =
          ((tmp_2000 (| AddressDescriptor_memattrs := tmp_1990 |))) in
        (let (result :: TLBRecord) = ((result (| TLBRecord_addrdesc := tmp_2000 |))) in
        (let (tmp_2010 :: MemAttrHints) =
          ((MemoryAttributes_inner  (AddressDescriptor_memattrs  (TLBRecord_addrdesc   result)))) in
        (let (tmp_2010 :: MemAttrHints) = ((tmp_2010 (| MemAttrHints_attrs := MemAttr_WB |))) in
        (let (tmp_2020 :: MemoryAttributes) = ((AddressDescriptor_memattrs  (TLBRecord_addrdesc   result))) in
        (let (tmp_2020 :: MemoryAttributes) = ((tmp_2020 (| MemoryAttributes_inner := tmp_2010 |))) in
        (let (tmp_2030 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
        (let (tmp_2030 :: AddressDescriptor) =
          ((tmp_2030 (| AddressDescriptor_memattrs := tmp_2020 |))) in
        (let (result :: TLBRecord) = ((result (| TLBRecord_addrdesc := tmp_2030 |))) in
        (let (tmp_2040 :: MemAttrHints) =
          ((MemoryAttributes_inner  (AddressDescriptor_memattrs  (TLBRecord_addrdesc   result)))) in
        (let (tmp_2040 :: MemAttrHints) = ((tmp_2040 (| MemAttrHints_hints := MemHint_RWA |))) in
        (let (tmp_2050 :: MemoryAttributes) = ((AddressDescriptor_memattrs  (TLBRecord_addrdesc   result))) in
        (let (tmp_2050 :: MemoryAttributes) = ((tmp_2050 (| MemoryAttributes_inner := tmp_2040 |))) in
        (let (tmp_2060 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
        (let (tmp_2060 :: AddressDescriptor) =
          ((tmp_2060 (| AddressDescriptor_memattrs := tmp_2050 |))) in
        (let (result :: TLBRecord) = ((result (| TLBRecord_addrdesc := tmp_2060 |))) in
        (let (tmp_2070 :: MemoryAttributes) = ((AddressDescriptor_memattrs  (TLBRecord_addrdesc   result))) in
        (let (tmp_2070 :: MemoryAttributes) = ((tmp_2070 (| MemoryAttributes_shareable := False |))) in
        (let (tmp_2080 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
        (let (tmp_2080 :: AddressDescriptor) =
          ((tmp_2080 (| AddressDescriptor_memattrs := tmp_2070 |))) in
        (let (result :: TLBRecord) = ((result (| TLBRecord_addrdesc := tmp_2080 |))) in
        (let (tmp_2090 :: MemoryAttributes) = ((AddressDescriptor_memattrs  (TLBRecord_addrdesc   result))) in
        (let (tmp_2090 :: MemoryAttributes) =
          ((tmp_2090 (| MemoryAttributes_outershareable := False |))) in
        (let (tmp_2100 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
        (let (tmp_2100 :: AddressDescriptor) =
          ((tmp_2100 (| AddressDescriptor_memattrs := tmp_2090 |))) in
        (let (result :: TLBRecord) = ((result (| TLBRecord_addrdesc := tmp_2100 |))) in
        return result)))))))))))))))))))))))))))))
      else if (((acctype \<noteq> AccType_IFETCH))) then
        (let (tmp_2110 :: MemoryAttributes) = ((AddressDescriptor_memattrs  (TLBRecord_addrdesc   result))) in
        (let tmp_2110 = ((tmp_2110 (| MemoryAttributes_typ := MemType_Device |))) in
        (let (tmp_2120 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
        (let tmp_2120 = ((tmp_2120 (| AddressDescriptor_memattrs := tmp_2110 |))) in
        (let result = ((result (| TLBRecord_addrdesc := tmp_2120 |))) in
        (let (tmp_2130 :: MemoryAttributes) = ((AddressDescriptor_memattrs  (TLBRecord_addrdesc   result))) in
        (let tmp_2130 = ((tmp_2130 (| MemoryAttributes_device := DeviceType_nGnRnE |))) in
        (let (tmp_2140 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
        (let tmp_2140 = ((tmp_2140 (| AddressDescriptor_memattrs := tmp_2130 |))) in
        (let result = ((result (| TLBRecord_addrdesc := tmp_2140 |))) in
        (let (tmp_2150 :: MemoryAttributes) = ((AddressDescriptor_memattrs  (TLBRecord_addrdesc   result))) in
        undefined_MemAttrHints ()  \<bind> (\<lambda> (w__8 :: MemAttrHints) . 
        (let (tmp_2150 :: MemoryAttributes) = ((tmp_2150 (| MemoryAttributes_inner := w__8 |))) in
        (let (tmp_2160 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
        (let (tmp_2160 :: AddressDescriptor) =
          ((tmp_2160 (| AddressDescriptor_memattrs := tmp_2150 |))) in
        (let (result :: TLBRecord) = ((result (| TLBRecord_addrdesc := tmp_2160 |))) in
        return result))))))))))))))))
      else
        (aget_SCTLR__1 ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__9 ::  32 Word.word) . 
        (let (cacheable :: bool) =
          ((vec_of_bits [access_vec_dec w__9 (( 12 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
        (let (tmp_2170 :: MemoryAttributes) = ((AddressDescriptor_memattrs  (TLBRecord_addrdesc   result))) in
        (let (tmp_2170 :: MemoryAttributes) =
          ((tmp_2170 (| MemoryAttributes_typ := MemType_Normal |))) in
        (let (tmp_2180 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
        (let (tmp_2180 :: AddressDescriptor) =
          ((tmp_2180 (| AddressDescriptor_memattrs := tmp_2170 |))) in
        (let (result :: TLBRecord) = ((result (| TLBRecord_addrdesc := tmp_2180 |))) in
        (let (result :: TLBRecord) =
          (if cacheable then
            (let (tmp_2190 :: MemAttrHints) =
              ((MemoryAttributes_inner  (AddressDescriptor_memattrs  (TLBRecord_addrdesc   result)))) in
            (let (tmp_2190 :: MemAttrHints) = ((tmp_2190 (| MemAttrHints_attrs := MemAttr_WT |))) in
            (let (tmp_2200 :: MemoryAttributes) =
              ((AddressDescriptor_memattrs  (TLBRecord_addrdesc   result))) in
            (let (tmp_2200 :: MemoryAttributes) =
              ((tmp_2200 (| MemoryAttributes_inner := tmp_2190 |))) in
            (let (tmp_2210 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
            (let (tmp_2210 :: AddressDescriptor) =
              ((tmp_2210 (| AddressDescriptor_memattrs := tmp_2200 |))) in
            (let (result :: TLBRecord) = ((result (| TLBRecord_addrdesc := tmp_2210 |))) in
            (let (tmp_2220 :: MemAttrHints) =
              ((MemoryAttributes_inner  (AddressDescriptor_memattrs  (TLBRecord_addrdesc   result)))) in
            (let (tmp_2220 :: MemAttrHints) = ((tmp_2220 (| MemAttrHints_hints := MemHint_RA |))) in
            (let (tmp_2230 :: MemoryAttributes) =
              ((AddressDescriptor_memattrs  (TLBRecord_addrdesc   result))) in
            (let (tmp_2230 :: MemoryAttributes) =
              ((tmp_2230 (| MemoryAttributes_inner := tmp_2220 |))) in
            (let (tmp_2240 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
            (let (tmp_2240 :: AddressDescriptor) =
              ((tmp_2240 (| AddressDescriptor_memattrs := tmp_2230 |))) in
            (result (| TLBRecord_addrdesc := tmp_2240 |)))))))))))))))
          else
            (let (tmp_2250 :: MemAttrHints) =
              ((MemoryAttributes_inner  (AddressDescriptor_memattrs  (TLBRecord_addrdesc   result)))) in
            (let (tmp_2250 :: MemAttrHints) = ((tmp_2250 (| MemAttrHints_attrs := MemAttr_NC |))) in
            (let (tmp_2260 :: MemoryAttributes) =
              ((AddressDescriptor_memattrs  (TLBRecord_addrdesc   result))) in
            (let (tmp_2260 :: MemoryAttributes) =
              ((tmp_2260 (| MemoryAttributes_inner := tmp_2250 |))) in
            (let (tmp_2270 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
            (let (tmp_2270 :: AddressDescriptor) =
              ((tmp_2270 (| AddressDescriptor_memattrs := tmp_2260 |))) in
            (let (result :: TLBRecord) = ((result (| TLBRecord_addrdesc := tmp_2270 |))) in
            (let (tmp_2280 :: MemAttrHints) =
              ((MemoryAttributes_inner  (AddressDescriptor_memattrs  (TLBRecord_addrdesc   result)))) in
            (let (tmp_2280 :: MemAttrHints) = ((tmp_2280 (| MemAttrHints_hints := MemHint_No |))) in
            (let (tmp_2290 :: MemoryAttributes) =
              ((AddressDescriptor_memattrs  (TLBRecord_addrdesc   result))) in
            (let (tmp_2290 :: MemoryAttributes) =
              ((tmp_2290 (| MemoryAttributes_inner := tmp_2280 |))) in
            (let (tmp_2300 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
            (let (tmp_2300 :: AddressDescriptor) =
              ((tmp_2300 (| AddressDescriptor_memattrs := tmp_2290 |))) in
            (result (| TLBRecord_addrdesc := tmp_2300 |)))))))))))))))) in
        (let (tmp_2310 :: MemoryAttributes) = ((AddressDescriptor_memattrs  (TLBRecord_addrdesc   result))) in
        (let (tmp_2310 :: MemoryAttributes) = ((tmp_2310 (| MemoryAttributes_shareable := True |))) in
        (let (tmp_2320 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
        (let (tmp_2320 :: AddressDescriptor) =
          ((tmp_2320 (| AddressDescriptor_memattrs := tmp_2310 |))) in
        (let (result :: TLBRecord) = ((result (| TLBRecord_addrdesc := tmp_2320 |))) in
        (let (tmp_2330 :: MemoryAttributes) = ((AddressDescriptor_memattrs  (TLBRecord_addrdesc   result))) in
        (let (tmp_2330 :: MemoryAttributes) =
          ((tmp_2330 (| MemoryAttributes_outershareable := True |))) in
        (let (tmp_2340 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
        (let (tmp_2340 :: AddressDescriptor) =
          ((tmp_2340 (| AddressDescriptor_memattrs := tmp_2330 |))) in
        (let (result :: TLBRecord) = ((result (| TLBRecord_addrdesc := tmp_2340 |))) in
        return result))))))))))))))))))) \<bind> (\<lambda> (result :: TLBRecord) . 
     (let (tmp_2350 :: MemoryAttributes) = ((AddressDescriptor_memattrs  (TLBRecord_addrdesc   result))) in
     (let tmp_2350 =
       ((tmp_2350 (|
         MemoryAttributes_outer :=
           ((MemoryAttributes_inner  (AddressDescriptor_memattrs  (TLBRecord_addrdesc   result))))|))) in
     (let (tmp_2360 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
     (let tmp_2360 = ((tmp_2360 (| AddressDescriptor_memattrs := tmp_2350 |))) in
     (let result = ((result (| TLBRecord_addrdesc := tmp_2360 |))) in
     (let (tmp_2370 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
     MemAttrDefaults(AddressDescriptor_memattrs  (TLBRecord_addrdesc   result)) \<bind> (\<lambda> (w__10 ::
       MemoryAttributes) . 
     (let tmp_2370 = ((tmp_2370 (| AddressDescriptor_memattrs := w__10 |))) in
     (let result = ((result (| TLBRecord_addrdesc := tmp_2370 |))) in
     (let (tmp_2380 :: Permissions) = ((TLBRecord_perms   result)) in
     (undefined_bitvector (( 3 :: int)::ii)  :: ( 3 Word.word) M) \<bind> (\<lambda> (w__11 ::  3 Word.word) . 
     (let tmp_2380 = ((tmp_2380 (| Permissions_ap := w__11 |))) in
     (let result = ((result (| TLBRecord_perms := tmp_2380 |))) in
     (let (tmp_2390 :: Permissions) = ((TLBRecord_perms   result)) in
     (let tmp_2390 = ((tmp_2390 (| Permissions_xn := ((vec_of_bits [B0]  ::  1 Word.word))|))) in
     (let result = ((result (| TLBRecord_perms := tmp_2390 |))) in
     (let (tmp_2400 :: Permissions) = ((TLBRecord_perms   result)) in
     (let tmp_2400 = ((tmp_2400 (| Permissions_pxn := ((vec_of_bits [B0]  ::  1 Word.word))|))) in
     (let result = ((result (| TLBRecord_perms := tmp_2400 |))) in
     (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__12 ::  1 Word.word) . 
     (let result = ((result (| TLBRecord_nG := w__12 |))) in
     undefined_bool ()  \<bind> (\<lambda> (w__13 :: bool) . 
     (let result = ((result (| TLBRecord_contiguous := w__13 |))) in
     (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (w__14 ::  4 Word.word) . 
     (let result = ((result (| TLBRecord_domain := w__14 |))) in
     undefined_int ()  \<bind> (\<lambda> (w__15 :: ii) . 
     (let result = ((result (| TLBRecord_level := w__15 |))) in
     undefined_int ()  \<bind> (\<lambda> (w__16 :: ii) . 
     (let result = ((result (| TLBRecord_blocksize := w__16 |))) in
     (let (tmp_2410 :: FullAddress) = ((AddressDescriptor_paddress  (TLBRecord_addrdesc   result))) in
     (let tmp_2410 =
       ((tmp_2410 (|
         FullAddress_physicaladdress := ((slice vaddress (( 0 :: int)::ii) (( 52 :: int)::ii)  ::  52 Word.word))|))) in
     (let (tmp_2420 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
     (let tmp_2420 = ((tmp_2420 (| AddressDescriptor_paddress := tmp_2410 |))) in
     (let result = ((result (| TLBRecord_addrdesc := tmp_2420 |))) in
     (let (tmp_2430 :: FullAddress) = ((AddressDescriptor_paddress  (TLBRecord_addrdesc   result))) in
     IsSecure ()  \<bind> (\<lambda> (w__17 :: bool) . 
     (let tmp_2430 =
       ((tmp_2430 (|
         FullAddress_NS :=
           (if w__17 then (vec_of_bits [B0]  ::  1 Word.word)
            else (vec_of_bits [B1]  ::  1 Word.word))|))) in
     (let (tmp_2440 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
     (let tmp_2440 = ((tmp_2440 (| AddressDescriptor_paddress := tmp_2430 |))) in
     (let result = ((result (| TLBRecord_addrdesc := tmp_2440 |))) in
     (let (tmp_2450 :: AddressDescriptor) = ((TLBRecord_addrdesc   result)) in
     AArch64_NoFault ()  \<bind> (\<lambda> (w__18 :: FaultRecord) . 
     (let (tmp_2450 :: AddressDescriptor) = ((tmp_2450 (| AddressDescriptor_fault := w__18 |))) in
     (let (result :: TLBRecord) = ((result (| TLBRecord_addrdesc := tmp_2450 |))) in
     return result))))))))))))))))))))))))))))))))))))))))))))))))))))))))))"


(*val AArch64_MaybeZeroRegisterUppers : unit -> M unit*)

definition AArch64_MaybeZeroRegisterUppers  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_MaybeZeroRegisterUppers _ = (
   UsingAArch32 ()  \<bind> (\<lambda> (w__0 :: bool) . 
   (assert_exp w__0 (''UsingAArch32()'') \<then>
   undefined_bool () ) \<bind> (\<lambda> (include_R15_name :: bool) . 
   undefined_int ()  \<bind> (\<lambda> (last1 :: ii) . 
   undefined_int ()  \<bind> (\<lambda> (first1 :: ii) . 
   and_boolM
     (read_reg PSTATE_ref \<bind> (\<lambda> (w__1 :: ProcState) .  return ((((ProcState_EL   w__1) = EL0)))))
     (ELUsingAArch32 EL1 \<bind> (\<lambda> (w__2 :: bool) .  return ((\<not> w__2)))) \<bind> (\<lambda> (w__3 :: bool) . 
   (if w__3 then
      (let (first1 :: ii) = ((( 0 :: int)::ii)) in
      (let (last1 :: ii) = ((( 14 :: int)::ii)) in
      (let (include_R15_name :: bool) = False in
      return (first1, include_R15_name, last1))))
    else
      and_boolM
        (and_boolM
           (and_boolM
              (or_boolM
                 (read_reg PSTATE_ref \<bind> (\<lambda> (w__4 :: ProcState) . 
                  return ((((ProcState_EL   w__4) = EL0)))))
                 (read_reg PSTATE_ref \<bind> (\<lambda> (w__5 :: ProcState) . 
                  return ((((ProcState_EL   w__5) = EL1)))))) (return ((HaveEL EL2))))
           (IsSecure ()  \<bind> (\<lambda> (w__8 :: bool) .  return ((\<not> w__8)))))
        (ELUsingAArch32 EL2 \<bind> (\<lambda> (w__10 :: bool) .  return ((\<not> w__10)))) \<bind> (\<lambda> (w__11 :: bool) . 
      (let ((first1 :: ii), (include_R15_name :: bool), (last1 :: ii)) =
        (if w__11 then
          (let (first1 :: ii) = ((( 0 :: int)::ii)) in
          (let (last1 :: ii) = ((( 30 :: int)::ii)) in
          (let (include_R15_name :: bool) = False in
          (first1, include_R15_name, last1))))
        else
          (let (first1 :: ii) = ((( 0 :: int)::ii)) in
          (let (last1 :: ii) = ((( 30 :: int)::ii)) in
          (let (include_R15_name :: bool) = True in
          (first1, include_R15_name, last1))))) in
      return (first1, include_R15_name, last1)))) \<bind> (\<lambda> varstup .  (let ((first1 :: ii), (include_R15_name ::
     bool), (last1 :: ii)) = varstup in
   (foreachM (index_list first1 last1 (( 1 :: int)::ii)) () 
     (\<lambda> n unit_var . 
       and_boolM (return ((((((n \<noteq> (( 15 :: int)::ii)))) \<or> include_R15_name))))
         ((ConstrainUnpredictableBool Unpredictable_ZEROUPPER)) \<bind> (\<lambda> (w__13 :: bool) . 
       if w__13 then
         read_reg R_ref \<bind> (\<lambda> (w__14 :: ( 64 bits) list) . 
         (let (tmp_30 :: 64 bits) = ((access_list_dec w__14 n  ::  64 Word.word)) in
         (let tmp_30 =
           ((set_slice (( 64 :: int)::ii) (( 32 :: int)::ii) tmp_30 (( 32 :: int)::ii) ((Zeros__1 (( 32 :: int)::ii) ()   ::  32 Word.word))
             ::  64 Word.word)) in
         read_reg R_ref \<bind> (\<lambda> (w__15 :: ( 64 bits) list) . 
         write_reg R_ref ((update_list_dec w__15 n tmp_30  :: ( 64 Word.word) list))))))
       else return () )))))))))))"


(*val DCPSInstruction : mword ty2 -> M unit*)

definition DCPSInstruction  :: "(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " DCPSInstruction target_el = (
   (let (_ :: unit) = (SynchronizeContext () ) in
   (undefined_bitvector (( 2 :: int)::ii)  :: ( 2 Word.word) M) \<bind> (\<lambda> (handle_el :: 2 bits) . 
   (let pat0 = target_el in
   (if (((pat0 = EL1))) then
      or_boolM
        (read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) .  return ((((ProcState_EL   w__0) = EL2)))))
        (and_boolM
           (read_reg PSTATE_ref \<bind> (\<lambda> (w__1 :: ProcState) . 
            return ((((ProcState_EL   w__1) = EL3)))))
           (UsingAArch32 ()  \<bind> (\<lambda> (w__2 :: bool) .  return ((\<not> w__2))))) \<bind> (\<lambda> (w__4 :: bool) . 
      if w__4 then
        read_reg PSTATE_ref \<bind> (\<lambda> (w__5 :: ProcState) . 
        (let (handle_el :: 2 bits) = ((ProcState_EL   w__5)) in
        return handle_el))
      else
        and_boolM
          (and_boolM (return ((HaveEL EL2)))
             (IsSecure ()  \<bind> (\<lambda> (w__6 :: bool) .  return ((\<not> w__6)))))
          ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__8 :: 64 bits) . 
           return ((((vec_of_bits [access_vec_dec w__8 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__9 :: bool) . 
        if w__9 then UndefinedFault ()  \<then> return handle_el
        else return EL1))
    else if (((pat0 = EL2))) then
      if ((\<not> ((HaveEL EL2)))) then UndefinedFault ()  \<then> return handle_el
      else
        and_boolM
          (read_reg PSTATE_ref \<bind> (\<lambda> (w__10 :: ProcState) . 
           return ((((ProcState_EL   w__10) = EL3)))))
          (UsingAArch32 ()  \<bind> (\<lambda> (w__11 :: bool) .  return ((\<not> w__11)))) \<bind> (\<lambda> (w__12 :: bool) . 
        if w__12 then return EL3
        else
          IsSecure ()  \<bind> (\<lambda> (w__13 :: bool) . 
          if w__13 then UndefinedFault ()  \<then> return handle_el
          else return EL2))
    else if (((pat0 = EL3))) then
      or_boolM
        ((read_reg EDSCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__14 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__14 (( 16 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) (return ((\<not> ((HaveEL EL3))))) \<bind> (\<lambda> (w__15 ::
        bool) . 
      (if w__15 then UndefinedFault ()  else return () ) \<then> return EL3)
    else Unreachable ()  \<then> return handle_el) \<bind> (\<lambda> (handle_el :: 2 bits) . 
   IsSecure ()  \<bind> (\<lambda> (from_secure :: bool) . 
   ELUsingAArch32 handle_el \<bind> (\<lambda> (w__16 :: bool) . 
   (((if w__16 then
      read_reg PSTATE_ref \<bind> (\<lambda> (w__17 :: ProcState) . 
      ((if ((((ProcState_M   w__17) = M32_Monitor))) then
         (read_reg SCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__18 :: 32 bits) . 
         write_reg
           SCR_ref
           ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__18 (( 0 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word)))
       else return () ) \<then>
      UsingAArch32 () ) \<bind> (\<lambda> (w__19 :: bool) . 
      assert_exp w__19 (''UsingAArch32()'') \<then>
      ((let pat0 = handle_el in
      (((if (((pat0 = EL1))) then
         (AArch32_WriteMode M32_Svc \<then>
         and_boolM (return ((HavePANExt () )))
           ((read_reg SCTLR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__20 :: 32 bits) . 
            return ((((vec_of_bits [access_vec_dec w__20 (( 23 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))) \<bind> (\<lambda> (w__21 :: bool) . 
         if w__21 then
           read_reg PSTATE_ref \<bind> (\<lambda> (w__22 :: ProcState) . 
           write_reg PSTATE_ref (w__22 (| ProcState_PAN := ((vec_of_bits [B1]  ::  1 Word.word))|)))
         else return () )
       else if (((pat0 = EL2))) then AArch32_WriteMode M32_Hyp
       else
         AArch32_WriteMode M32_Monitor \<then>
         (if ((HavePANExt () )) then
           if ((\<not> from_secure)) then
             read_reg PSTATE_ref \<bind> (\<lambda> (w__23 :: ProcState) . 
             write_reg PSTATE_ref (w__23 (| ProcState_PAN := ((vec_of_bits [B0]  ::  1 Word.word))|)))
           else
             (read_reg SCTLR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__24 :: 32 bits) . 
             if ((((vec_of_bits [access_vec_dec w__24 (( 23 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))) then
               read_reg PSTATE_ref \<bind> (\<lambda> (w__25 :: ProcState) . 
               write_reg PSTATE_ref (w__25 (| ProcState_PAN := ((vec_of_bits [B1]  ::  1 Word.word))|)))
             else return () )
         else return () )) \<then>
      (if (((handle_el = EL2))) then
         (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__26 ::  32 Word.word) . 
         (write_reg ELR_hyp_ref w__26 \<then>
         (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__27 ::  32 Word.word) . 
         write_reg HSR_ref w__27))
       else
         (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__28 ::  32 Word.word) . 
         set_LR w__28))) \<then>
      (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__29 ::  32 Word.word) . 
      (aset_SPSR w__29 \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__30 :: ProcState) . 
      (aget_SCTLR__1 ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__31 ::  32 Word.word) . 
      (write_reg
        PSTATE_ref
        (w__30 (| ProcState_E := ((vec_of_bits [access_vec_dec w__31 (( 25 :: int)::ii)]  ::  1 Word.word))|)) \<then>
      (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__32 ::  32 Word.word) . 
      (write_reg DLR_ref w__32 \<then>
      (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__33 ::  32 Word.word) . 
      write_reg DSPSR_ref w__33)))))))))
    else
      UsingAArch32 ()  \<bind> (\<lambda> (w__34 :: bool) . 
      ((if w__34 then AArch64_MaybeZeroRegisterUppers () 
       else return () ) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__35 :: ProcState) . 
      (write_reg PSTATE_ref (w__35 (| ProcState_nRW := ((vec_of_bits [B0]  ::  1 Word.word))|)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__36 :: ProcState) . 
      (write_reg PSTATE_ref (w__36 (| ProcState_SP := ((vec_of_bits [B1]  ::  1 Word.word))|)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__37 :: ProcState) . 
      (write_reg PSTATE_ref (w__37 (| ProcState_EL := handle_el |)) \<then>
      and_boolM (return ((HavePANExt () )))
        (or_boolM
           (and_boolM (return (((handle_el = EL1))))
              ((read_reg SCTLR_EL1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__38 :: 32 bits) . 
               return ((((vec_of_bits [access_vec_dec w__38 (( 23 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))))
           (and_boolM
              (and_boolM
                 (and_boolM (return (((handle_el = EL2))))
                    ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__40 :: 64 bits) . 
                     return ((((vec_of_bits [access_vec_dec w__40 (( 34 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
                 ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__42 :: 64 bits) . 
                  return ((((vec_of_bits [access_vec_dec w__42 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
              ((read_reg SCTLR_EL2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__44 :: 32 bits) . 
               return ((((vec_of_bits [access_vec_dec w__44 (( 23 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))))) \<bind> (\<lambda> (w__47 :: bool) . 
      ((if w__47 then
         read_reg PSTATE_ref \<bind> (\<lambda> (w__48 :: ProcState) . 
         write_reg PSTATE_ref (w__48 (| ProcState_PAN := ((vec_of_bits [B1]  ::  1 Word.word))|)))
       else return () ) \<then>
      (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__49 ::  64 Word.word) . 
      (aset_ELR__1 w__49 \<then>
      (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__50 ::  32 Word.word) . 
      (aset_SPSR w__50 \<then>
      (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__51 ::  32 Word.word) . 
      (aset_ESR__1 w__51 \<then>
      (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__52 ::  64 Word.word) . 
      (write_reg DLR_EL0_ref w__52 \<then>
      (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__53 ::  32 Word.word) . 
      write_reg DSPSR_EL0_ref w__53 \<then>
      (if ((HaveUAOExt () )) then
        read_reg PSTATE_ref \<bind> (\<lambda> (w__54 :: ProcState) . 
        write_reg PSTATE_ref (w__54 (| ProcState_UAO := ((vec_of_bits [B0]  ::  1 Word.word))|)))
      else return () )))))))))))) \<then>
   UpdateEDSCRFields () ) \<then>
   and_boolM
     (and_boolM (return ((HaveRASExt () )))
        ((aget_SCTLR__1 ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__55 ::  32 Word.word) . 
         return ((((vec_of_bits [access_vec_dec w__55 (( 21 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
     ((ConstrainUnpredictableBool Unpredictable_IESBinDebug))) \<bind> (\<lambda> (w__58 :: bool) . 
   (let (_ :: unit) =
     (if w__58 then ErrorSynchronizationBarrier MBReqDomain_FullSystem MBReqTypes_All
     else () ) in
   return () )))))))))"


(*val aarch64_system_exceptions_debug_exception : mword ty2 -> M unit*)

definition aarch64_system_exceptions_debug_exception  :: "(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_system_exceptions_debug_exception target_level = ( DCPSInstruction target_level )"


(*val AArch64_GenerateDebugExceptionsFrom : mword ty2 -> bool -> mword ty1 -> M bool*)

definition AArch64_GenerateDebugExceptionsFrom  :: "(2)Word.word \<Rightarrow> bool \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " AArch64_GenerateDebugExceptionsFrom from1 secure mask1 = (
   or_boolM
     (or_boolM
        ((read_reg OSLSR_EL1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__0 (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) ((DoubleLockStatus () ))) ((Halted () )) \<bind> (\<lambda> (w__4 ::
     bool) . 
   if w__4 then return False
   else
     and_boolM (return (((((HaveEL EL2)) \<and> ((\<not> secure))))))
       (or_boolM
          ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 :: 64 bits) . 
           return ((((vec_of_bits [access_vec_dec w__5 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))
          ((read_reg MDCR_EL2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__6 :: 32 bits) . 
           return ((((vec_of_bits [access_vec_dec w__6 (( 8 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))) \<bind> (\<lambda> (route_to_el2 :: bool) . 
     (let (target :: 2 bits) = (if route_to_el2 then EL2 else EL1) in
     or_boolM (return (((((\<not> ((HaveEL EL3)))) \<or> ((\<not> secure))))))
       ((read_reg MDCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__8 :: 32 bits) . 
        return ((((vec_of_bits [access_vec_dec w__8 (( 16 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (enabled :: bool) . 
     if (((from1 = target))) then
       and_boolM
         (and_boolM (return enabled)
            ((read_reg MDSCR_EL1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__9 :: 32 bits) . 
             return ((((vec_of_bits [access_vec_dec w__9 (( 13 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
         (return (((mask1 = (vec_of_bits [B0]  ::  1 Word.word)))))
     else
       (let (enabled :: bool) = (enabled \<and> ((((Word.uint target)) > ((Word.uint from1))))) in
       return enabled))))))"


(*val AArch64_GenerateDebugExceptions : unit -> M bool*)

definition AArch64_GenerateDebugExceptions  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " AArch64_GenerateDebugExceptions _ = (
   read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) . 
   IsSecure ()  \<bind> (\<lambda> (w__1 :: bool) . 
   read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) . 
   AArch64_GenerateDebugExceptionsFrom(ProcState_EL   w__0) w__1(ProcState_D   w__2)))))"


(*val AArch64_FaultSyndrome : bool -> FaultRecord -> M (mword ty25)*)

definition AArch64_FaultSyndrome  :: " bool \<Rightarrow> FaultRecord \<Rightarrow>((register_value),((25)Word.word),(exception))monad "  where 
     " AArch64_FaultSyndrome d_side fault = (
   assert_exp ((((FaultRecord_typ   fault) \<noteq> Fault_None))) (''((fault).type != Fault_None)'') \<then>
   ((let (iss :: 25 bits) = ((Zeros__1 (( 25 :: int)::ii) ()   ::  25 Word.word)) in
   and_boolM (return ((HaveRASExt () ))) ((IsExternalSyncAbort__1 fault)) \<bind> (\<lambda> (w__1 :: bool) . 
   (let (iss :: 25 bits) =
     (if w__1 then (set_slice (( 25 :: int)::ii) (( 2 :: int)::ii) iss (( 11 :: int)::ii)(FaultRecord_errortype   fault)  ::  25 Word.word)
     else iss) in
   (if d_side then
      and_boolM ((IsSecondStage fault)) (return ((\<not>(FaultRecord_s2fs1walk   fault)))) \<bind> (\<lambda> (w__3 ::
        bool) . 
      (if w__3 then
         (LSInstructionSyndrome ()   :: ( 11 Word.word) M) \<bind> (\<lambda> (w__4 ::  11 Word.word) . 
         (let (iss :: 25 bits) = ((set_slice (( 25 :: int)::ii) (( 11 :: int)::ii) iss (( 14 :: int)::ii) w__4  ::  25 Word.word)) in
         return iss))
       else return iss) \<bind> (\<lambda> (iss :: 25 bits) . 
      (let (iss :: 25 bits) =
        (if (((((((FaultRecord_acctype   fault) = AccType_DC))) \<or> (((((((FaultRecord_acctype   fault) = AccType_IC))) \<or> ((((FaultRecord_acctype   fault) = AccType_AT))))))))) then
          (let (iss :: 25 bits) =
            ((set_slice (( 25 :: int)::ii) (( 1 :: int)::ii) iss (( 8 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)  ::  25 Word.word)) in
          (set_slice (( 25 :: int)::ii) (( 1 :: int)::ii) iss (( 6 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)  ::  25 Word.word))
        else
          (set_slice (( 25 :: int)::ii) (( 1 :: int)::ii) iss (( 6 :: int)::ii)
             (if(FaultRecord_write   fault) then (vec_of_bits [B1]  ::  1 Word.word)
              else (vec_of_bits [B0]  ::  1 Word.word))
            ::  25 Word.word)) in
      return iss)))
    else return iss) \<bind> (\<lambda> (iss :: 25 bits) . 
   IsExternalAbort__1 fault \<bind> (\<lambda> (w__5 :: bool) . 
   (let (iss :: 25 bits) =
     (if w__5 then (set_slice (( 25 :: int)::ii) (( 1 :: int)::ii) iss (( 9 :: int)::ii)(FaultRecord_extflag   fault)  ::  25 Word.word)
     else iss) in
   (let iss =
     ((set_slice (( 25 :: int)::ii) (( 1 :: int)::ii) iss (( 7 :: int)::ii)
        (if(FaultRecord_s2fs1walk   fault) then (vec_of_bits [B1]  ::  1 Word.word)
         else (vec_of_bits [B0]  ::  1 Word.word))
       ::  25 Word.word)) in
   (EncodeLDFSC(FaultRecord_typ   fault)(FaultRecord_level   fault)  :: ( 6 Word.word) M) \<bind> (\<lambda> (w__6 ::
      6 Word.word) . 
   (let (iss :: 25 bits) = ((set_slice (( 25 :: int)::ii) (( 6 :: int)::ii) iss (( 0 :: int)::ii) w__6  ::  25 Word.word)) in
   return iss)))))))))))"


(*val AArch64_AbortSyndrome : Exception -> FaultRecord -> mword ty64 -> M ExceptionRecord*)

definition AArch64_AbortSyndrome  :: " Exception \<Rightarrow> FaultRecord \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(ExceptionRecord),(exception))monad "  where 
     " AArch64_AbortSyndrome typ1 fault vaddress = (
   ExceptionSyndrome typ1 \<bind> (\<lambda> (exception :: ExceptionRecord) . 
   (let (d_side :: bool) = ((((typ1 = Exception_DataAbort))) \<or> (((typ1 = Exception_Watchpoint)))) in
   (AArch64_FaultSyndrome d_side fault  :: ( 25 Word.word) M) \<bind> (\<lambda> (w__0 ::  25 Word.word) . 
   (let exception = ((exception (| ExceptionRecord_syndrome := w__0 |))) in
   (ZeroExtend__1 (( 64 :: int)::ii) vaddress  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   (let exception = ((exception (| ExceptionRecord_vaddress := w__1 |))) in
   IPAValid fault \<bind> (\<lambda> (w__2 :: bool) . 
   (let (exception :: ExceptionRecord) =
     (if w__2 then
       (let (exception :: ExceptionRecord) = ((exception (| ExceptionRecord_ipavalid := True |))) in
       (exception (| ExceptionRecord_ipaddress := ((FaultRecord_ipaddress   fault))|)))
     else (exception (| ExceptionRecord_ipavalid := False |))) in
   return exception)))))))))"


(*val AArch64_ExecutingATS1xPInstr : unit -> M bool*)

definition AArch64_ExecutingATS1xPInstr  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " AArch64_ExecutingATS1xPInstr _ = (
   if ((\<not> ((HavePrivATExt () )))) then return False
   else
     (ThisInstr0 ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (instr :: 32 bits) . 
     (undefined_bitvector (( 3 :: int)::ii)  :: ( 3 Word.word) M) \<bind> (\<lambda> (op2 :: 3 bits) . 
     (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (CRm :: 4 bits) . 
     (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (CRn :: 4 bits) . 
     (undefined_bitvector (( 3 :: int)::ii)  :: ( 3 Word.word) M) \<bind> (\<lambda> (op1 :: 3 bits) . 
     (let (w__0 :: bool) =
       (if (((((slice instr (( 22 :: int)::ii) (( 10 :: int)::ii)  ::  10 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B0,B1,B0,B1,B0,B0]  ::  10 Word.word)))) then
         (let (op1 :: 3 bits) = ((slice instr (( 16 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) in
         (let (CRn :: 4 bits) = ((slice instr (( 12 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) in
         (let (CRm :: 4 bits) = ((slice instr (( 8 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) in
         (let (op2 :: 3 bits) = ((slice instr (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) in
         ((((((((((op1 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((CRn = (vec_of_bits [B0,B1,B1,B1]  ::  4 Word.word))))))) \<and> (((CRm = (vec_of_bits [B1,B0,B0,B1]  ::  4 Word.word))))))) \<and> ((((((op2 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<or> (((op2 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word))))))))))))
       else False) in
     return w__0)))))))"


(*val AArch64_ExceptionClass : Exception -> mword ty2 -> M (ii * mword ty1)*)

definition AArch64_ExceptionClass  :: " Exception \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(int*(1)Word.word),(exception))monad "  where 
     " AArch64_ExceptionClass typ1 target_el = (
   ThisInstrLength ()  \<bind> (\<lambda> (w__0 :: ii) . 
   (let (il :: 1 bits) =
     (if (((((ex_int w__0)) = (( 32 :: int)::ii)))) then (vec_of_bits [B1]  ::  1 Word.word)
     else (vec_of_bits [B0]  ::  1 Word.word)) in
   UsingAArch32 ()  \<bind> (\<lambda> (from_32 :: bool) . 
   (assert_exp (((from_32 \<or> (((il = (vec_of_bits [B1]  ::  1 Word.word))))))) ([(CHR ''(''), (CHR ''f''), (CHR ''r''), (CHR ''o''), (CHR ''m''), (CHR ''_''), (CHR ''3''), (CHR ''2''), (CHR '' ''), (CHR ''|''), (CHR ''|''), (CHR '' ''), (CHR ''(''), (CHR ''i''), (CHR ''l''), (CHR '' ''), (CHR ''=''), (CHR ''=''), (CHR '' ''), (CHR 0x27), (CHR ''1''), (CHR 0x27), (CHR '')''), (CHR '')'')]) \<then>
   undefined_int () ) \<bind> (\<lambda> (ec :: ii) . 
   (case  typ1 of
     Exception_Uncategorized =>
      (let (ec :: ii) = ((( 0 :: int)::ii)) in
      (let (il :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
      return (ec, il)))
   | Exception_WFxTrap =>
      (let (ec :: ii) = ((( 1 :: int)::ii)) in
      return (ec, il))
   | Exception_CP15RTTrap =>
      (let ec = ((( 3 :: int)::ii)) in
      assert_exp from_32 (''from_32'') \<then> return (ec, il))
   | Exception_CP15RRTTrap =>
      (let ec = ((( 4 :: int)::ii)) in
      assert_exp from_32 (''from_32'') \<then> return (ec, il))
   | Exception_CP14RTTrap =>
      (let ec = ((( 5 :: int)::ii)) in
      assert_exp from_32 (''from_32'') \<then> return (ec, il))
   | Exception_CP14DTTrap =>
      (let ec = ((( 6 :: int)::ii)) in
      assert_exp from_32 (''from_32'') \<then> return (ec, il))
   | Exception_AdvSIMDFPAccessTrap =>
      (let (ec :: ii) = ((( 7 :: int)::ii)) in
      return (ec, il))
   | Exception_FPIDTrap =>
      (let (ec :: ii) = ((( 8 :: int)::ii)) in
      return (ec, il))
   | Exception_CP14RRTTrap =>
      (let ec = ((( 12 :: int)::ii)) in
      assert_exp from_32 (''from_32'') \<then> return (ec, il))
   | Exception_IllegalState =>
      (let (ec :: ii) = ((( 14 :: int)::ii)) in
      (let (il :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
      return (ec, il)))
   | Exception_SupervisorCall =>
      (let (ec :: ii) = ((( 17 :: int)::ii)) in
      return (ec, il))
   | Exception_HypervisorCall =>
      (let (ec :: ii) = ((( 18 :: int)::ii)) in
      return (ec, il))
   | Exception_MonitorCall =>
      (let (ec :: ii) = ((( 19 :: int)::ii)) in
      return (ec, il))
   | Exception_SystemRegisterTrap =>
      (let ec = ((( 24 :: int)::ii)) in
      assert_exp ((\<not> from_32)) (''!(from_32)'') \<then> return (ec, il))
   | Exception_InstructionAbort =>
      (let (ec :: ii) = ((( 32 :: int)::ii)) in
      (let (il :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
      return (ec, il)))
   | Exception_PCAlignment =>
      (let (ec :: ii) = ((( 34 :: int)::ii)) in
      (let (il :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
      return (ec, il)))
   | Exception_DataAbort =>
      (let (ec :: ii) = ((( 36 :: int)::ii)) in
      return (ec, il))
   | Exception_SPAlignment =>
      (let ec = ((( 38 :: int)::ii)) in
      (let il = ((vec_of_bits [B1]  ::  1 Word.word)) in
      assert_exp ((\<not> from_32)) (''!(from_32)'') \<then> return (ec, il)))
   | Exception_FPTrappedException =>
      (let (ec :: ii) = ((( 40 :: int)::ii)) in
      return (ec, il))
   | Exception_SError =>
      (let (ec :: ii) = ((( 47 :: int)::ii)) in
      (let (il :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
      return (ec, il)))
   | Exception_Breakpoint =>
      (let (ec :: ii) = ((( 48 :: int)::ii)) in
      (let (il :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
      return (ec, il)))
   | Exception_SoftwareStep =>
      (let (ec :: ii) = ((( 50 :: int)::ii)) in
      (let (il :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
      return (ec, il)))
   | Exception_Watchpoint =>
      (let (ec :: ii) = ((( 52 :: int)::ii)) in
      (let (il :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
      return (ec, il)))
   | Exception_SoftwareBreakpoint =>
      (let (ec :: ii) = ((( 56 :: int)::ii)) in
      return (ec, il))
   | Exception_VectorCatch =>
      (let ec = ((( 58 :: int)::ii)) in
      (let il = ((vec_of_bits [B1]  ::  1 Word.word)) in
      assert_exp from_32 (''from_32'') \<then> return (ec, il)))
   | _ => Unreachable ()  \<then> return (ec, il)
   ) \<bind> (\<lambda> varstup .  (let ((ec :: ii), (il :: 1 bits)) = varstup in
   and_boolM
     (return ((((((((ex_int ec)) = (( 32 :: int)::ii)))) \<or> ((((((((ex_int ec)) = (( 36 :: int)::ii)))) \<or> ((((((((ex_int ec)) = (( 48 :: int)::ii)))) \<or> ((((((((ex_int ec)) = (( 50 :: int)::ii)))) \<or> (((((ex_int ec)) = (( 52 :: int)::ii)))))))))))))))))
     (read_reg PSTATE_ref \<bind> (\<lambda> (w__1 :: ProcState) . 
      return (((target_el =(ProcState_EL   w__1)))))) \<bind> (\<lambda> (w__2 :: bool) . 
   (let (ec :: ii) = (if w__2 then ((ex_int ec)) + (( 1 :: int)::ii) else ec) in
   (let (ec :: ii) =
     (if (((((((((((ex_int ec)) = (( 17 :: int)::ii)))) \<or> ((((((((ex_int ec)) = (( 18 :: int)::ii)))) \<or> ((((((((ex_int ec)) = (( 19 :: int)::ii)))) \<or> ((((((((ex_int ec)) = (( 40 :: int)::ii)))) \<or> (((((ex_int ec)) = (( 56 :: int)::ii)))))))))))))))) \<and> ((\<not> from_32))))) then
       ((ex_int ec)) + (( 4 :: int)::ii)
     else ec) in
   return (ec, il)))))))))))"


(*val AArch64_ReportException : ExceptionRecord -> mword ty2 -> M unit*)

definition AArch64_ReportException  :: " ExceptionRecord \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_ReportException exception target_el = (
   (let (typ1 :: Exception) = ((ExceptionRecord_typ   exception)) in
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (il :: 1 bits) . 
   undefined_int ()  \<bind> (\<lambda> (ec :: ii) . 
   (AArch64_ExceptionClass typ1 target_el  :: ((ii *  1 Word.word)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1) = varstup in
   (let ec = tup__0 in
   (let il = tup__1 in
   (let (iss :: 25 bits) = ((ExceptionRecord_syndrome   exception)) in
   (let (il :: 1 bits) =
     (if (((((((((((ex_int ec)) = (( 36 :: int)::ii)))) \<or> (((((ex_int ec)) = (( 37 :: int)::ii))))))) \<and> ((((vec_of_bits [access_vec_dec iss (( 24 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))) then
       (vec_of_bits [B1]  ::  1 Word.word)
     else il) in
   (aset_ESR__0 target_el
     ((concat_vec
         ((concat_vec
             ((GetSlice_int ((make_the_value (( 6 :: int)::ii)  ::  6 itself)) ec (( 0 :: int)::ii)  ::  6 Word.word)) il
            ::  7 Word.word)) iss
        ::  32 Word.word)) \<then>
   (if ((((((typ1 = Exception_InstructionAbort))) \<or> ((((((typ1 = Exception_PCAlignment))) \<or> ((((((typ1 = Exception_DataAbort))) \<or> (((typ1 = Exception_Watchpoint)))))))))))) then
      aset_FAR__0 target_el(ExceptionRecord_vaddress   exception)
    else
      (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
      aset_FAR__0 target_el w__0))) \<then>
   (if (((target_el = EL2))) then
     if(ExceptionRecord_ipavalid   exception) then
       (read_reg HPFAR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 :: 64 bits) . 
       write_reg
         HPFAR_EL2_ref
         ((set_slice (( 64 :: int)::ii) (( 40 :: int)::ii) w__1 (( 4 :: int)::ii)
             ((slice(ExceptionRecord_ipaddress   exception) (( 12 :: int)::ii) (( 40 :: int)::ii)  ::  40 Word.word))
            ::  64 Word.word)))
     else
       (read_reg HPFAR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 :: 64 bits) . 
       (undefined_bitvector (( 40 :: int)::ii)  :: ( 40 Word.word) M) \<bind> (\<lambda> (w__3 ::  40 Word.word) . 
       write_reg HPFAR_EL2_ref ((set_slice (( 64 :: int)::ii) (( 40 :: int)::ii) w__2 (( 4 :: int)::ii) w__3  ::  64 Word.word))))
   else return () )))))))))))"


(*val AArch64_ESBOperation : unit -> M unit*)

definition AArch64_ESBOperation  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_ESBOperation _ = (
   and_boolM (return ((HaveEL EL3)))
     ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 :: 32 bits) . 
      return ((((vec_of_bits [access_vec_dec w__0 (( 3 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (route_to_el3 :: bool) . 
   and_boolM
     (and_boolM (return ((HaveEL EL2))) (IsSecure ()  \<bind> (\<lambda> (w__1 :: bool) .  return ((\<not> w__1)))))
     (or_boolM
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__3 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__4 (( 5 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))) \<bind> (\<lambda> (route_to_el2 :: bool) . 
   (let (target :: 2 bits) = (if route_to_el3 then EL3 else if route_to_el2 then EL2 else EL1) in
   undefined_bool ()  \<bind> (\<lambda> (mask_active :: bool) . 
   (if (((target = EL1))) then
      or_boolM
        (read_reg PSTATE_ref \<bind> (\<lambda> (w__6 :: ProcState) .  return ((((ProcState_EL   w__6) = EL0)))))
        (read_reg PSTATE_ref \<bind> (\<lambda> (w__7 :: ProcState) .  return ((((ProcState_EL   w__7) = EL1)))))
    else
      and_boolM (return (((((HaveVirtHostExt () )) \<and> (((target = EL2)))))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__9 :: 64 bits) . 
         (read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__10 :: 64 bits) . 
         return ((((access_vec_dec w__9 (( 34 :: int)::ii), access_vec_dec w__10 (( 27 :: int)::ii)) = (B1, B1))))))) \<bind> (\<lambda> (w__11 ::
        bool) . 
      if w__11 then
        or_boolM
          (read_reg PSTATE_ref \<bind> (\<lambda> (w__12 :: ProcState) . 
           return ((((ProcState_EL   w__12) = EL0)))))
          (read_reg PSTATE_ref \<bind> (\<lambda> (w__13 :: ProcState) . 
           return ((((ProcState_EL   w__13) = EL2)))))
      else
        read_reg PSTATE_ref \<bind> (\<lambda> (w__15 :: ProcState) . 
        (let (mask_active :: bool) = ((ProcState_EL   w__15) = target) in
        return mask_active)))) \<bind> (\<lambda> (mask_active :: bool) . 
   read_reg PSTATE_ref \<bind> (\<lambda> (w__16 :: ProcState) . 
   (let (mask_set :: bool) = ((ProcState_A   w__16) = (vec_of_bits [B1]  ::  1 Word.word)) in
   or_boolM ((Halted () )) ((ExternalDebugInterruptsDisabled target)) \<bind> (\<lambda> (intdis :: bool) . 
   or_boolM
     (or_boolM
        (read_reg PSTATE_ref \<bind> (\<lambda> (w__19 :: ProcState) . 
         return ((((Word.uint target)) < ((Word.uint(ProcState_EL   w__19))))))) (return intdis))
     (return (((mask_active \<and> mask_set)))) \<bind> (\<lambda> (masked :: bool) . 
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (DISR_EL1 :: 64 bits) . 
   (undefined_bitvector (( 25 :: int)::ii)  :: ( 25 Word.word) M) \<bind> (\<lambda> (syndrome64 :: 25 bits) . 
   undefined_bool ()  \<bind> (\<lambda> (implicit_esb :: bool) . 
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (DISR :: 32 bits) . 
   undefined_AArch32_SErrorSyndrome ()  \<bind> (\<lambda> (syndrome32 :: AArch32_SErrorSyndrome) . 
   and_boolM ((SErrorPending () )) (return masked) \<bind> (\<lambda> (w__22 :: bool) . 
   if w__22 then
     (S1TranslationRegime__1 ()   :: ( 2 Word.word) M) \<bind> (\<lambda> (w__23 ::  2 Word.word) . 
     ELUsingAArch32 w__23 \<bind> (\<lambda> (w__24 :: bool) . 
     (if w__24 then
        AArch32_PhysicalSErrorSyndrome ()  \<bind> (\<lambda> (w__25 :: AArch32_SErrorSyndrome) . 
        (let syndrome32 = w__25 in
        (AArch32_ReportDeferredSError(AArch32_SErrorSyndrome_AET   syndrome32)(AArch32_SErrorSyndrome_ExT  
           syndrome32)
          :: ( 32 Word.word) M) \<bind> (\<lambda> (w__26 ::  32 Word.word) . 
        (let (DISR :: 32 bits) = w__26 in
        return () ))))
      else
        (let implicit_esb = False in
        (AArch64_PhysicalSErrorSyndrome implicit_esb  :: ( 25 Word.word) M) \<bind> (\<lambda> (w__27 ::  25 Word.word) . 
        (let syndrome64 = w__27 in
        (AArch64_ReportDeferredSError syndrome64  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__28 ::  64 Word.word) . 
        (let (DISR_EL1 :: 64 bits) = w__28 in
        return () )))))) \<then>
     ClearPendingPhysicalSError () ))
   else return () ))))))))))))))))"


definition AArch64_CheckAndUpdateDescriptor  :: " DescriptorUpdate \<Rightarrow> FaultRecord \<Rightarrow> bool \<Rightarrow>(64)Word.word \<Rightarrow> AccType \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(FaultRecord),(exception))monad "  where 
     " AArch64_CheckAndUpdateDescriptor result fault secondstage vaddress acctype iswrite s2fs1walk hwupdatewalk__arg = (
   catch_early_return
     (liftR ((aget_SCTLR__1 ()   :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__0 ::  32 Word.word) . 
      (let reversedescriptors = (((access_vec_dec w__0 (( 25 :: int)::ii))) = B1) in
      (let hwupdatewalk = hwupdatewalk__arg in
      liftR (undefined_bool () ) \<bind> (\<lambda> (hw_update_AF :: bool) . 
      (let (hw_update_AF :: bool) =
        (if(DescriptorUpdate_AF   result) then
          if ((((FaultRecord_typ   fault) = Fault_None))) then True
          else if (((((ConstrainUnpredictable Unpredictable_AFUPDATE)) = Constraint_TRUE))) then True
          else False
        else False) in
      liftR (undefined_bool () ) \<bind> (\<lambda> (hw_update_AP :: bool) . 
      liftR (undefined_bool () ) \<bind> (\<lambda> (write_perm_req :: bool) . 
      (let (hw_update_AP :: bool) =
        (if ((((DescriptorUpdate_AP   result) \<and> ((((FaultRecord_typ   fault) = Fault_None)))))) then
          (let (write_perm_req :: bool) =
            ((((iswrite \<or> ((((((acctype = AccType_ATOMICRW))) \<or> (((acctype = AccType_ORDEREDRW))))))))) \<and> ((\<not> s2fs1walk))) in
          ((((write_perm_req \<and> ((\<not> ((((((acctype = AccType_AT))) \<or> (((acctype = AccType_DC))))))))))) \<or> hwupdatewalk))
        else False) in
      liftR ((undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (desc :: 64 bits) . 
      liftR (undefined_AccessDescriptor () ) \<bind> (\<lambda> (accdesc :: AccessDescriptor) . 
      liftR (undefined_AddressDescriptor () ) \<bind> (\<lambda> (descaddr2 :: AddressDescriptor) . 
      (if (((hw_update_AF \<or> hw_update_AP))) then
         or_boolM (return secondstage)
           (liftR (HasS2Translation () ) \<bind> (\<lambda> (w__1 :: bool) .  return ((\<not> w__1)))) \<bind> (\<lambda> (w__2 ::
           bool) . 
         (if w__2 then
            (let (descaddr2 :: AddressDescriptor) = ((DescriptorUpdate_descaddr   result)) in
            return descaddr2)
          else
            (let hwupdatewalk = True in
            liftR (AArch64_SecondStageWalk(DescriptorUpdate_descaddr   result) vaddress acctype iswrite
                     (( 8 :: int)::ii) hwupdatewalk) \<bind> (\<lambda> (w__3 :: AddressDescriptor) . 
            (let descaddr2 = w__3 in
            (if ((IsFault descaddr2)) then
               (early_return(AddressDescriptor_fault   descaddr2) :: (unit, FaultRecord) MR)
             else return () ) \<then>
            return descaddr2)))) \<bind> (\<lambda> (descaddr2 :: AddressDescriptor) . 
         liftR (CreateAccessDescriptor AccType_ATOMICRW) \<bind> (\<lambda> (w__4 :: AccessDescriptor) . 
         (let accdesc = w__4 in
         liftR ((aget__Mem descaddr2 (( 8 :: int)::ii) accdesc  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__5 ::  64 Word.word) . 
         (let desc = w__5 in
         (if reversedescriptors then liftR ((BigEndianReverse desc  :: ( 64 Word.word) M))
          else return desc) \<bind> (\<lambda> (desc :: 64 bits) . 
         (let (desc :: 64 bits) =
           (if hw_update_AF then
             (set_slice (( 64 :: int)::ii) (( 1 :: int)::ii) desc (( 10 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)  ::  64 Word.word)
           else desc) in
         (let (desc :: 64 bits) =
           (if hw_update_AP then
             (set_slice (( 64 :: int)::ii) (( 1 :: int)::ii) desc (( 7 :: int)::ii)
                (if secondstage then (vec_of_bits [B1]  ::  1 Word.word)
                 else (vec_of_bits [B0]  ::  1 Word.word))
               ::  64 Word.word)
           else desc) in
         (if reversedescriptors then liftR ((BigEndianReverse desc  :: ( 64 Word.word) M))
          else return desc) \<bind> (\<lambda> (desc :: 64 bits) . 
         liftR (aset__Mem descaddr2 (( 8 :: int)::ii) accdesc desc)))))))))))
       else return () ) \<then>
      return fault)))))))))))))"


(*val AArch64_BreakpointValueMatch : ii -> mword ty64 -> bool -> bool*)

definition AArch64_BreakpointValueMatch  :: " int \<Rightarrow>(64)Word.word \<Rightarrow> bool \<Rightarrow> bool "  where 
     " AArch64_BreakpointValueMatch n__arg vaddress linked_to = ( False )"


(*val AArch64_StateMatch : mword ty2 -> mword ty1 -> mword ty2 -> bool -> mword ty4 -> bool -> bool -> M bool*)

definition AArch64_StateMatch  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow> bool \<Rightarrow>(4)Word.word \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " AArch64_StateMatch SSC__arg HMC__arg PxC__arg linked__arg LBN isbreakpnt ispriv = (
   catch_early_return
     ((let HMC = HMC__arg in
     (let PxC = PxC__arg in
     (let SSC = SSC__arg in
     (let linked = linked__arg in
     liftR (undefined_Constraint () ) \<bind> (\<lambda> (c :: Constraint) . 
     (if ((((((((((((((((((((and_vec
                                     ((concat_vec ((concat_vec HMC SSC  ::  3 Word.word)) PxC
                                        ::  5 Word.word)) (vec_of_bits [B1,B1,B1,B0,B0]  ::  5 Word.word)
                                    ::  5 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0]  ::  5 Word.word)))) \<or> ((((((((and_vec
                                         ((concat_vec ((concat_vec HMC SSC  ::  3 Word.word)) PxC
                                            ::  5 Word.word))
                                         (vec_of_bits [B1,B1,B1,B0,B1]  ::  5 Word.word)
                                        ::  5 Word.word)) = (vec_of_bits [B1,B0,B0,B0,B0]  ::  5 Word.word)))) \<or> ((((((((and_vec
                                             ((concat_vec ((concat_vec HMC SSC  ::  3 Word.word)) PxC
                                                ::  5 Word.word))
                                             (vec_of_bits [B1,B1,B1,B0,B1]  ::  5 Word.word)
                                            ::  5 Word.word)) = (vec_of_bits [B1,B0,B1,B0,B0]  ::  5 Word.word)))) \<or> ((((((((concat_vec ((concat_vec HMC SSC  ::  3 Word.word)) PxC
                                                ::  5 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B0]  ::  5 Word.word)))) \<or> ((((((((concat_vec ((concat_vec HMC SSC  ::  3 Word.word))
                                                     PxC
                                                    ::  5 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B1]  ::  5 Word.word)))) \<or> (((((and_vec
                                                     ((concat_vec
                                                         ((concat_vec HMC SSC  ::  3 Word.word)) PxC
                                                        ::  5 Word.word))
                                                     (vec_of_bits [B1,B1,B1,B1,B0]  ::  5 Word.word)
                                                    ::  5 Word.word)) = (vec_of_bits [B1,B1,B1,B1,B0]  ::  5 Word.word))))))))))))))))))) \<or> (((((((((HMC = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((PxC = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) \<and> (((((\<not> isbreakpnt)) \<or> ((\<not> ((HaveAArch32EL EL1))))))))))))) \<or> (((((((((SSC = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<or> (((SSC = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) \<and> ((\<not> ((HaveEL EL3)))))))))) \<or> ((((((((((((((concat_vec HMC SSC  ::  3 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((concat_vec HMC SSC  ::  3 Word.word)) \<noteq> (vec_of_bits [B1,B1,B1]  ::  3 Word.word))))))) \<and> ((\<not> ((HaveEL EL3))))))) \<and> ((\<not> ((HaveEL EL2)))))))))) \<or> ((((((((concat_vec ((concat_vec HMC SSC  ::  3 Word.word)) PxC  ::  5 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B0]  ::  5 Word.word)))) \<and> ((\<not> ((HaveEL EL2)))))))))) then
        liftR ((undefined_bitvector (( 5 :: int)::ii)  :: ( 5 Word.word) M)) \<bind> (\<lambda> (tmp_50 :: 5 bits) . 
        liftR ((ConstrainUnpredictableBits (( 5 :: int)::ii) Unpredictable_RESBPWPCTRL
                 :: ((Constraint *  5 Word.word)) M)) \<bind> (\<lambda> (w__0 :: (Constraint *  5 Word.word)) . 
        (let (tup__0, tup__1) = w__0 in
        (let c = tup__0 in
        (let tmp_50 = tup__1 in
        (let (tmp_60 :: 5 bits) = tmp_50 in
        (let HMC = ((vec_of_bits [access_vec_dec tmp_60 (( 4 :: int)::ii)]  ::  1 Word.word)) in
        (let (tmp_70 :: 4 bits) = ((slice tmp_60 (( 0 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) in
        (let SSC = ((slice tmp_70 (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) in
        (let PxC = ((slice tmp_70 (( 0 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) in
        (liftR (assert_exp ((((((c = Constraint_DISABLED))) \<or> (((c = Constraint_UNKNOWN)))))) (''((c == Constraint_DISABLED) || (c == Constraint_UNKNOWN))'')) \<then>
        (if (((c = Constraint_DISABLED))) then (early_return False :: (unit, bool) MR)
         else return () )) \<then>
        return (HMC, PxC, SSC, c)))))))))))
      else return (HMC, PxC, SSC, c)) \<bind> (\<lambda> varstup .  (let ((HMC ::  1 Word.word), (PxC ::  2 Word.word), (SSC ::
        2 Word.word), (c :: Constraint)) = varstup in
     (let (EL3_match :: bool) =
       ((((((HaveEL EL3)) \<and> (((HMC = (vec_of_bits [B1]  ::  1 Word.word))))))) \<and> ((((vec_of_bits [access_vec_dec SSC (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))) in
     (let (EL2_match :: bool) = (((HaveEL EL2)) \<and> (((HMC = (vec_of_bits [B1]  ::  1 Word.word))))) in
     (let (EL1_match :: bool) =
       ((vec_of_bits [access_vec_dec PxC (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
     (let (EL0_match :: bool) =
       ((vec_of_bits [access_vec_dec PxC (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
     liftR (undefined_bool () ) \<bind> (\<lambda> (priv_match :: bool) . 
     (if (((((\<not> ispriv)) \<and> ((\<not> isbreakpnt))))) then return EL0_match
      else
        liftR (read_reg PSTATE_ref) \<bind> (\<lambda> (w__1 :: ProcState) . 
        (let p__294 = ((ProcState_EL   w__1)) in
        (let pat0 = p__294 in
        (let (priv_match :: bool) =
          (if (((pat0 = EL3))) then EL3_match
          else if (((pat0 = EL2))) then EL2_match
          else if (((pat0 = EL1))) then EL1_match
          else EL0_match) in
        return priv_match))))) \<bind> (\<lambda> (priv_match :: bool) . 
     liftR (undefined_bool () ) \<bind> (\<lambda> (security_state_match :: bool) . 
     (let b__0 = SSC in
     (if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then return True
      else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
        liftR (IsSecure () ) \<bind> (\<lambda> (w__2 :: bool) . 
        (let (security_state_match :: bool) = (\<not> w__2) in
        return security_state_match))
      else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then liftR (IsSecure () )
      else return True) \<bind> (\<lambda> (security_state_match :: bool) . 
     liftR (undefined_int () ) \<bind> (\<lambda> (last_ctx_cmp :: ii) . 
     liftR (undefined_int () ) \<bind> (\<lambda> (first_ctx_cmp :: ii) . 
     liftR (undefined_int () ) \<bind> (\<lambda> (lbn :: ii) . 
     (if linked then
        (let lbn = (Word.uint LBN) in
        liftR ((read_reg ID_AA64DFR0_EL1_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__4 :: 64 bits) . 
        liftR ((read_reg ID_AA64DFR0_EL1_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__5 :: 64 bits) . 
        (let first_ctx_cmp =
          (((Word.uint ((slice w__4 (( 12 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)))) -
            ((Word.uint ((slice w__5 (( 28 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))))) in
        liftR ((read_reg ID_AA64DFR0_EL1_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__6 :: 64 bits) . 
        (let last_ctx_cmp = (Word.uint ((slice w__6 (( 12 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))) in
        if (((((((ex_int lbn)) < ((ex_int first_ctx_cmp)))) \<or> ((((ex_int lbn)) > ((ex_int last_ctx_cmp))))))) then
          liftR (ConstrainUnpredictableInteger first_ctx_cmp last_ctx_cmp Unpredictable_BPNOTCTXCMP) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1) = varstup in
          (let c = tup__0 in
          (let lbn = tup__1 in
          (liftR (assert_exp ((((((c = Constraint_DISABLED))) \<or> ((((((c = Constraint_NONE))) \<or> (((c = Constraint_UNKNOWN))))))))) (''((c == Constraint_DISABLED) || ((c == Constraint_NONE) || (c == Constraint_UNKNOWN)))'')) \<then>
          (case  c of
            Constraint_DISABLED => (early_return False :: (unit, bool) MR) \<then> return linked
          | Constraint_NONE => return False
          )) \<bind> (\<lambda> (linked :: bool) . 
          return (lbn, linked))))))
        else return (lbn, linked)))))))
      else return (lbn, linked)) \<bind> (\<lambda> varstup .  (let ((lbn :: ii), (linked :: bool)) = varstup in
     liftR (undefined_bool () ) \<bind> (\<lambda> (linked_match :: bool) . 
     liftR (undefined_bool () ) \<bind> (\<lambda> (linked_to :: bool) . 
     liftR ((undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (vaddress :: 64 bits) . 
     (if linked then
        liftR ((undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__7 ::  64 Word.word) . 
        (let (vaddress :: 64 bits) = w__7 in
        (let (linked_to :: bool) = True in
        (let (linked_match :: bool) = (AArch64_BreakpointValueMatch lbn vaddress linked_to) in
        return linked_match))))
      else return linked_match) \<bind> (\<lambda> (linked_match :: bool) . 
     return ((((((priv_match \<and> security_state_match))) \<and> (((((\<not> linked)) \<or> linked_match)))))))))))))))))))))))))))))))))"


(*val AArch64_WatchpointMatch : ii -> mword ty64 -> ii -> bool -> bool -> M bool*)

definition AArch64_WatchpointMatch  :: " int \<Rightarrow>(64)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " AArch64_WatchpointMatch n vaddress size1 ispriv iswrite = (
   (S1TranslationRegime__1 ()   :: ( 2 Word.word) M) \<bind> (\<lambda> (w__0 ::  2 Word.word) . 
   ELUsingAArch32 w__0 \<bind> (\<lambda> (w__1 :: bool) . 
   (assert_exp ((\<not> w__1)) (''!(ELUsingAArch32(S1TranslationRegime()))'') \<then>
   (read_reg ID_AA64DFR0_EL1_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__2 :: 64 bits) . 
   (assert_exp ((n \<le> ((Word.uint ((slice w__2 (( 20 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)))))) (''(n <= UInt((ID_AA64DFR0_EL1).WRPs))'') \<then>
   read_reg DBGWCR_EL1_ref) \<bind> (\<lambda> (w__3 :: ( 32 bits) list) . 
   (let (enabled :: bool) =
     ((vec_of_bits [access_vec_dec ((access_list_dec w__3 n  ::  32 Word.word)) (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
   read_reg DBGWCR_EL1_ref \<bind> (\<lambda> (w__4 :: ( 32 bits) list) . 
   (let (linked :: bool) =
     ((vec_of_bits [access_vec_dec ((access_list_dec w__4 n  ::  32 Word.word)) (( 20 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
   (let (isbreakpnt :: bool) = False in
   read_reg DBGWCR_EL1_ref \<bind> (\<lambda> (w__5 :: ( 32 bits) list) . 
   read_reg DBGWCR_EL1_ref \<bind> (\<lambda> (w__6 :: ( 32 bits) list) . 
   read_reg DBGWCR_EL1_ref \<bind> (\<lambda> (w__7 :: ( 32 bits) list) . 
   read_reg DBGWCR_EL1_ref \<bind> (\<lambda> (w__8 :: ( 32 bits) list) . 
   AArch64_StateMatch ((slice ((access_list_dec w__5 n  ::  32 Word.word)) (( 14 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))
     (vec_of_bits [access_vec_dec ((access_list_dec w__6 n  ::  32 Word.word)) (( 13 :: int)::ii)]  ::  1 Word.word)
     ((slice ((access_list_dec w__7 n  ::  32 Word.word)) (( 1 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) linked
     ((slice ((access_list_dec w__8 n  ::  32 Word.word)) (( 16 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) isbreakpnt
     ispriv \<bind> (\<lambda> (state_match :: bool) . 
   read_reg DBGWCR_EL1_ref \<bind> (\<lambda> (w__9 :: ( 32 bits) list) . 
   (let (ls_match :: bool) =
     ((vec_of_bits [access_vec_dec
                       ((slice ((access_list_dec w__9 n  ::  32 Word.word)) (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))
                       (if iswrite then (( 1 :: int)::ii)
                        else (( 0 :: int)::ii))]
         ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
   (let (value_match_name :: bool) = False in
   (foreachM (index_list (( 0 :: int)::ii) ((size1 - (( 1 :: int)::ii))) (( 1 :: int)::ii)) value_match_name
     (\<lambda> byte value_match_name . 
       or_boolM (return value_match_name)
         ((AArch64_WatchpointByteMatch n ((add_vec_int vaddress byte  ::  64 Word.word)))))) \<bind> (\<lambda> (value_match_name ::
     bool) . 
   return (((((((((value_match_name \<and> state_match))) \<and> ls_match))) \<and> enabled)))))))))))))))))))))"


(*val AArch64_BreakpointMatch : ii -> mword ty64 -> ii -> M bool*)

definition AArch64_BreakpointMatch  :: " int \<Rightarrow>(64)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " AArch64_BreakpointMatch n vaddress size1 = (
   (S1TranslationRegime__1 ()   :: ( 2 Word.word) M) \<bind> (\<lambda> (w__0 ::  2 Word.word) . 
   ELUsingAArch32 w__0 \<bind> (\<lambda> (w__1 :: bool) . 
   (assert_exp ((\<not> w__1)) (''!(ELUsingAArch32(S1TranslationRegime()))'') \<then>
   (read_reg ID_AA64DFR0_EL1_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__2 :: 64 bits) . 
   (assert_exp ((n \<le> ((Word.uint ((slice w__2 (( 12 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)))))) (''(n <= UInt((ID_AA64DFR0_EL1).BRPs))'') \<then>
   read_reg DBGBCR_EL1_ref) \<bind> (\<lambda> (w__3 :: ( 32 bits) list) . 
   (let (enabled :: bool) =
     ((vec_of_bits [access_vec_dec ((access_list_dec w__3 n  ::  32 Word.word)) (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
   read_reg PSTATE_ref \<bind> (\<lambda> (w__4 :: ProcState) . 
   (let (ispriv :: bool) = ((ProcState_EL   w__4) \<noteq> EL0) in
   read_reg DBGBCR_EL1_ref \<bind> (\<lambda> (w__5 :: ( 32 bits) list) . 
   (let (linked :: bool) =
     (((and_vec ((slice ((access_list_dec w__5 n  ::  32 Word.word)) (( 20 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))
           (vec_of_bits [B1,B0,B1,B1]  ::  4 Word.word)
          ::  4 Word.word)) = (vec_of_bits [B0,B0,B0,B1]  ::  4 Word.word)) in
   (let (isbreakpnt :: bool) = True in
   (let (linked_to :: bool) = False in
   read_reg DBGBCR_EL1_ref \<bind> (\<lambda> (w__6 :: ( 32 bits) list) . 
   read_reg DBGBCR_EL1_ref \<bind> (\<lambda> (w__7 :: ( 32 bits) list) . 
   read_reg DBGBCR_EL1_ref \<bind> (\<lambda> (w__8 :: ( 32 bits) list) . 
   read_reg DBGBCR_EL1_ref \<bind> (\<lambda> (w__9 :: ( 32 bits) list) . 
   AArch64_StateMatch ((slice ((access_list_dec w__6 n  ::  32 Word.word)) (( 14 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))
     (vec_of_bits [access_vec_dec ((access_list_dec w__7 n  ::  32 Word.word)) (( 13 :: int)::ii)]  ::  1 Word.word)
     ((slice ((access_list_dec w__8 n  ::  32 Word.word)) (( 1 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) linked
     ((slice ((access_list_dec w__9 n  ::  32 Word.word)) (( 16 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) isbreakpnt
     ispriv \<bind> (\<lambda> (state_match :: bool) . 
   (let (value_match_name :: bool) = (AArch64_BreakpointValueMatch n vaddress linked_to) in
   undefined_bool ()  \<bind> (\<lambda> (match_i :: bool) . 
   (if (((((HaveAnyAArch32 () )) \<and> (((size1 = (( 4 :: int)::ii))))))) then
      (let match_i =
        (AArch64_BreakpointValueMatch n ((add_vec_int vaddress (( 2 :: int)::ii)  ::  64 Word.word)) linked_to) in
      if (((((\<not> value_match_name)) \<and> match_i))) then
        ConstrainUnpredictableBool Unpredictable_BPMATCHHALF
      else return value_match_name)
    else return value_match_name) \<bind> (\<lambda> (value_match_name :: bool) . 
   and_boolM
     (return ((((vec_of_bits [access_vec_dec vaddress (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))
     (read_reg DBGBCR_EL1_ref \<bind> (\<lambda> (w__11 :: ( 32 bits) list) . 
      return (((((slice ((access_list_dec w__11 n  ::  32 Word.word)) (( 5 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) = (vec_of_bits [B1,B1,B1,B1]  ::  4 Word.word)))))) \<bind> (\<lambda> (w__12 :: bool) . 
   (if w__12 then
      if value_match_name then ConstrainUnpredictableBool Unpredictable_BPMATCHHALF
      else return value_match_name
    else return value_match_name) \<bind> (\<lambda> (value_match_name :: bool) . 
   (let (val_match :: bool) = ((((value_match_name \<and> state_match))) \<and> enabled) in
   return val_match)))))))))))))))))))))))"


(*val AArch64_CheckBreakpoint : mword ty64 -> ii -> M FaultRecord*)

definition AArch64_CheckBreakpoint  :: "(64)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(FaultRecord),(exception))monad "  where 
     " AArch64_CheckBreakpoint vaddress size1 = (
   (S1TranslationRegime__1 ()   :: ( 2 Word.word) M) \<bind> (\<lambda> (w__0 ::  2 Word.word) . 
   ELUsingAArch32 w__0 \<bind> (\<lambda> (w__1 :: bool) . 
   (assert_exp ((\<not> w__1)) (''!(ELUsingAArch32(S1TranslationRegime()))'') \<then>
   or_boolM
     (and_boolM ((UsingAArch32 () )) (return ((((((size1 = (( 2 :: int)::ii)))) \<or> (((size1 = (( 4 :: int)::ii)))))))))
     (return (((size1 = (( 4 :: int)::ii)))))) \<bind> (\<lambda> (w__4 :: bool) . 
   assert_exp w__4 (''((UsingAArch32() && ((size == 2) || (size == 4))) || (size == 4))'') \<then>
   ((let (val_match :: bool) = False in
   undefined_bool ()  \<bind> (\<lambda> (match_i :: bool) . 
   (read_reg ID_AA64DFR0_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 :: 64 bits) . 
   (foreachM (index_list (( 0 :: int)::ii) ((Word.uint ((slice w__5 (( 12 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)))) (( 1 :: int)::ii)) (match_i,
                                                                                             val_match)
     (\<lambda> i varstup .  (let (match_i, val_match) = varstup in
       AArch64_BreakpointMatch i vaddress size1 \<bind> (\<lambda> (w__6 :: bool) . 
       (let (match_i :: bool) = w__6 in
       (let (val_match :: bool) = (val_match \<or> match_i) in
       return (match_i, val_match))))))) \<bind> (\<lambda> varstup .  (let ((match_i :: bool), (val_match :: bool)) = varstup in
   undefined_bool ()  \<bind> (\<lambda> (iswrite :: bool) . 
   undefined_AccType ()  \<bind> (\<lambda> (acctype :: AccType) . 
   (undefined_bitvector (( 6 :: int)::ii)  :: ( 6 Word.word) M) \<bind> (\<lambda> (reason :: 6 bits) . 
   and_boolM (return val_match) ((HaltOnBreakpointOrWatchpoint () )) \<bind> (\<lambda> (w__8 :: bool) . 
   if w__8 then
     (let reason = DebugHalt_Breakpoint in
     (Halt reason \<then> undefined_FaultRecord () ) \<bind> (\<lambda> (w__9 :: FaultRecord) .  return w__9))
   else
     and_boolM
       (and_boolM (return val_match)
          ((read_reg MDSCR_EL1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__10 :: 32 bits) . 
           return ((((vec_of_bits [access_vec_dec w__10 (( 15 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))) ((AArch64_GenerateDebugExceptions () )) \<bind> (\<lambda> (w__13 ::
       bool) . 
     if w__13 then
       (let acctype = AccType_IFETCH in
       (let iswrite = False in
       AArch64_DebugFault acctype iswrite))
     else AArch64_NoFault () )))))))))))))))"


(*val AArch64_BranchAddr : mword ty64 -> M (mword ty64)*)

definition AArch64_BranchAddr  :: "(64)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " AArch64_BranchAddr vaddress = (
   UsingAArch32 ()  \<bind> (\<lambda> (w__0 :: bool) . 
   (assert_exp ((\<not> w__0)) (''!(UsingAArch32())'') \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__1 :: ProcState) . 
   AddrTop vaddress True(ProcState_EL   w__1) \<bind> (\<lambda> (w__2 :: ii) . 
   coerce_int_nat w__2 \<bind> (\<lambda> (msbit :: ii) . 
   if (((((ex_nat msbit)) = (( 63 :: int)::ii)))) then return vaddress
   else
     and_boolM
       (or_boolM
          (or_boolM
             (read_reg PSTATE_ref \<bind> (\<lambda> (w__3 :: ProcState) . 
              return ((((ProcState_EL   w__3) = EL0)))))
             (read_reg PSTATE_ref \<bind> (\<lambda> (w__4 :: ProcState) . 
              return ((((ProcState_EL   w__4) = EL1)))))) ((IsInHost () )))
       (return ((((vec_of_bits [access_vec_dec vaddress msbit]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))) \<bind> (\<lambda> (w__8 :: bool) . 
     return (if w__8 then
               (sext_slice (( 64 :: int)::ii) vaddress (( 0 :: int)::ii) ((((ex_nat msbit)) + (( 1 :: int)::ii)))
                 ::  64 Word.word)
             else
               (zext_slice (( 64 :: int)::ii) vaddress (( 0 :: int)::ii) ((((ex_nat msbit)) + (( 1 :: int)::ii)))
                 ::  64 Word.word))))))))"


(*val BranchTo : forall 'N . Size 'N => mword 'N -> BranchType -> M unit*)

definition BranchTo  :: "('N::len)Word.word \<Rightarrow> BranchType \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " BranchTo target branch_type = (
   write_reg BranchTaken_ref True \<then>
   ((let (_ :: unit) = (Hint_Branch branch_type) in
   if (((((int (size target))) = (( 32 :: int)::ii)))) then
     (let (target ::  32 Word.word) = ((Word.ucast target  ::  32 Word.word)) in
     UsingAArch32 ()  \<bind> (\<lambda> (w__0 :: bool) . 
     (assert_exp w__0 (''UsingAArch32()'') \<then>
     (ZeroExtend__1 (( 64 :: int)::ii) target  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
     write_reg PC_ref w__1)))
   else
     and_boolM (return (((((int (size target))) = (( 64 :: int)::ii)))))
       (UsingAArch32 ()  \<bind> (\<lambda> (w__2 :: bool) .  return ((\<not> w__2)))) \<bind> (\<lambda> (w__3 :: bool) . 
     (assert_exp w__3 (''((N == 64) && !(UsingAArch32()))'') \<then>
     (AArch64_BranchAddr ((slice target (( 0 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__4 ::
        64 Word.word) . 
     write_reg PC_ref w__4)))))"


(*val aarch64_branch_unconditional_immediate : BranchType -> mword ty64 -> M unit*)

definition aarch64_branch_unconditional_immediate  :: " BranchType \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_branch_unconditional_immediate branch_type offset = (
   ((if (((branch_type = BranchType_CALL))) then
      (aget_PC ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
      aset_X (( 30 :: int)::ii) ((add_vec_int w__0 (( 4 :: int)::ii)  ::  64 Word.word)))
    else return () ) \<then>
   (aget_PC ()   :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   BranchTo ((add_vec w__1 offset  ::  64 Word.word)) branch_type))"


(*val branch_unconditional_immediate_decode : mword ty1 -> mword ty26 -> M unit*)

definition branch_unconditional_immediate_decode  :: "(1)Word.word \<Rightarrow>(26)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " branch_unconditional_immediate_decode op1 imm26 = (
   write_reg unconditional_ref True \<then>
   ((let (branch_type :: BranchType) =
     (if (((op1 = (vec_of_bits [B1]  ::  1 Word.word)))) then BranchType_CALL
     else BranchType_JMP) in
   (SignExtend__0 ((concat_vec imm26 (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  28 Word.word))
      ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
     :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
   aarch64_branch_unconditional_immediate branch_type offset))))"


(*val aarch64_branch_conditional_test : ii -> mword ty1 -> ii -> mword ty64 -> ii -> M unit*)

definition aarch64_branch_conditional_test  :: " int \<Rightarrow>(1)Word.word \<Rightarrow> int \<Rightarrow>(64)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_branch_conditional_test bit_pos bit_val l__143 offset t = (
   if (((l__143 = (( 8 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 8 :: int)::ii) t  :: ( 8 Word.word) M)) \<bind> (\<lambda> (operand :: 8 bits) . 
     if ((((vec_of_bits [access_vec_dec operand bit_pos]  ::  1 Word.word) = bit_val))) then
       (aget_PC ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
       BranchTo ((add_vec w__0 offset  ::  64 Word.word)) BranchType_JMP)
     else return () ))
   else if (((l__143 = (( 16 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 16 :: int)::ii) t  :: ( 16 Word.word) M)) \<bind> (\<lambda> (operand :: 16 bits) . 
     if ((((vec_of_bits [access_vec_dec operand bit_pos]  ::  1 Word.word) = bit_val))) then
       (aget_PC ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
       BranchTo ((add_vec w__1 offset  ::  64 Word.word)) BranchType_JMP)
     else return () ))
   else if (((l__143 = (( 32 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 32 :: int)::ii) t  :: ( 32 Word.word) M)) \<bind> (\<lambda> (operand :: 32 bits) . 
     if ((((vec_of_bits [access_vec_dec operand bit_pos]  ::  1 Word.word) = bit_val))) then
       (aget_PC ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::  64 Word.word) . 
       BranchTo ((add_vec w__2 offset  ::  64 Word.word)) BranchType_JMP)
     else return () ))
   else if (((l__143 = (( 64 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 64 :: int)::ii) t  :: ( 64 Word.word) M)) \<bind> (\<lambda> (operand :: 64 bits) . 
     if ((((vec_of_bits [access_vec_dec operand bit_pos]  ::  1 Word.word) = bit_val))) then
       (aget_PC ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::  64 Word.word) . 
       BranchTo ((add_vec w__3 offset  ::  64 Word.word)) BranchType_JMP)
     else return () ))
   else if (((l__143 = (( 128 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 128 :: int)::ii) t  :: ( 128 Word.word) M)) \<bind> (\<lambda> (operand :: 128 bits) . 
     if ((((vec_of_bits [access_vec_dec operand bit_pos]  ::  1 Word.word) = bit_val))) then
       (aget_PC ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 ::  64 Word.word) . 
       BranchTo ((add_vec w__4 offset  ::  64 Word.word)) BranchType_JMP)
     else return () ))
   else
     (let dbytes = (ex_int ((l__143 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))"


(*val branch_conditional_test_decode : mword ty1 -> mword ty1 -> mword ty5 -> mword ty14 -> mword ty5 -> M unit*)

definition branch_conditional_test_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(14)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " branch_conditional_test_decode b5 op1 b40 imm14 Rt = (
   write_reg unconditional_ref True \<then>
   ((let (t :: ii) = (Word.uint Rt) in
   (let (datasize :: int) =
     (if (((b5 = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 64 :: int)::ii)
     else (( 32 :: int)::ii)) in
   (let (bit_pos :: ii) = (Word.uint ((concat_vec b5 b40  ::  6 Word.word))) in
   (let (bit_val :: 1 bits) = op1 in
   (SignExtend__0 ((concat_vec imm14 (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  16 Word.word))
      ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
     :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
   aarch64_branch_conditional_test bit_pos bit_val datasize offset t)))))))"


(*val aarch64_branch_conditional_cond : mword ty4 -> mword ty64 -> M unit*)

definition aarch64_branch_conditional_cond  :: "(4)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_branch_conditional_cond condition offset = (
   ConditionHolds condition \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then
     (aget_PC ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
     BranchTo ((add_vec w__1 offset  ::  64 Word.word)) BranchType_JMP)
   else return () ))"


(*val branch_conditional_cond_decode : mword ty1 -> mword ty19 -> mword ty1 -> mword ty4 -> M unit*)

definition branch_conditional_cond_decode  :: "(1)Word.word \<Rightarrow>(19)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " branch_conditional_cond_decode o1 imm19 o0 cond = (
   (write_reg unconditional_ref True \<then>
   (SignExtend__0 ((concat_vec imm19 (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  21 Word.word))
      ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
     :: ( 64 Word.word) M)) \<bind> (\<lambda> (offset :: 64 bits) . 
   (let (condition :: 4 bits) = cond in
   aarch64_branch_conditional_cond condition offset)))"


(*val aarch64_branch_conditional_compare : ii -> bool -> mword ty64 -> ii -> M unit*)

definition aarch64_branch_conditional_compare  :: " int \<Rightarrow> bool \<Rightarrow>(64)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_branch_conditional_compare l__138 iszero1 offset t = (
   if (((l__138 = (( 8 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 8 :: int)::ii) t  :: ( 8 Word.word) M)) \<bind> (\<lambda> (operand1 :: 8 bits) . 
     if (((((IsZero operand1)) = iszero1))) then
       (aget_PC ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
       BranchTo ((add_vec w__0 offset  ::  64 Word.word)) BranchType_JMP)
     else return () ))
   else if (((l__138 = (( 16 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 16 :: int)::ii) t  :: ( 16 Word.word) M)) \<bind> (\<lambda> (operand1 :: 16 bits) . 
     if (((((IsZero operand1)) = iszero1))) then
       (aget_PC ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
       BranchTo ((add_vec w__1 offset  ::  64 Word.word)) BranchType_JMP)
     else return () ))
   else if (((l__138 = (( 32 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 32 :: int)::ii) t  :: ( 32 Word.word) M)) \<bind> (\<lambda> (operand1 :: 32 bits) . 
     if (((((IsZero operand1)) = iszero1))) then
       (aget_PC ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::  64 Word.word) . 
       BranchTo ((add_vec w__2 offset  ::  64 Word.word)) BranchType_JMP)
     else return () ))
   else if (((l__138 = (( 64 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 64 :: int)::ii) t  :: ( 64 Word.word) M)) \<bind> (\<lambda> (operand1 :: 64 bits) . 
     if (((((IsZero operand1)) = iszero1))) then
       (aget_PC ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::  64 Word.word) . 
       BranchTo ((add_vec w__3 offset  ::  64 Word.word)) BranchType_JMP)
     else return () ))
   else if (((l__138 = (( 128 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (aget_X (( 128 :: int)::ii) t  :: ( 128 Word.word) M)) \<bind> (\<lambda> (operand1 :: 128 bits) . 
     if (((((IsZero operand1)) = iszero1))) then
       (aget_PC ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 ::  64 Word.word) . 
       BranchTo ((add_vec w__4 offset  ::  64 Word.word)) BranchType_JMP)
     else return () ))
   else
     (let dbytes = (ex_int ((l__138 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))"


(*val branch_conditional_compare_decode : mword ty1 -> mword ty1 -> mword ty19 -> mword ty5 -> M unit*)

definition branch_conditional_compare_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(19)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " branch_conditional_compare_decode sf op1 imm19 Rt = (
   write_reg unconditional_ref True \<then>
   ((let (t :: ii) = (Word.uint Rt) in
   (let (datasize :: int) =
     (if (((sf = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 64 :: int)::ii)
     else (( 32 :: int)::ii)) in
   (let (iszero1 :: bool) = (op1 = (vec_of_bits [B0]  ::  1 Word.word)) in
   (SignExtend__0 ((concat_vec imm19 (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  21 Word.word))
      ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
     :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
   aarch64_branch_conditional_compare datasize iszero1 offset t))))))"


(*val AArch64_TakeReset : bool -> M unit*)

definition AArch64_TakeReset  :: " bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_TakeReset cold_reset = (
   (assert_exp ((\<not> ((HighestELUsingAArch32 () )))) (''!(HighestELUsingAArch32())'') \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__0 :: ProcState) . 
   (write_reg PSTATE_ref (w__0 (| ProcState_nRW := ((vec_of_bits [B0]  ::  1 Word.word))|)) \<then>
   (if ((HaveEL EL3)) then
      read_reg PSTATE_ref \<bind> (\<lambda> (w__1 :: ProcState) . 
      write_reg PSTATE_ref (w__1 (| ProcState_EL := EL3 |)))
    else if ((HaveEL EL2)) then
      read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) . 
      write_reg PSTATE_ref (w__2 (| ProcState_EL := EL2 |)))
    else
      read_reg PSTATE_ref \<bind> (\<lambda> (w__3 :: ProcState) . 
      write_reg PSTATE_ref (w__3 (| ProcState_EL := EL1 |))))) \<then>
   ((let (_ :: unit) = (AArch64_ResetControlRegisters cold_reset) in
   read_reg PSTATE_ref \<bind> (\<lambda> (w__4 :: ProcState) . 
   write_reg PSTATE_ref (w__4 (| ProcState_SP := ((vec_of_bits [B1]  ::  1 Word.word))|)) \<then>
   ((let split_vec = ((vec_of_bits [B1,B1,B1,B1]  ::  4 Word.word)) in
   (let (tup__0, tup__1, tup__2, tup__3) =
     ((subrange_vec_dec split_vec (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
      (subrange_vec_dec split_vec (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
      (subrange_vec_dec split_vec (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
      (subrange_vec_dec split_vec (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
   read_reg PSTATE_ref \<bind> (\<lambda> (w__5 :: ProcState) . 
   (write_reg PSTATE_ref (w__5 (| ProcState_D := tup__0 |)) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__6 :: ProcState) . 
   (write_reg PSTATE_ref (w__6 (| ProcState_A := tup__1 |)) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__7 :: ProcState) . 
   (write_reg PSTATE_ref (w__7 (| ProcState_I := tup__2 |)) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__8 :: ProcState) . 
   (write_reg PSTATE_ref (w__8 (| ProcState_F := tup__3 |)) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__9 :: ProcState) . 
   (write_reg PSTATE_ref (w__9 (| ProcState_SS := ((vec_of_bits [B0]  ::  1 Word.word))|)) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__10 :: ProcState) . 
   (((write_reg PSTATE_ref (w__10 (| ProcState_IL := ((vec_of_bits [B0]  ::  1 Word.word))|)) \<then>
   AArch64_ResetGeneralRegisters () ) \<then>
   AArch64_ResetSIMDFPRegisters () ) \<then>
   AArch64_ResetSpecialRegisters () ) \<then>
   ((let (_ :: unit) = (ResetExternalDebugRegisters cold_reset) in
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (rv :: 64 bits) . 
   (if ((HaveEL EL3)) then (read_reg RVBAR_EL3_ref  :: ( 64 Word.word) M)
    else if ((HaveEL EL2)) then (read_reg RVBAR_EL2_ref  :: ( 64 Word.word) M)
    else (read_reg RVBAR_EL1_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (rv :: 64 bits) . 
   and_boolM ((IsZero_slice rv ((PAMax () )) (((( 64 :: int)::ii) - ((ex_int ((PAMax () ))))))))
     ((IsZero_slice rv (( 0 :: int)::ii) (( 2 :: int)::ii))) \<bind> (\<lambda> (w__16 :: bool) . 
   assert_exp w__16 (''(IsZero((rv)<PAMax()+:((63 - PAMax()) + 1)>) && IsZero((rv)<0+:((1 - 0) + 1)>))'') \<then>
   BranchTo rv BranchType_UNKNOWN)))))))))))))))))))"


(*val __TakeColdReset : unit -> M unit*)

definition TakeColdReset  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " TakeColdReset _ = (
   read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) . 
   (write_reg PSTATE_ref (w__0 (| ProcState_nRW := ((vec_of_bits [B0]  ::  1 Word.word))|)) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__1 :: ProcState) . 
   (((write_reg PSTATE_ref (w__1 (| ProcState_SS := ((vec_of_bits [B0]  ::  1 Word.word))|)) \<then>
   ResetInterruptState () ) \<then>
   ResetMemoryState () ) \<then> ResetExecuteState () ) \<then> AArch64_TakeReset True)))"


(*val AArch64_TakeException : mword ty2 -> ExceptionRecord -> mword ty64 -> ii -> M unit*)

definition AArch64_TakeException  :: "(2)Word.word \<Rightarrow> ExceptionRecord \<Rightarrow>(64)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_TakeException target_el exception preferred_exception_return vect_offset__arg = (
   (let (vect_offset :: ii) = vect_offset__arg in
   (let (_ :: unit) = (SynchronizeContext () ) in
   and_boolM
     (and_boolM (return ((HaveEL target_el)))
        (ELUsingAArch32 target_el \<bind> (\<lambda> (w__0 :: bool) .  return ((\<not> w__0)))))
     (read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) . 
      return ((((Word.uint target_el)) \<ge> ((Word.uint(ProcState_EL   w__2))))))) \<bind> (\<lambda> (w__3 :: bool) . 
   (assert_exp w__3 (''((HaveEL(target_el) && !(ELUsingAArch32(target_el))) && (UInt(target_el) >= UInt((PSTATE).EL)))'') \<then>
   UsingAArch32 () ) \<bind> (\<lambda> (from_32 :: bool) . 
   ((if from_32 then AArch64_MaybeZeroRegisterUppers () 
    else return () ) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__4 :: ProcState) . 
   (if ((((Word.uint target_el)) > ((Word.uint(ProcState_EL   w__4))))) then
      undefined_bool ()  \<bind> (\<lambda> (lower_32 :: bool) . 
      (if (((target_el = EL3))) then
         and_boolM (IsSecure ()  \<bind> (\<lambda> (w__5 :: bool) .  return ((\<not> w__5))))
           (return ((HaveEL EL2))) \<bind> (\<lambda> (w__6 :: bool) . 
         if w__6 then ELUsingAArch32 EL2
         else ELUsingAArch32 EL1)
       else
         and_boolM
           (and_boolM ((IsInHost () ))
              (read_reg PSTATE_ref \<bind> (\<lambda> (w__10 :: ProcState) . 
               return ((((ProcState_EL   w__10) = EL0)))))) (return (((target_el = EL2)))) \<bind> (\<lambda> (w__12 ::
           bool) . 
         if w__12 then ELUsingAArch32 EL0
         else ELUsingAArch32 ((sub_vec_int target_el (( 1 :: int)::ii)  ::  2 Word.word)))) \<bind> (\<lambda> (lower_32 :: bool) . 
      (let (vect_offset :: ii) = (vect_offset + (if lower_32 then (( 1536 :: int)::ii) else (( 1024 :: int)::ii))) in
      return vect_offset)))
    else
      read_reg PSTATE_ref \<bind> (\<lambda> (w__15 :: ProcState) . 
      (let (vect_offset :: ii) =
        (if ((((ProcState_SP   w__15) = (vec_of_bits [B1]  ::  1 Word.word)))) then
          ((ex_int vect_offset)) + (( 512 :: int)::ii)
        else vect_offset) in
      return vect_offset))) \<bind> (\<lambda> (vect_offset :: ii) . 
   (GetPSRFromPSTATE ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (spsr :: 32 bits) . 
   (((if ((HaveUAOExt () )) then
      read_reg PSTATE_ref \<bind> (\<lambda> (w__16 :: ProcState) . 
      write_reg PSTATE_ref (w__16 (| ProcState_UAO := ((vec_of_bits [B0]  ::  1 Word.word))|)))
    else return () ) \<then>
   (if ((\<not> (((((((ExceptionRecord_typ   exception) = Exception_IRQ))) \<or> ((((ExceptionRecord_typ   exception) = Exception_FIQ)))))))) then
      AArch64_ReportException exception target_el
    else return () )) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__17 :: ProcState) . 
   (write_reg PSTATE_ref (w__17 (| ProcState_EL := target_el |)) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__18 :: ProcState) . 
   (write_reg PSTATE_ref (w__18 (| ProcState_nRW := ((vec_of_bits [B0]  ::  1 Word.word))|)) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__19 :: ProcState) . 
   (((write_reg PSTATE_ref (w__19 (| ProcState_SP := ((vec_of_bits [B1]  ::  1 Word.word))|)) \<then>
   aset_SPSR spsr) \<then>
   aset_ELR__1 preferred_exception_return) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__20 :: ProcState) . 
   write_reg PSTATE_ref (w__20 (| ProcState_SS := ((vec_of_bits [B0]  ::  1 Word.word))|)) \<then>
   ((let split_vec = ((vec_of_bits [B1,B1,B1,B1]  ::  4 Word.word)) in
   (let (tup__0, tup__1, tup__2, tup__3) =
     ((subrange_vec_dec split_vec (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
      (subrange_vec_dec split_vec (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
      (subrange_vec_dec split_vec (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
      (subrange_vec_dec split_vec (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
   read_reg PSTATE_ref \<bind> (\<lambda> (w__21 :: ProcState) . 
   (write_reg PSTATE_ref (w__21 (| ProcState_D := tup__0 |)) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__22 :: ProcState) . 
   (write_reg PSTATE_ref (w__22 (| ProcState_A := tup__1 |)) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__23 :: ProcState) . 
   (write_reg PSTATE_ref (w__23 (| ProcState_I := tup__2 |)) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__24 :: ProcState) . 
   (write_reg PSTATE_ref (w__24 (| ProcState_F := tup__3 |)) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__25 :: ProcState) . 
   ((write_reg PSTATE_ref (w__25 (| ProcState_IL := ((vec_of_bits [B0]  ::  1 Word.word))|)) \<then>
   (if from_32 then
      read_reg PSTATE_ref \<bind> (\<lambda> (w__26 :: ProcState) . 
      (write_reg
        PSTATE_ref
        (w__26 (| ProcState_IT := ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word))|)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__27 :: ProcState) . 
      write_reg PSTATE_ref (w__27 (| ProcState_T := ((vec_of_bits [B0]  ::  1 Word.word))|))))
    else return () )) \<then>
   and_boolM
     (and_boolM (return ((HavePANExt () )))
        (or_boolM
           (read_reg PSTATE_ref \<bind> (\<lambda> (w__28 :: ProcState) . 
            return ((((ProcState_EL   w__28) = EL1)))))
           (and_boolM
              (read_reg PSTATE_ref \<bind> (\<lambda> (w__29 :: ProcState) . 
               return ((((ProcState_EL   w__29) = EL2))))) ((ELIsInHost EL0)))))
     ((aget_SCTLR__1 ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__34 ::  32 Word.word) . 
      return ((((vec_of_bits [access_vec_dec w__34 (( 23 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))) \<bind> (\<lambda> (w__35 :: bool) . 
   ((if w__35 then
      read_reg PSTATE_ref \<bind> (\<lambda> (w__36 :: ProcState) . 
      write_reg PSTATE_ref (w__36 (| ProcState_PAN := ((vec_of_bits [B1]  ::  1 Word.word))|)))
    else return () ) \<then>
   (aget_VBAR__1 ()   :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__37 ::  64 Word.word) . 
   (BranchTo
     ((concat_vec ((slice w__37 (( 11 :: int)::ii) (( 53 :: int)::ii)  ::  53 Word.word))
         ((GetSlice_int ((make_the_value (( 11 :: int)::ii)  ::  11 itself)) vect_offset (( 0 :: int)::ii)  ::  11 Word.word))
        ::  64 Word.word)) BranchType_EXCEPTION \<then>
   undefined_bool () ) \<bind> (\<lambda> (iesb_req :: bool) . 
   and_boolM (return ((HaveRASExt () )))
     ((aget_SCTLR__1 ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__38 ::  32 Word.word) . 
      return ((((vec_of_bits [access_vec_dec w__38 (( 21 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__39 :: bool) . 
   (if w__39 then
      (let (_ :: unit) = (ErrorSynchronizationBarrier MBReqDomain_FullSystem MBReqTypes_All) in
      (let iesb_req = True in
      TakeUnmaskedPhysicalSErrorInterrupts iesb_req))
    else return () ) \<then>
   EndOfInstruction () ))))))))))))))))))))))))"


(*val TrapPACUse : mword ty2 -> M unit*)

definition TrapPACUse  :: "(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " TrapPACUse target_el = (
   and_boolM (return (((((HaveEL target_el)) \<and> (((target_el \<noteq> EL0)))))))
     (read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) . 
      return ((((Word.uint target_el)) \<ge> ((Word.uint(ProcState_EL   w__0))))))) \<bind> (\<lambda> (w__1 :: bool) . 
   (assert_exp w__1 (''((HaveEL(target_el) && (target_el != EL0)) && (UInt(target_el) >= UInt((PSTATE).EL)))'') \<then>
   (ThisInstrAddr (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)) \<bind> (\<lambda> (preferred_exception_return :: 64 bits) . 
   undefined_ExceptionRecord ()  \<bind> (\<lambda> (exception :: ExceptionRecord) . 
   (let (vect_offset :: ii) = ((( 0 :: int)::ii)) in
   ExceptionSyndrome Exception_PACTrap \<bind> (\<lambda> (w__2 :: ExceptionRecord) . 
   (let exception = w__2 in
   AArch64_TakeException target_el exception preferred_exception_return vect_offset)))))))"


(*val Strip : mword ty64 -> bool -> M (mword ty64)*)

definition Strip  :: "(64)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " Strip A data = (
   undefined_bool ()  \<bind> (\<lambda> (TrapEL2 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (TrapEL3 :: bool) . 
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (original_ptr :: 64 bits) . 
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (extfield :: 64 bits) . 
   CalculateTBI A data \<bind> (\<lambda> (tbi :: bool) . 
   CalculateBottomPACBit A (vec_of_bits [access_vec_dec A (( 55 :: int)::ii)]  ::  1 Word.word) \<bind> (\<lambda> (w__0 :: ii) . 
   (let bottom_PAC_bit = (ex_int w__0) in
   assert_exp True ('''') \<then>
   ((let extfield =
     ((replicate_bits (vec_of_bits [access_vec_dec A (( 55 :: int)::ii)]  ::  1 Word.word) (( 64 :: int)::ii)  ::  64 Word.word)) in
   (let (original_ptr :: 64 bits) =
     (if tbi then
       (concat_vec ((slice A (( 56 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))
          ((slice_slice_concat (( 56 :: int)::ii) extfield (( 0 :: int)::ii)
              ((((- bottom_PAC_bit)) + (( 56 :: int)::ii))) A (( 0 :: int)::ii) bottom_PAC_bit
             ::  56 Word.word))
         ::  64 Word.word)
     else
       (slice_slice_concat (( 64 :: int)::ii) extfield (( 0 :: int)::ii)
          ((((- bottom_PAC_bit)) + (( 64 :: int)::ii))) A (( 0 :: int)::ii) bottom_PAC_bit
         ::  64 Word.word)) in
   read_reg PSTATE_ref \<bind> (\<lambda> (w__1 :: ProcState) . 
   (let p__293 = ((ProcState_EL   w__1)) in
   (let pat0 = p__293 in
   (if (((pat0 = EL0))) then
      or_boolM
        (or_boolM (return ((\<not> ((HaveEL EL2)))))
           ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 :: 64 bits) . 
            return ((((vec_of_bits [access_vec_dec w__2 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__4 (( 34 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (IsEL1Regime :: bool) . 
      and_boolM
        (and_boolM (return (((((HaveEL EL2)) \<and> IsEL1Regime))))
           (IsSecure ()  \<bind> (\<lambda> (w__5 :: bool) .  return ((\<not> w__5)))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__7 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__7 (( 41 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__8 :: bool) . 
      (let TrapEL2 = w__8 in
      and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__9 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__9 (( 17 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__10 :: bool) . 
      (let (TrapEL3 :: bool) = w__10 in
      return (TrapEL2, TrapEL3))))))
    else if (((pat0 = EL1))) then
      and_boolM
        (and_boolM (return ((HaveEL EL2)))
           (IsSecure ()  \<bind> (\<lambda> (w__11 :: bool) .  return ((\<not> w__11)))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__13 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__13 (( 41 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__14 :: bool) . 
      (let TrapEL2 = w__14 in
      and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__15 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__15 (( 17 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__16 :: bool) . 
      (let (TrapEL3 :: bool) = w__16 in
      return (TrapEL2, TrapEL3)))))
    else if (((pat0 = EL2))) then
      (let TrapEL2 = False in
      and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__17 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__17 (( 17 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__18 :: bool) . 
      (let (TrapEL3 :: bool) = w__18 in
      return (TrapEL2, TrapEL3))))
    else
      (let (TrapEL2 :: bool) = False in
      (let (TrapEL3 :: bool) = False in
      return (TrapEL2, TrapEL3)))) \<bind> (\<lambda> varstup .  (let ((TrapEL2 :: bool), (TrapEL3 :: bool)) = varstup in
   if TrapEL2 then TrapPACUse EL2 \<then> (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
   else if TrapEL3 then TrapPACUse EL3 \<then> (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
   else return original_ptr))))))))))))))))"


(*val aarch64_integer_pac_strip_dp_1src : ii -> bool -> M unit*)

definition aarch64_integer_pac_strip_dp_1src  :: " int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_pac_strip_dp_1src d data = (
   if ((HavePACExt () )) then
     (aget_X (( 64 :: int)::ii) d  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
     (Strip w__0 data  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) .  aset_X d w__1))
   else return ()  )"


(*val integer_pac_strip_hint_decode : mword ty1 -> mword ty2 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty3 -> mword ty5 -> M unit*)

definition integer_pac_strip_hint_decode  :: "(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_pac_strip_hint_decode L op0 op1 CRn CRm op2 Rt = (
   write_reg unconditional_ref True \<then>
   ((let (d :: ii) = ((( 30 :: int)::ii)) in
   (let (data :: bool) = False in
   aarch64_integer_pac_strip_dp_1src d data))))"


(*val AuthIB : mword ty64 -> mword ty64 -> M (mword ty64)*)

definition AuthIB  :: "(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " AuthIB X Y = (
   undefined_bool ()  \<bind> (\<lambda> (TrapEL2 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (TrapEL3 :: bool) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (Enable :: 1 bits) . 
   (read_reg APIBKeyHi_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 :: 64 bits) . 
   (read_reg APIBKeyLo_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 :: 64 bits) . 
   (let (APIBKey_EL1 :: 128 bits) =
     ((concat_vec ((slice w__0 (( 0 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))
        ((slice w__1 (( 0 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))
       ::  128 Word.word)) in
   read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) . 
   (let p__292 = ((ProcState_EL   w__2)) in
   (let pat0 = p__292 in
   (if (((pat0 = EL0))) then
      or_boolM
        (or_boolM (return ((\<not> ((HaveEL EL2)))))
           ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 :: 64 bits) . 
            return ((((vec_of_bits [access_vec_dec w__3 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__5 (( 34 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (IsEL1Regime :: bool) . 
      (if IsEL1Regime then
         (read_reg SCTLR_EL1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__6 :: 32 bits) . 
         return (vec_of_bits [access_vec_dec w__6 (( 30 :: int)::ii)]  ::  1 Word.word))
       else
         (read_reg SCTLR_EL2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__7 :: 32 bits) . 
         return (vec_of_bits [access_vec_dec w__7 (( 30 :: int)::ii)]  ::  1 Word.word))) \<bind> (\<lambda> (w__8 ::  1 Word.word) . 
      (let Enable = w__8 in
      and_boolM
        (and_boolM (return (((((HaveEL EL2)) \<and> IsEL1Regime))))
           (IsSecure ()  \<bind> (\<lambda> (w__9 :: bool) .  return ((\<not> w__9)))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__11 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__11 (( 41 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__12 :: bool) . 
      (let TrapEL2 = w__12 in
      and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__13 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__13 (( 17 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__14 :: bool) . 
      (let (TrapEL3 :: bool) = w__14 in
      return (Enable, TrapEL2, TrapEL3))))))))
    else if (((pat0 = EL1))) then
      (read_reg SCTLR_EL1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__15 :: 32 bits) . 
      (let Enable = ((vec_of_bits [access_vec_dec w__15 (( 30 :: int)::ii)]  ::  1 Word.word)) in
      and_boolM
        (and_boolM (return ((HaveEL EL2)))
           (IsSecure ()  \<bind> (\<lambda> (w__16 :: bool) .  return ((\<not> w__16)))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__18 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__18 (( 41 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__19 :: bool) . 
      (let TrapEL2 = w__19 in
      and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__20 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__20 (( 17 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__21 :: bool) . 
      (let (TrapEL3 :: bool) = w__21 in
      return (Enable, TrapEL2, TrapEL3)))))))
    else if (((pat0 = EL2))) then
      (read_reg SCTLR_EL2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__22 :: 32 bits) . 
      (let Enable = ((vec_of_bits [access_vec_dec w__22 (( 30 :: int)::ii)]  ::  1 Word.word)) in
      (let TrapEL2 = False in
      and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__23 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__23 (( 17 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__24 :: bool) . 
      (let (TrapEL3 :: bool) = w__24 in
      return (Enable, TrapEL2, TrapEL3))))))
    else
      (read_reg SCTLR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__25 :: 32 bits) . 
      (let (Enable :: 1 bits) = ((vec_of_bits [access_vec_dec w__25 (( 30 :: int)::ii)]  ::  1 Word.word)) in
      (let (TrapEL2 :: bool) = False in
      (let (TrapEL3 :: bool) = False in
      return (Enable, TrapEL2, TrapEL3)))))) \<bind> (\<lambda> varstup .  (let ((Enable :: 1 bits), (TrapEL2 ::
     bool), (TrapEL3 :: bool)) = varstup in
   if (((Enable = (vec_of_bits [B0]  ::  1 Word.word)))) then return X
   else if TrapEL2 then TrapPACUse EL2 \<then> (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
   else if TrapEL3 then TrapPACUse EL3 \<then> (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
   else (Auth X Y APIBKey_EL1 False (vec_of_bits [B1]  ::  1 Word.word)  :: ( 64 Word.word) M)))))))))))))"


(*val aarch64_integer_pac_autib_dp_1src : ii -> ii -> bool -> M unit*)

definition aarch64_integer_pac_autib_dp_1src  :: " int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_pac_autib_dp_1src d n source_is_sp = (
   if ((HavePACExt () )) then
     if source_is_sp then
       (aget_X (( 64 :: int)::ii) d  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
       (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
       (AuthIB w__0 w__1  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::  64 Word.word) .  aset_X d w__2)))
     else
       (aget_X (( 64 :: int)::ii) d  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::  64 Word.word) . 
       (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 ::  64 Word.word) . 
       (AuthIB w__3 w__4  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 ::  64 Word.word) .  aset_X d w__5)))
   else return ()  )"


(*val integer_pac_autib_hint_decode : mword ty1 -> mword ty2 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty3 -> mword ty5 -> M unit*)

definition integer_pac_autib_hint_decode  :: "(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_pac_autib_hint_decode L op0 op1 CRn CRm op2 Rt = (
   (write_reg unconditional_ref True \<then>
   undefined_int () ) \<bind> (\<lambda> (d :: ii) . 
   undefined_int ()  \<bind> (\<lambda> (n :: ii) . 
   (let (source_is_sp :: bool) = False in
   (let b__0 = ((concat_vec CRm op2  ::  7 Word.word)) in
   (if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B1,B0]  ::  7 Word.word)))) then
      (let (d :: ii) = ((( 30 :: int)::ii)) in
      (let (n :: ii) = ((( 31 :: int)::ii)) in
      return (d, n, source_is_sp)))
    else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B1,B1]  ::  7 Word.word)))) then
      (let (d :: ii) = ((( 30 :: int)::ii)) in
      (let (source_is_sp :: bool) = True in
      return (d, n, source_is_sp)))
    else
      (if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B1,B1,B0]  ::  7 Word.word)))) then
         (let (d :: ii) = ((( 17 :: int)::ii)) in
         (let (n :: ii) = ((( 16 :: int)::ii)) in
         return (d, n)))
       else
         (if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0]  ::  7 Word.word)))) then
            throw (Error_See (''PACIA''))
          else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0]  ::  7 Word.word)))) then
            throw (Error_See (''PACIB''))
          else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B1,B0,B0]  ::  7 Word.word)))) then
            throw (Error_See (''AUTIA''))
          else if (((((subrange_vec_dec b__0 (( 6 :: int)::ii) (( 1 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B0]  ::  6 Word.word)))) then
            throw (Error_See (''PACIA''))
          else if (((((subrange_vec_dec b__0 (( 6 :: int)::ii) (( 1 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B1]  ::  6 Word.word)))) then
            throw (Error_See (''PACIB''))
          else if (((((subrange_vec_dec b__0 (( 6 :: int)::ii) (( 1 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B1,B0]  ::  6 Word.word)))) then
            throw (Error_See (''AUTIA''))
          else throw (Error_See (''XPACLRI''))) \<then>
         return (d, n)) \<bind> (\<lambda> varstup .  (let ((d :: ii), (n :: ii)) = varstup in
      return (d, n, source_is_sp)))) \<bind> (\<lambda> varstup .  (let ((d :: ii), (n :: ii), (source_is_sp :: bool)) = varstup in
   aarch64_integer_pac_autib_dp_1src d n source_is_sp)))))))"


(*val AuthIA : mword ty64 -> mword ty64 -> M (mword ty64)*)

definition AuthIA  :: "(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " AuthIA X Y = (
   undefined_bool ()  \<bind> (\<lambda> (TrapEL2 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (TrapEL3 :: bool) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (Enable :: 1 bits) . 
   (read_reg APIAKeyHi_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 :: 64 bits) . 
   (read_reg APIAKeyLo_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 :: 64 bits) . 
   (let (APIAKey_EL1 :: 128 bits) =
     ((concat_vec ((slice w__0 (( 0 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))
        ((slice w__1 (( 0 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))
       ::  128 Word.word)) in
   read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) . 
   (let p__291 = ((ProcState_EL   w__2)) in
   (let pat0 = p__291 in
   (if (((pat0 = EL0))) then
      or_boolM
        (or_boolM (return ((\<not> ((HaveEL EL2)))))
           ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 :: 64 bits) . 
            return ((((vec_of_bits [access_vec_dec w__3 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__5 (( 34 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (IsEL1Regime :: bool) . 
      (if IsEL1Regime then
         (read_reg SCTLR_EL1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__6 :: 32 bits) . 
         return (vec_of_bits [access_vec_dec w__6 (( 31 :: int)::ii)]  ::  1 Word.word))
       else
         (read_reg SCTLR_EL2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__7 :: 32 bits) . 
         return (vec_of_bits [access_vec_dec w__7 (( 31 :: int)::ii)]  ::  1 Word.word))) \<bind> (\<lambda> (w__8 ::  1 Word.word) . 
      (let Enable = w__8 in
      and_boolM
        (and_boolM (return (((((HaveEL EL2)) \<and> IsEL1Regime))))
           (IsSecure ()  \<bind> (\<lambda> (w__9 :: bool) .  return ((\<not> w__9)))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__11 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__11 (( 41 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__12 :: bool) . 
      (let TrapEL2 = w__12 in
      and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__13 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__13 (( 17 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__14 :: bool) . 
      (let (TrapEL3 :: bool) = w__14 in
      return (Enable, TrapEL2, TrapEL3))))))))
    else if (((pat0 = EL1))) then
      (read_reg SCTLR_EL1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__15 :: 32 bits) . 
      (let Enable = ((vec_of_bits [access_vec_dec w__15 (( 31 :: int)::ii)]  ::  1 Word.word)) in
      and_boolM
        (and_boolM (return ((HaveEL EL2)))
           (IsSecure ()  \<bind> (\<lambda> (w__16 :: bool) .  return ((\<not> w__16)))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__18 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__18 (( 41 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__19 :: bool) . 
      (let TrapEL2 = w__19 in
      and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__20 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__20 (( 17 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__21 :: bool) . 
      (let (TrapEL3 :: bool) = w__21 in
      return (Enable, TrapEL2, TrapEL3)))))))
    else if (((pat0 = EL2))) then
      (read_reg SCTLR_EL2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__22 :: 32 bits) . 
      (let Enable = ((vec_of_bits [access_vec_dec w__22 (( 31 :: int)::ii)]  ::  1 Word.word)) in
      (let TrapEL2 = False in
      and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__23 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__23 (( 17 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__24 :: bool) . 
      (let (TrapEL3 :: bool) = w__24 in
      return (Enable, TrapEL2, TrapEL3))))))
    else
      (read_reg SCTLR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__25 :: 32 bits) . 
      (let (Enable :: 1 bits) = ((vec_of_bits [access_vec_dec w__25 (( 31 :: int)::ii)]  ::  1 Word.word)) in
      (let (TrapEL2 :: bool) = False in
      (let (TrapEL3 :: bool) = False in
      return (Enable, TrapEL2, TrapEL3)))))) \<bind> (\<lambda> varstup .  (let ((Enable :: 1 bits), (TrapEL2 ::
     bool), (TrapEL3 :: bool)) = varstup in
   if (((Enable = (vec_of_bits [B0]  ::  1 Word.word)))) then return X
   else if TrapEL2 then TrapPACUse EL2 \<then> (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
   else if TrapEL3 then TrapPACUse EL3 \<then> (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
   else (Auth X Y APIAKey_EL1 False (vec_of_bits [B0]  ::  1 Word.word)  :: ( 64 Word.word) M)))))))))))))"


(*val aarch64_integer_pac_autia_dp_1src : ii -> ii -> bool -> M unit*)

definition aarch64_integer_pac_autia_dp_1src  :: " int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_pac_autia_dp_1src d n source_is_sp = (
   if ((HavePACExt () )) then
     if source_is_sp then
       (aget_X (( 64 :: int)::ii) d  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
       (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
       (AuthIA w__0 w__1  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::  64 Word.word) .  aset_X d w__2)))
     else
       (aget_X (( 64 :: int)::ii) d  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::  64 Word.word) . 
       (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 ::  64 Word.word) . 
       (AuthIA w__3 w__4  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 ::  64 Word.word) .  aset_X d w__5)))
   else return ()  )"


(*val integer_pac_autia_hint_decode : mword ty1 -> mword ty2 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty3 -> mword ty5 -> M unit*)

definition integer_pac_autia_hint_decode  :: "(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_pac_autia_hint_decode L op0 op1 CRn CRm op2 Rt = (
   (write_reg unconditional_ref True \<then>
   undefined_int () ) \<bind> (\<lambda> (d :: ii) . 
   undefined_int ()  \<bind> (\<lambda> (n :: ii) . 
   (let (source_is_sp :: bool) = False in
   (let b__0 = ((concat_vec CRm op2  ::  7 Word.word)) in
   (if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B0]  ::  7 Word.word)))) then
      (let (d :: ii) = ((( 30 :: int)::ii)) in
      (let (n :: ii) = ((( 31 :: int)::ii)) in
      return (d, n, source_is_sp)))
    else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1]  ::  7 Word.word)))) then
      (let (d :: ii) = ((( 30 :: int)::ii)) in
      (let (source_is_sp :: bool) = True in
      return (d, n, source_is_sp)))
    else
      (if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B1,B0,B0]  ::  7 Word.word)))) then
         (let (d :: ii) = ((( 17 :: int)::ii)) in
         (let (n :: ii) = ((( 16 :: int)::ii)) in
         return (d, n)))
       else
         (if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0]  ::  7 Word.word)))) then
            throw (Error_See (''PACIA''))
          else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0]  ::  7 Word.word)))) then
            throw (Error_See (''PACIB''))
          else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B1,B1,B0]  ::  7 Word.word)))) then
            throw (Error_See (''AUTIB''))
          else if (((((subrange_vec_dec b__0 (( 6 :: int)::ii) (( 1 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B0]  ::  6 Word.word)))) then
            throw (Error_See (''PACIA''))
          else if (((((subrange_vec_dec b__0 (( 6 :: int)::ii) (( 1 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B1]  ::  6 Word.word)))) then
            throw (Error_See (''PACIB''))
          else if (((((subrange_vec_dec b__0 (( 6 :: int)::ii) (( 1 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B1,B1]  ::  6 Word.word)))) then
            throw (Error_See (''AUTIB''))
          else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B1,B1,B1]  ::  7 Word.word)))) then
            throw (Error_See (''XPACLRI''))
          else throw (Error_See (''HINT''))) \<then>
         return (d, n)) \<bind> (\<lambda> varstup .  (let ((d :: ii), (n :: ii)) = varstup in
      return (d, n, source_is_sp)))) \<bind> (\<lambda> varstup .  (let ((d :: ii), (n :: ii), (source_is_sp :: bool)) = varstup in
   aarch64_integer_pac_autia_dp_1src d n source_is_sp)))))))"


(*val aarch64_branch_unconditional_register : BranchType -> ii -> ii -> bool -> bool -> bool -> M unit*)

definition aarch64_branch_unconditional_register  :: " BranchType \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_branch_unconditional_register branch_type m n pac source_is_sp use_key_a = (
   (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M) \<bind> (\<lambda> (target :: 64 bits) . 
   (if pac then
      (if source_is_sp then (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
       else (aget_X (( 64 :: int)::ii) m  :: ( 64 Word.word) M)) \<bind> (\<lambda> (modifier :: 64 bits) . 
      if use_key_a then (AuthIA target modifier  :: ( 64 Word.word) M)
      else (AuthIB target modifier  :: ( 64 Word.word) M))
    else return target) \<bind> (\<lambda> (target :: 64 bits) . 
   (if (((branch_type = BranchType_CALL))) then
      (aget_PC ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 ::  64 Word.word) . 
      aset_X (( 30 :: int)::ii) ((add_vec_int w__4 (( 4 :: int)::ii)  ::  64 Word.word)))
    else return () ) \<then>
   BranchTo target branch_type)))"


(*val AuthDB : mword ty64 -> mword ty64 -> M (mword ty64)*)

definition AuthDB  :: "(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " AuthDB X Y = (
   undefined_bool ()  \<bind> (\<lambda> (TrapEL2 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (TrapEL3 :: bool) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (Enable :: 1 bits) . 
   (read_reg APDBKeyHi_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 :: 64 bits) . 
   (read_reg APDBKeyLo_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 :: 64 bits) . 
   (let (APDBKey_EL1 :: 128 bits) =
     ((concat_vec ((slice w__0 (( 0 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))
        ((slice w__1 (( 0 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))
       ::  128 Word.word)) in
   read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) . 
   (let p__290 = ((ProcState_EL   w__2)) in
   (let pat0 = p__290 in
   (if (((pat0 = EL0))) then
      or_boolM
        (or_boolM (return ((\<not> ((HaveEL EL2)))))
           ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 :: 64 bits) . 
            return ((((vec_of_bits [access_vec_dec w__3 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__5 (( 34 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (IsEL1Regime :: bool) . 
      (if IsEL1Regime then
         (read_reg SCTLR_EL1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__6 :: 32 bits) . 
         return (vec_of_bits [access_vec_dec w__6 (( 13 :: int)::ii)]  ::  1 Word.word))
       else
         (read_reg SCTLR_EL2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__7 :: 32 bits) . 
         return (vec_of_bits [access_vec_dec w__7 (( 13 :: int)::ii)]  ::  1 Word.word))) \<bind> (\<lambda> (w__8 ::  1 Word.word) . 
      (let Enable = w__8 in
      and_boolM
        (and_boolM (return (((((HaveEL EL2)) \<and> IsEL1Regime))))
           (IsSecure ()  \<bind> (\<lambda> (w__9 :: bool) .  return ((\<not> w__9)))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__11 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__11 (( 41 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__12 :: bool) . 
      (let TrapEL2 = w__12 in
      and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__13 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__13 (( 17 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__14 :: bool) . 
      (let (TrapEL3 :: bool) = w__14 in
      return (Enable, TrapEL2, TrapEL3))))))))
    else if (((pat0 = EL1))) then
      (read_reg SCTLR_EL1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__15 :: 32 bits) . 
      (let Enable = ((vec_of_bits [access_vec_dec w__15 (( 13 :: int)::ii)]  ::  1 Word.word)) in
      and_boolM
        (and_boolM (return ((HaveEL EL2)))
           (IsSecure ()  \<bind> (\<lambda> (w__16 :: bool) .  return ((\<not> w__16)))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__18 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__18 (( 41 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__19 :: bool) . 
      (let TrapEL2 = w__19 in
      and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__20 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__20 (( 17 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__21 :: bool) . 
      (let (TrapEL3 :: bool) = w__21 in
      return (Enable, TrapEL2, TrapEL3)))))))
    else if (((pat0 = EL2))) then
      (read_reg SCTLR_EL2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__22 :: 32 bits) . 
      (let Enable = ((vec_of_bits [access_vec_dec w__22 (( 13 :: int)::ii)]  ::  1 Word.word)) in
      (let TrapEL2 = False in
      and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__23 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__23 (( 17 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__24 :: bool) . 
      (let (TrapEL3 :: bool) = w__24 in
      return (Enable, TrapEL2, TrapEL3))))))
    else
      (read_reg SCTLR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__25 :: 32 bits) . 
      (let (Enable :: 1 bits) = ((vec_of_bits [access_vec_dec w__25 (( 13 :: int)::ii)]  ::  1 Word.word)) in
      (let (TrapEL2 :: bool) = False in
      (let (TrapEL3 :: bool) = False in
      return (Enable, TrapEL2, TrapEL3)))))) \<bind> (\<lambda> varstup .  (let ((Enable :: 1 bits), (TrapEL2 ::
     bool), (TrapEL3 :: bool)) = varstup in
   if (((Enable = (vec_of_bits [B0]  ::  1 Word.word)))) then return X
   else if TrapEL2 then TrapPACUse EL2 \<then> (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
   else if TrapEL3 then TrapPACUse EL3 \<then> (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
   else (Auth X Y APDBKey_EL1 True (vec_of_bits [B1]  ::  1 Word.word)  :: ( 64 Word.word) M)))))))))))))"


(*val aarch64_integer_pac_autdb_dp_1src : ii -> ii -> bool -> M unit*)

definition aarch64_integer_pac_autdb_dp_1src  :: " int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_pac_autdb_dp_1src d n source_is_sp = (
   if source_is_sp then
     (aget_X (( 64 :: int)::ii) d  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
     (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
     (AuthDB w__0 w__1  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::  64 Word.word) .  aset_X d w__2)))
   else
     (aget_X (( 64 :: int)::ii) d  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::  64 Word.word) . 
     (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 ::  64 Word.word) . 
     (AuthDB w__3 w__4  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 ::  64 Word.word) .  aset_X d w__5))))"


(*val AuthDA : mword ty64 -> mword ty64 -> M (mword ty64)*)

definition AuthDA  :: "(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " AuthDA X Y = (
   undefined_bool ()  \<bind> (\<lambda> (TrapEL2 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (TrapEL3 :: bool) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (Enable :: 1 bits) . 
   (read_reg APDAKeyHi_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 :: 64 bits) . 
   (read_reg APDAKeyLo_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 :: 64 bits) . 
   (let (APDAKey_EL1 :: 128 bits) =
     ((concat_vec ((slice w__0 (( 0 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))
        ((slice w__1 (( 0 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))
       ::  128 Word.word)) in
   read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) . 
   (let p__289 = ((ProcState_EL   w__2)) in
   (let pat0 = p__289 in
   (if (((pat0 = EL0))) then
      or_boolM
        (or_boolM (return ((\<not> ((HaveEL EL2)))))
           ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 :: 64 bits) . 
            return ((((vec_of_bits [access_vec_dec w__3 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__5 (( 34 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (IsEL1Regime :: bool) . 
      (if IsEL1Regime then
         (read_reg SCTLR_EL1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__6 :: 32 bits) . 
         return (vec_of_bits [access_vec_dec w__6 (( 27 :: int)::ii)]  ::  1 Word.word))
       else
         (read_reg SCTLR_EL2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__7 :: 32 bits) . 
         return (vec_of_bits [access_vec_dec w__7 (( 27 :: int)::ii)]  ::  1 Word.word))) \<bind> (\<lambda> (w__8 ::  1 Word.word) . 
      (let Enable = w__8 in
      and_boolM
        (and_boolM (return (((((HaveEL EL2)) \<and> IsEL1Regime))))
           (IsSecure ()  \<bind> (\<lambda> (w__9 :: bool) .  return ((\<not> w__9)))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__11 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__11 (( 41 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__12 :: bool) . 
      (let TrapEL2 = w__12 in
      and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__13 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__13 (( 17 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__14 :: bool) . 
      (let (TrapEL3 :: bool) = w__14 in
      return (Enable, TrapEL2, TrapEL3))))))))
    else if (((pat0 = EL1))) then
      (read_reg SCTLR_EL1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__15 :: 32 bits) . 
      (let Enable = ((vec_of_bits [access_vec_dec w__15 (( 27 :: int)::ii)]  ::  1 Word.word)) in
      and_boolM
        (and_boolM (return ((HaveEL EL2)))
           (IsSecure ()  \<bind> (\<lambda> (w__16 :: bool) .  return ((\<not> w__16)))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__18 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__18 (( 41 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__19 :: bool) . 
      (let TrapEL2 = w__19 in
      and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__20 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__20 (( 17 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__21 :: bool) . 
      (let (TrapEL3 :: bool) = w__21 in
      return (Enable, TrapEL2, TrapEL3)))))))
    else if (((pat0 = EL2))) then
      (read_reg SCTLR_EL2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__22 :: 32 bits) . 
      (let Enable = ((vec_of_bits [access_vec_dec w__22 (( 27 :: int)::ii)]  ::  1 Word.word)) in
      (let TrapEL2 = False in
      and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__23 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__23 (( 17 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__24 :: bool) . 
      (let (TrapEL3 :: bool) = w__24 in
      return (Enable, TrapEL2, TrapEL3))))))
    else
      (read_reg SCTLR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__25 :: 32 bits) . 
      (let (Enable :: 1 bits) = ((vec_of_bits [access_vec_dec w__25 (( 27 :: int)::ii)]  ::  1 Word.word)) in
      (let (TrapEL2 :: bool) = False in
      (let (TrapEL3 :: bool) = False in
      return (Enable, TrapEL2, TrapEL3)))))) \<bind> (\<lambda> varstup .  (let ((Enable :: 1 bits), (TrapEL2 ::
     bool), (TrapEL3 :: bool)) = varstup in
   if (((Enable = (vec_of_bits [B0]  ::  1 Word.word)))) then return X
   else if TrapEL2 then TrapPACUse EL2 \<then> (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
   else if TrapEL3 then TrapPACUse EL3 \<then> (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
   else (Auth X Y APDAKey_EL1 True (vec_of_bits [B0]  ::  1 Word.word)  :: ( 64 Word.word) M)))))))))))))"


(*val aarch64_integer_pac_autda_dp_1src : ii -> ii -> bool -> M unit*)

definition aarch64_integer_pac_autda_dp_1src  :: " int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_pac_autda_dp_1src d n source_is_sp = (
   if source_is_sp then
     (aget_X (( 64 :: int)::ii) d  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
     (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
     (AuthDA w__0 w__1  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::  64 Word.word) .  aset_X d w__2)))
   else
     (aget_X (( 64 :: int)::ii) d  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::  64 Word.word) . 
     (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 ::  64 Word.word) . 
     (AuthDA w__3 w__4  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 ::  64 Word.word) .  aset_X d w__5))))"


(*val AddPACIB : mword ty64 -> mword ty64 -> M (mword ty64)*)

definition AddPACIB  :: "(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " AddPACIB X Y = (
   undefined_bool ()  \<bind> (\<lambda> (TrapEL2 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (TrapEL3 :: bool) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (Enable :: 1 bits) . 
   (read_reg APIBKeyHi_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 :: 64 bits) . 
   (read_reg APIBKeyLo_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 :: 64 bits) . 
   (let (APIBKey_EL1 :: 128 bits) =
     ((concat_vec ((slice w__0 (( 0 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))
        ((slice w__1 (( 0 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))
       ::  128 Word.word)) in
   read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) . 
   (let p__288 = ((ProcState_EL   w__2)) in
   (let pat0 = p__288 in
   (if (((pat0 = EL0))) then
      or_boolM
        (or_boolM (return ((\<not> ((HaveEL EL2)))))
           ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 :: 64 bits) . 
            return ((((vec_of_bits [access_vec_dec w__3 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__5 (( 34 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (IsEL1Regime :: bool) . 
      (if IsEL1Regime then
         (read_reg SCTLR_EL1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__6 :: 32 bits) . 
         return (vec_of_bits [access_vec_dec w__6 (( 30 :: int)::ii)]  ::  1 Word.word))
       else
         (read_reg SCTLR_EL2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__7 :: 32 bits) . 
         return (vec_of_bits [access_vec_dec w__7 (( 30 :: int)::ii)]  ::  1 Word.word))) \<bind> (\<lambda> (w__8 ::  1 Word.word) . 
      (let Enable = w__8 in
      and_boolM
        (and_boolM (return (((((HaveEL EL2)) \<and> IsEL1Regime))))
           (IsSecure ()  \<bind> (\<lambda> (w__9 :: bool) .  return ((\<not> w__9)))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__11 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__11 (( 41 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__12 :: bool) . 
      (let TrapEL2 = w__12 in
      and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__13 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__13 (( 17 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__14 :: bool) . 
      (let (TrapEL3 :: bool) = w__14 in
      return (Enable, TrapEL2, TrapEL3))))))))
    else if (((pat0 = EL1))) then
      (read_reg SCTLR_EL1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__15 :: 32 bits) . 
      (let Enable = ((vec_of_bits [access_vec_dec w__15 (( 30 :: int)::ii)]  ::  1 Word.word)) in
      and_boolM
        (and_boolM (return ((HaveEL EL2)))
           (IsSecure ()  \<bind> (\<lambda> (w__16 :: bool) .  return ((\<not> w__16)))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__18 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__18 (( 41 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__19 :: bool) . 
      (let TrapEL2 = w__19 in
      and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__20 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__20 (( 17 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__21 :: bool) . 
      (let (TrapEL3 :: bool) = w__21 in
      return (Enable, TrapEL2, TrapEL3)))))))
    else if (((pat0 = EL2))) then
      (read_reg SCTLR_EL2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__22 :: 32 bits) . 
      (let Enable = ((vec_of_bits [access_vec_dec w__22 (( 30 :: int)::ii)]  ::  1 Word.word)) in
      (let TrapEL2 = False in
      and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__23 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__23 (( 17 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__24 :: bool) . 
      (let (TrapEL3 :: bool) = w__24 in
      return (Enable, TrapEL2, TrapEL3))))))
    else
      (read_reg SCTLR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__25 :: 32 bits) . 
      (let (Enable :: 1 bits) = ((vec_of_bits [access_vec_dec w__25 (( 30 :: int)::ii)]  ::  1 Word.word)) in
      (let (TrapEL2 :: bool) = False in
      (let (TrapEL3 :: bool) = False in
      return (Enable, TrapEL2, TrapEL3)))))) \<bind> (\<lambda> varstup .  (let ((Enable :: 1 bits), (TrapEL2 ::
     bool), (TrapEL3 :: bool)) = varstup in
   if (((Enable = (vec_of_bits [B0]  ::  1 Word.word)))) then return X
   else if TrapEL2 then TrapPACUse EL2 \<then> (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
   else if TrapEL3 then TrapPACUse EL3 \<then> (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
   else (AddPAC X Y APIBKey_EL1 False  :: ( 64 Word.word) M)))))))))))))"


(*val aarch64_integer_pac_pacib_dp_1src : ii -> ii -> bool -> M unit*)

definition aarch64_integer_pac_pacib_dp_1src  :: " int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_pac_pacib_dp_1src d n source_is_sp = (
   if ((HavePACExt () )) then
     if source_is_sp then
       (aget_X (( 64 :: int)::ii) d  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
       (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
       (AddPACIB w__0 w__1  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::  64 Word.word) .  aset_X d w__2)))
     else
       (aget_X (( 64 :: int)::ii) d  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::  64 Word.word) . 
       (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 ::  64 Word.word) . 
       (AddPACIB w__3 w__4  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 ::  64 Word.word) .  aset_X d w__5)))
   else return ()  )"


(*val integer_pac_pacib_hint_decode : mword ty1 -> mword ty2 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty3 -> mword ty5 -> M unit*)

definition integer_pac_pacib_hint_decode  :: "(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_pac_pacib_hint_decode L op0 op1 CRn CRm op2 Rt = (
   (write_reg unconditional_ref True \<then>
   undefined_int () ) \<bind> (\<lambda> (d :: ii) . 
   undefined_int ()  \<bind> (\<lambda> (n :: ii) . 
   (let (source_is_sp :: bool) = False in
   (let b__0 = ((concat_vec CRm op2  ::  7 Word.word)) in
   (if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0]  ::  7 Word.word)))) then
      (let (d :: ii) = ((( 30 :: int)::ii)) in
      (let (n :: ii) = ((( 31 :: int)::ii)) in
      return (d, n, source_is_sp)))
    else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B1]  ::  7 Word.word)))) then
      (let (d :: ii) = ((( 30 :: int)::ii)) in
      (let (source_is_sp :: bool) = True in
      return (d, n, source_is_sp)))
    else
      (if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0]  ::  7 Word.word)))) then
         (let (d :: ii) = ((( 17 :: int)::ii)) in
         (let (n :: ii) = ((( 16 :: int)::ii)) in
         return (d, n)))
       else
         (if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0]  ::  7 Word.word)))) then
            throw (Error_See (''PACIA''))
          else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B1,B0,B0]  ::  7 Word.word)))) then
            throw (Error_See (''AUTIA''))
          else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B1,B1,B0]  ::  7 Word.word)))) then
            throw (Error_See (''AUTIB''))
          else if (((((subrange_vec_dec b__0 (( 6 :: int)::ii) (( 1 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B0]  ::  6 Word.word)))) then
            throw (Error_See (''PACIA''))
          else if (((((subrange_vec_dec b__0 (( 6 :: int)::ii) (( 1 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B1,B0]  ::  6 Word.word)))) then
            throw (Error_See (''AUTIA''))
          else if (((((subrange_vec_dec b__0 (( 6 :: int)::ii) (( 1 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B1,B1]  ::  6 Word.word)))) then
            throw (Error_See (''AUTIB''))
          else throw (Error_See (''XPACLRI''))) \<then>
         return (d, n)) \<bind> (\<lambda> varstup .  (let ((d :: ii), (n :: ii)) = varstup in
      return (d, n, source_is_sp)))) \<bind> (\<lambda> varstup .  (let ((d :: ii), (n :: ii), (source_is_sp :: bool)) = varstup in
   aarch64_integer_pac_pacib_dp_1src d n source_is_sp)))))))"


(*val AddPACIA : mword ty64 -> mword ty64 -> M (mword ty64)*)

definition AddPACIA  :: "(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " AddPACIA X Y = (
   undefined_bool ()  \<bind> (\<lambda> (TrapEL2 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (TrapEL3 :: bool) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (Enable :: 1 bits) . 
   (read_reg APIAKeyHi_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 :: 64 bits) . 
   (read_reg APIAKeyLo_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 :: 64 bits) . 
   (let (APIAKey_EL1 :: 128 bits) =
     ((concat_vec ((slice w__0 (( 0 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))
        ((slice w__1 (( 0 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))
       ::  128 Word.word)) in
   read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) . 
   (let p__287 = ((ProcState_EL   w__2)) in
   (let pat0 = p__287 in
   (if (((pat0 = EL0))) then
      or_boolM
        (or_boolM (return ((\<not> ((HaveEL EL2)))))
           ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 :: 64 bits) . 
            return ((((vec_of_bits [access_vec_dec w__3 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__5 (( 34 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (IsEL1Regime :: bool) . 
      (if IsEL1Regime then
         (read_reg SCTLR_EL1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__6 :: 32 bits) . 
         return (vec_of_bits [access_vec_dec w__6 (( 31 :: int)::ii)]  ::  1 Word.word))
       else
         (read_reg SCTLR_EL2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__7 :: 32 bits) . 
         return (vec_of_bits [access_vec_dec w__7 (( 31 :: int)::ii)]  ::  1 Word.word))) \<bind> (\<lambda> (w__8 ::  1 Word.word) . 
      (let Enable = w__8 in
      and_boolM
        (and_boolM (return (((((HaveEL EL2)) \<and> IsEL1Regime))))
           (IsSecure ()  \<bind> (\<lambda> (w__9 :: bool) .  return ((\<not> w__9)))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__11 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__11 (( 41 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__12 :: bool) . 
      (let TrapEL2 = w__12 in
      and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__13 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__13 (( 17 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__14 :: bool) . 
      (let (TrapEL3 :: bool) = w__14 in
      return (Enable, TrapEL2, TrapEL3))))))))
    else if (((pat0 = EL1))) then
      (read_reg SCTLR_EL1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__15 :: 32 bits) . 
      (let Enable = ((vec_of_bits [access_vec_dec w__15 (( 31 :: int)::ii)]  ::  1 Word.word)) in
      and_boolM
        (and_boolM (return ((HaveEL EL2)))
           (IsSecure ()  \<bind> (\<lambda> (w__16 :: bool) .  return ((\<not> w__16)))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__18 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__18 (( 41 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__19 :: bool) . 
      (let TrapEL2 = w__19 in
      and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__20 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__20 (( 17 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__21 :: bool) . 
      (let (TrapEL3 :: bool) = w__21 in
      return (Enable, TrapEL2, TrapEL3)))))))
    else if (((pat0 = EL2))) then
      (read_reg SCTLR_EL2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__22 :: 32 bits) . 
      (let Enable = ((vec_of_bits [access_vec_dec w__22 (( 31 :: int)::ii)]  ::  1 Word.word)) in
      (let TrapEL2 = False in
      and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__23 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__23 (( 17 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__24 :: bool) . 
      (let (TrapEL3 :: bool) = w__24 in
      return (Enable, TrapEL2, TrapEL3))))))
    else
      (read_reg SCTLR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__25 :: 32 bits) . 
      (let (Enable :: 1 bits) = ((vec_of_bits [access_vec_dec w__25 (( 31 :: int)::ii)]  ::  1 Word.word)) in
      (let (TrapEL2 :: bool) = False in
      (let (TrapEL3 :: bool) = False in
      return (Enable, TrapEL2, TrapEL3)))))) \<bind> (\<lambda> varstup .  (let ((Enable :: 1 bits), (TrapEL2 ::
     bool), (TrapEL3 :: bool)) = varstup in
   if (((Enable = (vec_of_bits [B0]  ::  1 Word.word)))) then return X
   else if TrapEL2 then TrapPACUse EL2 \<then> (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
   else if TrapEL3 then TrapPACUse EL3 \<then> (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
   else (AddPAC X Y APIAKey_EL1 False  :: ( 64 Word.word) M)))))))))))))"


(*val aarch64_integer_pac_pacia_dp_1src : ii -> ii -> bool -> M unit*)

definition aarch64_integer_pac_pacia_dp_1src  :: " int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_pac_pacia_dp_1src d n source_is_sp = (
   if ((HavePACExt () )) then
     if source_is_sp then
       (aget_X (( 64 :: int)::ii) d  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
       (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
       (AddPACIA w__0 w__1  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::  64 Word.word) .  aset_X d w__2)))
     else
       (aget_X (( 64 :: int)::ii) d  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::  64 Word.word) . 
       (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 ::  64 Word.word) . 
       (AddPACIA w__3 w__4  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 ::  64 Word.word) .  aset_X d w__5)))
   else return ()  )"


(*val integer_pac_pacia_hint_decode : mword ty1 -> mword ty2 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty3 -> mword ty5 -> M unit*)

definition integer_pac_pacia_hint_decode  :: "(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_pac_pacia_hint_decode L op0 op1 CRn CRm op2 Rt = (
   (write_reg unconditional_ref True \<then>
   undefined_int () ) \<bind> (\<lambda> (d :: ii) . 
   undefined_int ()  \<bind> (\<lambda> (n :: ii) . 
   (let (source_is_sp :: bool) = False in
   (let b__0 = ((concat_vec CRm op2  ::  7 Word.word)) in
   (if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0]  ::  7 Word.word)))) then
      (let (d :: ii) = ((( 30 :: int)::ii)) in
      (let (n :: ii) = ((( 31 :: int)::ii)) in
      return (d, n, source_is_sp)))
    else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B1]  ::  7 Word.word)))) then
      (let (d :: ii) = ((( 30 :: int)::ii)) in
      (let (source_is_sp :: bool) = True in
      return (d, n, source_is_sp)))
    else
      (if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0]  ::  7 Word.word)))) then
         (let (d :: ii) = ((( 17 :: int)::ii)) in
         (let (n :: ii) = ((( 16 :: int)::ii)) in
         return (d, n)))
       else
         (if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0]  ::  7 Word.word)))) then
            throw (Error_See (''PACIB''))
          else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B1,B0,B0]  ::  7 Word.word)))) then
            throw (Error_See (''AUTIA''))
          else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B1,B1,B0]  ::  7 Word.word)))) then
            throw (Error_See (''AUTIB''))
          else if (((((subrange_vec_dec b__0 (( 6 :: int)::ii) (( 1 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B1]  ::  6 Word.word)))) then
            throw (Error_See (''PACIB''))
          else if (((((subrange_vec_dec b__0 (( 6 :: int)::ii) (( 1 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B1,B0]  ::  6 Word.word)))) then
            throw (Error_See (''AUTIA''))
          else if (((((subrange_vec_dec b__0 (( 6 :: int)::ii) (( 1 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B1,B1]  ::  6 Word.word)))) then
            throw (Error_See (''AUTIB''))
          else throw (Error_See (''XPACLRI''))) \<then>
         return (d, n)) \<bind> (\<lambda> varstup .  (let ((d :: ii), (n :: ii)) = varstup in
      return (d, n, source_is_sp)))) \<bind> (\<lambda> varstup .  (let ((d :: ii), (n :: ii), (source_is_sp :: bool)) = varstup in
   aarch64_integer_pac_pacia_dp_1src d n source_is_sp)))))))"


(*val AddPACGA : mword ty64 -> mword ty64 -> M (mword ty64)*)

definition AddPACGA  :: "(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " AddPACGA X Y = (
   undefined_bool ()  \<bind> (\<lambda> (TrapEL2 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (TrapEL3 :: bool) . 
   (read_reg APGAKeyHi_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 :: 64 bits) . 
   (read_reg APGAKeyLo_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 :: 64 bits) . 
   (let (APGAKey_EL1 :: 128 bits) =
     ((concat_vec ((slice w__0 (( 0 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))
        ((slice w__1 (( 0 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))
       ::  128 Word.word)) in
   read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) . 
   (let p__286 = ((ProcState_EL   w__2)) in
   (let pat0 = p__286 in
   (if (((pat0 = EL0))) then
      or_boolM
        (or_boolM (return ((\<not> ((HaveEL EL2)))))
           ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 :: 64 bits) . 
            return ((((vec_of_bits [access_vec_dec w__3 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__5 (( 34 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (IsEL1Regime :: bool) . 
      and_boolM
        (and_boolM (return (((((HaveEL EL2)) \<and> IsEL1Regime))))
           (IsSecure ()  \<bind> (\<lambda> (w__6 :: bool) .  return ((\<not> w__6)))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__8 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__8 (( 41 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__9 :: bool) . 
      (let TrapEL2 = w__9 in
      (read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__10 :: 32 bits) . 
      (let (TrapEL3 :: bool) =
        ((vec_of_bits [access_vec_dec w__10 (( 17 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)) in
      return (TrapEL2, TrapEL3))))))
    else if (((pat0 = EL1))) then
      and_boolM
        (and_boolM (return ((HaveEL EL2)))
           (IsSecure ()  \<bind> (\<lambda> (w__11 :: bool) .  return ((\<not> w__11)))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__13 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__13 (( 41 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__14 :: bool) . 
      (let TrapEL2 = w__14 in
      and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__15 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__15 (( 17 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__16 :: bool) . 
      (let (TrapEL3 :: bool) = w__16 in
      return (TrapEL2, TrapEL3)))))
    else if (((pat0 = EL2))) then
      (let TrapEL2 = False in
      and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__17 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__17 (( 17 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__18 :: bool) . 
      (let (TrapEL3 :: bool) = w__18 in
      return (TrapEL2, TrapEL3))))
    else
      (let (TrapEL2 :: bool) = False in
      (let (TrapEL3 :: bool) = False in
      return (TrapEL2, TrapEL3)))) \<bind> (\<lambda> varstup .  (let ((TrapEL2 :: bool), (TrapEL3 :: bool)) = varstup in
   if TrapEL2 then TrapPACUse EL2 \<then> (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
   else if TrapEL3 then TrapPACUse EL3 \<then> (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
   else
     (ComputePAC X Y ((slice APGAKey_EL1 (( 64 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))
        ((slice APGAKey_EL1 (( 0 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))
       :: ( 64 Word.word) M) \<bind> (\<lambda> (w__21 ::  64 Word.word) . 
     return ((concat_vec ((slice w__21 (( 32 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
                ((Zeros__0 ((make_the_value (( 32 :: int)::ii)  ::  32 itself))  ::  32 Word.word))
               ::  64 Word.word))))))))))))))"


(*val aarch64_integer_pac_pacga_dp_2src : ii -> ii -> ii -> bool -> M unit*)

definition aarch64_integer_pac_pacga_dp_2src  :: " int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_pac_pacga_dp_2src d m n source_is_sp = (
   if source_is_sp then
     (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
     (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
     (AddPACGA w__0 w__1  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::  64 Word.word) .  aset_X d w__2)))
   else
     (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::  64 Word.word) . 
     (aget_X (( 64 :: int)::ii) m  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 ::  64 Word.word) . 
     (AddPACGA w__3 w__4  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 ::  64 Word.word) .  aset_X d w__5))))"


(*val AddPACDB : mword ty64 -> mword ty64 -> M (mword ty64)*)

definition AddPACDB  :: "(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " AddPACDB X Y = (
   undefined_bool ()  \<bind> (\<lambda> (TrapEL2 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (TrapEL3 :: bool) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (Enable :: 1 bits) . 
   (read_reg APDBKeyHi_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 :: 64 bits) . 
   (read_reg APDBKeyLo_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 :: 64 bits) . 
   (let (APDBKey_EL1 :: 128 bits) =
     ((concat_vec ((slice w__0 (( 0 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))
        ((slice w__1 (( 0 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))
       ::  128 Word.word)) in
   read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) . 
   (let p__285 = ((ProcState_EL   w__2)) in
   (let pat0 = p__285 in
   (if (((pat0 = EL0))) then
      or_boolM
        (or_boolM (return ((\<not> ((HaveEL EL2)))))
           ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 :: 64 bits) . 
            return ((((vec_of_bits [access_vec_dec w__3 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__5 (( 34 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (IsEL1Regime :: bool) . 
      (if IsEL1Regime then
         (read_reg SCTLR_EL1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__6 :: 32 bits) . 
         return (vec_of_bits [access_vec_dec w__6 (( 13 :: int)::ii)]  ::  1 Word.word))
       else
         (read_reg SCTLR_EL2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__7 :: 32 bits) . 
         return (vec_of_bits [access_vec_dec w__7 (( 13 :: int)::ii)]  ::  1 Word.word))) \<bind> (\<lambda> (w__8 ::  1 Word.word) . 
      (let Enable = w__8 in
      and_boolM
        (and_boolM (return (((((HaveEL EL2)) \<and> IsEL1Regime))))
           (IsSecure ()  \<bind> (\<lambda> (w__9 :: bool) .  return ((\<not> w__9)))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__11 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__11 (( 41 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__12 :: bool) . 
      (let TrapEL2 = w__12 in
      and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__13 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__13 (( 17 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__14 :: bool) . 
      (let (TrapEL3 :: bool) = w__14 in
      return (Enable, TrapEL2, TrapEL3))))))))
    else if (((pat0 = EL1))) then
      (read_reg SCTLR_EL1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__15 :: 32 bits) . 
      (let Enable = ((vec_of_bits [access_vec_dec w__15 (( 13 :: int)::ii)]  ::  1 Word.word)) in
      and_boolM
        (and_boolM (return ((HaveEL EL2)))
           (IsSecure ()  \<bind> (\<lambda> (w__16 :: bool) .  return ((\<not> w__16)))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__18 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__18 (( 41 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__19 :: bool) . 
      (let TrapEL2 = w__19 in
      and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__20 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__20 (( 17 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__21 :: bool) . 
      (let (TrapEL3 :: bool) = w__21 in
      return (Enable, TrapEL2, TrapEL3)))))))
    else if (((pat0 = EL2))) then
      (read_reg SCTLR_EL2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__22 :: 32 bits) . 
      (let Enable = ((vec_of_bits [access_vec_dec w__22 (( 13 :: int)::ii)]  ::  1 Word.word)) in
      (let TrapEL2 = False in
      and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__23 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__23 (( 17 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__24 :: bool) . 
      (let (TrapEL3 :: bool) = w__24 in
      return (Enable, TrapEL2, TrapEL3))))))
    else
      (read_reg SCTLR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__25 :: 32 bits) . 
      (let (Enable :: 1 bits) = ((vec_of_bits [access_vec_dec w__25 (( 13 :: int)::ii)]  ::  1 Word.word)) in
      (let (TrapEL2 :: bool) = False in
      (let (TrapEL3 :: bool) = False in
      return (Enable, TrapEL2, TrapEL3)))))) \<bind> (\<lambda> varstup .  (let ((Enable :: 1 bits), (TrapEL2 ::
     bool), (TrapEL3 :: bool)) = varstup in
   if (((Enable = (vec_of_bits [B0]  ::  1 Word.word)))) then return X
   else if TrapEL2 then TrapPACUse EL2 \<then> (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
   else if TrapEL3 then TrapPACUse EL3 \<then> (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
   else (AddPAC X Y APDBKey_EL1 True  :: ( 64 Word.word) M)))))))))))))"


(*val aarch64_integer_pac_pacdb_dp_1src : ii -> ii -> bool -> M unit*)

definition aarch64_integer_pac_pacdb_dp_1src  :: " int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_pac_pacdb_dp_1src d n source_is_sp = (
   if source_is_sp then
     (aget_X (( 64 :: int)::ii) d  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
     (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
     (AddPACDB w__0 w__1  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::  64 Word.word) .  aset_X d w__2)))
   else
     (aget_X (( 64 :: int)::ii) d  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::  64 Word.word) . 
     (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 ::  64 Word.word) . 
     (AddPACDB w__3 w__4  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 ::  64 Word.word) .  aset_X d w__5))))"


(*val AddPACDA : mword ty64 -> mword ty64 -> M (mword ty64)*)

definition AddPACDA  :: "(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " AddPACDA X Y = (
   undefined_bool ()  \<bind> (\<lambda> (TrapEL2 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (TrapEL3 :: bool) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (Enable :: 1 bits) . 
   (read_reg APDAKeyHi_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 :: 64 bits) . 
   (read_reg APDAKeyLo_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 :: 64 bits) . 
   (let (APDAKey_EL1 :: 128 bits) =
     ((concat_vec ((slice w__0 (( 0 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))
        ((slice w__1 (( 0 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))
       ::  128 Word.word)) in
   read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) . 
   (let p__284 = ((ProcState_EL   w__2)) in
   (let pat0 = p__284 in
   (if (((pat0 = EL0))) then
      or_boolM
        (or_boolM (return ((\<not> ((HaveEL EL2)))))
           ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 :: 64 bits) . 
            return ((((vec_of_bits [access_vec_dec w__3 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__5 (( 34 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (IsEL1Regime :: bool) . 
      (if IsEL1Regime then
         (read_reg SCTLR_EL1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__6 :: 32 bits) . 
         return (vec_of_bits [access_vec_dec w__6 (( 27 :: int)::ii)]  ::  1 Word.word))
       else
         (read_reg SCTLR_EL2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__7 :: 32 bits) . 
         return (vec_of_bits [access_vec_dec w__7 (( 27 :: int)::ii)]  ::  1 Word.word))) \<bind> (\<lambda> (w__8 ::  1 Word.word) . 
      (let Enable = w__8 in
      and_boolM
        (and_boolM (return (((((HaveEL EL2)) \<and> IsEL1Regime))))
           (IsSecure ()  \<bind> (\<lambda> (w__9 :: bool) .  return ((\<not> w__9)))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__11 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__11 (( 41 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__12 :: bool) . 
      (let TrapEL2 = w__12 in
      and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__13 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__13 (( 17 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__14 :: bool) . 
      (let (TrapEL3 :: bool) = w__14 in
      return (Enable, TrapEL2, TrapEL3))))))))
    else if (((pat0 = EL1))) then
      (read_reg SCTLR_EL1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__15 :: 32 bits) . 
      (let Enable = ((vec_of_bits [access_vec_dec w__15 (( 27 :: int)::ii)]  ::  1 Word.word)) in
      and_boolM
        (and_boolM (return ((HaveEL EL2)))
           (IsSecure ()  \<bind> (\<lambda> (w__16 :: bool) .  return ((\<not> w__16)))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__18 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__18 (( 41 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__19 :: bool) . 
      (let TrapEL2 = w__19 in
      and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__20 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__20 (( 17 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__21 :: bool) . 
      (let (TrapEL3 :: bool) = w__21 in
      return (Enable, TrapEL2, TrapEL3)))))))
    else if (((pat0 = EL2))) then
      (read_reg SCTLR_EL2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__22 :: 32 bits) . 
      (let Enable = ((vec_of_bits [access_vec_dec w__22 (( 27 :: int)::ii)]  ::  1 Word.word)) in
      (let TrapEL2 = False in
      and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__23 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__23 (( 17 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__24 :: bool) . 
      (let (TrapEL3 :: bool) = w__24 in
      return (Enable, TrapEL2, TrapEL3))))))
    else
      (read_reg SCTLR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__25 :: 32 bits) . 
      (let (Enable :: 1 bits) = ((vec_of_bits [access_vec_dec w__25 (( 27 :: int)::ii)]  ::  1 Word.word)) in
      (let (TrapEL2 :: bool) = False in
      (let (TrapEL3 :: bool) = False in
      return (Enable, TrapEL2, TrapEL3)))))) \<bind> (\<lambda> varstup .  (let ((Enable :: 1 bits), (TrapEL2 ::
     bool), (TrapEL3 :: bool)) = varstup in
   if (((Enable = (vec_of_bits [B0]  ::  1 Word.word)))) then return X
   else if TrapEL2 then TrapPACUse EL2 \<then> (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
   else if TrapEL3 then TrapPACUse EL3 \<then> (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
   else (AddPAC X Y APDAKey_EL1 True  :: ( 64 Word.word) M)))))))))))))"


(*val aarch64_integer_pac_pacda_dp_1src : ii -> ii -> bool -> M unit*)

definition aarch64_integer_pac_pacda_dp_1src  :: " int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_pac_pacda_dp_1src d n source_is_sp = (
   if source_is_sp then
     (aget_X (( 64 :: int)::ii) d  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
     (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
     (AddPACDA w__0 w__1  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::  64 Word.word) .  aset_X d w__2)))
   else
     (aget_X (( 64 :: int)::ii) d  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::  64 Word.word) . 
     (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 ::  64 Word.word) . 
     (AddPACDA w__3 w__4  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 ::  64 Word.word) .  aset_X d w__5))))"


(*val AArch64_WatchpointException : mword ty64 -> FaultRecord -> M unit*)

definition AArch64_WatchpointException  :: "(64)Word.word \<Rightarrow> FaultRecord \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_WatchpointException vaddress fault = (
   read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) . 
   (assert_exp ((((ProcState_EL   w__0) \<noteq> EL3))) (''((PSTATE).EL != EL3)'') \<then>
   and_boolM
     (and_boolM
        (and_boolM (return ((HaveEL EL2)))
           (IsSecure ()  \<bind> (\<lambda> (w__1 :: bool) .  return ((\<not> w__1)))))
        (or_boolM
           (read_reg PSTATE_ref \<bind> (\<lambda> (w__3 :: ProcState) . 
            return ((((ProcState_EL   w__3) = EL0)))))
           (read_reg PSTATE_ref \<bind> (\<lambda> (w__4 :: ProcState) . 
            return ((((ProcState_EL   w__4) = EL1)))))))
     (or_boolM
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__7 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__7 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))
        ((read_reg MDCR_EL2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__8 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__8 (( 8 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))) \<bind> (\<lambda> (route_to_el2 :: bool) . 
   (ThisInstrAddr (( 64 :: int)::ii) ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (preferred_exception_return :: 64 bits) . 
   (let (vect_offset :: ii) = ((( 0 :: int)::ii)) in
   AArch64_AbortSyndrome Exception_Watchpoint fault vaddress \<bind> (\<lambda> (exception :: ExceptionRecord) . 
   or_boolM
     (read_reg PSTATE_ref \<bind> (\<lambda> (w__10 :: ProcState) .  return ((((ProcState_EL   w__10) = EL2)))))
     (return route_to_el2) \<bind> (\<lambda> (w__11 :: bool) . 
   if w__11 then AArch64_TakeException EL2 exception preferred_exception_return vect_offset
   else AArch64_TakeException EL1 exception preferred_exception_return vect_offset)))))))"


(*val AArch64_WFxTrap : mword ty2 -> bool -> M unit*)

definition AArch64_WFxTrap  :: "(2)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_WFxTrap target_el is_wfe = (
   read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) . 
   (assert_exp ((((Word.uint target_el)) > ((Word.uint(ProcState_EL   w__0))))) (''(UInt(target_el) > UInt((PSTATE).EL))'') \<then>
   (ThisInstrAddr (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)) \<bind> (\<lambda> (preferred_exception_return :: 64 bits) . 
   (let (vect_offset :: ii) = ((( 0 :: int)::ii)) in
   ExceptionSyndrome Exception_WFxTrap \<bind> (\<lambda> (exception :: ExceptionRecord) . 
   (let (tmp_2720 :: 25 bits) = ((ExceptionRecord_syndrome   exception)) in
   (ConditionSyndrome ()   :: ( 5 Word.word) M) \<bind> (\<lambda> (w__1 ::  5 Word.word) . 
   (let tmp_2720 = ((set_slice (( 25 :: int)::ii) (( 5 :: int)::ii) tmp_2720 (( 20 :: int)::ii) w__1  ::  25 Word.word)) in
   (let exception = ((exception (| ExceptionRecord_syndrome := tmp_2720 |))) in
   (let (tmp_2730 :: 25 bits) = ((ExceptionRecord_syndrome   exception)) in
   (let tmp_2730 =
     ((set_slice (( 25 :: int)::ii) (( 1 :: int)::ii) tmp_2730 (( 0 :: int)::ii)
        (if is_wfe then (vec_of_bits [B1]  ::  1 Word.word)
         else (vec_of_bits [B0]  ::  1 Word.word))
       ::  25 Word.word)) in
   (let exception = ((exception (| ExceptionRecord_syndrome := tmp_2730 |))) in
   and_boolM
     (and_boolM (return ((((((target_el = EL1))) \<and> ((HaveEL EL2))))))
        (IsSecure ()  \<bind> (\<lambda> (w__2 :: bool) .  return ((\<not> w__2)))))
     ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 :: 64 bits) . 
      return ((((vec_of_bits [access_vec_dec w__4 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__5 :: bool) . 
   if w__5 then AArch64_TakeException EL2 exception preferred_exception_return vect_offset
   else AArch64_TakeException target_el exception preferred_exception_return vect_offset)))))))))))))"


(*val AArch64_CheckForWFxTrap : mword ty2 -> bool -> M unit*)

definition AArch64_CheckForWFxTrap  :: "(2)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_CheckForWFxTrap target_el is_wfe = (
   (assert_exp ((HaveEL target_el)) (''HaveEL(target_el)'') \<then>
   undefined_bool () ) \<bind> (\<lambda> (trap :: bool) . 
   (let pat0 = target_el in
   (if (((pat0 = EL1))) then
      (if is_wfe then
         (aget_SCTLR__1 ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 ::  32 Word.word) . 
         return (vec_of_bits [access_vec_dec w__0 (( 18 :: int)::ii)]  ::  1 Word.word))
       else
         (aget_SCTLR__1 ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 ::  32 Word.word) . 
         return (vec_of_bits [access_vec_dec w__1 (( 16 :: int)::ii)]  ::  1 Word.word))) \<bind> (\<lambda> (w__2 ::  1 Word.word) . 
      (let (trap :: bool) = (w__2 = (vec_of_bits [B0]  ::  1 Word.word)) in
      return trap))
    else if (((pat0 = EL2))) then
      (if is_wfe then
         (read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 :: 64 bits) . 
         return (vec_of_bits [access_vec_dec w__3 (( 14 :: int)::ii)]  ::  1 Word.word))
       else
         (read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 :: 64 bits) . 
         return (vec_of_bits [access_vec_dec w__4 (( 13 :: int)::ii)]  ::  1 Word.word))) \<bind> (\<lambda> (w__5 ::  1 Word.word) . 
      (let (trap :: bool) = (w__5 = (vec_of_bits [B1]  ::  1 Word.word)) in
      return trap))
    else
      (if is_wfe then
         (read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__6 :: 32 bits) . 
         return (vec_of_bits [access_vec_dec w__6 (( 13 :: int)::ii)]  ::  1 Word.word))
       else
         (read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__7 :: 32 bits) . 
         return (vec_of_bits [access_vec_dec w__7 (( 12 :: int)::ii)]  ::  1 Word.word))) \<bind> (\<lambda> (w__8 ::  1 Word.word) . 
      (let (trap :: bool) = (w__8 = (vec_of_bits [B1]  ::  1 Word.word)) in
      return trap))) \<bind> (\<lambda> (trap :: bool) . 
   if trap then AArch64_WFxTrap target_el is_wfe
   else return () ))))"


(*val aarch64_system_hints : SystemHintOp -> M unit*)

fun aarch64_system_hints  :: " SystemHintOp \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_system_hints SystemHintOp_YIELD = ( return ((Hint_Yield () )))"
|" aarch64_system_hints SystemHintOp_WFE = (
      IsEventRegisterSet ()  \<bind> (\<lambda> (w__0 :: bool) . 
      if w__0 then ClearEventRegister () 
      else
        read_reg PSTATE_ref \<bind> (\<lambda> (w__1 :: ProcState) . 
        ((if ((((ProcState_EL   w__1) = EL0))) then AArch64_CheckForWFxTrap EL1 True
         else return () ) \<then>
        and_boolM
          (and_boolM
             (and_boolM (return ((HaveEL EL2)))
                (IsSecure ()  \<bind> (\<lambda> (w__2 :: bool) .  return ((\<not> w__2)))))
             (or_boolM
                (read_reg PSTATE_ref \<bind> (\<lambda> (w__4 :: ProcState) . 
                 return ((((ProcState_EL   w__4) = EL0)))))
                (read_reg PSTATE_ref \<bind> (\<lambda> (w__5 :: ProcState) . 
                 return ((((ProcState_EL   w__5) = EL1)))))))
          (IsInHost ()  \<bind> (\<lambda> (w__8 :: bool) .  return ((\<not> w__8))))) \<bind> (\<lambda> (w__9 :: bool) . 
        ((if w__9 then AArch64_CheckForWFxTrap EL2 True
         else return () ) \<then>
        and_boolM (return ((HaveEL EL3)))
          (read_reg PSTATE_ref \<bind> (\<lambda> (w__10 :: ProcState) . 
           return ((((ProcState_EL   w__10) \<noteq> EL3)))))) \<bind> (\<lambda> (w__11 :: bool) . 
        (if w__11 then AArch64_CheckForWFxTrap EL3 True else return () ) \<then> WaitForEvent () )))))"
|" aarch64_system_hints SystemHintOp_WFI = (
      InterruptPending ()  \<bind> (\<lambda> (w__12 :: bool) . 
      if ((\<not> w__12)) then
        read_reg PSTATE_ref \<bind> (\<lambda> (w__13 :: ProcState) . 
        ((if ((((ProcState_EL   w__13) = EL0))) then AArch64_CheckForWFxTrap EL1 False
         else return () ) \<then>
        and_boolM
          (and_boolM
             (and_boolM (return ((HaveEL EL2)))
                (IsSecure ()  \<bind> (\<lambda> (w__14 :: bool) .  return ((\<not> w__14)))))
             (or_boolM
                (read_reg PSTATE_ref \<bind> (\<lambda> (w__16 :: ProcState) . 
                 return ((((ProcState_EL   w__16) = EL0)))))
                (read_reg PSTATE_ref \<bind> (\<lambda> (w__17 :: ProcState) . 
                 return ((((ProcState_EL   w__17) = EL1)))))))
          (IsInHost ()  \<bind> (\<lambda> (w__20 :: bool) .  return ((\<not> w__20))))) \<bind> (\<lambda> (w__21 :: bool) . 
        ((if w__21 then AArch64_CheckForWFxTrap EL2 False
         else return () ) \<then>
        and_boolM (return ((HaveEL EL3)))
          (read_reg PSTATE_ref \<bind> (\<lambda> (w__22 :: ProcState) . 
           return ((((ProcState_EL   w__22) \<noteq> EL3)))))) \<bind> (\<lambda> (w__23 :: bool) . 
        (if w__23 then AArch64_CheckForWFxTrap EL3 False else return () ) \<then> WaitForInterrupt () )))
      else return () ))"
|" aarch64_system_hints SystemHintOp_SEV = ( SendEvent ()  )"
|" aarch64_system_hints SystemHintOp_SEVL = ( SendEventLocal ()  )"
|" aarch64_system_hints SystemHintOp_ESB = (
      (let (_ :: unit) = (ErrorSynchronizationBarrier MBReqDomain_FullSystem MBReqTypes_All) in
      (AArch64_ESBOperation ()  \<then>
      and_boolM
        (and_boolM (return ((HaveEL EL2)))
           (IsSecure ()  \<bind> (\<lambda> (w__24 :: bool) .  return ((\<not> w__24)))))
        (or_boolM
           (read_reg PSTATE_ref \<bind> (\<lambda> (w__26 :: ProcState) . 
            return ((((ProcState_EL   w__26) = EL0)))))
           (read_reg PSTATE_ref \<bind> (\<lambda> (w__27 :: ProcState) . 
            return ((((ProcState_EL   w__27) = EL1))))))) \<bind> (\<lambda> (w__29 :: bool) . 
      (if w__29 then AArch64_vESBOperation ()  else return () ) \<then> TakeUnmaskedSErrorInterrupts () )))"
|" aarch64_system_hints SystemHintOp_PSB = ( return ((ProfilingSynchronizationBarrier () )))"
|" aarch64_system_hints _ = ( return ()  )"


(*val system_hints_decode : mword ty1 -> mword ty2 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty3 -> mword ty5 -> M unit*)

definition system_hints_decode  :: "(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " system_hints_decode L op0 op1 CRn CRm op2 Rt = (
   (write_reg unconditional_ref True \<then>
   undefined_SystemHintOp () ) \<bind> (\<lambda> (op1 :: SystemHintOp) . 
   (let b__0 = ((concat_vec CRm op2  ::  7 Word.word)) in
   (if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) then
      return SystemHintOp_NOP
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)))) then
      return SystemHintOp_YIELD
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0]  ::  7 Word.word)))) then
      return SystemHintOp_WFE
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B1]  ::  7 Word.word)))) then
      return SystemHintOp_WFI
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B1,B0,B0]  ::  7 Word.word)))) then
      return SystemHintOp_SEV
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B1,B0,B1]  ::  7 Word.word)))) then
      return SystemHintOp_SEVL
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B1,B1,B1]  ::  7 Word.word)))) then
      throw (Error_See (''XPACLRI'')) \<then> return op1
    else if (((((subrange_vec_dec b__0 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = (vec_of_bits [B0,B0,B0,B1]  ::  4 Word.word)))) then
      throw (Error_See (''PACIA1716, PACIB1716, AUTIA1716, AUTIB1716'')) \<then> return op1
    else if (((b__0 = (vec_of_bits [B0,B0,B1,B0,B0,B0,B0]  ::  7 Word.word)))) then
      (if ((\<not> ((HaveRASExt () )))) then EndOfInstruction () 
       else return () ) \<then>
      return SystemHintOp_ESB
    else if (((b__0 = (vec_of_bits [B0,B0,B1,B0,B0,B0,B1]  ::  7 Word.word)))) then
      (if ((\<not> ((HaveStatisticalProfiling () )))) then EndOfInstruction () 
       else return () ) \<then>
      return SystemHintOp_PSB
    else
      (if (((((subrange_vec_dec b__0 (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  4 Word.word)) = (vec_of_bits [B0,B0,B1,B1]  ::  4 Word.word)))) then
         throw (Error_See (''PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP''))
       else EndOfInstruction () ) \<then>
      return op1) \<bind> (\<lambda> (op1 :: SystemHintOp) . 
   aarch64_system_hints op1))))"


(*val AArch64_VectorCatchException : FaultRecord -> M unit*)

definition AArch64_VectorCatchException  :: " FaultRecord \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_VectorCatchException fault = (
   read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) . 
   (assert_exp ((((ProcState_EL   w__0) \<noteq> EL2))) (''((PSTATE).EL != EL2)'') \<then>
   and_boolM
     (and_boolM (return ((HaveEL EL2))) (IsSecure ()  \<bind> (\<lambda> (w__1 :: bool) .  return ((\<not> w__1)))))
     (or_boolM
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__3 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))
        ((read_reg MDCR_EL2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__4 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__4 (( 8 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))) \<bind> (\<lambda> (w__6 :: bool) . 
   (assert_exp w__6 ([(CHR ''(''), (CHR ''(''), (CHR ''H''), (CHR ''a''), (CHR ''v''), (CHR ''e''), (CHR ''E''), (CHR ''L''), (CHR ''(''), (CHR ''E''), (CHR ''L''), (CHR ''2''), (CHR '')''), (CHR '' ''), (CHR ''&''), (CHR ''&''), (CHR '' ''), (CHR ''!''), (CHR ''(''), (CHR ''I''), (CHR ''s''), (CHR ''S''), (CHR ''e''), (CHR ''c''), (CHR ''u''), (CHR ''r''), (CHR ''e''), (CHR ''(''), (CHR '')''), (CHR '')''), (CHR '')''), (CHR '' ''), (CHR ''&''), (CHR ''&''), (CHR '' ''), (CHR ''(''), (CHR ''(''), (CHR ''(''), (CHR ''H''), (CHR ''C''), (CHR ''R''), (CHR ''_''), (CHR ''E''), (CHR ''L''), (CHR ''2''), (CHR '')''), (CHR ''.''), (CHR ''T''), (CHR ''G''), (CHR ''E''), (CHR '' ''), (CHR ''=''), (CHR ''=''), (CHR '' ''), (CHR 0x27), (CHR ''1''), (CHR 0x27), (CHR '')''), (CHR '' ''), (CHR ''|''), (CHR ''|''), (CHR '' ''), (CHR ''(''), (CHR ''(''), (CHR ''M''), (CHR ''D''), (CHR ''C''), (CHR ''R''), (CHR ''_''), (CHR ''E''), (CHR ''L''), (CHR ''2''), (CHR '')''), (CHR ''.''), (CHR ''T''), (CHR ''D''), (CHR ''E''), (CHR '' ''), (CHR ''=''), (CHR ''=''), (CHR '' ''), (CHR 0x27), (CHR ''1''), (CHR 0x27), (CHR '')''), (CHR '')''), (CHR '')'')]) \<then>
   (ThisInstrAddr (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)) \<bind> (\<lambda> (preferred_exception_return :: 64 bits) . 
   (let (vect_offset :: ii) = ((( 0 :: int)::ii)) in
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (vaddress :: 64 bits) . 
   AArch64_AbortSyndrome Exception_VectorCatch fault vaddress \<bind> (\<lambda> (exception :: ExceptionRecord) . 
   AArch64_TakeException EL2 exception preferred_exception_return vect_offset)))))))"


(*val AArch64_UndefinedFault : unit -> M unit*)

definition AArch64_UndefinedFault  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_UndefinedFault _ = (
   and_boolM
     (and_boolM
        (and_boolM (return ((HaveEL EL2)))
           (IsSecure ()  \<bind> (\<lambda> (w__0 :: bool) .  return ((\<not> w__0)))))
        (read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) .  return ((((ProcState_EL   w__2) = EL0))))))
     ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 :: 64 bits) . 
      return ((((vec_of_bits [access_vec_dec w__4 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (route_to_el2 :: bool) . 
   (ThisInstrAddr (( 64 :: int)::ii) ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (preferred_exception_return :: 64 bits) . 
   (let (vect_offset :: ii) = ((( 0 :: int)::ii)) in
   ExceptionSyndrome Exception_Uncategorized \<bind> (\<lambda> (exception :: ExceptionRecord) . 
   read_reg PSTATE_ref \<bind> (\<lambda> (w__5 :: ProcState) . 
   if ((((Word.uint(ProcState_EL   w__5))) > ((Word.uint EL1)))) then
     read_reg PSTATE_ref \<bind> (\<lambda> (w__6 :: ProcState) . 
     AArch64_TakeException(ProcState_EL   w__6) exception preferred_exception_return vect_offset)
   else if route_to_el2 then
     AArch64_TakeException EL2 exception preferred_exception_return vect_offset
   else AArch64_TakeException EL1 exception preferred_exception_return vect_offset))))))"


(*val AArch64_SystemRegisterTrap : mword ty2 -> mword ty2 -> mword ty3 -> mword ty3 -> mword ty4 -> mword ty5 -> mword ty4 -> mword ty1 -> M unit*)

definition AArch64_SystemRegisterTrap  :: "(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_SystemRegisterTrap target_el op0 op2 op1 crn rt crm dir = (
   read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) . 
   (assert_exp ((((Word.uint target_el)) \<ge> ((Word.uint(ProcState_EL   w__0))))) (''(UInt(target_el) >= UInt((PSTATE).EL))'') \<then>
   (ThisInstrAddr (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)) \<bind> (\<lambda> (preferred_exception_return :: 64 bits) . 
   (let (vect_offset :: ii) = ((( 0 :: int)::ii)) in
   ExceptionSyndrome Exception_SystemRegisterTrap \<bind> (\<lambda> (exception :: ExceptionRecord) . 
   (let (tmp_2800 :: 25 bits) = ((ExceptionRecord_syndrome   exception)) in
   (let tmp_2800 = ((set_slice (( 25 :: int)::ii) (( 2 :: int)::ii) tmp_2800 (( 20 :: int)::ii) op0  ::  25 Word.word)) in
   (let exception = ((exception (| ExceptionRecord_syndrome := tmp_2800 |))) in
   (let (tmp_2810 :: 25 bits) = ((ExceptionRecord_syndrome   exception)) in
   (let tmp_2810 = ((set_slice (( 25 :: int)::ii) (( 3 :: int)::ii) tmp_2810 (( 17 :: int)::ii) op2  ::  25 Word.word)) in
   (let exception = ((exception (| ExceptionRecord_syndrome := tmp_2810 |))) in
   (let (tmp_2820 :: 25 bits) = ((ExceptionRecord_syndrome   exception)) in
   (let tmp_2820 = ((set_slice (( 25 :: int)::ii) (( 3 :: int)::ii) tmp_2820 (( 14 :: int)::ii) op1  ::  25 Word.word)) in
   (let exception = ((exception (| ExceptionRecord_syndrome := tmp_2820 |))) in
   (let (tmp_2830 :: 25 bits) = ((ExceptionRecord_syndrome   exception)) in
   (let tmp_2830 = ((set_slice (( 25 :: int)::ii) (( 4 :: int)::ii) tmp_2830 (( 10 :: int)::ii) crn  ::  25 Word.word)) in
   (let exception = ((exception (| ExceptionRecord_syndrome := tmp_2830 |))) in
   (let (tmp_2840 :: 25 bits) = ((ExceptionRecord_syndrome   exception)) in
   (let tmp_2840 = ((set_slice (( 25 :: int)::ii) (( 5 :: int)::ii) tmp_2840 (( 5 :: int)::ii) rt  ::  25 Word.word)) in
   (let exception = ((exception (| ExceptionRecord_syndrome := tmp_2840 |))) in
   (let (tmp_2850 :: 25 bits) = ((ExceptionRecord_syndrome   exception)) in
   (let tmp_2850 = ((set_slice (( 25 :: int)::ii) (( 4 :: int)::ii) tmp_2850 (( 1 :: int)::ii) crm  ::  25 Word.word)) in
   (let exception = ((exception (| ExceptionRecord_syndrome := tmp_2850 |))) in
   (let (tmp_2860 :: 25 bits) = ((ExceptionRecord_syndrome   exception)) in
   (let tmp_2860 = ((set_slice (( 25 :: int)::ii) (( 1 :: int)::ii) tmp_2860 (( 0 :: int)::ii) dir  ::  25 Word.word)) in
   (let exception = ((exception (| ExceptionRecord_syndrome := tmp_2860 |))) in
   and_boolM
     (and_boolM (return ((((((target_el = EL1))) \<and> ((HaveEL EL2))))))
        (IsSecure ()  \<bind> (\<lambda> (w__1 :: bool) .  return ((\<not> w__1)))))
     ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 :: 64 bits) . 
      return ((((vec_of_bits [access_vec_dec w__3 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__4 :: bool) . 
   if w__4 then AArch64_TakeException EL2 exception preferred_exception_return vect_offset
   else AArch64_TakeException target_el exception preferred_exception_return vect_offset)))))))))))))))))))))))))))"


(*val AArch64_SoftwareBreakpoint : mword ty16 -> M unit*)

definition AArch64_SoftwareBreakpoint  :: "(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_SoftwareBreakpoint immediate = (
   and_boolM
     (and_boolM
        (and_boolM (return ((HaveEL EL2)))
           (IsSecure ()  \<bind> (\<lambda> (w__0 :: bool) .  return ((\<not> w__0)))))
        (or_boolM
           (read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) . 
            return ((((ProcState_EL   w__2) = EL0)))))
           (read_reg PSTATE_ref \<bind> (\<lambda> (w__3 :: ProcState) . 
            return ((((ProcState_EL   w__3) = EL1)))))))
     (or_boolM
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__6 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__6 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))
        ((read_reg MDCR_EL2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__7 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__7 (( 8 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))) \<bind> (\<lambda> (route_to_el2 :: bool) . 
   (ThisInstrAddr (( 64 :: int)::ii) ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (preferred_exception_return :: 64 bits) . 
   (let (vect_offset :: ii) = ((( 0 :: int)::ii)) in
   ExceptionSyndrome Exception_SoftwareBreakpoint \<bind> (\<lambda> (exception :: ExceptionRecord) . 
   (let (tmp_2710 :: 25 bits) = ((ExceptionRecord_syndrome   exception)) in
   (let tmp_2710 = ((set_slice (( 25 :: int)::ii) (( 16 :: int)::ii) tmp_2710 (( 0 :: int)::ii) immediate  ::  25 Word.word)) in
   (let exception = ((exception (| ExceptionRecord_syndrome := tmp_2710 |))) in
   read_reg PSTATE_ref \<bind> (\<lambda> (w__9 :: ProcState) . 
   if ((((Word.uint(ProcState_EL   w__9))) > ((Word.uint EL1)))) then
     read_reg PSTATE_ref \<bind> (\<lambda> (w__10 :: ProcState) . 
     AArch64_TakeException(ProcState_EL   w__10) exception preferred_exception_return vect_offset)
   else if route_to_el2 then
     AArch64_TakeException EL2 exception preferred_exception_return vect_offset
   else AArch64_TakeException EL1 exception preferred_exception_return vect_offset)))))))))"


(*val aarch64_system_exceptions_debug_breakpoint : mword ty16 -> M unit*)

definition aarch64_system_exceptions_debug_breakpoint  :: "(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_system_exceptions_debug_breakpoint comment = ( AArch64_SoftwareBreakpoint comment )"


(*val system_exceptions_debug_breakpoint_decode : mword ty3 -> mword ty16 -> mword ty3 -> mword ty2 -> M unit*)

definition system_exceptions_debug_breakpoint_decode  :: "(3)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " system_exceptions_debug_breakpoint_decode opc imm16 op2 LL = (
   write_reg unconditional_ref True \<then>
   ((let (comment :: 16 bits) = imm16 in
   aarch64_system_exceptions_debug_breakpoint comment)))"


(*val AArch64_SPAlignmentFault : unit -> M unit*)

definition AArch64_SPAlignmentFault  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_SPAlignmentFault _ = (
   (ThisInstrAddr (( 64 :: int)::ii) ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (preferred_exception_return :: 64 bits) . 
   (let (vect_offset :: ii) = ((( 0 :: int)::ii)) in
   ExceptionSyndrome Exception_SPAlignment \<bind> (\<lambda> (exception :: ExceptionRecord) . 
   read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) . 
   if ((((Word.uint(ProcState_EL   w__0))) > ((Word.uint EL1)))) then
     read_reg PSTATE_ref \<bind> (\<lambda> (w__1 :: ProcState) . 
     AArch64_TakeException(ProcState_EL   w__1) exception preferred_exception_return vect_offset)
   else
     and_boolM
       (and_boolM (return ((HaveEL EL2))) (IsSecure ()  \<bind> (\<lambda> (w__2 :: bool) .  return ((\<not> w__2)))))
       ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 :: 64 bits) . 
        return ((((vec_of_bits [access_vec_dec w__4 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__5 :: bool) . 
     if w__5 then AArch64_TakeException EL2 exception preferred_exception_return vect_offset
     else AArch64_TakeException EL1 exception preferred_exception_return vect_offset))))))"


(*val CheckSPAlignment : unit -> M unit*)

definition CheckSPAlignment  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " CheckSPAlignment _ = (
   (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (sp :: 64 bits) . 
   undefined_bool ()  \<bind> (\<lambda> (stack_align_check :: bool) . 
   read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) . 
   (if ((((ProcState_EL   w__0) = EL0))) then
      (aget_SCTLR__1 ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 ::  32 Word.word) . 
      (let (stack_align_check :: bool) =
        ((vec_of_bits [access_vec_dec w__1 (( 4 :: int)::ii)]  ::  1 Word.word) \<noteq> (vec_of_bits [B0]  ::  1 Word.word)) in
      return stack_align_check))
    else
      (aget_SCTLR__1 ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__2 ::  32 Word.word) . 
      (let (stack_align_check :: bool) =
        ((vec_of_bits [access_vec_dec w__2 (( 3 :: int)::ii)]  ::  1 Word.word) \<noteq> (vec_of_bits [B0]  ::  1 Word.word)) in
      return stack_align_check))) \<bind> (\<lambda> (stack_align_check :: bool) . 
   if (((stack_align_check \<and> (((sp \<noteq> ((Align__1 sp (( 16 :: int)::ii)  ::  64 Word.word)))))))) then
     AArch64_SPAlignmentFault () 
   else return () )))))"


(*val AArch64_InstructionAbort : mword ty64 -> FaultRecord -> M unit*)

definition AArch64_InstructionAbort  :: "(64)Word.word \<Rightarrow> FaultRecord \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_InstructionAbort vaddress fault = (
   and_boolM
     (and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__0 (( 3 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))) ((IsExternalAbort__1 fault)) \<bind> (\<lambda> (route_to_el3 ::
     bool) . 
   and_boolM
     (and_boolM
        (and_boolM (return ((HaveEL EL2)))
           (IsSecure ()  \<bind> (\<lambda> (w__3 :: bool) .  return ((\<not> w__3)))))
        (or_boolM
           (read_reg PSTATE_ref \<bind> (\<lambda> (w__5 :: ProcState) . 
            return ((((ProcState_EL   w__5) = EL0)))))
           (read_reg PSTATE_ref \<bind> (\<lambda> (w__6 :: ProcState) . 
            return ((((ProcState_EL   w__6) = EL1)))))))
     (or_boolM
        (or_boolM
           ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__9 :: 64 bits) . 
            return ((((vec_of_bits [access_vec_dec w__9 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) ((IsSecondStage fault)))
        (and_boolM
           (and_boolM (return ((HaveRASExt () )))
              ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__12 :: 64 bits) . 
               return ((((vec_of_bits [access_vec_dec w__12 (( 37 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))) ((IsExternalAbort__1 fault)))) \<bind> (\<lambda> (route_to_el2 ::
     bool) . 
   (ThisInstrAddr (( 64 :: int)::ii) ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (preferred_exception_return :: 64 bits) . 
   (let (vect_offset :: ii) = ((( 0 :: int)::ii)) in
   AArch64_AbortSyndrome Exception_InstructionAbort fault vaddress \<bind> (\<lambda> (exception ::
     ExceptionRecord) . 
   or_boolM
     (read_reg PSTATE_ref \<bind> (\<lambda> (w__17 :: ProcState) .  return ((((ProcState_EL   w__17) = EL3)))))
     (return route_to_el3) \<bind> (\<lambda> (w__18 :: bool) . 
   if w__18 then AArch64_TakeException EL3 exception preferred_exception_return vect_offset
   else
     or_boolM
       (read_reg PSTATE_ref \<bind> (\<lambda> (w__19 :: ProcState) .  return ((((ProcState_EL   w__19) = EL2)))))
       (return route_to_el2) \<bind> (\<lambda> (w__20 :: bool) . 
     if w__20 then AArch64_TakeException EL2 exception preferred_exception_return vect_offset
     else AArch64_TakeException EL1 exception preferred_exception_return vect_offset))))))))"


(*val AArch64_DataAbort : mword ty64 -> FaultRecord -> M unit*)

definition AArch64_DataAbort  :: "(64)Word.word \<Rightarrow> FaultRecord \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_DataAbort vaddress fault = (
   and_boolM
     (and_boolM (return ((HaveEL EL3)))
        ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__0 (( 3 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))) ((IsExternalAbort__1 fault)) \<bind> (\<lambda> (route_to_el3 ::
     bool) . 
   and_boolM
     (and_boolM
        (and_boolM (return ((HaveEL EL2)))
           (IsSecure ()  \<bind> (\<lambda> (w__3 :: bool) .  return ((\<not> w__3)))))
        (or_boolM
           (read_reg PSTATE_ref \<bind> (\<lambda> (w__5 :: ProcState) . 
            return ((((ProcState_EL   w__5) = EL0)))))
           (read_reg PSTATE_ref \<bind> (\<lambda> (w__6 :: ProcState) . 
            return ((((ProcState_EL   w__6) = EL1)))))))
     (or_boolM
        (or_boolM
           ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__9 :: 64 bits) . 
            return ((((vec_of_bits [access_vec_dec w__9 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) ((IsSecondStage fault)))
        (and_boolM
           (and_boolM (return ((HaveRASExt () )))
              ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__12 :: 64 bits) . 
               return ((((vec_of_bits [access_vec_dec w__12 (( 37 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))) ((IsExternalAbort__1 fault)))) \<bind> (\<lambda> (route_to_el2 ::
     bool) . 
   (ThisInstrAddr (( 64 :: int)::ii) ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (preferred_exception_return :: 64 bits) . 
   (let (vect_offset :: ii) = ((( 0 :: int)::ii)) in
   AArch64_AbortSyndrome Exception_DataAbort fault vaddress \<bind> (\<lambda> (exception :: ExceptionRecord) . 
   or_boolM
     (read_reg PSTATE_ref \<bind> (\<lambda> (w__17 :: ProcState) .  return ((((ProcState_EL   w__17) = EL3)))))
     (return route_to_el3) \<bind> (\<lambda> (w__18 :: bool) . 
   if w__18 then AArch64_TakeException EL3 exception preferred_exception_return vect_offset
   else
     or_boolM
       (read_reg PSTATE_ref \<bind> (\<lambda> (w__19 :: ProcState) .  return ((((ProcState_EL   w__19) = EL2)))))
       (return route_to_el2) \<bind> (\<lambda> (w__20 :: bool) . 
     if w__20 then AArch64_TakeException EL2 exception preferred_exception_return vect_offset
     else AArch64_TakeException EL1 exception preferred_exception_return vect_offset))))))))"


(*val AArch64_CheckForERetTrap : bool -> bool -> M unit*)

definition AArch64_CheckForERetTrap  :: " bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_CheckForERetTrap eret_with_pac pac_uses_key_a = (
   and_boolM
     (and_boolM
        (and_boolM (return (((((HaveNVExt () )) \<and> ((HaveEL EL2))))))
           (IsSecure ()  \<bind> (\<lambda> (w__0 :: bool) .  return ((\<not> w__0)))))
        (read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) .  return ((((ProcState_EL   w__2) = EL1))))))
     ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 :: 64 bits) . 
      return ((((vec_of_bits [access_vec_dec w__4 (( 42 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (route_to_el2 :: bool) . 
   undefined_int ()  \<bind> (\<lambda> (vect_offset :: ii) . 
   if route_to_el2 then
     undefined_ExceptionRecord ()  \<bind> (\<lambda> (exception :: ExceptionRecord) . 
     (ThisInstrAddr (( 64 :: int)::ii) ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (preferred_exception_return :: 64 bits) . 
     (let vect_offset = ((( 0 :: int)::ii)) in
     ExceptionSyndrome Exception_ERetTrap \<bind> (\<lambda> (w__5 :: ExceptionRecord) . 
     (let exception = w__5 in
     (let (tmp_2550 :: 25 bits) = ((ExceptionRecord_syndrome   exception)) in
     (ZeroExtend__0 (vec_of_bits [B0]  ::  1 Word.word) ((make_the_value (( 23 :: int)::ii)  ::  23 itself))
       :: ( 23 Word.word) M) \<bind> (\<lambda> (w__6 ::  23 Word.word) . 
     (let tmp_2550 = ((set_slice (( 25 :: int)::ii) (( 23 :: int)::ii) tmp_2550 (( 2 :: int)::ii) w__6  ::  25 Word.word)) in
     (let exception = ((exception (| ExceptionRecord_syndrome := tmp_2550 |))) in
     (let (exception :: ExceptionRecord) =
       (if ((\<not> eret_with_pac)) then
         (let (tmp_2560 :: 25 bits) = ((ExceptionRecord_syndrome   exception)) in
         (let (tmp_2560 :: 25 bits) =
           ((set_slice (( 25 :: int)::ii) (( 1 :: int)::ii) tmp_2560 (( 1 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  25 Word.word)) in
         (let (exception :: ExceptionRecord) = ((exception (| ExceptionRecord_syndrome := tmp_2560 |))) in
         (let (tmp_2570 :: 25 bits) = ((ExceptionRecord_syndrome   exception)) in
         (let (tmp_2570 :: 25 bits) =
           ((set_slice (( 25 :: int)::ii) (( 1 :: int)::ii) tmp_2570 (( 0 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  25 Word.word)) in
         (exception (| ExceptionRecord_syndrome := tmp_2570 |)))))))
       else
         (let (tmp_2580 :: 25 bits) = ((ExceptionRecord_syndrome   exception)) in
         (let (tmp_2580 :: 25 bits) =
           ((set_slice (( 25 :: int)::ii) (( 1 :: int)::ii) tmp_2580 (( 1 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)  ::  25 Word.word)) in
         (let (exception :: ExceptionRecord) = ((exception (| ExceptionRecord_syndrome := tmp_2580 |))) in
         if pac_uses_key_a then
           (let (tmp_2590 :: 25 bits) = ((ExceptionRecord_syndrome   exception)) in
           (let (tmp_2590 :: 25 bits) =
             ((set_slice (( 25 :: int)::ii) (( 1 :: int)::ii) tmp_2590 (( 0 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)
               ::  25 Word.word)) in
           (exception (| ExceptionRecord_syndrome := tmp_2590 |))))
         else
           (let (tmp_2600 :: 25 bits) = ((ExceptionRecord_syndrome   exception)) in
           (let (tmp_2600 :: 25 bits) =
             ((set_slice (( 25 :: int)::ii) (( 1 :: int)::ii) tmp_2600 (( 0 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)
               ::  25 Word.word)) in
           (exception (| ExceptionRecord_syndrome := tmp_2600 |)))))))) in
     AArch64_TakeException EL2 exception preferred_exception_return vect_offset))))))))))
   else return () )))"


(*val AArch64_CallSupervisor : mword ty16 -> M unit*)

definition AArch64_CallSupervisor  :: "(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_CallSupervisor immediate = (
   UsingAArch32 ()  \<bind> (\<lambda> (w__0 :: bool) . 
   (((if w__0 then AArch32_ITAdvance () 
    else return () ) \<then>
   SSAdvance () ) \<then>
   and_boolM
     (and_boolM
        (and_boolM (return ((HaveEL EL2)))
           (IsSecure ()  \<bind> (\<lambda> (w__1 :: bool) .  return ((\<not> w__1)))))
        (read_reg PSTATE_ref \<bind> (\<lambda> (w__3 :: ProcState) .  return ((((ProcState_EL   w__3) = EL0))))))
     ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 :: 64 bits) . 
      return ((((vec_of_bits [access_vec_dec w__5 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))) \<bind> (\<lambda> (route_to_el2 :: bool) . 
   (NextInstrAddr (( 64 :: int)::ii) ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (preferred_exception_return :: 64 bits) . 
   (let (vect_offset :: ii) = ((( 0 :: int)::ii)) in
   ExceptionSyndrome Exception_SupervisorCall \<bind> (\<lambda> (exception :: ExceptionRecord) . 
   (let (tmp_2770 :: 25 bits) = ((ExceptionRecord_syndrome   exception)) in
   (let tmp_2770 = ((set_slice (( 25 :: int)::ii) (( 16 :: int)::ii) tmp_2770 (( 0 :: int)::ii) immediate  ::  25 Word.word)) in
   (let exception = ((exception (| ExceptionRecord_syndrome := tmp_2770 |))) in
   read_reg PSTATE_ref \<bind> (\<lambda> (w__6 :: ProcState) . 
   if ((((Word.uint(ProcState_EL   w__6))) > ((Word.uint EL1)))) then
     read_reg PSTATE_ref \<bind> (\<lambda> (w__7 :: ProcState) . 
     AArch64_TakeException(ProcState_EL   w__7) exception preferred_exception_return vect_offset)
   else if route_to_el2 then
     AArch64_TakeException EL2 exception preferred_exception_return vect_offset
   else AArch64_TakeException EL1 exception preferred_exception_return vect_offset))))))))))"


(*val aarch64_system_exceptions_runtime_svc : mword ty16 -> M unit*)

definition aarch64_system_exceptions_runtime_svc  :: "(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_system_exceptions_runtime_svc imm = ( AArch64_CallSupervisor imm )"


(*val system_exceptions_runtime_svc_decode : mword ty3 -> mword ty16 -> mword ty3 -> mword ty2 -> M unit*)

definition system_exceptions_runtime_svc_decode  :: "(3)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " system_exceptions_runtime_svc_decode opc imm16 op2 LL = (
   write_reg unconditional_ref True \<then>
   ((let (imm :: 16 bits) = imm16 in
   aarch64_system_exceptions_runtime_svc imm)))"


(*val AArch64_CallSecureMonitor : mword ty16 -> M unit*)

definition AArch64_CallSecureMonitor  :: "(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_CallSecureMonitor immediate = (
   and_boolM (return ((HaveEL EL3)))
     (ELUsingAArch32 EL3 \<bind> (\<lambda> (w__0 :: bool) .  return ((\<not> w__0)))) \<bind> (\<lambda> (w__1 :: bool) . 
   (assert_exp w__1 (''(HaveEL(EL3) && !(ELUsingAArch32(EL3)))'') \<then>
   UsingAArch32 () ) \<bind> (\<lambda> (w__2 :: bool) . 
   (((if w__2 then AArch32_ITAdvance () 
    else return () ) \<then>
   SSAdvance () ) \<then>
   (NextInstrAddr (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)) \<bind> (\<lambda> (preferred_exception_return :: 64 bits) . 
   (let (vect_offset :: ii) = ((( 0 :: int)::ii)) in
   ExceptionSyndrome Exception_MonitorCall \<bind> (\<lambda> (exception :: ExceptionRecord) . 
   (let (tmp_2930 :: 25 bits) = ((ExceptionRecord_syndrome   exception)) in
   (let tmp_2930 = ((set_slice (( 25 :: int)::ii) (( 16 :: int)::ii) tmp_2930 (( 0 :: int)::ii) immediate  ::  25 Word.word)) in
   (let exception = ((exception (| ExceptionRecord_syndrome := tmp_2930 |))) in
   AArch64_TakeException EL3 exception preferred_exception_return vect_offset)))))))))"


(*val AArch64_CallHypervisor : mword ty16 -> M unit*)

definition AArch64_CallHypervisor  :: "(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_CallHypervisor immediate = (
   (assert_exp ((HaveEL EL2)) (''HaveEL(EL2)'') \<then>
   UsingAArch32 () ) \<bind> (\<lambda> (w__0 :: bool) . 
   (((if w__0 then AArch32_ITAdvance () 
    else return () ) \<then>
   SSAdvance () ) \<then>
   (NextInstrAddr (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)) \<bind> (\<lambda> (preferred_exception_return :: 64 bits) . 
   (let (vect_offset :: ii) = ((( 0 :: int)::ii)) in
   ExceptionSyndrome Exception_HypervisorCall \<bind> (\<lambda> (exception :: ExceptionRecord) . 
   (let (tmp_2890 :: 25 bits) = ((ExceptionRecord_syndrome   exception)) in
   (let tmp_2890 = ((set_slice (( 25 :: int)::ii) (( 16 :: int)::ii) tmp_2890 (( 0 :: int)::ii) immediate  ::  25 Word.word)) in
   (let exception = ((exception (| ExceptionRecord_syndrome := tmp_2890 |))) in
   read_reg PSTATE_ref \<bind> (\<lambda> (w__1 :: ProcState) . 
   if ((((ProcState_EL   w__1) = EL3))) then
     AArch64_TakeException EL3 exception preferred_exception_return vect_offset
   else AArch64_TakeException EL2 exception preferred_exception_return vect_offset)))))))))"


(*val AArch64_BreakpointException : FaultRecord -> M unit*)

definition AArch64_BreakpointException  :: " FaultRecord \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_BreakpointException fault = (
   read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) . 
   (assert_exp ((((ProcState_EL   w__0) \<noteq> EL3))) (''((PSTATE).EL != EL3)'') \<then>
   and_boolM
     (and_boolM
        (and_boolM (return ((HaveEL EL2)))
           (IsSecure ()  \<bind> (\<lambda> (w__1 :: bool) .  return ((\<not> w__1)))))
        (or_boolM
           (read_reg PSTATE_ref \<bind> (\<lambda> (w__3 :: ProcState) . 
            return ((((ProcState_EL   w__3) = EL0)))))
           (read_reg PSTATE_ref \<bind> (\<lambda> (w__4 :: ProcState) . 
            return ((((ProcState_EL   w__4) = EL1)))))))
     (or_boolM
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__7 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__7 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))
        ((read_reg MDCR_EL2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__8 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__8 (( 8 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))) \<bind> (\<lambda> (route_to_el2 :: bool) . 
   (ThisInstrAddr (( 64 :: int)::ii) ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (preferred_exception_return :: 64 bits) . 
   (let (vect_offset :: ii) = ((( 0 :: int)::ii)) in
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (vaddress :: 64 bits) . 
   AArch64_AbortSyndrome Exception_Breakpoint fault vaddress \<bind> (\<lambda> (exception :: ExceptionRecord) . 
   or_boolM
     (read_reg PSTATE_ref \<bind> (\<lambda> (w__10 :: ProcState) .  return ((((ProcState_EL   w__10) = EL2)))))
     (return route_to_el2) \<bind> (\<lambda> (w__11 :: bool) . 
   if w__11 then AArch64_TakeException EL2 exception preferred_exception_return vect_offset
   else AArch64_TakeException EL1 exception preferred_exception_return vect_offset))))))))"


(*val AArch64_Abort : mword ty64 -> FaultRecord -> M unit*)

definition AArch64_Abort  :: "(64)Word.word \<Rightarrow> FaultRecord \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_Abort vaddress fault = (
   IsDebugException fault \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then
     if ((((FaultRecord_acctype   fault) = AccType_IFETCH))) then
       and_boolM ((UsingAArch32 () ))
         (return ((((FaultRecord_debugmoe   fault) = DebugException_VectorCatch)))) \<bind> (\<lambda> (w__2 ::
         bool) . 
       if w__2 then AArch64_VectorCatchException fault
       else AArch64_BreakpointException fault)
     else AArch64_WatchpointException vaddress fault
   else if ((((FaultRecord_acctype   fault) = AccType_IFETCH))) then
     AArch64_InstructionAbort vaddress fault
   else AArch64_DataAbort vaddress fault))"


(*val AArch64_CheckAlignment : mword ty64 -> ii -> AccType -> bool -> M bool*)

definition AArch64_CheckAlignment  :: "(64)Word.word \<Rightarrow> int \<Rightarrow> AccType \<Rightarrow> bool \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " AArch64_CheckAlignment address alignment acctype iswrite = (
   (let (aligned :: bool) = (address = ((Align__1 address alignment  ::  64 Word.word))) in
   (let (atomic :: bool) = ((((acctype = AccType_ATOMIC))) \<or> (((acctype = AccType_ATOMICRW)))) in
   (let (ordered :: bool) =
     ((((acctype = AccType_ORDERED))) \<or> ((((((acctype = AccType_ORDEREDRW))) \<or> (((acctype = AccType_LIMITEDORDERED))))))) in
   (let (vector_name :: bool) = (acctype = AccType_VEC) in
   or_boolM (return (((atomic \<or> ordered))))
     ((aget_SCTLR__1 ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 ::  32 Word.word) . 
      return ((((vec_of_bits [access_vec_dec w__0 (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (check' :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (secondstage :: bool) . 
   (if (((check' \<and> ((\<not> aligned))))) then
      (let secondstage = False in
      AArch64_AlignmentFault acctype iswrite secondstage \<bind> (\<lambda> (w__1 :: FaultRecord) . 
      AArch64_Abort address w__1))
    else return () ) \<then>
   return aligned)))))))"


(*val AArch32_EnterMode : mword ty5 -> mword ty32 -> ii -> ii -> M unit*)

definition AArch32_EnterMode  :: "(5)Word.word \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch32_EnterMode target_mode preferred_exception_return lr_offset vect_offset = (
   (let (_ :: unit) = (SynchronizeContext () ) in
   and_boolM ((ELUsingAArch32 EL1))
     (read_reg PSTATE_ref \<bind> (\<lambda> (w__1 :: ProcState) .  return ((((ProcState_EL   w__1) \<noteq> EL2))))) \<bind> (\<lambda> (w__2 ::
     bool) . 
   (assert_exp w__2 (''(ELUsingAArch32(EL1) && ((PSTATE).EL != EL2))'') \<then>
   (GetPSRFromPSTATE ()   :: ( 32 Word.word) M)) \<bind> (\<lambda> (spsr :: 32 bits) . 
   read_reg PSTATE_ref \<bind> (\<lambda> (w__3 :: ProcState) . 
   (((((if ((((ProcState_M   w__3) = M32_Monitor))) then
      (read_reg SCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__4 :: 32 bits) . 
      write_reg
        SCR_ref
        ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__4 (( 0 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word)))
    else return () ) \<then>
   AArch32_WriteMode target_mode) \<then>
   aset_SPSR spsr) \<then>
   aset_R (( 14 :: int)::ii) ((add_vec_int preferred_exception_return lr_offset  ::  32 Word.word))) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__5 :: ProcState) . 
   (read_reg SCTLR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__6 :: 32 bits) . 
   (write_reg
     PSTATE_ref
     (w__5 (| ProcState_T := ((vec_of_bits [access_vec_dec w__6 (( 30 :: int)::ii)]  ::  1 Word.word))|)) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__7 :: ProcState) . 
   ((write_reg PSTATE_ref (w__7 (| ProcState_SS := ((vec_of_bits [B0]  ::  1 Word.word))|)) \<then>
   (if (((target_mode = M32_FIQ))) then
      (let split_vec = ((vec_of_bits [B1,B1,B1]  ::  3 Word.word)) in
      (let (tup__0, tup__1, tup__2) =
        ((subrange_vec_dec split_vec (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
      read_reg PSTATE_ref \<bind> (\<lambda> (w__8 :: ProcState) . 
      (write_reg PSTATE_ref (w__8 (| ProcState_A := tup__0 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__9 :: ProcState) . 
      (write_reg PSTATE_ref (w__9 (| ProcState_I := tup__1 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__10 :: ProcState) . 
      write_reg PSTATE_ref (w__10 (| ProcState_F := tup__2 |)))))))
    else if ((((((target_mode = M32_Abort))) \<or> (((target_mode = M32_IRQ)))))) then
      (let split_vec = ((vec_of_bits [B1,B1]  ::  2 Word.word)) in
      (let (tup__0, tup__1) =
        ((subrange_vec_dec split_vec (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
      read_reg PSTATE_ref \<bind> (\<lambda> (w__11 :: ProcState) . 
      (write_reg PSTATE_ref (w__11 (| ProcState_A := tup__0 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__12 :: ProcState) . 
      write_reg PSTATE_ref (w__12 (| ProcState_I := tup__1 |))))))
    else
      read_reg PSTATE_ref \<bind> (\<lambda> (w__13 :: ProcState) . 
      write_reg PSTATE_ref (w__13 (| ProcState_I := ((vec_of_bits [B1]  ::  1 Word.word))|))))) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__14 :: ProcState) . 
   (read_reg SCTLR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__15 :: 32 bits) . 
   (write_reg
     PSTATE_ref
     (w__14 (| ProcState_E := ((vec_of_bits [access_vec_dec w__15 (( 25 :: int)::ii)]  ::  1 Word.word))|)) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__16 :: ProcState) . 
   (write_reg PSTATE_ref (w__16 (| ProcState_IL := ((vec_of_bits [B0]  ::  1 Word.word))|)) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__17 :: ProcState) . 
   (write_reg
     PSTATE_ref
     (w__17 (| ProcState_IT := ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word))|)) \<then>
   and_boolM (return ((HavePANExt () )))
     ((read_reg SCTLR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__18 :: 32 bits) . 
      return ((((vec_of_bits [access_vec_dec w__18 (( 23 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))) \<bind> (\<lambda> (w__19 :: bool) . 
   ((if w__19 then
      read_reg PSTATE_ref \<bind> (\<lambda> (w__20 :: ProcState) . 
      write_reg PSTATE_ref (w__20 (| ProcState_PAN := ((vec_of_bits [B1]  ::  1 Word.word))|)))
    else return () ) \<then>
   (ExcVectorBase ()   :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__21 ::  32 Word.word) . 
   BranchTo
     ((concat_vec ((slice w__21 (( 5 :: int)::ii) (( 27 :: int)::ii)  ::  27 Word.word))
         ((GetSlice_int ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) vect_offset (( 0 :: int)::ii)  ::  5 Word.word))
        ::  32 Word.word)) BranchType_UNKNOWN \<then>
   EndOfInstruction () ))))))))))))))"


(*val AArch64_AdvSIMDFPAccessTrap : mword ty2 -> M unit*)

definition AArch64_AdvSIMDFPAccessTrap  :: "(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_AdvSIMDFPAccessTrap target_el = (
   (ThisInstrAddr (( 64 :: int)::ii) ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (preferred_exception_return :: 64 bits) . 
   (let (vect_offset :: ii) = ((( 0 :: int)::ii)) in
   and_boolM
     (and_boolM (return ((((((target_el = EL1))) \<and> ((HaveEL EL2))))))
        (IsSecure ()  \<bind> (\<lambda> (w__0 :: bool) .  return ((\<not> w__0)))))
     ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 :: 64 bits) . 
      return ((((vec_of_bits [access_vec_dec w__2 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (route_to_el2 :: bool) . 
   undefined_ExceptionRecord ()  \<bind> (\<lambda> (exception :: ExceptionRecord) . 
   if route_to_el2 then
     ExceptionSyndrome Exception_Uncategorized \<bind> (\<lambda> (w__3 :: ExceptionRecord) . 
     (let exception = w__3 in
     AArch64_TakeException EL2 exception preferred_exception_return vect_offset))
   else
     ExceptionSyndrome Exception_AdvSIMDFPAccessTrap \<bind> (\<lambda> (w__4 :: ExceptionRecord) . 
     (let exception = w__4 in
     (let (tmp_2610 :: 25 bits) = ((ExceptionRecord_syndrome   exception)) in
     (ConditionSyndrome ()   :: ( 5 Word.word) M) \<bind> (\<lambda> (w__5 ::  5 Word.word) . 
     (let tmp_2610 = ((set_slice (( 25 :: int)::ii) (( 5 :: int)::ii) tmp_2610 (( 20 :: int)::ii) w__5  ::  25 Word.word)) in
     (let exception = ((exception (| ExceptionRecord_syndrome := tmp_2610 |))) in
     AArch64_TakeException target_el exception preferred_exception_return vect_offset)))))))))))"


(*val AArch64_CheckFPAdvSIMDTrap : unit -> M unit*)

definition AArch64_CheckFPAdvSIMDTrap  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_CheckFPAdvSIMDTrap _ = (
   undefined_bool ()  \<bind> (\<lambda> (disabled :: bool) . 
   and_boolM (return ((HaveEL EL2))) (IsSecure ()  \<bind> (\<lambda> (w__0 :: bool) .  return ((\<not> w__0)))) \<bind> (\<lambda> (w__1 ::
     bool) . 
   (if w__1 then
      and_boolM (return ((HaveVirtHostExt () )))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__2 (( 34 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__3 :: bool) . 
      if w__3 then
        (read_reg CPTR_EL2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__4 :: 32 bits) . 
        (let p__283 = ((slice w__4 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) in
        (let v__94 = p__283 in
        (if (((((subrange_vec_dec v__94 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))) then
           and_boolM
             (read_reg PSTATE_ref \<bind> (\<lambda> (w__5 :: ProcState) . 
              return ((((ProcState_EL   w__5) = EL1)))))
             ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__6 :: 64 bits) . 
              return ((((vec_of_bits [access_vec_dec w__6 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__7 :: bool) . 
           (let (disabled :: bool) = (\<not> w__7) in
           return disabled))
         else if (((v__94 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
           and_boolM
             (read_reg PSTATE_ref \<bind> (\<lambda> (w__8 :: ProcState) . 
              return ((((ProcState_EL   w__8) = EL0)))))
             ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__9 :: 64 bits) . 
              return ((((vec_of_bits [access_vec_dec w__9 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))
         else return False) \<bind> (\<lambda> (disabled :: bool) . 
        if disabled then AArch64_AdvSIMDFPAccessTrap EL2
        else return () ))))
      else
        (read_reg CPTR_EL2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__11 :: 32 bits) . 
        if ((((vec_of_bits [access_vec_dec w__11 (( 10 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
          AArch64_AdvSIMDFPAccessTrap EL2
        else return () ))
    else return () ) \<then>
   (if ((HaveEL EL3)) then
     (read_reg CPTR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__12 :: 32 bits) . 
     if ((((vec_of_bits [access_vec_dec w__12 (( 10 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
       AArch64_AdvSIMDFPAccessTrap EL3
     else return () )
   else return () ))))"


(*val AArch64_CheckFPAdvSIMDEnabled : unit -> M unit*)

definition AArch64_CheckFPAdvSIMDEnabled  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_CheckFPAdvSIMDEnabled _ = (
   undefined_bool ()  \<bind> (\<lambda> (disabled :: bool) . 
   or_boolM
     (read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) .  return ((((ProcState_EL   w__0) = EL0)))))
     (read_reg PSTATE_ref \<bind> (\<lambda> (w__1 :: ProcState) .  return ((((ProcState_EL   w__1) = EL1))))) \<bind> (\<lambda> (w__2 ::
     bool) . 
   (if w__2 then
      (aget_CPACR ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__3 ::  32 Word.word) . 
      (let p__282 = ((slice w__3 (( 20 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) in
      (let v__96 = p__282 in
      (if (((((subrange_vec_dec v__96 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))) then
         return True
       else if (((v__96 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
         read_reg PSTATE_ref \<bind> (\<lambda> (w__4 :: ProcState) . 
         (let (disabled :: bool) = ((ProcState_EL   w__4) = EL0) in
         return disabled))
       else return False) \<bind> (\<lambda> (disabled :: bool) . 
      if disabled then AArch64_AdvSIMDFPAccessTrap EL1
      else return () ))))
    else return () ) \<then>
   AArch64_CheckFPAdvSIMDTrap () )))"


(*val CheckFPAdvSIMDEnabled64 : unit -> M unit*)

definition CheckFPAdvSIMDEnabled64  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " CheckFPAdvSIMDEnabled64 _ = ( AArch64_CheckFPAdvSIMDEnabled ()  )"


(*val aarch64_float_move_fp_select : mword ty4 -> ii -> ii -> ii -> ii -> M unit*)

definition aarch64_float_move_fp_select  :: "(4)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_float_move_fp_select condition d l__133 m n = (
   if (((l__133 = (( 8 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     ConditionHolds condition) \<bind> (\<lambda> (w__0 :: bool) . 
     (if w__0 then (aget_V (( 8 :: int)::ii) n  :: ( 8 Word.word) M)
      else (aget_V (( 8 :: int)::ii) m  :: ( 8 Word.word) M)) \<bind> (\<lambda> (result :: 8 bits) . 
     aset_V d result)))
   else if (((l__133 = (( 16 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     ConditionHolds condition) \<bind> (\<lambda> (w__3 :: bool) . 
     (if w__3 then (aget_V (( 16 :: int)::ii) n  :: ( 16 Word.word) M)
      else (aget_V (( 16 :: int)::ii) m  :: ( 16 Word.word) M)) \<bind> (\<lambda> (result :: 16 bits) . 
     aset_V d result)))
   else if (((l__133 = (( 32 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     ConditionHolds condition) \<bind> (\<lambda> (w__6 :: bool) . 
     (if w__6 then (aget_V (( 32 :: int)::ii) n  :: ( 32 Word.word) M)
      else (aget_V (( 32 :: int)::ii) m  :: ( 32 Word.word) M)) \<bind> (\<lambda> (result :: 32 bits) . 
     aset_V d result)))
   else if (((l__133 = (( 64 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     ConditionHolds condition) \<bind> (\<lambda> (w__9 :: bool) . 
     (if w__9 then (aget_V (( 64 :: int)::ii) n  :: ( 64 Word.word) M)
      else (aget_V (( 64 :: int)::ii) m  :: ( 64 Word.word) M)) \<bind> (\<lambda> (result :: 64 bits) . 
     aset_V d result)))
   else if (((l__133 = (( 128 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     ConditionHolds condition) \<bind> (\<lambda> (w__12 :: bool) . 
     (if w__12 then (aget_V (( 128 :: int)::ii) n  :: ( 128 Word.word) M)
      else (aget_V (( 128 :: int)::ii) m  :: ( 128 Word.word) M)) \<bind> (\<lambda> (result :: 128 bits) . 
     aset_V d result)))
   else
     (let dbytes = (ex_int ((l__133 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))"


(*val aarch64_float_move_fp_imm : forall 'datasize. Size 'datasize => ii -> itself 'datasize -> mword 'datasize -> M unit*)

definition aarch64_float_move_fp_imm  :: " int \<Rightarrow>('datasize::len)itself \<Rightarrow>('datasize::len)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_float_move_fp_imm d datasize imm = (
   (let datasize = (size_itself_int datasize) in
   (let dbytes = (ex_int ((datasize div (( 8 :: int)::ii)))) in
   ((assert_exp True (''datasize constraint'') \<then>
   assert_exp True (''dbytes constraint'')) \<then> CheckFPAdvSIMDEnabled64 () ) \<then> aset_V d imm)))"


(*val aarch64_float_convert_int : forall 'fltsize 'intsize . Size 'fltsize, Size 'intsize => ii -> itself 'fltsize -> itself 'intsize -> ii -> FPConvOp -> ii -> FPRounding -> bool -> M unit*)

definition aarch64_float_convert_int  :: " int \<Rightarrow>('fltsize::len)itself \<Rightarrow>('intsize::len)itself \<Rightarrow> int \<Rightarrow> FPConvOp \<Rightarrow> int \<Rightarrow> FPRounding \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_float_convert_int d fltsize intsize n op1 part rounding unsigned = (
   (let intsize = (size_itself_int intsize) in
   (let fltsize = (size_itself_int fltsize) in
   (CheckFPAdvSIMDEnabled64 ()  \<then>
   (undefined_bitvector fltsize  :: (( 'fltsize::len)Word.word) M)) \<bind> (\<lambda> fltval . 
   (undefined_bitvector intsize  :: (( 'intsize::len)Word.word) M) \<bind> (\<lambda> intval . 
   (case  op1 of
     FPConvOp_CVT_FtoI =>
      (aget_V fltsize n  :: (( 'fltsize::len)Word.word) M) \<bind> (\<lambda> (w__0 :: ( 'fltsize::len)Word.word) . 
      (let fltval = w__0 in
      (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 :: 32 bits) . 
      (FPToFixed intsize fltval (( 0 :: int)::ii) unsigned w__1 rounding  :: (( 'intsize::len)Word.word) M) \<bind> (\<lambda> (w__2 ::
        ( 'intsize::len)Word.word) . 
      (let intval = w__2 in
      aset_X d intval)))))
   | FPConvOp_CVT_ItoF =>
      (aget_X intsize n  :: (( 'intsize::len)Word.word) M) \<bind> (\<lambda> (w__3 :: ( 'intsize::len)Word.word) . 
      (let intval = w__3 in
      (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__4 :: 32 bits) . 
      (FixedToFP fltsize intval (( 0 :: int)::ii) unsigned w__4 rounding  :: (( 'fltsize::len)Word.word) M) \<bind> (\<lambda> (w__5 ::
        ( 'fltsize::len)Word.word) . 
      (let fltval = w__5 in
      aset_V d fltval)))))
   | FPConvOp_MOV_FtoI =>
      (aget_Vpart fltsize n part  :: (( 'fltsize::len)Word.word) M) \<bind> (\<lambda> (w__6 :: ( 'fltsize::len)Word.word) . 
      (let fltval = w__6 in
      (ZeroExtend__0 fltval ((make_the_value intsize ))  :: (( 'intsize::len)Word.word) M) \<bind> (\<lambda> (w__7 ::
        ( 'intsize::len)Word.word) . 
      (let intval = w__7 in
      aset_X d intval))))
   | FPConvOp_MOV_ItoF =>
      (aget_X intsize n  :: (( 'intsize::len)Word.word) M) \<bind> (\<lambda> (w__8 :: ( 'intsize::len)Word.word) . 
      (let intval = w__8 in
      (let fltval = ((slice intval (( 0 :: int)::ii) fltsize  :: ( 'fltsize::len)Word.word)) in
      aset_Vpart d part fltval)))
   | FPConvOp_CVT_FtoI_JS =>
      (aget_V fltsize n  :: (( 'fltsize::len)Word.word) M) \<bind> (\<lambda> (w__9 :: ( 'fltsize::len)Word.word) . 
      (let fltval = w__9 in
      (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__10 :: 32 bits) . 
      (FPToFixedJS intsize fltval w__10 True  :: (( 'intsize::len)Word.word) M) \<bind> (\<lambda> (w__11 :: ( 'intsize::len)Word.word) . 
      (let intval = w__11 in
      (ZeroExtend__0 ((slice intval (( 0 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
         ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
        :: ( 64 Word.word) M) \<bind> (\<lambda> (w__12 ::  64 Word.word) . 
      aset_X d w__12))))))
   ))))))"


(*val aarch64_float_convert_fp : forall 'dstsize 'srcsize . Size 'dstsize, Size 'srcsize => ii -> itself 'dstsize -> ii -> itself 'srcsize -> M unit*)

definition aarch64_float_convert_fp  :: " int \<Rightarrow>('dstsize::len)itself \<Rightarrow> int \<Rightarrow>('srcsize::len)itself \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_float_convert_fp d dstsize n srcsize = (
   (let srcsize = (size_itself_int srcsize) in
   (let dstsize = (size_itself_int dstsize) in
   (CheckFPAdvSIMDEnabled64 ()  \<then>
   (undefined_bitvector dstsize  :: (( 'dstsize::len)Word.word) M)) \<bind> (\<lambda> result . 
   (aget_V srcsize n  :: (( 'srcsize::len)Word.word) M) \<bind> (\<lambda> operand . 
   (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 :: 32 bits) . 
   (FPConvert__1 dstsize operand w__0  :: (( 'dstsize::len)Word.word) M) \<bind> (\<lambda> (w__1 :: ( 'dstsize::len)Word.word) . 
   (let result = w__1 in
   aset_V d result))))))))"


(*val aarch64_float_convert_fix : forall 'fltsize 'intsize . Size 'fltsize, Size 'intsize => ii -> itself 'fltsize -> ii -> itself 'intsize -> ii -> FPConvOp -> FPRounding -> bool -> M unit*)

definition aarch64_float_convert_fix  :: " int \<Rightarrow>('fltsize::len)itself \<Rightarrow> int \<Rightarrow>('intsize::len)itself \<Rightarrow> int \<Rightarrow> FPConvOp \<Rightarrow> FPRounding \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_float_convert_fix d fltsize fracbits intsize n op1 rounding unsigned = (
   (let intsize = (size_itself_int intsize) in
   (let fltsize = (size_itself_int fltsize) in
   (CheckFPAdvSIMDEnabled64 ()  \<then>
   (undefined_bitvector fltsize  :: (( 'fltsize::len)Word.word) M)) \<bind> (\<lambda> fltval . 
   (undefined_bitvector intsize  :: (( 'intsize::len)Word.word) M) \<bind> (\<lambda> intval . 
   (case  op1 of
     FPConvOp_CVT_FtoI =>
      (aget_V fltsize n  :: (( 'fltsize::len)Word.word) M) \<bind> (\<lambda> (w__0 :: ( 'fltsize::len)Word.word) . 
      (let fltval = w__0 in
      (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 :: 32 bits) . 
      (FPToFixed intsize fltval fracbits unsigned w__1 rounding  :: (( 'intsize::len)Word.word) M) \<bind> (\<lambda> (w__2 ::
        ( 'intsize::len)Word.word) . 
      (let intval = w__2 in
      aset_X d intval)))))
   | FPConvOp_CVT_ItoF =>
      (aget_X intsize n  :: (( 'intsize::len)Word.word) M) \<bind> (\<lambda> (w__3 :: ( 'intsize::len)Word.word) . 
      (let intval = w__3 in
      (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__4 :: 32 bits) . 
      (FixedToFP fltsize intval fracbits unsigned w__4 rounding  :: (( 'fltsize::len)Word.word) M) \<bind> (\<lambda> (w__5 ::
        ( 'fltsize::len)Word.word) . 
      (let fltval = w__5 in
      aset_V d fltval)))))
   ))))))"


(*val aarch64_float_compare_uncond : bool -> ii -> ii -> ii -> bool -> M unit*)

definition aarch64_float_compare_uncond  :: " bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_float_compare_uncond cmp_with_zero l__128 m n signal_all_nans = (
   if (((l__128 = (( 8 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (aget_V (( 8 :: int)::ii) n  :: ( 8 Word.word) M)) \<bind> (\<lambda> (operand1 :: 8 bits) . 
     (if cmp_with_zero then (FPZero (( 8 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  :: ( 8 Word.word) M)
      else (aget_V (( 8 :: int)::ii) m  :: ( 8 Word.word) M)) \<bind> (\<lambda> (operand2 :: 8 bits) . 
     (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__2 :: 32 bits) . 
     (FPCompare operand1 operand2 signal_all_nans w__2  :: ( 4 Word.word) M) \<bind> (\<lambda> split_vec . 
     (let (tup__0, tup__1, tup__2, tup__3) =
       ((subrange_vec_dec split_vec (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec split_vec (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec split_vec (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec split_vec (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__3 :: ProcState) . 
     (write_reg PSTATE_ref (w__3 (| ProcState_N := tup__0 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__4 :: ProcState) . 
     (write_reg PSTATE_ref (w__4 (| ProcState_Z := tup__1 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__5 :: ProcState) . 
     (write_reg PSTATE_ref (w__5 (| ProcState_C := tup__2 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__6 :: ProcState) . 
     write_reg PSTATE_ref (w__6 (| ProcState_V := tup__3 |))))))))))))
   else if (((l__128 = (( 16 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (aget_V (( 16 :: int)::ii) n  :: ( 16 Word.word) M)) \<bind> (\<lambda> (operand1 :: 16 bits) . 
     (if cmp_with_zero then (FPZero (( 16 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  :: ( 16 Word.word) M)
      else (aget_V (( 16 :: int)::ii) m  :: ( 16 Word.word) M)) \<bind> (\<lambda> (operand2 :: 16 bits) . 
     (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__9 :: 32 bits) . 
     (FPCompare operand1 operand2 signal_all_nans w__9  :: ( 4 Word.word) M) \<bind> (\<lambda> split_vec . 
     (let (tup__0, tup__1, tup__2, tup__3) =
       ((subrange_vec_dec split_vec (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec split_vec (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec split_vec (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec split_vec (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__10 :: ProcState) . 
     (write_reg PSTATE_ref (w__10 (| ProcState_N := tup__0 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__11 :: ProcState) . 
     (write_reg PSTATE_ref (w__11 (| ProcState_Z := tup__1 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__12 :: ProcState) . 
     (write_reg PSTATE_ref (w__12 (| ProcState_C := tup__2 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__13 :: ProcState) . 
     write_reg PSTATE_ref (w__13 (| ProcState_V := tup__3 |))))))))))))
   else if (((l__128 = (( 32 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (aget_V (( 32 :: int)::ii) n  :: ( 32 Word.word) M)) \<bind> (\<lambda> (operand1 :: 32 bits) . 
     (if cmp_with_zero then (FPZero (( 32 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  :: ( 32 Word.word) M)
      else (aget_V (( 32 :: int)::ii) m  :: ( 32 Word.word) M)) \<bind> (\<lambda> (operand2 :: 32 bits) . 
     (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__16 :: 32 bits) . 
     (FPCompare operand1 operand2 signal_all_nans w__16  :: ( 4 Word.word) M) \<bind> (\<lambda> split_vec . 
     (let (tup__0, tup__1, tup__2, tup__3) =
       ((subrange_vec_dec split_vec (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec split_vec (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec split_vec (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec split_vec (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__17 :: ProcState) . 
     (write_reg PSTATE_ref (w__17 (| ProcState_N := tup__0 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__18 :: ProcState) . 
     (write_reg PSTATE_ref (w__18 (| ProcState_Z := tup__1 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__19 :: ProcState) . 
     (write_reg PSTATE_ref (w__19 (| ProcState_C := tup__2 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__20 :: ProcState) . 
     write_reg PSTATE_ref (w__20 (| ProcState_V := tup__3 |))))))))))))
   else if (((l__128 = (( 64 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (aget_V (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (operand1 :: 64 bits) . 
     (if cmp_with_zero then (FPZero (( 64 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  :: ( 64 Word.word) M)
      else (aget_V (( 64 :: int)::ii) m  :: ( 64 Word.word) M)) \<bind> (\<lambda> (operand2 :: 64 bits) . 
     (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__23 :: 32 bits) . 
     (FPCompare operand1 operand2 signal_all_nans w__23  :: ( 4 Word.word) M) \<bind> (\<lambda> split_vec . 
     (let (tup__0, tup__1, tup__2, tup__3) =
       ((subrange_vec_dec split_vec (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec split_vec (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec split_vec (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec split_vec (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__24 :: ProcState) . 
     (write_reg PSTATE_ref (w__24 (| ProcState_N := tup__0 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__25 :: ProcState) . 
     (write_reg PSTATE_ref (w__25 (| ProcState_Z := tup__1 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__26 :: ProcState) . 
     (write_reg PSTATE_ref (w__26 (| ProcState_C := tup__2 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__27 :: ProcState) . 
     write_reg PSTATE_ref (w__27 (| ProcState_V := tup__3 |))))))))))))
   else if (((l__128 = (( 128 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (aget_V (( 128 :: int)::ii) n  :: ( 128 Word.word) M)) \<bind> (\<lambda> (operand1 :: 128 bits) . 
     (if cmp_with_zero then (FPZero (( 128 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  :: ( 128 Word.word) M)
      else (aget_V (( 128 :: int)::ii) m  :: ( 128 Word.word) M)) \<bind> (\<lambda> (operand2 :: 128 bits) . 
     (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__30 :: 32 bits) . 
     (FPCompare operand1 operand2 signal_all_nans w__30  :: ( 4 Word.word) M) \<bind> (\<lambda> split_vec . 
     (let (tup__0, tup__1, tup__2, tup__3) =
       ((subrange_vec_dec split_vec (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec split_vec (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec split_vec (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec split_vec (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__31 :: ProcState) . 
     (write_reg PSTATE_ref (w__31 (| ProcState_N := tup__0 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__32 :: ProcState) . 
     (write_reg PSTATE_ref (w__32 (| ProcState_Z := tup__1 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__33 :: ProcState) . 
     (write_reg PSTATE_ref (w__33 (| ProcState_C := tup__2 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__34 :: ProcState) . 
     write_reg PSTATE_ref (w__34 (| ProcState_V := tup__3 |))))))))))))
   else
     (let dbytes = (ex_int ((l__128 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))"


(*val aarch64_float_compare_cond : mword ty4 -> ii -> mword ty4 -> ii -> ii -> bool -> M unit*)

definition aarch64_float_compare_cond  :: "(4)Word.word \<Rightarrow> int \<Rightarrow>(4)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_float_compare_cond condition l__123 flags__arg m n signal_all_nans = (
   if (((l__123 = (( 8 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let flags = flags__arg in
     (CheckFPAdvSIMDEnabled64 ()  \<then>
     (aget_V (( 8 :: int)::ii) n  :: ( 8 Word.word) M)) \<bind> (\<lambda> (operand1 :: 8 bits) . 
     (aget_V (( 8 :: int)::ii) m  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand2 :: 8 bits) . 
     ConditionHolds condition \<bind> (\<lambda> (w__0 :: bool) . 
     (if w__0 then
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 :: 32 bits) . 
        (FPCompare operand1 operand2 signal_all_nans w__1  :: ( 4 Word.word) M))
      else return flags) \<bind> (\<lambda> (flags ::  4 Word.word) . 
     (let (tup__0, tup__1, tup__2, tup__3) =
       ((subrange_vec_dec flags (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec flags (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec flags (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec flags (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__3 :: ProcState) . 
     (write_reg PSTATE_ref (w__3 (| ProcState_N := tup__0 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__4 :: ProcState) . 
     (write_reg PSTATE_ref (w__4 (| ProcState_Z := tup__1 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__5 :: ProcState) . 
     (write_reg PSTATE_ref (w__5 (| ProcState_C := tup__2 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__6 :: ProcState) . 
     write_reg PSTATE_ref (w__6 (| ProcState_V := tup__3 |))))))))))))))
   else if (((l__123 = (( 16 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let flags = flags__arg in
     (CheckFPAdvSIMDEnabled64 ()  \<then>
     (aget_V (( 16 :: int)::ii) n  :: ( 16 Word.word) M)) \<bind> (\<lambda> (operand1 :: 16 bits) . 
     (aget_V (( 16 :: int)::ii) m  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand2 :: 16 bits) . 
     ConditionHolds condition \<bind> (\<lambda> (w__7 :: bool) . 
     (if w__7 then
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__8 :: 32 bits) . 
        (FPCompare operand1 operand2 signal_all_nans w__8  :: ( 4 Word.word) M))
      else return flags) \<bind> (\<lambda> (flags ::  4 Word.word) . 
     (let (tup__0, tup__1, tup__2, tup__3) =
       ((subrange_vec_dec flags (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec flags (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec flags (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec flags (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__10 :: ProcState) . 
     (write_reg PSTATE_ref (w__10 (| ProcState_N := tup__0 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__11 :: ProcState) . 
     (write_reg PSTATE_ref (w__11 (| ProcState_Z := tup__1 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__12 :: ProcState) . 
     (write_reg PSTATE_ref (w__12 (| ProcState_C := tup__2 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__13 :: ProcState) . 
     write_reg PSTATE_ref (w__13 (| ProcState_V := tup__3 |))))))))))))))
   else if (((l__123 = (( 32 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let flags = flags__arg in
     (CheckFPAdvSIMDEnabled64 ()  \<then>
     (aget_V (( 32 :: int)::ii) n  :: ( 32 Word.word) M)) \<bind> (\<lambda> (operand1 :: 32 bits) . 
     (aget_V (( 32 :: int)::ii) m  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand2 :: 32 bits) . 
     ConditionHolds condition \<bind> (\<lambda> (w__14 :: bool) . 
     (if w__14 then
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__15 :: 32 bits) . 
        (FPCompare operand1 operand2 signal_all_nans w__15  :: ( 4 Word.word) M))
      else return flags) \<bind> (\<lambda> (flags ::  4 Word.word) . 
     (let (tup__0, tup__1, tup__2, tup__3) =
       ((subrange_vec_dec flags (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec flags (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec flags (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec flags (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__17 :: ProcState) . 
     (write_reg PSTATE_ref (w__17 (| ProcState_N := tup__0 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__18 :: ProcState) . 
     (write_reg PSTATE_ref (w__18 (| ProcState_Z := tup__1 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__19 :: ProcState) . 
     (write_reg PSTATE_ref (w__19 (| ProcState_C := tup__2 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__20 :: ProcState) . 
     write_reg PSTATE_ref (w__20 (| ProcState_V := tup__3 |))))))))))))))
   else if (((l__123 = (( 64 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let flags = flags__arg in
     (CheckFPAdvSIMDEnabled64 ()  \<then>
     (aget_V (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (operand1 :: 64 bits) . 
     (aget_V (( 64 :: int)::ii) m  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand2 :: 64 bits) . 
     ConditionHolds condition \<bind> (\<lambda> (w__21 :: bool) . 
     (if w__21 then
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__22 :: 32 bits) . 
        (FPCompare operand1 operand2 signal_all_nans w__22  :: ( 4 Word.word) M))
      else return flags) \<bind> (\<lambda> (flags ::  4 Word.word) . 
     (let (tup__0, tup__1, tup__2, tup__3) =
       ((subrange_vec_dec flags (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec flags (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec flags (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec flags (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__24 :: ProcState) . 
     (write_reg PSTATE_ref (w__24 (| ProcState_N := tup__0 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__25 :: ProcState) . 
     (write_reg PSTATE_ref (w__25 (| ProcState_Z := tup__1 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__26 :: ProcState) . 
     (write_reg PSTATE_ref (w__26 (| ProcState_C := tup__2 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__27 :: ProcState) . 
     write_reg PSTATE_ref (w__27 (| ProcState_V := tup__3 |))))))))))))))
   else if (((l__123 = (( 128 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let flags = flags__arg in
     (CheckFPAdvSIMDEnabled64 ()  \<then>
     (aget_V (( 128 :: int)::ii) n  :: ( 128 Word.word) M)) \<bind> (\<lambda> (operand1 :: 128 bits) . 
     (aget_V (( 128 :: int)::ii) m  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand2 :: 128 bits) . 
     ConditionHolds condition \<bind> (\<lambda> (w__28 :: bool) . 
     (if w__28 then
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__29 :: 32 bits) . 
        (FPCompare operand1 operand2 signal_all_nans w__29  :: ( 4 Word.word) M))
      else return flags) \<bind> (\<lambda> (flags ::  4 Word.word) . 
     (let (tup__0, tup__1, tup__2, tup__3) =
       ((subrange_vec_dec flags (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec flags (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec flags (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
        (subrange_vec_dec flags (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
     read_reg PSTATE_ref \<bind> (\<lambda> (w__31 :: ProcState) . 
     (write_reg PSTATE_ref (w__31 (| ProcState_N := tup__0 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__32 :: ProcState) . 
     (write_reg PSTATE_ref (w__32 (| ProcState_Z := tup__1 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__33 :: ProcState) . 
     (write_reg PSTATE_ref (w__33 (| ProcState_C := tup__2 |)) \<then>
     read_reg PSTATE_ref) \<bind> (\<lambda> (w__34 :: ProcState) . 
     write_reg PSTATE_ref (w__34 (| ProcState_V := tup__3 |))))))))))))))
   else
     (let dbytes = (ex_int ((l__123 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))"


(*val aarch64_float_arithmetic_unary : ii -> ii -> FPUnaryOp -> ii -> M unit*)

definition aarch64_float_arithmetic_unary  :: " int \<Rightarrow> int \<Rightarrow> FPUnaryOp \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_float_arithmetic_unary d l__118 fpop n = (
   if (((l__118 = (( 8 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M)) \<bind> (\<lambda> (result :: 8 bits) . 
     (aget_V (( 8 :: int)::ii) n  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand :: 8 bits) . 
     (case  fpop of
       FPUnaryOp_MOV => return operand
     | FPUnaryOp_ABS => (FPAbs operand  :: ( 8 Word.word) M)
     | FPUnaryOp_NEG => (FPNeg operand  :: ( 8 Word.word) M)
     | FPUnaryOp_SQRT =>
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__2 :: 32 bits) . 
        (FPSqrt operand w__2  :: ( 8 Word.word) M))
     ) \<bind> (\<lambda> (result :: 8 bits) . 
     aset_V d result))))
   else if (((l__118 = (( 16 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M)) \<bind> (\<lambda> (result :: 16 bits) . 
     (aget_V (( 16 :: int)::ii) n  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand :: 16 bits) . 
     (case  fpop of
       FPUnaryOp_MOV => return operand
     | FPUnaryOp_ABS => (FPAbs operand  :: ( 16 Word.word) M)
     | FPUnaryOp_NEG => (FPNeg operand  :: ( 16 Word.word) M)
     | FPUnaryOp_SQRT =>
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__6 :: 32 bits) . 
        (FPSqrt operand w__6  :: ( 16 Word.word) M))
     ) \<bind> (\<lambda> (result :: 16 bits) . 
     aset_V d result))))
   else if (((l__118 = (( 32 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (result :: 32 bits) . 
     (aget_V (( 32 :: int)::ii) n  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand :: 32 bits) . 
     (case  fpop of
       FPUnaryOp_MOV => return operand
     | FPUnaryOp_ABS => (FPAbs operand  :: ( 32 Word.word) M)
     | FPUnaryOp_NEG => (FPNeg operand  :: ( 32 Word.word) M)
     | FPUnaryOp_SQRT =>
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__10 :: 32 bits) . 
        (FPSqrt operand w__10  :: ( 32 Word.word) M))
     ) \<bind> (\<lambda> (result :: 32 bits) . 
     aset_V d result))))
   else if (((l__118 = (( 64 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (result :: 64 bits) . 
     (aget_V (( 64 :: int)::ii) n  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand :: 64 bits) . 
     (case  fpop of
       FPUnaryOp_MOV => return operand
     | FPUnaryOp_ABS => (FPAbs operand  :: ( 64 Word.word) M)
     | FPUnaryOp_NEG => (FPNeg operand  :: ( 64 Word.word) M)
     | FPUnaryOp_SQRT =>
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__14 :: 32 bits) . 
        (FPSqrt operand w__14  :: ( 64 Word.word) M))
     ) \<bind> (\<lambda> (result :: 64 bits) . 
     aset_V d result))))
   else if (((l__118 = (( 128 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M)) \<bind> (\<lambda> (result :: 128 bits) . 
     (aget_V (( 128 :: int)::ii) n  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand :: 128 bits) . 
     (case  fpop of
       FPUnaryOp_MOV => return operand
     | FPUnaryOp_ABS => (FPAbs operand  :: ( 128 Word.word) M)
     | FPUnaryOp_NEG => (FPNeg operand  :: ( 128 Word.word) M)
     | FPUnaryOp_SQRT =>
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__18 :: 32 bits) . 
        (FPSqrt operand w__18  :: ( 128 Word.word) M))
     ) \<bind> (\<lambda> (result :: 128 bits) . 
     aset_V d result))))
   else
     (let dbytes = (ex_int ((l__118 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))"


(*val aarch64_float_arithmetic_round : ii -> ii -> bool -> ii -> FPRounding -> M unit*)

definition aarch64_float_arithmetic_round  :: " int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> FPRounding \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_float_arithmetic_round d l__113 exact n rounding = (
   if (((l__113 = (( 8 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M)) \<bind> (\<lambda> (result :: 8 bits) . 
     (aget_V (( 8 :: int)::ii) n  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand :: 8 bits) . 
     (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 :: 32 bits) . 
     (FPRoundInt operand w__0 rounding exact  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__1 ::  8 Word.word) . 
     (let result = w__1 in
     aset_V d result))))))
   else if (((l__113 = (( 16 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M)) \<bind> (\<lambda> (result :: 16 bits) . 
     (aget_V (( 16 :: int)::ii) n  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand :: 16 bits) . 
     (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__2 :: 32 bits) . 
     (FPRoundInt operand w__2 rounding exact  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__3 ::  16 Word.word) . 
     (let result = w__3 in
     aset_V d result))))))
   else if (((l__113 = (( 32 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (result :: 32 bits) . 
     (aget_V (( 32 :: int)::ii) n  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand :: 32 bits) . 
     (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__4 :: 32 bits) . 
     (FPRoundInt operand w__4 rounding exact  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__5 ::  32 Word.word) . 
     (let result = w__5 in
     aset_V d result))))))
   else if (((l__113 = (( 64 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (result :: 64 bits) . 
     (aget_V (( 64 :: int)::ii) n  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand :: 64 bits) . 
     (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__6 :: 32 bits) . 
     (FPRoundInt operand w__6 rounding exact  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__7 ::  64 Word.word) . 
     (let result = w__7 in
     aset_V d result))))))
   else if (((l__113 = (( 128 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M)) \<bind> (\<lambda> (result :: 128 bits) . 
     (aget_V (( 128 :: int)::ii) n  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand :: 128 bits) . 
     (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__8 :: 32 bits) . 
     (FPRoundInt operand w__8 rounding exact  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__9 ::  128 Word.word) . 
     (let result = w__9 in
     aset_V d result))))))
   else
     (let dbytes = (ex_int ((l__113 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))"


(*val aarch64_float_arithmetic_mul_product : ii -> ii -> ii -> ii -> bool -> M unit*)

definition aarch64_float_arithmetic_mul_product  :: " int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_float_arithmetic_mul_product d l__108 m n negated = (
   if (((l__108 = (( 8 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M)) \<bind> (\<lambda> (result :: 8 bits) . 
     (aget_V (( 8 :: int)::ii) n  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand1 :: 8 bits) . 
     (aget_V (( 8 :: int)::ii) m  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand2 :: 8 bits) . 
     (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 :: 32 bits) . 
     (FPMul operand1 operand2 w__0  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__1 ::  8 Word.word) . 
     (let result = w__1 in
     (if negated then (FPNeg result  :: ( 8 Word.word) M)
      else return result) \<bind> (\<lambda> (result :: 8 bits) . 
     aset_V d result))))))))
   else if (((l__108 = (( 16 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M)) \<bind> (\<lambda> (result :: 16 bits) . 
     (aget_V (( 16 :: int)::ii) n  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand1 :: 16 bits) . 
     (aget_V (( 16 :: int)::ii) m  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand2 :: 16 bits) . 
     (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__3 :: 32 bits) . 
     (FPMul operand1 operand2 w__3  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__4 ::  16 Word.word) . 
     (let result = w__4 in
     (if negated then (FPNeg result  :: ( 16 Word.word) M)
      else return result) \<bind> (\<lambda> (result :: 16 bits) . 
     aset_V d result))))))))
   else if (((l__108 = (( 32 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (result :: 32 bits) . 
     (aget_V (( 32 :: int)::ii) n  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand1 :: 32 bits) . 
     (aget_V (( 32 :: int)::ii) m  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand2 :: 32 bits) . 
     (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__6 :: 32 bits) . 
     (FPMul operand1 operand2 w__6  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__7 ::  32 Word.word) . 
     (let result = w__7 in
     (if negated then (FPNeg result  :: ( 32 Word.word) M)
      else return result) \<bind> (\<lambda> (result :: 32 bits) . 
     aset_V d result))))))))
   else if (((l__108 = (( 64 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (result :: 64 bits) . 
     (aget_V (( 64 :: int)::ii) n  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand1 :: 64 bits) . 
     (aget_V (( 64 :: int)::ii) m  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand2 :: 64 bits) . 
     (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__9 :: 32 bits) . 
     (FPMul operand1 operand2 w__9  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__10 ::  64 Word.word) . 
     (let result = w__10 in
     (if negated then (FPNeg result  :: ( 64 Word.word) M)
      else return result) \<bind> (\<lambda> (result :: 64 bits) . 
     aset_V d result))))))))
   else if (((l__108 = (( 128 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M)) \<bind> (\<lambda> (result :: 128 bits) . 
     (aget_V (( 128 :: int)::ii) n  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand1 :: 128 bits) . 
     (aget_V (( 128 :: int)::ii) m  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand2 :: 128 bits) . 
     (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__12 :: 32 bits) . 
     (FPMul operand1 operand2 w__12  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__13 ::  128 Word.word) . 
     (let result = w__13 in
     (if negated then (FPNeg result  :: ( 128 Word.word) M)
      else return result) \<bind> (\<lambda> (result :: 128 bits) . 
     aset_V d result))))))))
   else
     (let dbytes = (ex_int ((l__108 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))"


(*val aarch64_float_arithmetic_mul_addsub : ii -> ii -> ii -> ii -> ii -> bool -> bool -> M unit*)

definition aarch64_float_arithmetic_mul_addsub  :: " int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_float_arithmetic_mul_addsub a d l__103 m n op1_neg opa_neg = (
   if (((l__103 = (( 8 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M)) \<bind> (\<lambda> (result :: 8 bits) . 
     (aget_V (( 8 :: int)::ii) a  :: ( 8 Word.word) M) \<bind> (\<lambda> (operanda :: 8 bits) . 
     (aget_V (( 8 :: int)::ii) n  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand1 :: 8 bits) . 
     (aget_V (( 8 :: int)::ii) m  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand2 :: 8 bits) . 
     (if opa_neg then (FPNeg operanda  :: ( 8 Word.word) M)
      else return operanda) \<bind> (\<lambda> (operanda :: 8 bits) . 
     (if op1_neg then (FPNeg operand1  :: ( 8 Word.word) M)
      else return operand1) \<bind> (\<lambda> (operand1 :: 8 bits) . 
     (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__2 :: 32 bits) . 
     (FPMulAdd operanda operand1 operand2 w__2  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__3 ::  8 Word.word) . 
     (let result = w__3 in
     aset_V d result))))))))))
   else if (((l__103 = (( 16 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M)) \<bind> (\<lambda> (result :: 16 bits) . 
     (aget_V (( 16 :: int)::ii) a  :: ( 16 Word.word) M) \<bind> (\<lambda> (operanda :: 16 bits) . 
     (aget_V (( 16 :: int)::ii) n  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand1 :: 16 bits) . 
     (aget_V (( 16 :: int)::ii) m  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand2 :: 16 bits) . 
     (if opa_neg then (FPNeg operanda  :: ( 16 Word.word) M)
      else return operanda) \<bind> (\<lambda> (operanda :: 16 bits) . 
     (if op1_neg then (FPNeg operand1  :: ( 16 Word.word) M)
      else return operand1) \<bind> (\<lambda> (operand1 :: 16 bits) . 
     (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__6 :: 32 bits) . 
     (FPMulAdd operanda operand1 operand2 w__6  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__7 ::  16 Word.word) . 
     (let result = w__7 in
     aset_V d result))))))))))
   else if (((l__103 = (( 32 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (result :: 32 bits) . 
     (aget_V (( 32 :: int)::ii) a  :: ( 32 Word.word) M) \<bind> (\<lambda> (operanda :: 32 bits) . 
     (aget_V (( 32 :: int)::ii) n  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand1 :: 32 bits) . 
     (aget_V (( 32 :: int)::ii) m  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand2 :: 32 bits) . 
     (if opa_neg then (FPNeg operanda  :: ( 32 Word.word) M)
      else return operanda) \<bind> (\<lambda> (operanda :: 32 bits) . 
     (if op1_neg then (FPNeg operand1  :: ( 32 Word.word) M)
      else return operand1) \<bind> (\<lambda> (operand1 :: 32 bits) . 
     (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__10 :: 32 bits) . 
     (FPMulAdd operanda operand1 operand2 w__10  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__11 ::  32 Word.word) . 
     (let result = w__11 in
     aset_V d result))))))))))
   else if (((l__103 = (( 64 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (result :: 64 bits) . 
     (aget_V (( 64 :: int)::ii) a  :: ( 64 Word.word) M) \<bind> (\<lambda> (operanda :: 64 bits) . 
     (aget_V (( 64 :: int)::ii) n  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand1 :: 64 bits) . 
     (aget_V (( 64 :: int)::ii) m  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand2 :: 64 bits) . 
     (if opa_neg then (FPNeg operanda  :: ( 64 Word.word) M)
      else return operanda) \<bind> (\<lambda> (operanda :: 64 bits) . 
     (if op1_neg then (FPNeg operand1  :: ( 64 Word.word) M)
      else return operand1) \<bind> (\<lambda> (operand1 :: 64 bits) . 
     (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__14 :: 32 bits) . 
     (FPMulAdd operanda operand1 operand2 w__14  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__15 ::  64 Word.word) . 
     (let result = w__15 in
     aset_V d result))))))))))
   else if (((l__103 = (( 128 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M)) \<bind> (\<lambda> (result :: 128 bits) . 
     (aget_V (( 128 :: int)::ii) a  :: ( 128 Word.word) M) \<bind> (\<lambda> (operanda :: 128 bits) . 
     (aget_V (( 128 :: int)::ii) n  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand1 :: 128 bits) . 
     (aget_V (( 128 :: int)::ii) m  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand2 :: 128 bits) . 
     (if opa_neg then (FPNeg operanda  :: ( 128 Word.word) M)
      else return operanda) \<bind> (\<lambda> (operanda :: 128 bits) . 
     (if op1_neg then (FPNeg operand1  :: ( 128 Word.word) M)
      else return operand1) \<bind> (\<lambda> (operand1 :: 128 bits) . 
     (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__18 :: 32 bits) . 
     (FPMulAdd operanda operand1 operand2 w__18  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__19 ::  128 Word.word) . 
     (let result = w__19 in
     aset_V d result))))))))))
   else
     (let dbytes = (ex_int ((l__103 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))"


(*val aarch64_float_arithmetic_maxmin : ii -> ii -> ii -> ii -> FPMaxMinOp -> M unit*)

definition aarch64_float_arithmetic_maxmin  :: " int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> FPMaxMinOp \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_float_arithmetic_maxmin d l__98 m n operation = (
   if (((l__98 = (( 8 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M)) \<bind> (\<lambda> (result :: 8 bits) . 
     (aget_V (( 8 :: int)::ii) n  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand1 :: 8 bits) . 
     (aget_V (( 8 :: int)::ii) m  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand2 :: 8 bits) . 
     (case  operation of
       FPMaxMinOp_MAX =>
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 :: 32 bits) . 
        (FPMax operand1 operand2 w__0  :: ( 8 Word.word) M))
     | FPMaxMinOp_MIN =>
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__2 :: 32 bits) . 
        (FPMin operand1 operand2 w__2  :: ( 8 Word.word) M))
     | FPMaxMinOp_MAXNUM =>
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__4 :: 32 bits) . 
        (FPMaxNum operand1 operand2 w__4  :: ( 8 Word.word) M))
     | FPMaxMinOp_MINNUM =>
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__6 :: 32 bits) . 
        (FPMinNum operand1 operand2 w__6  :: ( 8 Word.word) M))
     ) \<bind> (\<lambda> (result :: 8 bits) . 
     aset_V d result)))))
   else if (((l__98 = (( 16 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M)) \<bind> (\<lambda> (result :: 16 bits) . 
     (aget_V (( 16 :: int)::ii) n  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand1 :: 16 bits) . 
     (aget_V (( 16 :: int)::ii) m  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand2 :: 16 bits) . 
     (case  operation of
       FPMaxMinOp_MAX =>
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__8 :: 32 bits) . 
        (FPMax operand1 operand2 w__8  :: ( 16 Word.word) M))
     | FPMaxMinOp_MIN =>
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__10 :: 32 bits) . 
        (FPMin operand1 operand2 w__10  :: ( 16 Word.word) M))
     | FPMaxMinOp_MAXNUM =>
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__12 :: 32 bits) . 
        (FPMaxNum operand1 operand2 w__12  :: ( 16 Word.word) M))
     | FPMaxMinOp_MINNUM =>
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__14 :: 32 bits) . 
        (FPMinNum operand1 operand2 w__14  :: ( 16 Word.word) M))
     ) \<bind> (\<lambda> (result :: 16 bits) . 
     aset_V d result)))))
   else if (((l__98 = (( 32 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (result :: 32 bits) . 
     (aget_V (( 32 :: int)::ii) n  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand1 :: 32 bits) . 
     (aget_V (( 32 :: int)::ii) m  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand2 :: 32 bits) . 
     (case  operation of
       FPMaxMinOp_MAX =>
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__16 :: 32 bits) . 
        (FPMax operand1 operand2 w__16  :: ( 32 Word.word) M))
     | FPMaxMinOp_MIN =>
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__18 :: 32 bits) . 
        (FPMin operand1 operand2 w__18  :: ( 32 Word.word) M))
     | FPMaxMinOp_MAXNUM =>
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__20 :: 32 bits) . 
        (FPMaxNum operand1 operand2 w__20  :: ( 32 Word.word) M))
     | FPMaxMinOp_MINNUM =>
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__22 :: 32 bits) . 
        (FPMinNum operand1 operand2 w__22  :: ( 32 Word.word) M))
     ) \<bind> (\<lambda> (result :: 32 bits) . 
     aset_V d result)))))
   else if (((l__98 = (( 64 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (result :: 64 bits) . 
     (aget_V (( 64 :: int)::ii) n  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand1 :: 64 bits) . 
     (aget_V (( 64 :: int)::ii) m  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand2 :: 64 bits) . 
     (case  operation of
       FPMaxMinOp_MAX =>
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__24 :: 32 bits) . 
        (FPMax operand1 operand2 w__24  :: ( 64 Word.word) M))
     | FPMaxMinOp_MIN =>
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__26 :: 32 bits) . 
        (FPMin operand1 operand2 w__26  :: ( 64 Word.word) M))
     | FPMaxMinOp_MAXNUM =>
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__28 :: 32 bits) . 
        (FPMaxNum operand1 operand2 w__28  :: ( 64 Word.word) M))
     | FPMaxMinOp_MINNUM =>
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__30 :: 32 bits) . 
        (FPMinNum operand1 operand2 w__30  :: ( 64 Word.word) M))
     ) \<bind> (\<lambda> (result :: 64 bits) . 
     aset_V d result)))))
   else if (((l__98 = (( 128 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M)) \<bind> (\<lambda> (result :: 128 bits) . 
     (aget_V (( 128 :: int)::ii) n  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand1 :: 128 bits) . 
     (aget_V (( 128 :: int)::ii) m  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand2 :: 128 bits) . 
     (case  operation of
       FPMaxMinOp_MAX =>
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__32 :: 32 bits) . 
        (FPMax operand1 operand2 w__32  :: ( 128 Word.word) M))
     | FPMaxMinOp_MIN =>
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__34 :: 32 bits) . 
        (FPMin operand1 operand2 w__34  :: ( 128 Word.word) M))
     | FPMaxMinOp_MAXNUM =>
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__36 :: 32 bits) . 
        (FPMaxNum operand1 operand2 w__36  :: ( 128 Word.word) M))
     | FPMaxMinOp_MINNUM =>
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__38 :: 32 bits) . 
        (FPMinNum operand1 operand2 w__38  :: ( 128 Word.word) M))
     ) \<bind> (\<lambda> (result :: 128 bits) . 
     aset_V d result)))))
   else
     (let dbytes = (ex_int ((l__98 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))"


(*val aarch64_float_arithmetic_div : ii -> ii -> ii -> ii -> M unit*)

definition aarch64_float_arithmetic_div  :: " int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_float_arithmetic_div d l__93 m n = (
   if (((l__93 = (( 8 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M)) \<bind> (\<lambda> (result :: 8 bits) . 
     (aget_V (( 8 :: int)::ii) n  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand1 :: 8 bits) . 
     (aget_V (( 8 :: int)::ii) m  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand2 :: 8 bits) . 
     (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 :: 32 bits) . 
     (FPDiv operand1 operand2 w__0  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__1 ::  8 Word.word) . 
     (let result = w__1 in
     aset_V d result)))))))
   else if (((l__93 = (( 16 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M)) \<bind> (\<lambda> (result :: 16 bits) . 
     (aget_V (( 16 :: int)::ii) n  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand1 :: 16 bits) . 
     (aget_V (( 16 :: int)::ii) m  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand2 :: 16 bits) . 
     (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__2 :: 32 bits) . 
     (FPDiv operand1 operand2 w__2  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__3 ::  16 Word.word) . 
     (let result = w__3 in
     aset_V d result)))))))
   else if (((l__93 = (( 32 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (result :: 32 bits) . 
     (aget_V (( 32 :: int)::ii) n  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand1 :: 32 bits) . 
     (aget_V (( 32 :: int)::ii) m  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand2 :: 32 bits) . 
     (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__4 :: 32 bits) . 
     (FPDiv operand1 operand2 w__4  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__5 ::  32 Word.word) . 
     (let result = w__5 in
     aset_V d result)))))))
   else if (((l__93 = (( 64 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (result :: 64 bits) . 
     (aget_V (( 64 :: int)::ii) n  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand1 :: 64 bits) . 
     (aget_V (( 64 :: int)::ii) m  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand2 :: 64 bits) . 
     (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__6 :: 32 bits) . 
     (FPDiv operand1 operand2 w__6  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__7 ::  64 Word.word) . 
     (let result = w__7 in
     aset_V d result)))))))
   else if (((l__93 = (( 128 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M)) \<bind> (\<lambda> (result :: 128 bits) . 
     (aget_V (( 128 :: int)::ii) n  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand1 :: 128 bits) . 
     (aget_V (( 128 :: int)::ii) m  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand2 :: 128 bits) . 
     (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__8 :: 32 bits) . 
     (FPDiv operand1 operand2 w__8  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__9 ::  128 Word.word) . 
     (let result = w__9 in
     aset_V d result)))))))
   else
     (let dbytes = (ex_int ((l__93 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))"


(*val aarch64_float_arithmetic_addsub : ii -> ii -> ii -> ii -> bool -> M unit*)

definition aarch64_float_arithmetic_addsub  :: " int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_float_arithmetic_addsub d l__88 m n sub_op = (
   if (((l__88 = (( 8 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M)) \<bind> (\<lambda> (result :: 8 bits) . 
     (aget_V (( 8 :: int)::ii) n  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand1 :: 8 bits) . 
     (aget_V (( 8 :: int)::ii) m  :: ( 8 Word.word) M) \<bind> (\<lambda> (operand2 :: 8 bits) . 
     (if sub_op then
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 :: 32 bits) . 
        (FPSub operand1 operand2 w__0  :: ( 8 Word.word) M))
      else
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__2 :: 32 bits) . 
        (FPAdd operand1 operand2 w__2  :: ( 8 Word.word) M))) \<bind> (\<lambda> (result :: 8 bits) . 
     aset_V d result)))))
   else if (((l__88 = (( 16 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M)) \<bind> (\<lambda> (result :: 16 bits) . 
     (aget_V (( 16 :: int)::ii) n  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand1 :: 16 bits) . 
     (aget_V (( 16 :: int)::ii) m  :: ( 16 Word.word) M) \<bind> (\<lambda> (operand2 :: 16 bits) . 
     (if sub_op then
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__4 :: 32 bits) . 
        (FPSub operand1 operand2 w__4  :: ( 16 Word.word) M))
      else
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__6 :: 32 bits) . 
        (FPAdd operand1 operand2 w__6  :: ( 16 Word.word) M))) \<bind> (\<lambda> (result :: 16 bits) . 
     aset_V d result)))))
   else if (((l__88 = (( 32 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (result :: 32 bits) . 
     (aget_V (( 32 :: int)::ii) n  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand1 :: 32 bits) . 
     (aget_V (( 32 :: int)::ii) m  :: ( 32 Word.word) M) \<bind> (\<lambda> (operand2 :: 32 bits) . 
     (if sub_op then
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__8 :: 32 bits) . 
        (FPSub operand1 operand2 w__8  :: ( 32 Word.word) M))
      else
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__10 :: 32 bits) . 
        (FPAdd operand1 operand2 w__10  :: ( 32 Word.word) M))) \<bind> (\<lambda> (result :: 32 bits) . 
     aset_V d result)))))
   else if (((l__88 = (( 64 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (result :: 64 bits) . 
     (aget_V (( 64 :: int)::ii) n  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand1 :: 64 bits) . 
     (aget_V (( 64 :: int)::ii) m  :: ( 64 Word.word) M) \<bind> (\<lambda> (operand2 :: 64 bits) . 
     (if sub_op then
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__12 :: 32 bits) . 
        (FPSub operand1 operand2 w__12  :: ( 64 Word.word) M))
      else
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__14 :: 32 bits) . 
        (FPAdd operand1 operand2 w__14  :: ( 64 Word.word) M))) \<bind> (\<lambda> (result :: 64 bits) . 
     aset_V d result)))))
   else if (((l__88 = (( 128 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M)) \<bind> (\<lambda> (result :: 128 bits) . 
     (aget_V (( 128 :: int)::ii) n  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand1 :: 128 bits) . 
     (aget_V (( 128 :: int)::ii) m  :: ( 128 Word.word) M) \<bind> (\<lambda> (operand2 :: 128 bits) . 
     (if sub_op then
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__16 :: 32 bits) . 
        (FPSub operand1 operand2 w__16  :: ( 128 Word.word) M))
      else
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__18 :: 32 bits) . 
        (FPAdd operand1 operand2 w__18  :: ( 128 Word.word) M))) \<bind> (\<lambda> (result :: 128 bits) . 
     aset_V d result)))))
   else
     (let dbytes = (ex_int ((l__88 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))"


(*val AArch64_AccessIsPrivileged : AccType -> M bool*)

definition AArch64_AccessIsPrivileged  :: " AccType \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " AArch64_AccessIsPrivileged acctype = (
   undefined_bool ()  \<bind> (\<lambda> (ispriv :: bool) . 
   read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) . 
   if ((((ProcState_EL   w__0) = EL0))) then return False
   else
     read_reg PSTATE_ref \<bind> (\<lambda> (w__1 :: ProcState) . 
     if ((((ProcState_EL   w__1) = EL3))) then return True
     else
       and_boolM
         (read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) .  return ((((ProcState_EL   w__2) = EL2)))))
         (or_boolM (IsInHost ()  \<bind> (\<lambda> (w__3 :: bool) .  return ((\<not> w__3))))
            ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 :: 64 bits) . 
             return ((((vec_of_bits [access_vec_dec w__4 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))) \<bind> (\<lambda> (w__6 :: bool) . 
       if w__6 then return True
       else
         and_boolM (return ((HaveUAOExt () )))
           (read_reg PSTATE_ref \<bind> (\<lambda> (w__7 :: ProcState) . 
            return ((((ProcState_UAO   w__7) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__8 ::
           bool) . 
         (let (ispriv :: bool) = (if w__8 then True else (acctype \<noteq> AccType_UNPRIV)) in
         return ispriv)))))))"


(*val AArch64_CheckWatchpoint : mword ty64 -> AccType -> bool -> ii -> M FaultRecord*)

definition AArch64_CheckWatchpoint  :: "(64)Word.word \<Rightarrow> AccType \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(FaultRecord),(exception))monad "  where 
     " AArch64_CheckWatchpoint vaddress acctype iswrite size1 = (
   (S1TranslationRegime__1 ()   :: ( 2 Word.word) M) \<bind> (\<lambda> (w__0 ::  2 Word.word) . 
   ELUsingAArch32 w__0 \<bind> (\<lambda> (w__1 :: bool) . 
   assert_exp ((\<not> w__1)) (''!(ELUsingAArch32(S1TranslationRegime()))'') \<then>
   ((let (val_match :: bool) = False in
   AArch64_AccessIsPrivileged acctype \<bind> (\<lambda> (ispriv :: bool) . 
   (read_reg ID_AA64DFR0_EL1_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 :: 64 bits) . 
   (foreachM (index_list (( 0 :: int)::ii) ((Word.uint ((slice w__2 (( 20 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)))) (( 1 :: int)::ii)) val_match
     (\<lambda> i val_match . 
       or_boolM (return val_match) ((AArch64_WatchpointMatch i vaddress size1 ispriv iswrite)))) \<bind> (\<lambda> (val_match ::
     bool) . 
   (undefined_bitvector (( 6 :: int)::ii)  :: ( 6 Word.word) M) \<bind> (\<lambda> (reason :: 6 bits) . 
   and_boolM (return val_match) ((HaltOnBreakpointOrWatchpoint () )) \<bind> (\<lambda> (w__6 :: bool) . 
   if w__6 then
     (let reason = DebugHalt_Watchpoint in
     Halt reason \<then> undefined_FaultRecord () )
   else
     and_boolM
       (and_boolM (return val_match)
          ((read_reg MDSCR_EL1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__8 :: 32 bits) . 
           return ((((vec_of_bits [access_vec_dec w__8 (( 15 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))) ((AArch64_GenerateDebugExceptions () )) \<bind> (\<lambda> (w__11 ::
       bool) . 
     if w__11 then AArch64_DebugFault acctype iswrite
     else AArch64_NoFault () )))))))))))"


(*val AArch64_CheckDebug : mword ty64 -> AccType -> bool -> ii -> M FaultRecord*)

definition AArch64_CheckDebug  :: "(64)Word.word \<Rightarrow> AccType \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(FaultRecord),(exception))monad "  where 
     " AArch64_CheckDebug vaddress acctype iswrite size1 = (
   AArch64_NoFault ()  \<bind> (\<lambda> (fault :: FaultRecord) . 
   (let (d_side :: bool) = (acctype \<noteq> AccType_IFETCH) in
   and_boolM ((AArch64_GenerateDebugExceptions () ))
     ((read_reg MDSCR_EL1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 :: 32 bits) . 
      return ((((vec_of_bits [access_vec_dec w__1 (( 15 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (generate_exception :: bool) . 
   HaltOnBreakpointOrWatchpoint ()  \<bind> (\<lambda> (halt :: bool) . 
   if (((generate_exception \<or> halt))) then
     if d_side then AArch64_CheckWatchpoint vaddress acctype iswrite size1
     else AArch64_CheckBreakpoint vaddress size1
   else return fault)))))"


(*val AArch64_CheckPermission : Permissions -> mword ty64 -> ii -> mword ty1 -> AccType -> bool -> M FaultRecord*)

definition AArch64_CheckPermission  :: " Permissions \<Rightarrow>(64)Word.word \<Rightarrow> int \<Rightarrow>(1)Word.word \<Rightarrow> AccType \<Rightarrow> bool \<Rightarrow>((register_value),(FaultRecord),(exception))monad "  where 
     " AArch64_CheckPermission perms vaddress level NS acctype iswrite = (
   (S1TranslationRegime__1 ()   :: ( 2 Word.word) M) \<bind> (\<lambda> (w__0 ::  2 Word.word) . 
   ELUsingAArch32 w__0 \<bind> (\<lambda> (w__1 :: bool) . 
   (assert_exp ((\<not> w__1)) (''!(ELUsingAArch32(S1TranslationRegime()))'') \<then>
   (aget_SCTLR__1 ()   :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__2 ::  32 Word.word) . 
   (let (wxn :: bool) =
     ((vec_of_bits [access_vec_dec w__2 (( 19 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
   undefined_bool ()  \<bind> (\<lambda> (xn :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (w :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (r :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (priv_xn :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (user_xn :: bool) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (pan :: 1 bits) . 
   undefined_bool ()  \<bind> (\<lambda> (ispriv :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (user_w :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (user_r :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (priv_w :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (priv_r :: bool) . 
   or_boolM
     (or_boolM
        (read_reg PSTATE_ref \<bind> (\<lambda> (w__3 :: ProcState) .  return ((((ProcState_EL   w__3) = EL0)))))
        (read_reg PSTATE_ref \<bind> (\<lambda> (w__4 :: ProcState) .  return ((((ProcState_EL   w__4) = EL1))))))
     ((IsInHost () )) \<bind> (\<lambda> (w__7 :: bool) . 
   (if w__7 then
      (let priv_r = True in
      (let priv_w =
        ((vec_of_bits [access_vec_dec(Permissions_ap   perms) (( 2 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)) in
      (let user_r =
        ((vec_of_bits [access_vec_dec(Permissions_ap   perms) (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
      (let user_w =
        (((slice(Permissions_ap   perms) (( 1 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)) in
      AArch64_AccessIsPrivileged acctype \<bind> (\<lambda> (w__8 :: bool) . 
      (let ispriv = w__8 in
      (if ((HavePANExt () )) then
         read_reg PSTATE_ref \<bind> (\<lambda> (w__9 :: ProcState) .  return(ProcState_PAN   w__9))
       else return (vec_of_bits [B0]  ::  1 Word.word)) \<bind> (\<lambda> (w__10 ::  1 Word.word) . 
      (let pan = w__10 in
      and_boolM
        (and_boolM
           (and_boolM
              (and_boolM (return (((((HaveNVExt () )) \<and> ((HaveEL EL2))))))
                 ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__11 :: 64 bits) . 
                  return ((((vec_of_bits [access_vec_dec w__11 (( 42 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
              ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__13 :: 64 bits) . 
               return ((((vec_of_bits [access_vec_dec w__13 (( 43 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
           (IsSecure ()  \<bind> (\<lambda> (w__15 :: bool) .  return ((\<not> w__15)))))
        (read_reg PSTATE_ref \<bind> (\<lambda> (w__17 :: ProcState) .  return ((((ProcState_EL   w__17) = EL1))))) \<bind> (\<lambda> (w__18 ::
        bool) . 
      (let (pan :: 1 bits) = (if w__18 then (vec_of_bits [B0]  ::  1 Word.word) else pan) in
      or_boolM
        (return ((((((((((((pan = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> user_r))) \<and> ispriv))) \<and> ((\<not> ((((((acctype = AccType_DC))) \<or> ((((((acctype = AccType_AT))) \<or> (((acctype = AccType_IFETCH)))))))))))))))
        (and_boolM (return (((acctype = AccType_AT)))) ((AArch64_ExecutingATS1xPInstr () ))) \<bind> (\<lambda> (w__21 ::
        bool) . 
      (let ((priv_r :: bool), (priv_w :: bool)) =
        (if w__21 then
          (let (priv_r :: bool) = False in
          (let (priv_w :: bool) = False in
          (priv_r, priv_w)))
        else (priv_r, priv_w)) in
      (let (user_xn :: bool) =
        (((((Permissions_xn   perms) = (vec_of_bits [B1]  ::  1 Word.word)))) \<or> (((user_w \<and> wxn)))) in
      (let (priv_xn :: bool) =
        ((((((((Permissions_pxn   perms) = (vec_of_bits [B1]  ::  1 Word.word)))) \<or> (((priv_w \<and> wxn)))))) \<or> user_w) in
      (let ((r :: bool), (w :: bool), (xn :: bool)) =
        (if ispriv then
          (let (tup__0, tup__1, tup__2) = (priv_r, priv_w, priv_xn) in
          (let (r :: bool) = tup__0 in
          (let (w :: bool) = tup__1 in
          (let (xn :: bool) = tup__2 in
          (r, w, xn)))))
        else
          (let (tup__0, tup__1, tup__2) = (user_r, user_w, user_xn) in
          (let (r :: bool) = tup__0 in
          (let (w :: bool) = tup__1 in
          (let (xn :: bool) = tup__2 in
          (r, w, xn)))))) in
      return (r, w, xn))))))))))))))))
    else
      (let (r :: bool) = True in
      (let (w :: bool) =
        ((vec_of_bits [access_vec_dec(Permissions_ap   perms) (( 2 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)) in
      (let (xn :: bool) =
        (((((Permissions_xn   perms) = (vec_of_bits [B1]  ::  1 Word.word)))) \<or> (((w \<and> wxn)))) in
      return (r, w, xn))))) \<bind> (\<lambda> varstup .  (let ((r :: bool), (w :: bool), (xn :: bool)) = varstup in
   and_boolM
     (and_boolM (and_boolM (return ((HaveEL EL3))) ((IsSecure () )))
        (return (((NS = (vec_of_bits [B1]  ::  1 Word.word))))))
     ((read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__25 :: 32 bits) . 
      return ((((vec_of_bits [access_vec_dec w__25 (( 9 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__26 :: bool) . 
   (let (xn :: bool) = (if w__26 then True else xn) in
   undefined_bool ()  \<bind> (\<lambda> (failedread :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (fail1 :: bool) . 
   (let ((fail1 :: bool), (failedread :: bool)) =
     (if (((acctype = AccType_IFETCH))) then
       (let (fail1 :: bool) = xn in
       (let (failedread :: bool) = True in
       (fail1, failedread)))
     else
       (let ((fail1 :: bool), (failedread :: bool)) =
         (if ((((((acctype = AccType_ATOMICRW))) \<or> (((acctype = AccType_ORDEREDRW)))))) then
           (let (fail1 :: bool) = (((\<not> r)) \<or> ((\<not> w))) in
           (let (failedread :: bool) = (\<not> r) in
           (fail1, failedread)))
         else
           (let ((fail1 :: bool), (failedread :: bool)) =
             (if iswrite then
               (let (fail1 :: bool) = (\<not> w) in
               (let (failedread :: bool) = False in
               (fail1, failedread)))
             else
               (let (fail1 :: bool) = (\<not> r) in
               (let (failedread :: bool) = True in
               (fail1, failedread)))) in
           (fail1, failedread))) in
       (fail1, failedread))) in
   (undefined_bitvector (( 52 :: int)::ii)  :: ( 52 Word.word) M) \<bind> (\<lambda> (ipaddress :: 52 bits) . 
   undefined_bool ()  \<bind> (\<lambda> (s2fs1walk :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (secondstage :: bool) . 
   if fail1 then
     (let secondstage = False in
     (let s2fs1walk = False in
     (undefined_bitvector (( 52 :: int)::ii)  :: ( 52 Word.word) M) \<bind> (\<lambda> (w__27 ::  52 Word.word) . 
     (let ipaddress = w__27 in
     AArch64_PermissionFault ipaddress level acctype ((\<not> failedread)) secondstage s2fs1walk))))
   else AArch64_NoFault () )))))))))))))))))))))))))))"


(*val AArch64_FirstStageTranslate : mword ty64 -> AccType -> bool -> bool -> ii -> M AddressDescriptor*)

definition AArch64_FirstStageTranslate  :: "(64)Word.word \<Rightarrow> AccType \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(AddressDescriptor),(exception))monad "  where 
     " AArch64_FirstStageTranslate vaddress acctype iswrite wasaligned size1 = (
   undefined_bool ()  \<bind> (\<lambda> (s1_enabled :: bool) . 
   HasS2Translation ()  \<bind> (\<lambda> (w__0 :: bool) . 
   (if w__0 then
      and_boolM
        (and_boolM
           ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 :: 64 bits) . 
            return ((((vec_of_bits [access_vec_dec w__1 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))
           ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 :: 64 bits) . 
            return ((((vec_of_bits [access_vec_dec w__2 (( 12 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))))))
        ((read_reg SCTLR_EL1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__4 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__4 (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))
    else
      (aget_SCTLR__1 ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__6 ::  32 Word.word) . 
      (let (s1_enabled :: bool) =
        ((vec_of_bits [access_vec_dec w__6 (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
      return s1_enabled))) \<bind> (\<lambda> (s1_enabled :: bool) . 
   (undefined_bitvector (( 52 :: int)::ii)  :: ( 52 Word.word) M) \<bind> (\<lambda> (ipaddress :: 52 bits) . 
   (let (secondstage :: bool) = False in
   (let (s2fs1walk :: bool) = False in
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (nTLSMD :: 1 bits) . 
   undefined_bool ()  \<bind> (\<lambda> (permissioncheck :: bool) . 
   undefined_TLBRecord ()  \<bind> (\<lambda> (S1 :: TLBRecord) . 
   (if s1_enabled then
      AArch64_TranslationTableWalk ipaddress vaddress acctype iswrite secondstage s2fs1walk size1 \<bind> (\<lambda> (w__7 ::
        TLBRecord) . 
      (let (S1 :: TLBRecord) = w__7 in
      (let (permissioncheck :: bool) = True in
      return (S1, permissioncheck))))
    else
      AArch64_TranslateAddressS1Off vaddress acctype iswrite \<bind> (\<lambda> (w__8 :: TLBRecord) . 
      (let S1 = w__8 in
      (let permissioncheck = False in
      and_boolM (and_boolM ((UsingAArch32 () )) (return ((HaveTrapLoadStoreMultipleDeviceExt () ))))
        ((AArch32_ExecutingLSMInstr () )) \<bind> (\<lambda> (w__12 :: bool) . 
      (if w__12 then
         if (((((((MemoryAttributes_typ  (AddressDescriptor_memattrs  (TLBRecord_addrdesc   S1))) = MemType_Device))) \<and> ((((MemoryAttributes_device  (AddressDescriptor_memattrs  (TLBRecord_addrdesc   S1))) \<noteq> DeviceType_GRE)))))) then
           (S1TranslationRegime__1 ()   :: ( 2 Word.word) M) \<bind> (\<lambda> (w__13 ::  2 Word.word) . 
           (if (((w__13 = EL2))) then
              (read_reg SCTLR_EL2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__14 :: 32 bits) . 
              return (vec_of_bits [access_vec_dec w__14 (( 28 :: int)::ii)]  ::  1 Word.word))
            else
              (read_reg SCTLR_EL1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__15 :: 32 bits) . 
              return (vec_of_bits [access_vec_dec w__15 (( 28 :: int)::ii)]  ::  1 Word.word))) \<bind> (\<lambda> (w__16 ::
              1 Word.word) . 
           (let nTLSMD = w__16 in
           if (((nTLSMD = (vec_of_bits [B0]  ::  1 Word.word)))) then
             (let (tmp_2460 :: AddressDescriptor) = ((TLBRecord_addrdesc   S1)) in
             AArch64_AlignmentFault acctype iswrite secondstage \<bind> (\<lambda> (w__17 :: FaultRecord) . 
             (let (tmp_2460 :: AddressDescriptor) =
               ((tmp_2460 (| AddressDescriptor_fault := w__17 |))) in
             (let (S1 :: TLBRecord) = ((S1 (| TLBRecord_addrdesc := tmp_2460 |))) in
             return S1))))
           else return S1)))
         else return S1
       else return S1) \<bind> (\<lambda> (S1 :: TLBRecord) . 
      return (S1, permissioncheck))))))) \<bind> (\<lambda> varstup .  (let ((S1 :: TLBRecord), (permissioncheck ::
     bool)) = varstup in
   (if ((((((((((((((\<not> wasaligned)) \<and> (((acctype \<noteq> AccType_IFETCH)))))) \<or> (((acctype = AccType_DCZVA)))))) \<and> ((((MemoryAttributes_typ  (AddressDescriptor_memattrs  (TLBRecord_addrdesc   S1))) = MemType_Device)))))) \<and> ((\<not> ((IsFault(TLBRecord_addrdesc   S1)))))))) then
      (let (tmp_2470 :: AddressDescriptor) = ((TLBRecord_addrdesc   S1)) in
      AArch64_AlignmentFault acctype iswrite secondstage \<bind> (\<lambda> (w__18 :: FaultRecord) . 
      (let (tmp_2470 :: AddressDescriptor) = ((tmp_2470 (| AddressDescriptor_fault := w__18 |))) in
      (let (S1 :: TLBRecord) = ((S1 (| TLBRecord_addrdesc := tmp_2470 |))) in
      return S1))))
    else return S1) \<bind> (\<lambda> (S1 :: TLBRecord) . 
   (if (((((\<not> ((IsFault(TLBRecord_addrdesc   S1))))) \<and> permissioncheck))) then
      (let (tmp_2480 :: AddressDescriptor) = ((TLBRecord_addrdesc   S1)) in
      AArch64_CheckPermission(TLBRecord_perms   S1) vaddress(TLBRecord_level   S1)(FullAddress_NS  (AddressDescriptor_paddress  (TLBRecord_addrdesc  
        S1))) acctype iswrite \<bind> (\<lambda> (w__19 ::
        FaultRecord) . 
      (let (tmp_2480 :: AddressDescriptor) = ((tmp_2480 (| AddressDescriptor_fault := w__19 |))) in
      (let (S1 :: TLBRecord) = ((S1 (| TLBRecord_addrdesc := tmp_2480 |))) in
      return S1))))
    else return S1) \<bind> (\<lambda> (S1 :: TLBRecord) . 
   (if ((((((((\<not> ((IsFault(TLBRecord_addrdesc   S1))))) \<and> ((((MemoryAttributes_typ  (AddressDescriptor_memattrs  (TLBRecord_addrdesc   S1))) = MemType_Device)))))) \<and> (((acctype = AccType_IFETCH)))))) then
      AArch64_InstructionDevice(TLBRecord_addrdesc   S1) vaddress ipaddress(TLBRecord_level   S1) acctype
        iswrite secondstage s2fs1walk \<bind> (\<lambda> (w__20 :: AddressDescriptor) . 
      (let (S1 :: TLBRecord) = ((S1 (| TLBRecord_addrdesc := w__20 |))) in
      return S1))
    else return S1) \<bind> (\<lambda> (S1 :: TLBRecord) . 
   (let (hwupdatewalk :: bool) = False in
   (let s2fs1walk = False in
   (let (tmp_2490 :: AddressDescriptor) = ((TLBRecord_addrdesc   S1)) in
   AArch64_CheckAndUpdateDescriptor(TLBRecord_descupdate   S1)(AddressDescriptor_fault  (TLBRecord_addrdesc  
     S1)) secondstage vaddress acctype iswrite s2fs1walk
     hwupdatewalk \<bind> (\<lambda> (w__21 :: FaultRecord) . 
   (let (tmp_2490 :: AddressDescriptor) = ((tmp_2490 (| AddressDescriptor_fault := w__21 |))) in
   (let (S1 :: TLBRecord) = ((S1 (| TLBRecord_addrdesc := tmp_2490 |))) in
   return(TLBRecord_addrdesc   S1))))))))))))))))))))))"


(*val AArch64_FullTranslate : mword ty64 -> AccType -> bool -> bool -> ii -> M AddressDescriptor*)

definition AArch64_FullTranslate  :: "(64)Word.word \<Rightarrow> AccType \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(AddressDescriptor),(exception))monad "  where 
     " AArch64_FullTranslate vaddress acctype iswrite wasaligned size1 = (
   AArch64_FirstStageTranslate vaddress acctype iswrite wasaligned size1 \<bind> (\<lambda> (S1 ::
     AddressDescriptor) . 
   undefined_AddressDescriptor ()  \<bind> (\<lambda> (result :: AddressDescriptor) . 
   undefined_bool ()  \<bind> (\<lambda> (hwupdatewalk :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (s2fs1walk :: bool) . 
   and_boolM (return ((\<not> ((IsFault S1))))) ((HasS2Translation () )) \<bind> (\<lambda> (w__1 :: bool) . 
   if w__1 then
     (let s2fs1walk = False in
     (let hwupdatewalk = False in
     AArch64_SecondStageTranslate S1 vaddress acctype iswrite wasaligned s2fs1walk size1 hwupdatewalk))
   else return S1))))))"


(*val AArch64_TranslateAddress : mword ty64 -> AccType -> bool -> bool -> ii -> M AddressDescriptor*)

definition AArch64_TranslateAddress  :: "(64)Word.word \<Rightarrow> AccType \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(AddressDescriptor),(exception))monad "  where 
     " AArch64_TranslateAddress vaddress acctype iswrite wasaligned size1 = (
   AArch64_FullTranslate vaddress acctype iswrite wasaligned size1 \<bind> (\<lambda> (result ::
     AddressDescriptor) . 
   (if (((((\<not> ((((((acctype = AccType_PTW))) \<or> ((((((acctype = AccType_IC))) \<or> (((acctype = AccType_AT))))))))))) \<and> ((\<not> ((IsFault result))))))) then
      AArch64_CheckDebug vaddress acctype iswrite size1 \<bind> (\<lambda> (w__0 :: FaultRecord) . 
      (let (result :: AddressDescriptor) = ((result (| AddressDescriptor_fault := w__0 |))) in
      return result))
    else return result) \<bind> (\<lambda> (result :: AddressDescriptor) . 
   (ZeroExtend__1 (( 64 :: int)::ii) vaddress  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   (let (result :: AddressDescriptor) = ((result (| AddressDescriptor_vaddress := w__1 |))) in
   return result)))))"


(*val AArch64_aset_MemSingle : forall   'p8_times_size_ . Size 'p8_times_size_ => mword ty64 -> integer -> AccType -> bool -> mword 'p8_times_size_ -> M unit*)

definition AArch64_aset_MemSingle  :: "(64)Word.word \<Rightarrow> int \<Rightarrow> AccType \<Rightarrow> bool \<Rightarrow>('p8_times_size_::len)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_aset_MemSingle address size1 acctype wasaligned value_name = (
   ((assert_exp ((((((size1 = (( 1 :: int)::ii)))) \<or> ((((((size1 = (( 2 :: int)::ii)))) \<or> ((((((size1 = (( 4 :: int)::ii)))) \<or> ((((((size1 = (( 8 :: int)::ii)))) \<or> (((size1 = (( 16 :: int)::ii)))))))))))))))) (''((size == 1) || ((size == 2) || ((size == 4) || ((size == 8) || (size == 16)))))'') \<then>
   assert_exp (((address = ((Align__1 address size1  ::  64 Word.word))))) (''(address == Align(address, size))'')) \<then>
   undefined_AddressDescriptor () ) \<bind> (\<lambda> (memaddrdesc :: AddressDescriptor) . 
   (let (iswrite :: bool) = True in
   AArch64_TranslateAddress address acctype iswrite wasaligned size1 \<bind> (\<lambda> (w__0 ::
     AddressDescriptor) . 
   (let memaddrdesc = w__0 in
   (if ((IsFault memaddrdesc)) then AArch64_Abort address(AddressDescriptor_fault   memaddrdesc)
    else return () ) \<then>
   ((let (_ :: unit) =
     (if(MemoryAttributes_shareable  (AddressDescriptor_memattrs   memaddrdesc)) then
       ClearExclusiveByAddress(AddressDescriptor_paddress   memaddrdesc) ((ProcessorID () )) size1
     else () ) in
   CreateAccessDescriptor acctype \<bind> (\<lambda> (accdesc :: AccessDescriptor) . 
   aset__Mem memaddrdesc size1 accdesc value_name))))))))"


(*val aset_Mem : forall   'p8_times_size_ . Size 'p8_times_size_ => mword ty64 -> integer -> AccType -> mword 'p8_times_size_ -> M unit*)

definition aset_Mem  :: "(64)Word.word \<Rightarrow> int \<Rightarrow> AccType \<Rightarrow>('p8_times_size_::len)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aset_Mem address size1 acctype value_name__arg = (
   (let value_name = value_name__arg in
   undefined_int ()  \<bind> (\<lambda> (i :: ii) . 
   (let (iswrite :: bool) = True in
   BigEndian ()  \<bind> (\<lambda> (w__0 :: bool) . 
   (if w__0 then (BigEndianReverse value_name  :: (( 'p8_times_size_::len)Word.word) M)
    else return value_name) \<bind> (\<lambda> value_name . 
   AArch64_CheckAlignment address size1 acctype iswrite \<bind> (\<lambda> (aligned :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (atomic :: bool) . 
   (let (atomic :: bool) =
     (if ((((((size1 \<noteq> (( 16 :: int)::ii)))) \<or> ((\<not> ((((((acctype = AccType_VEC))) \<or> (((acctype = AccType_VECSTREAM))))))))))) then
       aligned
     else (address = ((Align__1 address (( 8 :: int)::ii)  ::  64 Word.word)))) in
   undefined_Constraint ()  \<bind> (\<lambda> (c :: Constraint) . 
   if ((\<not> atomic)) then
     ((assert_exp ((size1 > (( 1 :: int)::ii))) (''(size > 1)'') \<then>
     AArch64_aset_MemSingle address (( 1 :: int)::ii) acctype aligned
       ((slice value_name (( 0 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))) \<then>
     (if ((\<not> aligned)) then
        (let c = (ConstrainUnpredictable Unpredictable_DEVPAGE2) in
        assert_exp ((((((c = Constraint_FAULT))) \<or> (((c = Constraint_NONE)))))) (''((c == Constraint_FAULT) || (c == Constraint_NONE))'') \<then>
        ((let (aligned :: bool) = (if (((c = Constraint_NONE))) then True else aligned) in
        return aligned)))
      else return aligned)) \<bind> (\<lambda> (aligned :: bool) . 
     (foreachM (index_list (( 1 :: int)::ii) ((size1 - (( 1 :: int)::ii))) (( 1 :: int)::ii)) () 
       (\<lambda> i unit_var . 
         AArch64_aset_MemSingle ((add_vec_int address i  ::  64 Word.word)) (( 1 :: int)::ii) acctype aligned
           ((slice value_name (((( 8 :: int)::ii) * i)) (( 8 :: int)::ii)  ::  8 Word.word)))))
   else if ((((((size1 = (( 16 :: int)::ii)))) \<and> ((((((acctype = AccType_VEC))) \<or> (((acctype = AccType_VECSTREAM))))))))) then
     AArch64_aset_MemSingle address (( 8 :: int)::ii) acctype aligned
       ((slice ((Word.ucast value_name  ::  128 Word.word)) (( 0 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word)) \<then>
     AArch64_aset_MemSingle ((add_vec_int address (( 8 :: int)::ii)  ::  64 Word.word)) (( 8 :: int)::ii) acctype aligned
       ((slice ((Word.ucast value_name  ::  128 Word.word)) (( 64 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word))
   else AArch64_aset_MemSingle address size1 acctype aligned value_name))))))))))"


(*val AArch64_aget_MemSingle : forall   'p8_times_size_ . Size 'p8_times_size_ => mword ty64 -> integer -> AccType -> bool -> M (mword 'p8_times_size_)*)

definition AArch64_aget_MemSingle  :: "(64)Word.word \<Rightarrow> int \<Rightarrow> AccType \<Rightarrow> bool \<Rightarrow>((register_value),(('p8_times_size_::len)Word.word),(exception))monad "  where 
     " AArch64_aget_MemSingle address size1 acctype wasaligned = (
   ((assert_exp ((((((size1 = (( 1 :: int)::ii)))) \<or> ((((((size1 = (( 2 :: int)::ii)))) \<or> ((((((size1 = (( 4 :: int)::ii)))) \<or> ((((((size1 = (( 8 :: int)::ii)))) \<or> (((size1 = (( 16 :: int)::ii)))))))))))))))) (''((size == 1) || ((size == 2) || ((size == 4) || ((size == 8) || (size == 16)))))'') \<then>
   assert_exp (((address = ((Align__1 address size1  ::  64 Word.word))))) (''(address == Align(address, size))'')) \<then>
   undefined_AddressDescriptor () ) \<bind> (\<lambda> (memaddrdesc :: AddressDescriptor) . 
   (undefined_bitvector (((( 8 :: int)::ii) * size1))  :: (( 'p8_times_size_::len)Word.word) M) \<bind> (\<lambda> value_name . 
   (let (iswrite :: bool) = False in
   AArch64_TranslateAddress address acctype iswrite wasaligned size1 \<bind> (\<lambda> (w__0 ::
     AddressDescriptor) . 
   (let memaddrdesc = w__0 in
   ((if ((IsFault memaddrdesc)) then AArch64_Abort address(AddressDescriptor_fault   memaddrdesc)
    else return () ) \<then>
   CreateAccessDescriptor acctype) \<bind> (\<lambda> (accdesc :: AccessDescriptor) . 
   (aget__Mem memaddrdesc size1 accdesc  :: (( 'p8_times_size_::len)Word.word) M))))))))"


(*val aget_Mem : forall   'p8_times_size_ . Size 'p8_times_size_ => mword ty64 -> integer -> AccType -> M (mword 'p8_times_size_)*)

definition aget_Mem  :: "(64)Word.word \<Rightarrow> int \<Rightarrow> AccType \<Rightarrow>((register_value),(('p8_times_size_::len)Word.word),(exception))monad "  where 
     " aget_Mem address size1 acctype = (
   (assert_exp ((((((size1 = (( 1 :: int)::ii)))) \<or> ((((((size1 = (( 2 :: int)::ii)))) \<or> ((((((size1 = (( 4 :: int)::ii)))) \<or> ((((((size1 = (( 8 :: int)::ii)))) \<or> (((size1 = (( 16 :: int)::ii)))))))))))))))) (''((size == 1) || ((size == 2) || ((size == 4) || ((size == 8) || (size == 16)))))'') \<then>
   (undefined_bitvector (((( 8 :: int)::ii) * size1))  :: (( 'p8_times_size_::len)Word.word) M)) \<bind> (\<lambda> value_name . 
   undefined_int ()  \<bind> (\<lambda> (i :: ii) . 
   (let (iswrite :: bool) = False in
   AArch64_CheckAlignment address size1 acctype iswrite \<bind> (\<lambda> (aligned :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (atomic :: bool) . 
   (let (atomic :: bool) =
     (if ((((((size1 \<noteq> (( 16 :: int)::ii)))) \<or> ((\<not> ((((((acctype = AccType_VEC))) \<or> (((acctype = AccType_VECSTREAM))))))))))) then
       aligned
     else (address = ((Align__1 address (( 8 :: int)::ii)  ::  64 Word.word)))) in
   undefined_Constraint ()  \<bind> (\<lambda> (c :: Constraint) . 
   (if ((\<not> atomic)) then
      (assert_exp ((size1 > (( 1 :: int)::ii))) (''(size > 1)'') \<then>
      (AArch64_aget_MemSingle address (( 1 :: int)::ii) acctype aligned  :: ( 8 Word.word) M)) \<bind> (\<lambda> (w__0 ::
         8 Word.word) . 
      (let value_name =
        ((set_slice (((( 8 :: int)::ii) * size1)) (( 8 :: int)::ii) value_name (( 0 :: int)::ii) w__0
          :: ( 'p8_times_size_::len)Word.word)) in
      (if ((\<not> aligned)) then
         (let c = (ConstrainUnpredictable Unpredictable_DEVPAGE2) in
         assert_exp ((((((c = Constraint_FAULT))) \<or> (((c = Constraint_NONE)))))) (''((c == Constraint_FAULT) || (c == Constraint_NONE))'') \<then>
         ((let (aligned :: bool) = (if (((c = Constraint_NONE))) then True else aligned) in
         return aligned)))
       else return aligned) \<bind> (\<lambda> (aligned :: bool) . 
      (foreachM (index_list (( 1 :: int)::ii) ((size1 - (( 1 :: int)::ii))) (( 1 :: int)::ii)) value_name
        (\<lambda> i value_name . 
          (AArch64_aget_MemSingle ((add_vec_int address i  ::  64 Word.word)) (( 1 :: int)::ii) acctype aligned
            :: ( 8 Word.word) M) \<bind> (\<lambda> (w__1 ::  8 Word.word) . 
          (let value_name =
            ((set_slice (((( 8 :: int)::ii) * size1)) (( 8 :: int)::ii) value_name (((( 8 :: int)::ii) * i)) w__1
              :: ( 'p8_times_size_::len)Word.word)) in
          return value_name)))))))
    else if ((((((size1 = (( 16 :: int)::ii)))) \<and> ((((((acctype = AccType_VEC))) \<or> (((acctype = AccType_VECSTREAM))))))))) then
      (AArch64_aget_MemSingle address (( 8 :: int)::ii) acctype aligned  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::
         64 Word.word) . 
      (let value_name =
        ((Word.ucast
           ((set_slice (((( 8 :: int)::ii) * (( 16 :: int)::ii))) (( 64 :: int)::ii)
               ((Word.ucast value_name  ::  128 Word.word)) (( 0 :: int)::ii) w__2
              ::  128 Word.word))
          :: ( 'p8_times_size_::len)Word.word)) in
      (AArch64_aget_MemSingle ((add_vec_int address (( 8 :: int)::ii)  ::  64 Word.word)) (( 8 :: int)::ii) acctype aligned
        :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::  64 Word.word) . 
      (let value_name =
        ((Word.ucast
           ((set_slice (((( 8 :: int)::ii) * (( 16 :: int)::ii))) (( 64 :: int)::ii)
               ((Word.ucast value_name  ::  128 Word.word)) (( 64 :: int)::ii) w__3
              ::  128 Word.word))
          :: ( 'p8_times_size_::len)Word.word)) in
      return value_name))))
    else (AArch64_aget_MemSingle address size1 acctype aligned  :: (( 'p8_times_size_::len)Word.word) M)) \<bind> (\<lambda> value_name . 
   BigEndian ()  \<bind> (\<lambda> (w__5 :: bool) . 
   if w__5 then (BigEndianReverse value_name  :: (( 'p8_times_size_::len)Word.word) M)
   else return value_name))))))))))"


(*val aarch64_memory_vector_single_nowb : forall 'datasize 'esize . Size 'datasize, Size 'esize => itself 'datasize -> itself 'esize -> ii -> ii -> MemOp -> ii -> bool -> integer -> ii -> bool -> M unit*)

definition aarch64_memory_vector_single_nowb  :: "('datasize::len)itself \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> MemOp \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_memory_vector_single_nowb datasize esize index1 m memop n replicate1 selem t__arg wback = (
   (let esize = (size_itself_int esize) in
   (let datasize = (size_itself_int datasize) in
   assert_exp True ('''') \<then>
   ((let (t :: ii) = t__arg in
   (CheckFPAdvSIMDEnabled64 ()  \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offs :: 64 bits) . 
   (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> (\<lambda> (rval :: 128 bits) . 
   (undefined_bitvector esize  :: (( 'esize::len)Word.word) M) \<bind> (\<lambda> element . 
   undefined_int ()  \<bind> (\<lambda> (s :: ii) . 
   (let (ebytes :: int) = (ex_int ((esize div (( 8 :: int)::ii)))) in
   (assert_exp True ('''') \<then>
   (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
    else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M))) \<bind> (\<lambda> (address :: 64 bits) . 
   (let offs = ((Zeros__1 (( 64 :: int)::ii) ()   ::  64 Word.word)) in
   (if replicate1 then
      (foreachM (index_list (( 0 :: int)::ii) ((selem - (( 1 :: int)::ii))) (( 1 :: int)::ii)) (element, offs, t)
        (\<lambda> s varstup .  (let (element, offs, t) = varstup in
          (aget_Mem ((add_vec address offs  ::  64 Word.word)) ebytes AccType_VEC  :: (( 'esize::len)Word.word) M) \<bind> (\<lambda> (w__2 ::
            ( 'esize::len)Word.word) . 
          (let element = w__2 in
          (let (v :: int) = (ex_int ((datasize div esize))) in
          (assert_exp True ('''') \<then>
          aset_V t ((replicate_bits element v  :: ( 'datasize::len)Word.word))) \<then>
          ((let (offs :: 64 bits) = ((add_vec_int offs ebytes  ::  64 Word.word)) in
          (let (t :: ii) = (((((ex_int t)) + (( 1 :: int)::ii))) mod (( 32 :: int)::ii)) in
          return (element, offs, t)))))))))) \<bind> (\<lambda> varstup .  (let (element, (offs :: 64 bits), (t :: ii)) = varstup in
      return offs))
    else
      (foreachM (index_list (( 0 :: int)::ii) ((selem - (( 1 :: int)::ii))) (( 1 :: int)::ii)) (offs, rval, t)
        (\<lambda> s varstup .  (let (offs, rval, t) = varstup in
          (aget_V (( 128 :: int)::ii) t  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__3 ::  128 Word.word) . 
          (let rval = w__3 in
          (if (((memop = MemOp_LOAD))) then
             (aget_Mem ((add_vec address offs  ::  64 Word.word)) ebytes AccType_VEC  :: (( 'esize::len)Word.word) M) \<bind> (\<lambda> (w__4 ::
               ( 'esize::len)Word.word) . 
             (aset_Elem__0 rval index1 ((make_the_value esize )) w__4  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__5 ::
                128 Word.word) . 
             (let rval = w__5 in
             aset_V t rval \<then> return rval)))
           else
             (aget_Elem__0 rval index1 ((make_the_value esize ))  :: (( 'esize::len)Word.word) M) \<bind> (\<lambda> (w__6 ::
               ( 'esize::len)Word.word) . 
             aset_Mem ((add_vec address offs  ::  64 Word.word)) ebytes AccType_VEC w__6 \<then> return rval)) \<bind> (\<lambda> (rval :: 128
            bits) . 
          (let (offs :: 64 bits) = ((add_vec_int offs ebytes  ::  64 Word.word)) in
          (let (t :: ii) = (((((ex_int t)) + (( 1 :: int)::ii))) mod (( 32 :: int)::ii)) in
          return (offs, rval, t))))))))) \<bind> (\<lambda> varstup .  (let ((offs :: 64 bits), (rval :: 128 bits), (t ::
        ii)) = varstup in
      return offs))) \<bind> (\<lambda> (offs :: 64 bits) . 
   if wback then
     (if (((m \<noteq> (( 31 :: int)::ii)))) then (aget_X (( 64 :: int)::ii) m  :: ( 64 Word.word) M)
      else return offs) \<bind> (\<lambda> (offs :: 64 bits) . 
     if (((n = (( 31 :: int)::ii)))) then aset_SP ((add_vec address offs  ::  64 Word.word))
     else aset_X n ((add_vec address offs  ::  64 Word.word)))
   else return () ))))))))))))))"


(*val aarch64_memory_vector_multiple_nowb : forall 'datasize 'esize   . Size 'datasize, Size 'esize => itself 'datasize -> integer -> itself 'esize -> ii -> MemOp -> ii -> integer -> integer -> ii -> bool -> M unit*)

definition aarch64_memory_vector_multiple_nowb  :: "('datasize::len)itself \<Rightarrow> int \<Rightarrow>('esize::len)itself \<Rightarrow> int \<Rightarrow> MemOp \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_memory_vector_multiple_nowb datasize elements esize m memop n rpt selem t wback = (
   (let esize = (size_itself_int esize) in
   (let datasize = (size_itself_int datasize) in
   ((assert_exp True (''datasize constraint'') \<then>
   CheckFPAdvSIMDEnabled64 () ) \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offs :: 64 bits) . 
   (undefined_bitvector datasize  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> rval . 
   undefined_int ()  \<bind> (\<lambda> (e :: ii) . 
   undefined_int ()  \<bind> (\<lambda> (r :: ii) . 
   undefined_int ()  \<bind> (\<lambda> (s :: ii) . 
   undefined_int ()  \<bind> (\<lambda> (tt :: ii) . 
   (let ebytes = (ex_int ((esize div (( 8 :: int)::ii)))) in
   (assert_exp True ('''') \<then>
   (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
    else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M))) \<bind> (\<lambda> (address :: 64 bits) . 
   (let offs = ((Zeros__1 (( 64 :: int)::ii) ()   ::  64 Word.word)) in
   (foreachM (index_list (( 0 :: int)::ii) ((rpt - (( 1 :: int)::ii))) (( 1 :: int)::ii)) (offs, rval, tt)
     (\<lambda> r varstup .  (let (offs, rval, tt) = varstup in
       (foreachM (index_list (( 0 :: int)::ii) ((elements - (( 1 :: int)::ii))) (( 1 :: int)::ii)) (offs, rval, tt)
         (\<lambda> e varstup .  (let (offs, rval, tt) = varstup in
           (let tt = (((t + r)) mod (( 32 :: int)::ii)) in
           (foreachM (index_list (( 0 :: int)::ii) ((selem - (( 1 :: int)::ii))) (( 1 :: int)::ii)) (offs, rval, tt)
             (\<lambda> s varstup .  (let (offs, rval, tt) = varstup in
               (aget_V datasize tt  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> (w__2 :: ( 'datasize::len)Word.word) . 
               (let rval = w__2 in
               (if (((memop = MemOp_LOAD))) then
                  (aget_Mem ((add_vec address offs  ::  64 Word.word)) ebytes AccType_VEC
                    :: (( 'esize::len)Word.word) M) \<bind> (\<lambda> (w__3 :: ( 'esize::len)Word.word) . 
                  (aset_Elem__0 rval e ((make_the_value esize )) w__3  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> (w__4 ::
                    ( 'datasize::len)Word.word) . 
                  (let rval = w__4 in
                  aset_V tt rval \<then> return rval)))
                else
                  (aget_Elem__0 rval e ((make_the_value esize ))  :: (( 'esize::len)Word.word) M) \<bind> (\<lambda> (w__5 ::
                    ( 'esize::len)Word.word) . 
                  aset_Mem ((add_vec address offs  ::  64 Word.word)) ebytes AccType_VEC w__5 \<then>
                  return rval)) \<bind> (\<lambda> rval . 
               (let (offs :: 64 bits) = ((add_vec_int offs ebytes  ::  64 Word.word)) in
               (let (tt :: ii) = (((((ex_int tt)) + (( 1 :: int)::ii))) mod (( 32 :: int)::ii)) in
               return (offs, rval, tt)))))))))))))))) \<bind> (\<lambda> varstup .  (let ((offs :: 64 bits), rval, (tt ::
     ii)) = varstup in
   if wback then
     (if (((m \<noteq> (( 31 :: int)::ii)))) then (aget_X (( 64 :: int)::ii) m  :: ( 64 Word.word) M)
      else return offs) \<bind> (\<lambda> (offs :: 64 bits) . 
     if (((n = (( 31 :: int)::ii)))) then aset_SP ((add_vec address offs  ::  64 Word.word))
     else aset_X n ((add_vec address offs  ::  64 Word.word)))
   else return () )))))))))))))))"


(*val aarch64_memory_single_simdfp_register : AccType -> ii -> ExtendType -> ii -> MemOp -> ii -> bool -> ii -> ii -> bool -> M unit*)

definition aarch64_memory_single_simdfp_register  :: " AccType \<Rightarrow> int \<Rightarrow> ExtendType \<Rightarrow> int \<Rightarrow> MemOp \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_memory_single_simdfp_register acctype l__83 extend_type m memop n postindex shift t wback = (
   if (((l__83 = (( 8 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (ExtendReg (( 64 :: int)::ii) m extend_type shift  :: ( 64 Word.word) M)) \<bind> (\<lambda> (offset :: 64 bits) . 
     (CheckFPAdvSIMDEnabled64 ()  \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> (\<lambda> (data :: 8 bits) . 
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (aget_V (( 8 :: int)::ii) t  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__2 ::  8 Word.word) . 
        (let data = w__2 in
        aset_Mem address (((( 8 :: int)::ii) div (( 8 :: int)::ii))) acctype data))
     | MemOp_LOAD =>
        (aget_Mem address (((( 8 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__3 ::
           8 Word.word) . 
        (let data = w__3 in
        aset_V t data))
     ) \<then>
     (if wback then
       (let (address :: 64 bits) =
         (if postindex then (add_vec address offset  ::  64 Word.word)
         else address) in
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () )))))))
   else if (((l__83 = (( 16 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (ExtendReg (( 64 :: int)::ii) m extend_type shift  :: ( 64 Word.word) M)) \<bind> (\<lambda> (offset :: 64 bits) . 
     (CheckFPAdvSIMDEnabled64 ()  \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (data :: 16 bits) . 
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (aget_V (( 16 :: int)::ii) t  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__6 ::  16 Word.word) . 
        (let data = w__6 in
        aset_Mem address (((( 16 :: int)::ii) div (( 8 :: int)::ii))) acctype data))
     | MemOp_LOAD =>
        (aget_Mem address (((( 16 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__7 ::
           16 Word.word) . 
        (let data = w__7 in
        aset_V t data))
     ) \<then>
     (if wback then
       (let (address :: 64 bits) =
         (if postindex then (add_vec address offset  ::  64 Word.word)
         else address) in
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () )))))))
   else if (((l__83 = (( 32 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (ExtendReg (( 64 :: int)::ii) m extend_type shift  :: ( 64 Word.word) M)) \<bind> (\<lambda> (offset :: 64 bits) . 
     (CheckFPAdvSIMDEnabled64 ()  \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (data :: 32 bits) . 
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (aget_V (( 32 :: int)::ii) t  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__10 ::  32 Word.word) . 
        (let data = w__10 in
        aset_Mem address (((( 32 :: int)::ii) div (( 8 :: int)::ii))) acctype data))
     | MemOp_LOAD =>
        (aget_Mem address (((( 32 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__11 ::
           32 Word.word) . 
        (let data = w__11 in
        aset_V t data))
     ) \<then>
     (if wback then
       (let (address :: 64 bits) =
         (if postindex then (add_vec address offset  ::  64 Word.word)
         else address) in
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () )))))))
   else if (((l__83 = (( 64 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (ExtendReg (( 64 :: int)::ii) m extend_type shift  :: ( 64 Word.word) M)) \<bind> (\<lambda> (offset :: 64 bits) . 
     (CheckFPAdvSIMDEnabled64 ()  \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (data :: 64 bits) . 
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (aget_V (( 64 :: int)::ii) t  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__14 ::  64 Word.word) . 
        (let data = w__14 in
        aset_Mem address (((( 64 :: int)::ii) div (( 8 :: int)::ii))) acctype data))
     | MemOp_LOAD =>
        (aget_Mem address (((( 64 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__15 ::
           64 Word.word) . 
        (let data = w__15 in
        aset_V t data))
     ) \<then>
     (if wback then
       (let (address :: 64 bits) =
         (if postindex then (add_vec address offset  ::  64 Word.word)
         else address) in
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () )))))))
   else if (((l__83 = (( 128 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (ExtendReg (( 64 :: int)::ii) m extend_type shift  :: ( 64 Word.word) M)) \<bind> (\<lambda> (offset :: 64 bits) . 
     (CheckFPAdvSIMDEnabled64 ()  \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> (\<lambda> (data :: 128 bits) . 
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (aget_V (( 128 :: int)::ii) t  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__18 ::  128 Word.word) . 
        (let data = w__18 in
        aset_Mem address (((( 128 :: int)::ii) div (( 8 :: int)::ii))) acctype data))
     | MemOp_LOAD =>
        (aget_Mem address (((( 128 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__19 ::
           128 Word.word) . 
        (let data = w__19 in
        aset_V t data))
     ) \<then>
     (if wback then
       (let (address :: 64 bits) =
         (if postindex then (add_vec address offset  ::  64 Word.word)
         else address) in
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () )))))))
   else
     (let dbytes = (ex_int ((l__83 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))"


(*val aarch64_memory_single_simdfp_immediate_signed_postidx : AccType -> ii -> MemOp -> ii -> mword ty64 -> bool -> ii -> bool -> M unit*)

definition aarch64_memory_single_simdfp_immediate_signed_postidx  :: " AccType \<Rightarrow> int \<Rightarrow> MemOp \<Rightarrow> int \<Rightarrow>(64)Word.word \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_memory_single_simdfp_immediate_signed_postidx acctype l__78 memop n offset postindex t wback = (
   if (((l__78 = (( 8 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> (\<lambda> (data :: 8 bits) . 
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (aget_V (( 8 :: int)::ii) t  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__2 ::  8 Word.word) . 
        (let data = w__2 in
        aset_Mem address (((( 8 :: int)::ii) div (( 8 :: int)::ii))) acctype data))
     | MemOp_LOAD =>
        (aget_Mem address (((( 8 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__3 ::
           8 Word.word) . 
        (let data = w__3 in
        aset_V t data))
     ) \<then>
     (if wback then
       (let (address :: 64 bits) =
         (if postindex then (add_vec address offset  ::  64 Word.word)
         else address) in
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () ))))))
   else if (((l__78 = (( 16 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (data :: 16 bits) . 
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (aget_V (( 16 :: int)::ii) t  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__6 ::  16 Word.word) . 
        (let data = w__6 in
        aset_Mem address (((( 16 :: int)::ii) div (( 8 :: int)::ii))) acctype data))
     | MemOp_LOAD =>
        (aget_Mem address (((( 16 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__7 ::
           16 Word.word) . 
        (let data = w__7 in
        aset_V t data))
     ) \<then>
     (if wback then
       (let (address :: 64 bits) =
         (if postindex then (add_vec address offset  ::  64 Word.word)
         else address) in
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () ))))))
   else if (((l__78 = (( 32 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (data :: 32 bits) . 
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (aget_V (( 32 :: int)::ii) t  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__10 ::  32 Word.word) . 
        (let data = w__10 in
        aset_Mem address (((( 32 :: int)::ii) div (( 8 :: int)::ii))) acctype data))
     | MemOp_LOAD =>
        (aget_Mem address (((( 32 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__11 ::
           32 Word.word) . 
        (let data = w__11 in
        aset_V t data))
     ) \<then>
     (if wback then
       (let (address :: 64 bits) =
         (if postindex then (add_vec address offset  ::  64 Word.word)
         else address) in
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () ))))))
   else if (((l__78 = (( 64 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (data :: 64 bits) . 
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (aget_V (( 64 :: int)::ii) t  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__14 ::  64 Word.word) . 
        (let data = w__14 in
        aset_Mem address (((( 64 :: int)::ii) div (( 8 :: int)::ii))) acctype data))
     | MemOp_LOAD =>
        (aget_Mem address (((( 64 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__15 ::
           64 Word.word) . 
        (let data = w__15 in
        aset_V t data))
     ) \<then>
     (if wback then
       (let (address :: 64 bits) =
         (if postindex then (add_vec address offset  ::  64 Word.word)
         else address) in
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () ))))))
   else if (((l__78 = (( 128 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> (\<lambda> (data :: 128 bits) . 
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (aget_V (( 128 :: int)::ii) t  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__18 ::  128 Word.word) . 
        (let data = w__18 in
        aset_Mem address (((( 128 :: int)::ii) div (( 8 :: int)::ii))) acctype data))
     | MemOp_LOAD =>
        (aget_Mem address (((( 128 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__19 ::
           128 Word.word) . 
        (let data = w__19 in
        aset_V t data))
     ) \<then>
     (if wback then
       (let (address :: 64 bits) =
         (if postindex then (add_vec address offset  ::  64 Word.word)
         else address) in
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () ))))))
   else
     (let dbytes = (ex_int ((l__78 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))"


(*val aarch64_memory_single_simdfp_immediate_signed_offset_normal : AccType -> ii -> MemOp -> ii -> mword ty64 -> bool -> ii -> bool -> M unit*)

definition aarch64_memory_single_simdfp_immediate_signed_offset_normal  :: " AccType \<Rightarrow> int \<Rightarrow> MemOp \<Rightarrow> int \<Rightarrow>(64)Word.word \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_memory_single_simdfp_immediate_signed_offset_normal acctype l__73 memop n offset postindex t wback = (
   if (((l__73 = (( 8 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> (\<lambda> (data :: 8 bits) . 
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (aget_V (( 8 :: int)::ii) t  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__2 ::  8 Word.word) . 
        (let data = w__2 in
        aset_Mem address (((( 8 :: int)::ii) div (( 8 :: int)::ii))) acctype data))
     | MemOp_LOAD =>
        (aget_Mem address (((( 8 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__3 ::
           8 Word.word) . 
        (let data = w__3 in
        aset_V t data))
     ) \<then>
     (if wback then
       (let (address :: 64 bits) =
         (if postindex then (add_vec address offset  ::  64 Word.word)
         else address) in
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () ))))))
   else if (((l__73 = (( 16 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (data :: 16 bits) . 
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (aget_V (( 16 :: int)::ii) t  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__6 ::  16 Word.word) . 
        (let data = w__6 in
        aset_Mem address (((( 16 :: int)::ii) div (( 8 :: int)::ii))) acctype data))
     | MemOp_LOAD =>
        (aget_Mem address (((( 16 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__7 ::
           16 Word.word) . 
        (let data = w__7 in
        aset_V t data))
     ) \<then>
     (if wback then
       (let (address :: 64 bits) =
         (if postindex then (add_vec address offset  ::  64 Word.word)
         else address) in
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () ))))))
   else if (((l__73 = (( 32 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (data :: 32 bits) . 
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (aget_V (( 32 :: int)::ii) t  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__10 ::  32 Word.word) . 
        (let data = w__10 in
        aset_Mem address (((( 32 :: int)::ii) div (( 8 :: int)::ii))) acctype data))
     | MemOp_LOAD =>
        (aget_Mem address (((( 32 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__11 ::
           32 Word.word) . 
        (let data = w__11 in
        aset_V t data))
     ) \<then>
     (if wback then
       (let (address :: 64 bits) =
         (if postindex then (add_vec address offset  ::  64 Word.word)
         else address) in
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () ))))))
   else if (((l__73 = (( 64 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (data :: 64 bits) . 
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (aget_V (( 64 :: int)::ii) t  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__14 ::  64 Word.word) . 
        (let data = w__14 in
        aset_Mem address (((( 64 :: int)::ii) div (( 8 :: int)::ii))) acctype data))
     | MemOp_LOAD =>
        (aget_Mem address (((( 64 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__15 ::
           64 Word.word) . 
        (let data = w__15 in
        aset_V t data))
     ) \<then>
     (if wback then
       (let (address :: 64 bits) =
         (if postindex then (add_vec address offset  ::  64 Word.word)
         else address) in
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () ))))))
   else if (((l__73 = (( 128 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     (((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     CheckFPAdvSIMDEnabled64 () ) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> (\<lambda> (data :: 128 bits) . 
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (aget_V (( 128 :: int)::ii) t  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__18 ::  128 Word.word) . 
        (let data = w__18 in
        aset_Mem address (((( 128 :: int)::ii) div (( 8 :: int)::ii))) acctype data))
     | MemOp_LOAD =>
        (aget_Mem address (((( 128 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__19 ::
           128 Word.word) . 
        (let data = w__19 in
        aset_V t data))
     ) \<then>
     (if wback then
       (let (address :: 64 bits) =
         (if postindex then (add_vec address offset  ::  64 Word.word)
         else address) in
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () ))))))
   else
     (let dbytes = (ex_int ((l__73 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))"


(*val aarch64_memory_ordered : forall 'datasize 'regsize. Size 'datasize, Size 'regsize => AccType -> itself 'datasize -> MemOp -> ii -> itself 'regsize -> ii -> M unit*)

definition aarch64_memory_ordered  :: " AccType \<Rightarrow>('datasize::len)itself \<Rightarrow> MemOp \<Rightarrow> int \<Rightarrow>('regsize::len)itself \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_memory_ordered acctype datasize memop n regsize t = (
   (let regsize = (size_itself_int regsize) in
   (let datasize = (size_itself_int datasize) in
   (assert_exp True (''datasize constraint'') \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
   (undefined_bitvector datasize  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> data . 
   (let dbytes = (ex_int ((datasize div (( 8 :: int)::ii)))) in
   (assert_exp True ('''') \<then>
   (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
    else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M))) \<bind> (\<lambda> (address :: 64 bits) . 
   (case  memop of
     MemOp_STORE =>
      (aget_X ((int (size data))) t  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> (w__2 :: ( 'datasize::len)Word.word) . 
      (let data = w__2 in
      aset_Mem address dbytes acctype data))
   | MemOp_LOAD =>
      (aget_Mem address dbytes acctype  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> (w__3 :: ( 'datasize::len)Word.word) . 
      (let data = w__3 in
      (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__4 ::
        ( 'regsize::len)Word.word) . 
      aset_X t w__4)))
   ))))))))"


(*val memory_ordered_decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_ordered_decode  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_ordered_decode b__0 o2 L o1 Rs o0 Rt2 Rn Rt = (
   if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (s :: ii) = (Word.uint Rs) in
     (let (acctype :: AccType) =
       (if (((o0 = (vec_of_bits [B0]  ::  1 Word.word)))) then AccType_LIMITEDORDERED
       else AccType_ORDERED) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (elsize :: ii) = ((( 8 :: int)::ii)) in
     (let (regsize :: ii) = ((( 32 :: int)::ii)) in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_ordered acctype ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) memop n
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) t))))))))))
   else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (s :: ii) = (Word.uint Rs) in
     (let (acctype :: AccType) =
       (if (((o0 = (vec_of_bits [B0]  ::  1 Word.word)))) then AccType_LIMITEDORDERED
       else AccType_ORDERED) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (elsize :: ii) = ((( 16 :: int)::ii)) in
     (let (regsize :: ii) = ((( 32 :: int)::ii)) in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_ordered acctype ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) memop n
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) t))))))))))
   else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (s :: ii) = (Word.uint Rs) in
     (let (acctype :: AccType) =
       (if (((o0 = (vec_of_bits [B0]  ::  1 Word.word)))) then AccType_LIMITEDORDERED
       else AccType_ORDERED) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (elsize :: ii) = ((( 32 :: int)::ii)) in
     (let (regsize :: ii) = ((( 32 :: int)::ii)) in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_ordered acctype ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) memop n
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) t))))))))))
   else
     write_reg unconditional_ref True \<then>
     ((let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (s :: ii) = (Word.uint Rs) in
     (let (acctype :: AccType) =
       (if (((o0 = (vec_of_bits [B0]  ::  1 Word.word)))) then AccType_LIMITEDORDERED
       else AccType_ORDERED) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (elsize :: ii) = ((( 64 :: int)::ii)) in
     (let (regsize :: ii) = ((( 64 :: int)::ii)) in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     aarch64_memory_ordered acctype ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) memop n
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) t)))))))))))"


(*val aarch64_memory_orderedrcpc : forall 'datasize 'regsize. Size 'datasize, Size 'regsize => AccType -> itself 'datasize -> ii -> itself 'regsize -> ii -> M unit*)

definition aarch64_memory_orderedrcpc  :: " AccType \<Rightarrow>('datasize::len)itself \<Rightarrow> int \<Rightarrow>('regsize::len)itself \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_memory_orderedrcpc acctype datasize n regsize t = (
   (let regsize = (size_itself_int regsize) in
   (let datasize = (size_itself_int datasize) in
   (assert_exp True (''datasize constraint'') \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
   (undefined_bitvector datasize  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> data . 
   (let dbytes = (ex_int ((datasize div (( 8 :: int)::ii)))) in
   (assert_exp True ('''') \<then>
   (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
    else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M))) \<bind> (\<lambda> (address :: 64 bits) . 
   (aget_Mem address dbytes acctype  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> (w__2 :: ( 'datasize::len)Word.word) . 
   (let data = w__2 in
   (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__3 ::
     ( 'regsize::len)Word.word) . 
   aset_X t w__3))))))))))"


(*val memory_orderedrcpc_decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty3 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_orderedrcpc_decode  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_orderedrcpc_decode b__0 V1 A R1 Rs o3 opc Rn Rt = (
   if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (s :: ii) = (Word.uint Rs) in
     (let (acctype :: AccType) = AccType_ORDERED in
     (let (elsize :: ii) = ((( 8 :: int)::ii)) in
     (let (regsize :: ii) = ((( 32 :: int)::ii)) in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_orderedrcpc AccType_ORDERED ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) n
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) t))))))))
   else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (s :: ii) = (Word.uint Rs) in
     (let (acctype :: AccType) = AccType_ORDERED in
     (let (elsize :: ii) = ((( 16 :: int)::ii)) in
     (let (regsize :: ii) = ((( 32 :: int)::ii)) in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_orderedrcpc AccType_ORDERED ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) n
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) t))))))))
   else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (s :: ii) = (Word.uint Rs) in
     (let (acctype :: AccType) = AccType_ORDERED in
     (let (elsize :: ii) = ((( 32 :: int)::ii)) in
     (let (regsize :: ii) = ((( 32 :: int)::ii)) in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_orderedrcpc AccType_ORDERED ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) n
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) t))))))))
   else
     write_reg unconditional_ref True \<then>
     ((let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (s :: ii) = (Word.uint Rs) in
     (let (acctype :: AccType) = AccType_ORDERED in
     (let (elsize :: ii) = ((( 64 :: int)::ii)) in
     (let (regsize :: ii) = ((( 64 :: int)::ii)) in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     aarch64_memory_orderedrcpc AccType_ORDERED ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) n
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) t)))))))))"


(*val aarch64_memory_literal_simdfp : mword ty64 -> integer -> ii -> M unit*)

definition aarch64_memory_literal_simdfp  :: "(64)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_memory_literal_simdfp offset l__70 t = (
   if (((l__70 = (( 4 :: int)::ii)))) then
     ((assert_exp True ('''') \<then>
     assert_exp True ('''')) \<then>
     (aget_PC ()   :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
     (let (address :: 64 bits) = ((add_vec w__0 offset  ::  64 Word.word)) in
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (data :: 32 bits) . 
     (CheckFPAdvSIMDEnabled64 ()  \<then>
     (aget_Mem address (( 4 :: int)::ii) AccType_VEC  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__1 ::  32 Word.word) . 
     (let data = w__1 in
     aset_V t data)))))
   else if (((l__70 = (( 8 :: int)::ii)))) then
     ((assert_exp True ('''') \<then>
     assert_exp True ('''')) \<then>
     (aget_PC ()   :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__2 ::  64 Word.word) . 
     (let (address :: 64 bits) = ((add_vec w__2 offset  ::  64 Word.word)) in
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (data :: 64 bits) . 
     (CheckFPAdvSIMDEnabled64 ()  \<then>
     (aget_Mem address (( 8 :: int)::ii) AccType_VEC  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__3 ::  64 Word.word) . 
     (let data = w__3 in
     aset_V t data)))))
   else if (((l__70 = (( 16 :: int)::ii)))) then
     ((assert_exp True ('''') \<then>
     assert_exp True ('''')) \<then>
     (aget_PC ()   :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__4 ::  64 Word.word) . 
     (let (address :: 64 bits) = ((add_vec w__4 offset  ::  64 Word.word)) in
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> (\<lambda> (data :: 128 bits) . 
     (CheckFPAdvSIMDEnabled64 ()  \<then>
     (aget_Mem address (( 16 :: int)::ii) AccType_VEC  :: ( 128 Word.word) M)) \<bind> (\<lambda> (w__5 ::  128 Word.word) . 
     (let data = w__5 in
     aset_V t data)))))
   else assert_exp True ('''') \<then> assert_exp True (''''))"


(*val aarch64_memory_literal_general : forall 'size. Size 'size => MemOp -> mword ty64 -> bool -> itself 'size -> ii -> M unit*)

definition aarch64_memory_literal_general  :: " MemOp \<Rightarrow>(64)Word.word \<Rightarrow> bool \<Rightarrow>('size::len)itself \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_memory_literal_general memop offset signed size1 t = (
   (let size1 = (size_itself_int size1) in
   (aget_PC ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (let (address :: 64 bits) = ((add_vec w__0 offset  ::  64 Word.word)) in
   (undefined_bitvector size1  :: (( 'size::len)Word.word) M) \<bind> (\<lambda> data . 
   (case  memop of
     MemOp_LOAD =>
      assert_exp True ('''') \<then>
      ((let bytes = (size1 div (( 8 :: int)::ii)) in
      (assert_exp True ('''') \<then>
      (aget_Mem address bytes AccType_NORMAL  :: (( 'size::len)Word.word) M)) \<bind> (\<lambda> (w__1 :: ( 'size::len)Word.word) . 
      (let data = w__1 in
      if signed then
        (SignExtend__0 data ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::
           64 Word.word) . 
        aset_X t w__2)
      else aset_X t data))))
   | MemOp_PREFETCH =>
      Prefetch address
        ((GetSlice_int ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) t (( 0 :: int)::ii)  ::  5 Word.word))
   ))))))"


(*val memory_literal_general_decode : mword ty2 -> mword ty1 -> mword ty19 -> mword ty5 -> M unit*)

definition memory_literal_general_decode  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(19)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_literal_general_decode b__0 V1 imm19 Rt = (
   if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (memop :: MemOp) = MemOp_LOAD in
     (let (signed :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (size1 :: ii) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let size1 = ((( 4 :: int)::ii)) in
     (SignExtend__0 ((concat_vec imm19 (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  21 Word.word))
        ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
     (let offset = w__0 in
     aarch64_memory_literal_general MemOp_LOAD offset False
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) t)))))))))
   else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (memop :: MemOp) = MemOp_LOAD in
     (let (signed :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (size1 :: ii) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let size1 = ((( 8 :: int)::ii)) in
     (SignExtend__0 ((concat_vec imm19 (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  21 Word.word))
        ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
     (let offset = w__1 in
     aarch64_memory_literal_general MemOp_LOAD offset False
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) t)))))))))
   else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (memop :: MemOp) = MemOp_LOAD in
     (let (signed :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (size1 :: ii) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let size1 = ((( 4 :: int)::ii)) in
     (let signed = True in
     (SignExtend__0 ((concat_vec imm19 (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  21 Word.word))
        ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::  64 Word.word) . 
     (let offset = w__2 in
     aarch64_memory_literal_general MemOp_LOAD offset True ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       t))))))))))
   else
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (memop :: MemOp) = MemOp_LOAD in
     (let (signed :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (size1 :: ii) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let memop = MemOp_PREFETCH in
     (SignExtend__0 ((concat_vec imm19 (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  21 Word.word))
        ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::  64 Word.word) . 
     (let offset = w__3 in
     aarch64_memory_literal_general MemOp_PREFETCH offset False
       ((make_the_value (((( 8 :: int)::ii) * (( 32 :: int)::ii)))  ::  256 itself)) t))))))))))"


(*val aarch64_memory_atomicops_swp : forall 'regsize. Size 'regsize => ii -> AccType -> ii -> itself 'regsize -> ii -> AccType -> ii -> M unit*)

definition aarch64_memory_atomicops_swp  :: " int \<Rightarrow> AccType \<Rightarrow> int \<Rightarrow>('regsize::len)itself \<Rightarrow> int \<Rightarrow> AccType \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_memory_atomicops_swp l__65 ldacctype n regsize s stacctype t = (
   if (((l__65 = (( 8 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> (\<lambda> (data :: 8 bits) . 
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (aget_Mem address (((( 8 :: int)::ii) div (( 8 :: int)::ii))) ldacctype  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__2 ::
        8 Word.word) . 
     (let data = w__2 in
     (aget_X ((int (size data))) s  :: ( 8 Word.word) M) \<bind> (\<lambda> w__3 . 
     (aset_Mem address (((( 8 :: int)::ii) div (( 8 :: int)::ii))) stacctype w__3 \<then>
     (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M)) \<bind> (\<lambda> (w__4 ::
       ( 'regsize::len)Word.word) . 
     aset_X t w__4))))))))))
   else if (((l__65 = (( 16 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (data :: 16 bits) . 
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (aget_Mem address (((( 16 :: int)::ii) div (( 8 :: int)::ii))) ldacctype  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__7 ::
        16 Word.word) . 
     (let data = w__7 in
     (aget_X ((int (size data))) s  :: ( 16 Word.word) M) \<bind> (\<lambda> w__8 . 
     (aset_Mem address (((( 16 :: int)::ii) div (( 8 :: int)::ii))) stacctype w__8 \<then>
     (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M)) \<bind> (\<lambda> (w__9 ::
       ( 'regsize::len)Word.word) . 
     aset_X t w__9))))))))))
   else if (((l__65 = (( 32 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (data :: 32 bits) . 
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (aget_Mem address (((( 32 :: int)::ii) div (( 8 :: int)::ii))) ldacctype  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__12 ::
        32 Word.word) . 
     (let data = w__12 in
     (aget_X ((int (size data))) s  :: ( 32 Word.word) M) \<bind> (\<lambda> w__13 . 
     (aset_Mem address (((( 32 :: int)::ii) div (( 8 :: int)::ii))) stacctype w__13 \<then>
     (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M)) \<bind> (\<lambda> (w__14 ::
       ( 'regsize::len)Word.word) . 
     aset_X t w__14))))))))))
   else if (((l__65 = (( 64 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (data :: 64 bits) . 
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (aget_Mem address (((( 64 :: int)::ii) div (( 8 :: int)::ii))) ldacctype  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__17 ::
        64 Word.word) . 
     (let data = w__17 in
     (aget_X ((int (size address))) s  :: ( 64 Word.word) M) \<bind> (\<lambda> w__18 . 
     (aset_Mem address (((( 64 :: int)::ii) div (( 8 :: int)::ii))) stacctype w__18 \<then>
     (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M)) \<bind> (\<lambda> (w__19 ::
       ( 'regsize::len)Word.word) . 
     aset_X t w__19))))))))))
   else if (((l__65 = (( 128 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> (\<lambda> (data :: 128 bits) . 
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (aget_Mem address (((( 128 :: int)::ii) div (( 8 :: int)::ii))) ldacctype  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__22 ::
        128 Word.word) . 
     (let data = w__22 in
     (aget_X ((int (size data))) s  :: ( 128 Word.word) M) \<bind> (\<lambda> w__23 . 
     (aset_Mem address (((( 128 :: int)::ii) div (( 8 :: int)::ii))) stacctype w__23 \<then>
     (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M)) \<bind> (\<lambda> (w__24 ::
       ( 'regsize::len)Word.word) . 
     aset_X t w__24))))))))))
   else
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int ((l__65 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))))"


(*val aarch64_memory_atomicops_st : ii -> AccType -> ii -> MemAtomicOp -> ii -> AccType -> M unit*)

definition aarch64_memory_atomicops_st  :: " int \<Rightarrow> AccType \<Rightarrow> int \<Rightarrow> MemAtomicOp \<Rightarrow> int \<Rightarrow> AccType \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_memory_atomicops_st l__60 ldacctype n op1 s stacctype = (
   if (((l__60 = (( 8 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> (\<lambda> (value_name :: 8 bits) . 
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> (\<lambda> (data :: 8 bits) . 
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> (\<lambda> (result :: 8 bits) . 
     (aget_X (( 8 :: int)::ii) s  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__0 ::  8 Word.word) . 
     (let value_name = w__0 in
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (aget_Mem address (((( 8 :: int)::ii) div (( 8 :: int)::ii))) ldacctype  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__3 ::
        8 Word.word) . 
     (let data = w__3 in
     (let (result :: 8 bits) =
       ((case  op1 of
         MemAtomicOp_ADD => (add_vec data value_name  ::  8 Word.word)
       | MemAtomicOp_BIC => (and_vec data ((not_vec value_name  ::  8 Word.word))  ::  8 Word.word)
       | MemAtomicOp_EOR => (xor_vec data value_name  ::  8 Word.word)
       | MemAtomicOp_ORR => (or_vec data value_name  ::  8 Word.word)
       | MemAtomicOp_SMAX => if ((((Word.sint data)) > ((Word.sint value_name)))) then data else value_name
       | MemAtomicOp_SMIN => if ((((Word.sint data)) > ((Word.sint value_name)))) then value_name else data
       | MemAtomicOp_UMAX => if ((((Word.uint data)) > ((Word.uint value_name)))) then data else value_name
       | MemAtomicOp_UMIN => if ((((Word.uint data)) > ((Word.uint value_name)))) then value_name else data
       )) in
     aset_Mem address (((( 8 :: int)::ii) div (( 8 :: int)::ii))) stacctype result)))))))))))
   else if (((l__60 = (( 16 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (value_name :: 16 bits) . 
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (data :: 16 bits) . 
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (result :: 16 bits) . 
     (aget_X (( 16 :: int)::ii) s  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__4 ::  16 Word.word) . 
     (let value_name = w__4 in
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (aget_Mem address (((( 16 :: int)::ii) div (( 8 :: int)::ii))) ldacctype  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__7 ::
        16 Word.word) . 
     (let data = w__7 in
     (let (result :: 16 bits) =
       ((case  op1 of
         MemAtomicOp_ADD => (add_vec data value_name  ::  16 Word.word)
       | MemAtomicOp_BIC => (and_vec data ((not_vec value_name  ::  16 Word.word))  ::  16 Word.word)
       | MemAtomicOp_EOR => (xor_vec data value_name  ::  16 Word.word)
       | MemAtomicOp_ORR => (or_vec data value_name  ::  16 Word.word)
       | MemAtomicOp_SMAX => if ((((Word.sint data)) > ((Word.sint value_name)))) then data else value_name
       | MemAtomicOp_SMIN => if ((((Word.sint data)) > ((Word.sint value_name)))) then value_name else data
       | MemAtomicOp_UMAX => if ((((Word.uint data)) > ((Word.uint value_name)))) then data else value_name
       | MemAtomicOp_UMIN => if ((((Word.uint data)) > ((Word.uint value_name)))) then value_name else data
       )) in
     aset_Mem address (((( 16 :: int)::ii) div (( 8 :: int)::ii))) stacctype result)))))))))))
   else if (((l__60 = (( 32 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (value_name :: 32 bits) . 
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (data :: 32 bits) . 
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (result :: 32 bits) . 
     (aget_X (( 32 :: int)::ii) s  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__8 ::  32 Word.word) . 
     (let value_name = w__8 in
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (aget_Mem address (((( 32 :: int)::ii) div (( 8 :: int)::ii))) ldacctype  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__11 ::
        32 Word.word) . 
     (let data = w__11 in
     (let (result :: 32 bits) =
       ((case  op1 of
         MemAtomicOp_ADD => (add_vec data value_name  ::  32 Word.word)
       | MemAtomicOp_BIC => (and_vec data ((not_vec value_name  ::  32 Word.word))  ::  32 Word.word)
       | MemAtomicOp_EOR => (xor_vec data value_name  ::  32 Word.word)
       | MemAtomicOp_ORR => (or_vec data value_name  ::  32 Word.word)
       | MemAtomicOp_SMAX => if ((((Word.sint data)) > ((Word.sint value_name)))) then data else value_name
       | MemAtomicOp_SMIN => if ((((Word.sint data)) > ((Word.sint value_name)))) then value_name else data
       | MemAtomicOp_UMAX => if ((((Word.uint data)) > ((Word.uint value_name)))) then data else value_name
       | MemAtomicOp_UMIN => if ((((Word.uint data)) > ((Word.uint value_name)))) then value_name else data
       )) in
     aset_Mem address (((( 32 :: int)::ii) div (( 8 :: int)::ii))) stacctype result)))))))))))
   else if (((l__60 = (( 64 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (value_name :: 64 bits) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (data :: 64 bits) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (result :: 64 bits) . 
     (aget_X (( 64 :: int)::ii) s  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__12 ::  64 Word.word) . 
     (let value_name = w__12 in
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (aget_Mem address (((( 64 :: int)::ii) div (( 8 :: int)::ii))) ldacctype  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__15 ::
        64 Word.word) . 
     (let data = w__15 in
     (let (result :: 64 bits) =
       ((case  op1 of
         MemAtomicOp_ADD => (add_vec data value_name  ::  64 Word.word)
       | MemAtomicOp_BIC => (and_vec data ((not_vec value_name  ::  64 Word.word))  ::  64 Word.word)
       | MemAtomicOp_EOR => (xor_vec data value_name  ::  64 Word.word)
       | MemAtomicOp_ORR => (or_vec data value_name  ::  64 Word.word)
       | MemAtomicOp_SMAX => if ((((Word.sint data)) > ((Word.sint value_name)))) then data else value_name
       | MemAtomicOp_SMIN => if ((((Word.sint data)) > ((Word.sint value_name)))) then value_name else data
       | MemAtomicOp_UMAX => if ((((Word.uint data)) > ((Word.uint value_name)))) then data else value_name
       | MemAtomicOp_UMIN => if ((((Word.uint data)) > ((Word.uint value_name)))) then value_name else data
       )) in
     aset_Mem address (((( 64 :: int)::ii) div (( 8 :: int)::ii))) stacctype result)))))))))))
   else if (((l__60 = (( 128 :: int)::ii)))) then
     (let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> (\<lambda> (value_name :: 128 bits) . 
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> (\<lambda> (data :: 128 bits) . 
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> (\<lambda> (result :: 128 bits) . 
     (aget_X (( 128 :: int)::ii) s  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__16 ::  128 Word.word) . 
     (let value_name = w__16 in
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (aget_Mem address (((( 128 :: int)::ii) div (( 8 :: int)::ii))) ldacctype  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__19 ::
        128 Word.word) . 
     (let data = w__19 in
     (let (result :: 128 bits) =
       ((case  op1 of
         MemAtomicOp_ADD => (add_vec data value_name  ::  128 Word.word)
       | MemAtomicOp_BIC => (and_vec data ((not_vec value_name  ::  128 Word.word))  ::  128 Word.word)
       | MemAtomicOp_EOR => (xor_vec data value_name  ::  128 Word.word)
       | MemAtomicOp_ORR => (or_vec data value_name  ::  128 Word.word)
       | MemAtomicOp_SMAX => if ((((Word.sint data)) > ((Word.sint value_name)))) then data else value_name
       | MemAtomicOp_SMIN => if ((((Word.sint data)) > ((Word.sint value_name)))) then value_name else data
       | MemAtomicOp_UMAX => if ((((Word.uint data)) > ((Word.uint value_name)))) then data else value_name
       | MemAtomicOp_UMIN => if ((((Word.uint data)) > ((Word.uint value_name)))) then value_name else data
       )) in
     aset_Mem address (((( 128 :: int)::ii) div (( 8 :: int)::ii))) stacctype result)))))))))))
   else
     (let dbytes = (ex_int ((l__60 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))"


(*val aarch64_memory_atomicops_ld : forall 'regsize. Size 'regsize => ii -> AccType -> ii -> MemAtomicOp -> itself 'regsize -> ii -> AccType -> ii -> M unit*)

definition aarch64_memory_atomicops_ld  :: " int \<Rightarrow> AccType \<Rightarrow> int \<Rightarrow> MemAtomicOp \<Rightarrow>('regsize::len)itself \<Rightarrow> int \<Rightarrow> AccType \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_memory_atomicops_ld l__55 ldacctype n op1 regsize s stacctype t = (
   if (((l__55 = (( 8 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> (\<lambda> (value_name :: 8 bits) . 
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> (\<lambda> (data :: 8 bits) . 
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> (\<lambda> (result :: 8 bits) . 
     (aget_X (( 8 :: int)::ii) s  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__0 ::  8 Word.word) . 
     (let value_name = w__0 in
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (aget_Mem address (((( 8 :: int)::ii) div (( 8 :: int)::ii))) ldacctype  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__3 ::
        8 Word.word) . 
     (let data = w__3 in
     (let (result :: 8 bits) =
       ((case  op1 of
         MemAtomicOp_ADD => (add_vec data value_name  ::  8 Word.word)
       | MemAtomicOp_BIC => (and_vec data ((not_vec value_name  ::  8 Word.word))  ::  8 Word.word)
       | MemAtomicOp_EOR => (xor_vec data value_name  ::  8 Word.word)
       | MemAtomicOp_ORR => (or_vec data value_name  ::  8 Word.word)
       | MemAtomicOp_SMAX => if ((((Word.sint data)) > ((Word.sint value_name)))) then data else value_name
       | MemAtomicOp_SMIN => if ((((Word.sint data)) > ((Word.sint value_name)))) then value_name else data
       | MemAtomicOp_UMAX => if ((((Word.uint data)) > ((Word.uint value_name)))) then data else value_name
       | MemAtomicOp_UMIN => if ((((Word.uint data)) > ((Word.uint value_name)))) then value_name else data
       )) in
     (aset_Mem address (((( 8 :: int)::ii) div (( 8 :: int)::ii))) stacctype result \<then>
     (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M)) \<bind> (\<lambda> (w__4 ::
       ( 'regsize::len)Word.word) . 
     aset_X t w__4))))))))))))))
   else if (((l__55 = (( 16 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (value_name :: 16 bits) . 
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (data :: 16 bits) . 
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (result :: 16 bits) . 
     (aget_X (( 16 :: int)::ii) s  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__5 ::  16 Word.word) . 
     (let value_name = w__5 in
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (aget_Mem address (((( 16 :: int)::ii) div (( 8 :: int)::ii))) ldacctype  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__8 ::
        16 Word.word) . 
     (let data = w__8 in
     (let (result :: 16 bits) =
       ((case  op1 of
         MemAtomicOp_ADD => (add_vec data value_name  ::  16 Word.word)
       | MemAtomicOp_BIC => (and_vec data ((not_vec value_name  ::  16 Word.word))  ::  16 Word.word)
       | MemAtomicOp_EOR => (xor_vec data value_name  ::  16 Word.word)
       | MemAtomicOp_ORR => (or_vec data value_name  ::  16 Word.word)
       | MemAtomicOp_SMAX => if ((((Word.sint data)) > ((Word.sint value_name)))) then data else value_name
       | MemAtomicOp_SMIN => if ((((Word.sint data)) > ((Word.sint value_name)))) then value_name else data
       | MemAtomicOp_UMAX => if ((((Word.uint data)) > ((Word.uint value_name)))) then data else value_name
       | MemAtomicOp_UMIN => if ((((Word.uint data)) > ((Word.uint value_name)))) then value_name else data
       )) in
     (aset_Mem address (((( 16 :: int)::ii) div (( 8 :: int)::ii))) stacctype result \<then>
     (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M)) \<bind> (\<lambda> (w__9 ::
       ( 'regsize::len)Word.word) . 
     aset_X t w__9))))))))))))))
   else if (((l__55 = (( 32 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (value_name :: 32 bits) . 
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (data :: 32 bits) . 
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (result :: 32 bits) . 
     (aget_X (( 32 :: int)::ii) s  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__10 ::  32 Word.word) . 
     (let value_name = w__10 in
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (aget_Mem address (((( 32 :: int)::ii) div (( 8 :: int)::ii))) ldacctype  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__13 ::
        32 Word.word) . 
     (let data = w__13 in
     (let (result :: 32 bits) =
       ((case  op1 of
         MemAtomicOp_ADD => (add_vec data value_name  ::  32 Word.word)
       | MemAtomicOp_BIC => (and_vec data ((not_vec value_name  ::  32 Word.word))  ::  32 Word.word)
       | MemAtomicOp_EOR => (xor_vec data value_name  ::  32 Word.word)
       | MemAtomicOp_ORR => (or_vec data value_name  ::  32 Word.word)
       | MemAtomicOp_SMAX => if ((((Word.sint data)) > ((Word.sint value_name)))) then data else value_name
       | MemAtomicOp_SMIN => if ((((Word.sint data)) > ((Word.sint value_name)))) then value_name else data
       | MemAtomicOp_UMAX => if ((((Word.uint data)) > ((Word.uint value_name)))) then data else value_name
       | MemAtomicOp_UMIN => if ((((Word.uint data)) > ((Word.uint value_name)))) then value_name else data
       )) in
     (aset_Mem address (((( 32 :: int)::ii) div (( 8 :: int)::ii))) stacctype result \<then>
     (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M)) \<bind> (\<lambda> (w__14 ::
       ( 'regsize::len)Word.word) . 
     aset_X t w__14))))))))))))))
   else if (((l__55 = (( 64 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (value_name :: 64 bits) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (data :: 64 bits) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (result :: 64 bits) . 
     (aget_X (( 64 :: int)::ii) s  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__15 ::  64 Word.word) . 
     (let value_name = w__15 in
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (aget_Mem address (((( 64 :: int)::ii) div (( 8 :: int)::ii))) ldacctype  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__18 ::
        64 Word.word) . 
     (let data = w__18 in
     (let (result :: 64 bits) =
       ((case  op1 of
         MemAtomicOp_ADD => (add_vec data value_name  ::  64 Word.word)
       | MemAtomicOp_BIC => (and_vec data ((not_vec value_name  ::  64 Word.word))  ::  64 Word.word)
       | MemAtomicOp_EOR => (xor_vec data value_name  ::  64 Word.word)
       | MemAtomicOp_ORR => (or_vec data value_name  ::  64 Word.word)
       | MemAtomicOp_SMAX => if ((((Word.sint data)) > ((Word.sint value_name)))) then data else value_name
       | MemAtomicOp_SMIN => if ((((Word.sint data)) > ((Word.sint value_name)))) then value_name else data
       | MemAtomicOp_UMAX => if ((((Word.uint data)) > ((Word.uint value_name)))) then data else value_name
       | MemAtomicOp_UMIN => if ((((Word.uint data)) > ((Word.uint value_name)))) then value_name else data
       )) in
     (aset_Mem address (((( 64 :: int)::ii) div (( 8 :: int)::ii))) stacctype result \<then>
     (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M)) \<bind> (\<lambda> (w__19 ::
       ( 'regsize::len)Word.word) . 
     aset_X t w__19))))))))))))))
   else if (((l__55 = (( 128 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> (\<lambda> (value_name :: 128 bits) . 
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> (\<lambda> (data :: 128 bits) . 
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> (\<lambda> (result :: 128 bits) . 
     (aget_X (( 128 :: int)::ii) s  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__20 ::  128 Word.word) . 
     (let value_name = w__20 in
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (aget_Mem address (((( 128 :: int)::ii) div (( 8 :: int)::ii))) ldacctype  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__23 ::
        128 Word.word) . 
     (let data = w__23 in
     (let (result :: 128 bits) =
       ((case  op1 of
         MemAtomicOp_ADD => (add_vec data value_name  ::  128 Word.word)
       | MemAtomicOp_BIC => (and_vec data ((not_vec value_name  ::  128 Word.word))  ::  128 Word.word)
       | MemAtomicOp_EOR => (xor_vec data value_name  ::  128 Word.word)
       | MemAtomicOp_ORR => (or_vec data value_name  ::  128 Word.word)
       | MemAtomicOp_SMAX => if ((((Word.sint data)) > ((Word.sint value_name)))) then data else value_name
       | MemAtomicOp_SMIN => if ((((Word.sint data)) > ((Word.sint value_name)))) then value_name else data
       | MemAtomicOp_UMAX => if ((((Word.uint data)) > ((Word.uint value_name)))) then data else value_name
       | MemAtomicOp_UMIN => if ((((Word.uint data)) > ((Word.uint value_name)))) then value_name else data
       )) in
     (aset_Mem address (((( 128 :: int)::ii) div (( 8 :: int)::ii))) stacctype result \<then>
     (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M)) \<bind> (\<lambda> (w__24 ::
       ( 'regsize::len)Word.word) . 
     aset_X t w__24))))))))))))))
   else
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int ((l__55 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))))"


(*val aarch64_memory_atomicops_cas_single : forall 'regsize. Size 'regsize => ii -> AccType -> ii -> itself 'regsize -> ii -> AccType -> ii -> M unit*)

definition aarch64_memory_atomicops_cas_single  :: " int \<Rightarrow> AccType \<Rightarrow> int \<Rightarrow>('regsize::len)itself \<Rightarrow> int \<Rightarrow> AccType \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_memory_atomicops_cas_single l__50 ldacctype n regsize s stacctype t = (
   if (((l__50 = (( 8 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> (\<lambda> (comparevalue :: 8 bits) . 
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> (\<lambda> (newvalue :: 8 bits) . 
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> (\<lambda> (data :: 8 bits) . 
     (aget_X (( 8 :: int)::ii) s  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__0 ::  8 Word.word) . 
     (let comparevalue = w__0 in
     (aget_X (( 8 :: int)::ii) t  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__1 ::  8 Word.word) . 
     (let newvalue = w__1 in
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (aget_Mem address (((( 8 :: int)::ii) div (( 8 :: int)::ii))) ldacctype  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__4 ::
        8 Word.word) . 
     (let data = w__4 in
     ((if (((data = comparevalue))) then
        aset_Mem address (((( 8 :: int)::ii) div (( 8 :: int)::ii))) stacctype newvalue
      else return () ) \<then>
     (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M)) \<bind> (\<lambda> (w__5 ::
       ( 'regsize::len)Word.word) . 
     aset_X s w__5)))))))))))))))
   else if (((l__50 = (( 16 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (comparevalue :: 16 bits) . 
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (newvalue :: 16 bits) . 
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (data :: 16 bits) . 
     (aget_X (( 16 :: int)::ii) s  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__6 ::  16 Word.word) . 
     (let comparevalue = w__6 in
     (aget_X (( 16 :: int)::ii) t  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__7 ::  16 Word.word) . 
     (let newvalue = w__7 in
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (aget_Mem address (((( 16 :: int)::ii) div (( 8 :: int)::ii))) ldacctype  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__10 ::
        16 Word.word) . 
     (let data = w__10 in
     ((if (((data = comparevalue))) then
        aset_Mem address (((( 16 :: int)::ii) div (( 8 :: int)::ii))) stacctype newvalue
      else return () ) \<then>
     (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M)) \<bind> (\<lambda> (w__11 ::
       ( 'regsize::len)Word.word) . 
     aset_X s w__11)))))))))))))))
   else if (((l__50 = (( 32 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (comparevalue :: 32 bits) . 
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (newvalue :: 32 bits) . 
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (data :: 32 bits) . 
     (aget_X (( 32 :: int)::ii) s  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__12 ::  32 Word.word) . 
     (let comparevalue = w__12 in
     (aget_X (( 32 :: int)::ii) t  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__13 ::  32 Word.word) . 
     (let newvalue = w__13 in
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (aget_Mem address (((( 32 :: int)::ii) div (( 8 :: int)::ii))) ldacctype  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__16 ::
        32 Word.word) . 
     (let data = w__16 in
     ((if (((data = comparevalue))) then
        aset_Mem address (((( 32 :: int)::ii) div (( 8 :: int)::ii))) stacctype newvalue
      else return () ) \<then>
     (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M)) \<bind> (\<lambda> (w__17 ::
       ( 'regsize::len)Word.word) . 
     aset_X s w__17)))))))))))))))
   else if (((l__50 = (( 64 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (comparevalue :: 64 bits) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (newvalue :: 64 bits) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (data :: 64 bits) . 
     (aget_X (( 64 :: int)::ii) s  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__18 ::  64 Word.word) . 
     (let comparevalue = w__18 in
     (aget_X (( 64 :: int)::ii) t  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__19 ::  64 Word.word) . 
     (let newvalue = w__19 in
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (aget_Mem address (((( 64 :: int)::ii) div (( 8 :: int)::ii))) ldacctype  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__22 ::
        64 Word.word) . 
     (let data = w__22 in
     ((if (((data = comparevalue))) then
        aset_Mem address (((( 64 :: int)::ii) div (( 8 :: int)::ii))) stacctype newvalue
      else return () ) \<then>
     (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M)) \<bind> (\<lambda> (w__23 ::
       ( 'regsize::len)Word.word) . 
     aset_X s w__23)))))))))))))))
   else if (((l__50 = (( 128 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> (\<lambda> (comparevalue :: 128 bits) . 
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> (\<lambda> (newvalue :: 128 bits) . 
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> (\<lambda> (data :: 128 bits) . 
     (aget_X (( 128 :: int)::ii) s  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__24 ::  128 Word.word) . 
     (let comparevalue = w__24 in
     (aget_X (( 128 :: int)::ii) t  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__25 ::  128 Word.word) . 
     (let newvalue = w__25 in
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (aget_Mem address (((( 128 :: int)::ii) div (( 8 :: int)::ii))) ldacctype  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__28 ::
        128 Word.word) . 
     (let data = w__28 in
     ((if (((data = comparevalue))) then
        aset_Mem address (((( 128 :: int)::ii) div (( 8 :: int)::ii))) stacctype newvalue
      else return () ) \<then>
     (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M)) \<bind> (\<lambda> (w__29 ::
       ( 'regsize::len)Word.word) . 
     aset_X s w__29)))))))))))))))
   else
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int ((l__50 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))))"


(*val aarch64_memory_atomicops_cas_pair : forall 'regsize. Size 'regsize => ii -> AccType -> ii -> itself 'regsize -> ii -> AccType -> ii -> M unit*)

definition aarch64_memory_atomicops_cas_pair  :: " int \<Rightarrow> AccType \<Rightarrow> int \<Rightarrow>('regsize::len)itself \<Rightarrow> int \<Rightarrow> AccType \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_memory_atomicops_cas_pair l__45 ldacctype n regsize s stacctype t = (
   if (((l__45 = (( 8 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (comparevalue :: 16 bits) . 
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (newvalue :: 16 bits) . 
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (data :: 16 bits) . 
     (aget_X (( 8 :: int)::ii) s  :: ( 8 Word.word) M) \<bind> (\<lambda> (s1 :: 8 bits) . 
     (aget_X (( 8 :: int)::ii) ((s + (( 1 :: int)::ii)))  :: ( 8 Word.word) M) \<bind> (\<lambda> (s2 :: 8 bits) . 
     (aget_X (( 8 :: int)::ii) t  :: ( 8 Word.word) M) \<bind> (\<lambda> (t1 :: 8 bits) . 
     (aget_X (( 8 :: int)::ii) ((t + (( 1 :: int)::ii)))  :: ( 8 Word.word) M) \<bind> (\<lambda> (t2 :: 8 bits) . 
     BigEndian ()  \<bind> (\<lambda> (w__0 :: bool) . 
     (let comparevalue =
       (if w__0 then (concat_vec s1 s2  ::  16 Word.word)
       else (concat_vec s2 s1  ::  16 Word.word)) in
     BigEndian ()  \<bind> (\<lambda> (w__1 :: bool) . 
     (let newvalue =
       (if w__1 then (concat_vec t1 t2  ::  16 Word.word)
       else (concat_vec t2 t1  ::  16 Word.word)) in
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (aget_Mem address (((( 16 :: int)::ii) div (( 8 :: int)::ii))) ldacctype  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__4 ::
        16 Word.word) . 
     (let data = w__4 in
     ((if (((data = comparevalue))) then
        aset_Mem address (((( 16 :: int)::ii) div (( 8 :: int)::ii))) stacctype newvalue
      else return () ) \<then>
     BigEndian () ) \<bind> (\<lambda> (w__5 :: bool) . 
     if w__5 then
       (ZeroExtend__0 ((slice data (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word)) ((make_the_value regsize ))
         :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__6 :: ( 'regsize::len)Word.word) . 
       (aset_X s w__6 \<then>
       (ZeroExtend__0 ((slice data (( 0 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word)) ((make_the_value regsize ))
         :: (( 'regsize::len)Word.word) M)) \<bind> (\<lambda> (w__7 :: ( 'regsize::len)Word.word) . 
       aset_X ((s + (( 1 :: int)::ii))) w__7))
     else
       (ZeroExtend__0 ((slice data (( 0 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word)) ((make_the_value regsize ))
         :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__8 :: ( 'regsize::len)Word.word) . 
       (aset_X s w__8 \<then>
       (ZeroExtend__0 ((slice data (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word)) ((make_the_value regsize ))
         :: (( 'regsize::len)Word.word) M)) \<bind> (\<lambda> (w__9 :: ( 'regsize::len)Word.word) . 
       aset_X ((s + (( 1 :: int)::ii))) w__9)))))))))))))))))))))
   else if (((l__45 = (( 16 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (comparevalue :: 32 bits) . 
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (newvalue :: 32 bits) . 
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (data :: 32 bits) . 
     (aget_X (( 16 :: int)::ii) s  :: ( 16 Word.word) M) \<bind> (\<lambda> (s1 :: 16 bits) . 
     (aget_X (( 16 :: int)::ii) ((s + (( 1 :: int)::ii)))  :: ( 16 Word.word) M) \<bind> (\<lambda> (s2 :: 16 bits) . 
     (aget_X (( 16 :: int)::ii) t  :: ( 16 Word.word) M) \<bind> (\<lambda> (t1 :: 16 bits) . 
     (aget_X (( 16 :: int)::ii) ((t + (( 1 :: int)::ii)))  :: ( 16 Word.word) M) \<bind> (\<lambda> (t2 :: 16 bits) . 
     BigEndian ()  \<bind> (\<lambda> (w__10 :: bool) . 
     (let comparevalue =
       (if w__10 then (concat_vec s1 s2  ::  32 Word.word)
       else (concat_vec s2 s1  ::  32 Word.word)) in
     BigEndian ()  \<bind> (\<lambda> (w__11 :: bool) . 
     (let newvalue =
       (if w__11 then (concat_vec t1 t2  ::  32 Word.word)
       else (concat_vec t2 t1  ::  32 Word.word)) in
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (aget_Mem address (((( 32 :: int)::ii) div (( 8 :: int)::ii))) ldacctype  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__14 ::
        32 Word.word) . 
     (let data = w__14 in
     ((if (((data = comparevalue))) then
        aset_Mem address (((( 32 :: int)::ii) div (( 8 :: int)::ii))) stacctype newvalue
      else return () ) \<then>
     BigEndian () ) \<bind> (\<lambda> (w__15 :: bool) . 
     if w__15 then
       (ZeroExtend__0 ((slice data (( 16 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)) ((make_the_value regsize ))
         :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__16 :: ( 'regsize::len)Word.word) . 
       (aset_X s w__16 \<then>
       (ZeroExtend__0 ((slice data (( 0 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)) ((make_the_value regsize ))
         :: (( 'regsize::len)Word.word) M)) \<bind> (\<lambda> (w__17 :: ( 'regsize::len)Word.word) . 
       aset_X ((s + (( 1 :: int)::ii))) w__17))
     else
       (ZeroExtend__0 ((slice data (( 0 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)) ((make_the_value regsize ))
         :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__18 :: ( 'regsize::len)Word.word) . 
       (aset_X s w__18 \<then>
       (ZeroExtend__0 ((slice data (( 16 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)) ((make_the_value regsize ))
         :: (( 'regsize::len)Word.word) M)) \<bind> (\<lambda> (w__19 :: ( 'regsize::len)Word.word) . 
       aset_X ((s + (( 1 :: int)::ii))) w__19)))))))))))))))))))))
   else if (((l__45 = (( 32 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (comparevalue :: 64 bits) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (newvalue :: 64 bits) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (data :: 64 bits) . 
     (aget_X (( 32 :: int)::ii) s  :: ( 32 Word.word) M) \<bind> (\<lambda> (s1 :: 32 bits) . 
     (aget_X (( 32 :: int)::ii) ((s + (( 1 :: int)::ii)))  :: ( 32 Word.word) M) \<bind> (\<lambda> (s2 :: 32 bits) . 
     (aget_X (( 32 :: int)::ii) t  :: ( 32 Word.word) M) \<bind> (\<lambda> (t1 :: 32 bits) . 
     (aget_X (( 32 :: int)::ii) ((t + (( 1 :: int)::ii)))  :: ( 32 Word.word) M) \<bind> (\<lambda> (t2 :: 32 bits) . 
     BigEndian ()  \<bind> (\<lambda> (w__20 :: bool) . 
     (let comparevalue =
       (if w__20 then (concat_vec s1 s2  ::  64 Word.word)
       else (concat_vec s2 s1  ::  64 Word.word)) in
     BigEndian ()  \<bind> (\<lambda> (w__21 :: bool) . 
     (let newvalue =
       (if w__21 then (concat_vec t1 t2  ::  64 Word.word)
       else (concat_vec t2 t1  ::  64 Word.word)) in
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (aget_Mem address (((( 64 :: int)::ii) div (( 8 :: int)::ii))) ldacctype  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__24 ::
        64 Word.word) . 
     (let data = w__24 in
     ((if (((data = comparevalue))) then
        aset_Mem address (((( 64 :: int)::ii) div (( 8 :: int)::ii))) stacctype newvalue
      else return () ) \<then>
     BigEndian () ) \<bind> (\<lambda> (w__25 :: bool) . 
     if w__25 then
       (ZeroExtend__0 ((slice data (( 32 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) ((make_the_value regsize ))
         :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__26 :: ( 'regsize::len)Word.word) . 
       (aset_X s w__26 \<then>
       (ZeroExtend__0 ((slice data (( 0 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) ((make_the_value regsize ))
         :: (( 'regsize::len)Word.word) M)) \<bind> (\<lambda> (w__27 :: ( 'regsize::len)Word.word) . 
       aset_X ((s + (( 1 :: int)::ii))) w__27))
     else
       (ZeroExtend__0 ((slice data (( 0 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) ((make_the_value regsize ))
         :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__28 :: ( 'regsize::len)Word.word) . 
       (aset_X s w__28 \<then>
       (ZeroExtend__0 ((slice data (( 32 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) ((make_the_value regsize ))
         :: (( 'regsize::len)Word.word) M)) \<bind> (\<lambda> (w__29 :: ( 'regsize::len)Word.word) . 
       aset_X ((s + (( 1 :: int)::ii))) w__29)))))))))))))))))))))
   else if (((l__45 = (( 64 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> (\<lambda> (comparevalue :: 128 bits) . 
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> (\<lambda> (newvalue :: 128 bits) . 
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> (\<lambda> (data :: 128 bits) . 
     (aget_X (( 64 :: int)::ii) s  :: ( 64 Word.word) M) \<bind> (\<lambda> (s1 :: 64 bits) . 
     (aget_X (( 64 :: int)::ii) ((s + (( 1 :: int)::ii)))  :: ( 64 Word.word) M) \<bind> (\<lambda> (s2 :: 64 bits) . 
     (aget_X (( 64 :: int)::ii) t  :: ( 64 Word.word) M) \<bind> (\<lambda> (t1 :: 64 bits) . 
     (aget_X (( 64 :: int)::ii) ((t + (( 1 :: int)::ii)))  :: ( 64 Word.word) M) \<bind> (\<lambda> (t2 :: 64 bits) . 
     BigEndian ()  \<bind> (\<lambda> (w__30 :: bool) . 
     (let comparevalue =
       (if w__30 then (concat_vec s1 s2  ::  128 Word.word)
       else (concat_vec s2 s1  ::  128 Word.word)) in
     BigEndian ()  \<bind> (\<lambda> (w__31 :: bool) . 
     (let newvalue =
       (if w__31 then (concat_vec t1 t2  ::  128 Word.word)
       else (concat_vec t2 t1  ::  128 Word.word)) in
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (aget_Mem address (((( 128 :: int)::ii) div (( 8 :: int)::ii))) ldacctype  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__34 ::
        128 Word.word) . 
     (let data = w__34 in
     ((if (((data = comparevalue))) then
        aset_Mem address (((( 128 :: int)::ii) div (( 8 :: int)::ii))) stacctype newvalue
      else return () ) \<then>
     BigEndian () ) \<bind> (\<lambda> (w__35 :: bool) . 
     if w__35 then
       (ZeroExtend__0 ((slice data (( 64 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word)) ((make_the_value regsize ))
         :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__36 :: ( 'regsize::len)Word.word) . 
       (aset_X s w__36 \<then>
       (ZeroExtend__0 ((slice data (( 0 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word)) ((make_the_value regsize ))
         :: (( 'regsize::len)Word.word) M)) \<bind> (\<lambda> (w__37 :: ( 'regsize::len)Word.word) . 
       aset_X ((s + (( 1 :: int)::ii))) w__37))
     else
       (ZeroExtend__0 ((slice data (( 0 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word)) ((make_the_value regsize ))
         :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__38 :: ( 'regsize::len)Word.word) . 
       (aset_X s w__38 \<then>
       (ZeroExtend__0 ((slice data (( 64 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word)) ((make_the_value regsize ))
         :: (( 'regsize::len)Word.word) M)) \<bind> (\<lambda> (w__39 :: ( 'regsize::len)Word.word) . 
       aset_X ((s + (( 1 :: int)::ii))) w__39)))))))))))))))))))))
   else if (((l__45 = (( 128 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 256 :: int)::ii)  :: ( 256 Word.word) M) \<bind> (\<lambda> (comparevalue :: 256 bits) . 
     (undefined_bitvector (( 256 :: int)::ii)  :: ( 256 Word.word) M) \<bind> (\<lambda> (newvalue :: 256 bits) . 
     (undefined_bitvector (( 256 :: int)::ii)  :: ( 256 Word.word) M) \<bind> (\<lambda> (data :: 256 bits) . 
     (aget_X (( 128 :: int)::ii) s  :: ( 128 Word.word) M) \<bind> (\<lambda> (s1 :: 128 bits) . 
     (aget_X (( 128 :: int)::ii) ((s + (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> (\<lambda> (s2 :: 128 bits) . 
     (aget_X (( 128 :: int)::ii) t  :: ( 128 Word.word) M) \<bind> (\<lambda> (t1 :: 128 bits) . 
     (aget_X (( 128 :: int)::ii) ((t + (( 1 :: int)::ii)))  :: ( 128 Word.word) M) \<bind> (\<lambda> (t2 :: 128 bits) . 
     BigEndian ()  \<bind> (\<lambda> (w__40 :: bool) . 
     (let comparevalue =
       (if w__40 then (concat_vec s1 s2  ::  256 Word.word)
       else (concat_vec s2 s1  ::  256 Word.word)) in
     BigEndian ()  \<bind> (\<lambda> (w__41 :: bool) . 
     (let newvalue =
       (if w__41 then (concat_vec t1 t2  ::  256 Word.word)
       else (concat_vec t2 t1  ::  256 Word.word)) in
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (aget_Mem address (((( 256 :: int)::ii) div (( 8 :: int)::ii))) ldacctype  :: ( 256 Word.word) M) \<bind> (\<lambda> (w__44 ::
        256 Word.word) . 
     (let data = w__44 in
     ((if (((data = comparevalue))) then
        aset_Mem address (((( 256 :: int)::ii) div (( 8 :: int)::ii))) stacctype newvalue
      else return () ) \<then>
     BigEndian () ) \<bind> (\<lambda> (w__45 :: bool) . 
     if w__45 then
       (ZeroExtend__0 ((slice data (( 128 :: int)::ii) (( 128 :: int)::ii)  ::  128 Word.word)) ((make_the_value regsize ))
         :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__46 :: ( 'regsize::len)Word.word) . 
       (aset_X s w__46 \<then>
       (ZeroExtend__0 ((slice data (( 0 :: int)::ii) (( 128 :: int)::ii)  ::  128 Word.word)) ((make_the_value regsize ))
         :: (( 'regsize::len)Word.word) M)) \<bind> (\<lambda> (w__47 :: ( 'regsize::len)Word.word) . 
       aset_X ((s + (( 1 :: int)::ii))) w__47))
     else
       (ZeroExtend__0 ((slice data (( 0 :: int)::ii) (( 128 :: int)::ii)  ::  128 Word.word)) ((make_the_value regsize ))
         :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__48 :: ( 'regsize::len)Word.word) . 
       (aset_X s w__48 \<then>
       (ZeroExtend__0 ((slice data (( 128 :: int)::ii) (( 128 :: int)::ii)  ::  128 Word.word)) ((make_the_value regsize ))
         :: (( 'regsize::len)Word.word) M)) \<bind> (\<lambda> (w__49 :: ( 'regsize::len)Word.word) . 
       aset_X ((s + (( 1 :: int)::ii))) w__49)))))))))))))))))))))
   else
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int ((l__45 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))))"


(*val AArch64_SetExclusiveMonitors : mword ty64 -> ii -> M unit*)

definition AArch64_SetExclusiveMonitors  :: "(64)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_SetExclusiveMonitors address size1 = (
   (let (acctype :: AccType) = AccType_ATOMIC in
   (let (iswrite :: bool) = False in
   (let (aligned :: bool) = (address \<noteq> ((Align__1 address size1  ::  64 Word.word))) in
   AArch64_TranslateAddress address acctype iswrite aligned size1 \<bind> (\<lambda> (memaddrdesc ::
     AddressDescriptor) . 
   (let (_ :: unit) = (if ((IsFault memaddrdesc)) then ()  else () ) in
   ((if(MemoryAttributes_shareable  (AddressDescriptor_memattrs   memaddrdesc)) then
      MarkExclusiveGlobal(AddressDescriptor_paddress   memaddrdesc) ((ProcessorID () )) size1
    else return () ) \<then>
   MarkExclusiveLocal(AddressDescriptor_paddress   memaddrdesc) ((ProcessorID () )) size1) \<then>
   AArch64_MarkExclusiveVA address ((ProcessorID () )) size1))))))"


(*val AArch64_ExclusiveMonitorsPass : mword ty64 -> ii -> M bool*)

definition AArch64_ExclusiveMonitorsPass  :: "(64)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " AArch64_ExclusiveMonitorsPass address size1 = (
   (let (acctype :: AccType) = AccType_ATOMIC in
   (let (iswrite :: bool) = True in
   (let (aligned :: bool) = (address = ((Align__1 address size1  ::  64 Word.word))) in
   undefined_bool ()  \<bind> (\<lambda> (secondstage :: bool) . 
   ((if ((\<not> aligned)) then
      (let secondstage = False in
      AArch64_AlignmentFault acctype iswrite secondstage \<bind> (\<lambda> (w__0 :: FaultRecord) . 
      AArch64_Abort address w__0))
    else return () ) \<then>
   AArch64_IsExclusiveVA address ((ProcessorID () )) size1) \<bind> (\<lambda> (passed :: bool) . 
   if ((\<not> passed)) then return False
   else
     AArch64_TranslateAddress address acctype iswrite aligned size1 \<bind> (\<lambda> (memaddrdesc ::
       AddressDescriptor) . 
     ((if ((IsFault memaddrdesc)) then AArch64_Abort address(AddressDescriptor_fault   memaddrdesc)
      else return () ) \<then>
     IsExclusiveLocal(AddressDescriptor_paddress   memaddrdesc) ((ProcessorID () )) size1) \<bind> (\<lambda> (w__1 ::
       bool) . 
     (let passed = w__1 in
     if passed then
       ClearExclusiveLocal ((ProcessorID () )) \<then>
       (if(MemoryAttributes_shareable  (AddressDescriptor_memattrs   memaddrdesc)) then
         IsExclusiveGlobal(AddressDescriptor_paddress   memaddrdesc) ((ProcessorID () )) size1
       else return passed)
     else return passed)))))))))"


(*val AArch32_SelfHostedSecurePrivilegedInvasiveDebugEnabled : unit -> M bool*)

definition AArch32_SelfHostedSecurePrivilegedInvasiveDebugEnabled  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " AArch32_SelfHostedSecurePrivilegedInvasiveDebugEnabled _ = (
   and_boolM (return ((\<not> ((HaveEL EL3)))))
     (IsSecure ()  \<bind> (\<lambda> (w__0 :: bool) .  return ((\<not> w__0)))) \<bind> (\<lambda> (w__1 :: bool) . 
   if w__1 then return False
   else
     and_boolM (read_reg DBGEN_ref \<bind> (\<lambda> (w__2 :: signal) .  return (((w__2 = HIGH)))))
       (read_reg SPIDEN_ref \<bind> (\<lambda> (w__3 :: signal) .  return (((w__3 = HIGH)))))))"


(*val AArch32_GenerateDebugExceptionsFrom : mword ty2 -> bool -> M bool*)

definition AArch32_GenerateDebugExceptionsFrom  :: "(2)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " AArch32_GenerateDebugExceptionsFrom from1 secure = (
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (mask1 :: 1 bits) . 
   and_boolM (return (((from1 = EL0))))
     (ELStateUsingAArch32 EL1 secure \<bind> (\<lambda> (w__0 :: bool) .  return ((\<not> w__0)))) \<bind> (\<lambda> (w__1 ::
     bool) . 
   if w__1 then
     (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__2 ::  1 Word.word) . 
     (let mask1 = w__2 in
     AArch64_GenerateDebugExceptionsFrom from1 secure mask1))
   else
     or_boolM
       (or_boolM
          ((read_reg DBGOSLSR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__4 :: 32 bits) . 
           return ((((vec_of_bits [access_vec_dec w__4 (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) ((DoubleLockStatus () ))) ((Halted () )) \<bind> (\<lambda> (w__8 ::
       bool) . 
     if w__8 then return False
     else
       undefined_bool ()  \<bind> (\<lambda> (enabled :: bool) . 
       (undefined_bitvector (( 2 :: int)::ii)  :: ( 2 Word.word) M) \<bind> (\<lambda> (spd :: 2 bits) . 
       if (((((HaveEL EL3)) \<and> secure))) then
         ELUsingAArch32 EL3 \<bind> (\<lambda> (w__9 :: bool) . 
         (if w__9 then
            (read_reg SDCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__10 :: 32 bits) . 
            return ((slice w__10 (( 14 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)))
          else
            (read_reg MDCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__11 :: 32 bits) . 
            return ((slice w__11 (( 14 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)))) \<bind> (\<lambda> (w__12 ::  2 Word.word) . 
         (let spd = w__12 in
         (if ((((vec_of_bits [access_vec_dec spd (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
            (let (enabled :: bool) =
              ((vec_of_bits [access_vec_dec spd (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
            return enabled)
          else AArch32_SelfHostedSecurePrivilegedInvasiveDebugEnabled () ) \<bind> (\<lambda> (enabled :: bool) . 
         if (((from1 = EL0))) then
           or_boolM (return enabled)
             ((read_reg SDER_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__14 :: 32 bits) . 
              return ((((vec_of_bits [access_vec_dec w__14 (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))
         else return enabled))))
       else
         (let (enabled :: bool) = (from1 \<noteq> EL2) in
         return enabled)))))))"


(*val AArch32_GenerateDebugExceptions : unit -> M bool*)

definition AArch32_GenerateDebugExceptions  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " AArch32_GenerateDebugExceptions _ = (
   read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) . 
   IsSecure ()  \<bind> (\<lambda> (w__1 :: bool) .  AArch32_GenerateDebugExceptionsFrom(ProcState_EL   w__0) w__1)))"


(*val DebugExceptionReturnSS : mword ty32 -> M (mword ty1)*)

definition DebugExceptionReturnSS  :: "(32)Word.word \<Rightarrow>((register_value),((1)Word.word),(exception))monad "  where 
     " DebugExceptionReturnSS spsr = (
   or_boolM (or_boolM ((Halted () )) ((Restarting () )))
     (read_reg PSTATE_ref \<bind> (\<lambda> (w__3 :: ProcState) .  return ((((ProcState_EL   w__3) \<noteq> EL0))))) \<bind> (\<lambda> (w__4 ::
     bool) . 
   assert_exp w__4 (''((Halted() || Restarting()) || ((PSTATE).EL != EL0))'') \<then>
   ((let (SS_bit :: 1 bits) = ((vec_of_bits [B0]  ::  1 Word.word)) in
   (undefined_bitvector (( 2 :: int)::ii)  :: ( 2 Word.word) M) \<bind> (\<lambda> (ELd :: 2 bits) . 
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M) \<bind> (\<lambda> (mask1 :: 1 bits) . 
   undefined_bool ()  \<bind> (\<lambda> (enabled_at_dest :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (secure :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (valid_name :: bool) . 
   (undefined_bitvector (( 2 :: int)::ii)  :: ( 2 Word.word) M) \<bind> (\<lambda> (dest :: 2 bits) . 
   undefined_bool ()  \<bind> (\<lambda> (enabled_at_source :: bool) . 
   (read_reg MDSCR_EL1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__5 :: 32 bits) . 
   if ((((vec_of_bits [access_vec_dec w__5 (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
     Restarting ()  \<bind> (\<lambda> (w__6 :: bool) . 
     (if w__6 then return False
      else
        UsingAArch32 ()  \<bind> (\<lambda> (w__7 :: bool) . 
        if w__7 then AArch32_GenerateDebugExceptions () 
        else AArch64_GenerateDebugExceptions () )) \<bind> (\<lambda> (enabled_at_source :: bool) . 
     IllegalExceptionReturn spsr \<bind> (\<lambda> (w__10 :: bool) . 
     (if w__10 then
        read_reg PSTATE_ref \<bind> (\<lambda> (w__11 :: ProcState) . 
        (let (dest :: 2 bits) = ((ProcState_EL   w__11)) in
        return dest))
      else
        (ELFromSPSR spsr  :: ((bool *  2 Word.word)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1) = varstup in
        (let valid_name = tup__0 in
        (let dest = tup__1 in
        assert_exp valid_name (''valid'') \<then> return dest))))) \<bind> (\<lambda> (dest :: 2 bits) . 
     or_boolM ((IsSecureBelowEL3 () )) (return (((dest = EL3)))) \<bind> (\<lambda> (w__13 :: bool) . 
     (let secure = w__13 in
     ELUsingAArch32 dest \<bind> (\<lambda> (w__14 :: bool) . 
     (if w__14 then AArch32_GenerateDebugExceptionsFrom dest secure
      else
        (let mask1 = ((vec_of_bits [access_vec_dec spsr (( 9 :: int)::ii)]  ::  1 Word.word)) in
        AArch64_GenerateDebugExceptionsFrom dest secure mask1)) \<bind> (\<lambda> (enabled_at_dest :: bool) . 
     (DebugTargetFrom secure  :: ( 2 Word.word) M) \<bind> (\<lambda> (w__17 ::  2 Word.word) . 
     (let ELd = w__17 in
     and_boolM
       (and_boolM (ELUsingAArch32 ELd \<bind> (\<lambda> (w__18 :: bool) .  return ((\<not> w__18))))
          (return ((\<not> enabled_at_source)))) (return enabled_at_dest) \<bind> (\<lambda> (w__20 :: bool) . 
     (let (SS_bit :: 1 bits) =
       (if w__20 then (vec_of_bits [access_vec_dec spsr (( 21 :: int)::ii)]  ::  1 Word.word)
       else SS_bit) in
     return SS_bit))))))))))))
   else return SS_bit))))))))))))"


(*val SetPSTATEFromPSR : mword ty32 -> M unit*)

definition SetPSTATEFromPSR  :: "(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " SetPSTATEFromPSR spsr__arg = (
   (let spsr = spsr__arg in
   read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) . 
   (DebugExceptionReturnSS spsr  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__1 ::  1 Word.word) . 
   (write_reg PSTATE_ref (w__0 (| ProcState_SS := w__1 |)) \<then>
   IllegalExceptionReturn spsr) \<bind> (\<lambda> (w__2 :: bool) . 
   ((if w__2 then
      read_reg PSTATE_ref \<bind> (\<lambda> (w__3 :: ProcState) . 
      write_reg PSTATE_ref (w__3 (| ProcState_IL := ((vec_of_bits [B1]  ::  1 Word.word))|)))
    else
      read_reg PSTATE_ref \<bind> (\<lambda> (w__4 :: ProcState) . 
      write_reg
        PSTATE_ref
        (w__4 (| ProcState_IL := ((vec_of_bits [access_vec_dec spsr (( 20 :: int)::ii)]  ::  1 Word.word))|)) \<then>
      (if ((((vec_of_bits [access_vec_dec spsr (( 4 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
        AArch32_WriteMode ((slice spsr (( 0 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word))
      else
        read_reg PSTATE_ref \<bind> (\<lambda> (w__5 :: ProcState) . 
        (write_reg PSTATE_ref (w__5 (| ProcState_nRW := ((vec_of_bits [B0]  ::  1 Word.word))|)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__6 :: ProcState) . 
        (write_reg PSTATE_ref (w__6 (| ProcState_EL := ((slice spsr (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))|)) \<then>
        read_reg PSTATE_ref) \<bind> (\<lambda> (w__7 :: ProcState) . 
        write_reg
          PSTATE_ref
          (w__7 (| ProcState_SP := ((vec_of_bits [access_vec_dec spsr (( 0 :: int)::ii)]  ::  1 Word.word))|)))))))) \<then>
   and_boolM
     (read_reg PSTATE_ref \<bind> (\<lambda> (w__8 :: ProcState) . 
      return ((((ProcState_IL   w__8) = (vec_of_bits [B1]  ::  1 Word.word))))))
     (read_reg PSTATE_ref \<bind> (\<lambda> (w__9 :: ProcState) . 
      return ((((ProcState_nRW   w__9) = (vec_of_bits [B1]  ::  1 Word.word))))))) \<bind> (\<lambda> (w__10 :: bool) . 
   (if w__10 then
      ConstrainUnpredictableBool Unpredictable_ILZEROT \<bind> (\<lambda> (w__11 :: bool) . 
      (let (spsr ::  32 Word.word) =
        (if w__11 then
          (set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) spsr (( 5 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word)
        else spsr) in
      return spsr))
    else return spsr) \<bind> (\<lambda> (spsr ::  32 Word.word) . 
   (let split_vec = ((slice spsr (( 28 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) in
   (let (tup__0, tup__1, tup__2, tup__3) =
     ((subrange_vec_dec split_vec (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
      (subrange_vec_dec split_vec (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
      (subrange_vec_dec split_vec (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
      (subrange_vec_dec split_vec (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
   read_reg PSTATE_ref \<bind> (\<lambda> (w__12 :: ProcState) . 
   (write_reg PSTATE_ref (w__12 (| ProcState_N := tup__0 |)) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__13 :: ProcState) . 
   (write_reg PSTATE_ref (w__13 (| ProcState_Z := tup__1 |)) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__14 :: ProcState) . 
   (write_reg PSTATE_ref (w__14 (| ProcState_C := tup__2 |)) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__15 :: ProcState) . 
   (write_reg PSTATE_ref (w__15 (| ProcState_V := tup__3 |)) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__16 :: ProcState) . 
   ((if ((((ProcState_nRW   w__16) = (vec_of_bits [B1]  ::  1 Word.word)))) then
      read_reg PSTATE_ref \<bind> (\<lambda> (w__17 :: ProcState) . 
      (write_reg
        PSTATE_ref
        (w__17 (| ProcState_Q := ((vec_of_bits [access_vec_dec spsr (( 27 :: int)::ii)]  ::  1 Word.word))|)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__18 :: ProcState) . 
      (RestoredITBits spsr  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__19 ::  8 Word.word) . 
      (write_reg PSTATE_ref (w__18 (| ProcState_IT := w__19 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__20 :: ProcState) . 
      (write_reg PSTATE_ref (w__20 (| ProcState_GE := ((slice spsr (( 16 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word))|)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__21 :: ProcState) . 
      write_reg
        PSTATE_ref
        (w__21 (| ProcState_E := ((vec_of_bits [access_vec_dec spsr (( 9 :: int)::ii)]  ::  1 Word.word))|)) \<then>
      ((let split_vec = ((slice spsr (( 6 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) in
      (let (tup__0, tup__1, tup__2) =
        ((subrange_vec_dec split_vec (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
      read_reg PSTATE_ref \<bind> (\<lambda> (w__22 :: ProcState) . 
      (write_reg PSTATE_ref (w__22 (| ProcState_A := tup__0 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__23 :: ProcState) . 
      (write_reg PSTATE_ref (w__23 (| ProcState_I := tup__1 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__24 :: ProcState) . 
      (write_reg PSTATE_ref (w__24 (| ProcState_F := tup__2 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__25 :: ProcState) . 
      write_reg
        PSTATE_ref
        (w__25 (| ProcState_T := ((vec_of_bits [access_vec_dec spsr (( 5 :: int)::ii)]  ::  1 Word.word))|))))))))))))))
    else
      (let split_vec = ((slice spsr (( 6 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) in
      (let (tup__0, tup__1, tup__2, tup__3) =
        ((subrange_vec_dec split_vec (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
      read_reg PSTATE_ref \<bind> (\<lambda> (w__26 :: ProcState) . 
      (write_reg PSTATE_ref (w__26 (| ProcState_D := tup__0 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__27 :: ProcState) . 
      (write_reg PSTATE_ref (w__27 (| ProcState_A := tup__1 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__28 :: ProcState) . 
      (write_reg PSTATE_ref (w__28 (| ProcState_I := tup__2 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__29 :: ProcState) . 
      write_reg PSTATE_ref (w__29 (| ProcState_F := tup__3 |))))))))) \<then>
   (if ((HavePANExt () )) then
      read_reg PSTATE_ref \<bind> (\<lambda> (w__30 :: ProcState) . 
      write_reg
        PSTATE_ref
        (w__30 (| ProcState_PAN := ((vec_of_bits [access_vec_dec spsr (( 22 :: int)::ii)]  ::  1 Word.word))|)))
    else return () )) \<then>
   (if ((HaveUAOExt () )) then
     read_reg PSTATE_ref \<bind> (\<lambda> (w__31 :: ProcState) . 
     write_reg
       PSTATE_ref
       (w__31 (| ProcState_UAO := ((vec_of_bits [access_vec_dec spsr (( 23 :: int)::ii)]  ::  1 Word.word))|)))
   else return () )))))))))))))))"


(*val DRPSInstruction : unit -> M unit*)

definition DRPSInstruction  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " DRPSInstruction _ = (
   (let (_ :: unit) = (SynchronizeContext () ) in
   and_boolM
     (and_boolM (return ((HaveRASExt () )))
        ((aget_SCTLR__1 ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 ::  32 Word.word) . 
         return ((((vec_of_bits [access_vec_dec w__0 (( 21 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
     ((ConstrainUnpredictableBool Unpredictable_IESBinDebug)) \<bind> (\<lambda> (w__3 :: bool) . 
   (let (_ :: unit) =
     (if w__3 then ErrorSynchronizationBarrier MBReqDomain_FullSystem MBReqTypes_All
     else () ) in
   (aget_SPSR ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__4 ::  32 Word.word) . 
   (SetPSTATEFromPSR w__4 \<then>
   UsingAArch32 () ) \<bind> (\<lambda> (w__5 :: bool) . 
   (if w__5 then
      (undefined_bitvector (( 13 :: int)::ii)  :: ( 13 Word.word) M) \<bind> (\<lambda> (w__6 ::  13 Word.word) . 
      (let split_vec = w__6 in
      (let (tup__0, tup__1, tup__2, tup__3, tup__4, tup__5, tup__6, tup__7, tup__8, tup__9) =
        ((subrange_vec_dec split_vec (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 11 :: int)::ii) (( 11 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 10 :: int)::ii) (( 10 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 9 :: int)::ii) (( 9 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 7 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word),
         (subrange_vec_dec split_vec (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
      read_reg PSTATE_ref \<bind> (\<lambda> (w__7 :: ProcState) . 
      (write_reg PSTATE_ref (w__7 (| ProcState_N := tup__0 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__8 :: ProcState) . 
      (write_reg PSTATE_ref (w__8 (| ProcState_Z := tup__1 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__9 :: ProcState) . 
      (write_reg PSTATE_ref (w__9 (| ProcState_C := tup__2 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__10 :: ProcState) . 
      (write_reg PSTATE_ref (w__10 (| ProcState_V := tup__3 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__11 :: ProcState) . 
      (write_reg PSTATE_ref (w__11 (| ProcState_Q := tup__4 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__12 :: ProcState) . 
      (write_reg PSTATE_ref (w__12 (| ProcState_GE := tup__5 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__13 :: ProcState) . 
      (write_reg PSTATE_ref (w__13 (| ProcState_SS := tup__6 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__14 :: ProcState) . 
      (write_reg PSTATE_ref (w__14 (| ProcState_A := tup__7 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__15 :: ProcState) . 
      (write_reg PSTATE_ref (w__15 (| ProcState_I := tup__8 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__16 :: ProcState) . 
      (write_reg PSTATE_ref (w__16 (| ProcState_F := tup__9 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__17 :: ProcState) . 
      (write_reg
        PSTATE_ref
        (w__17 (| ProcState_IT := ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word))|)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__18 :: ProcState) . 
      (write_reg PSTATE_ref (w__18 (| ProcState_T := ((vec_of_bits [B1]  ::  1 Word.word))|)) \<then>
      (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__19 ::  32 Word.word) . 
      (write_reg DLR_ref w__19 \<then>
      (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__20 ::  32 Word.word) . 
      write_reg DSPSR_ref w__20)))))))))))))))))
    else
      (undefined_bitvector (( 9 :: int)::ii)  :: ( 9 Word.word) M) \<bind> (\<lambda> (w__21 ::  9 Word.word) . 
      (let split_vec = w__21 in
      (let (tup__0, tup__1, tup__2, tup__3, tup__4, tup__5, tup__6, tup__7, tup__8) =
        ((subrange_vec_dec split_vec (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word),
         (subrange_vec_dec split_vec (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
      read_reg PSTATE_ref \<bind> (\<lambda> (w__22 :: ProcState) . 
      (write_reg PSTATE_ref (w__22 (| ProcState_N := tup__0 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__23 :: ProcState) . 
      (write_reg PSTATE_ref (w__23 (| ProcState_Z := tup__1 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__24 :: ProcState) . 
      (write_reg PSTATE_ref (w__24 (| ProcState_C := tup__2 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__25 :: ProcState) . 
      (write_reg PSTATE_ref (w__25 (| ProcState_V := tup__3 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__26 :: ProcState) . 
      (write_reg PSTATE_ref (w__26 (| ProcState_SS := tup__4 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__27 :: ProcState) . 
      (write_reg PSTATE_ref (w__27 (| ProcState_D := tup__5 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__28 :: ProcState) . 
      (write_reg PSTATE_ref (w__28 (| ProcState_A := tup__6 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__29 :: ProcState) . 
      (write_reg PSTATE_ref (w__29 (| ProcState_I := tup__7 |)) \<then>
      read_reg PSTATE_ref) \<bind> (\<lambda> (w__30 :: ProcState) . 
      (write_reg PSTATE_ref (w__30 (| ProcState_F := tup__8 |)) \<then>
      (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__31 ::  64 Word.word) . 
      (write_reg DLR_EL0_ref w__31 \<then>
      (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__32 ::  32 Word.word) . 
      write_reg DSPSR_EL0_ref w__32))))))))))))))) \<then>
   UpdateEDSCRFields () ))))))"


(*val aarch64_branch_unconditional_dret : unit -> M unit*)

definition aarch64_branch_unconditional_dret  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_branch_unconditional_dret _ = ( DRPSInstruction ()  )"


(*val AArch64_ExceptionReturn : mword ty64 -> mword ty32 -> M unit*)

definition AArch64_ExceptionReturn  :: "(64)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_ExceptionReturn new_pc__arg spsr = (
   (let new_pc = new_pc__arg in
   (let (_ :: unit) = (SynchronizeContext () ) in
   undefined_bool ()  \<bind> (\<lambda> (iesb_req :: bool) . 
   and_boolM (return ((HaveRASExt () )))
     ((aget_SCTLR__1 ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 ::  32 Word.word) . 
      return ((((vec_of_bits [access_vec_dec w__0 (( 21 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__1 :: bool) . 
   (((((if w__1 then
      (let (_ :: unit) = (ErrorSynchronizationBarrier MBReqDomain_FullSystem MBReqTypes_All) in
      (let iesb_req = True in
      TakeUnmaskedPhysicalSErrorInterrupts iesb_req))
    else return () ) \<then>
   SetPSTATEFromPSR spsr) \<then>
   ClearExclusiveLocal ((ProcessorID () ))) \<then>
   SendEventLocal () ) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__2 :: ProcState) . 
   (if ((((ProcState_IL   w__2) = (vec_of_bits [B1]  ::  1 Word.word)))) then
      (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__3 ::  32 Word.word) . 
      (let new_pc = ((set_slice (( 64 :: int)::ii) (( 32 :: int)::ii) new_pc (( 32 :: int)::ii) w__3  ::  64 Word.word)) in
      (undefined_bitvector (( 2 :: int)::ii)  :: ( 2 Word.word) M) \<bind> (\<lambda> (w__4 ::  2 Word.word) . 
      (let (new_pc ::  64 Word.word) = ((set_slice (( 64 :: int)::ii) (( 2 :: int)::ii) new_pc (( 0 :: int)::ii) w__4  ::  64 Word.word)) in
      return new_pc))))
    else
      UsingAArch32 ()  \<bind> (\<lambda> (w__5 :: bool) . 
      if w__5 then
        read_reg PSTATE_ref \<bind> (\<lambda> (w__6 :: ProcState) . 
        (let (new_pc ::  64 Word.word) =
          (if ((((ProcState_T   w__6) = (vec_of_bits [B0]  ::  1 Word.word)))) then
            (set_slice (( 64 :: int)::ii) (( 1 :: int)::ii) new_pc (( 0 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  64 Word.word)
          else
            (set_slice (( 64 :: int)::ii) (( 2 :: int)::ii) new_pc (( 0 :: int)::ii) (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  64 Word.word)) in
        return new_pc))
      else (AArch64_BranchAddr new_pc  :: ( 64 Word.word) M))) \<bind> (\<lambda> (new_pc ::  64 Word.word) . 
   UsingAArch32 ()  \<bind> (\<lambda> (w__8 :: bool) . 
   if w__8 then BranchTo ((slice new_pc (( 0 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) BranchType_UNKNOWN
   else BranchToAddr new_pc BranchType_ERET))))))))"


(*val aarch64_branch_unconditional_eret : bool -> bool -> M unit*)

definition aarch64_branch_unconditional_eret  :: " bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_branch_unconditional_eret pac use_key_a = (
   (AArch64_CheckForERetTrap pac use_key_a \<then>
   (aget_ELR__1 ()   :: ( 64 Word.word) M)) \<bind> (\<lambda> (target :: 64 bits) . 
   (if pac then
      if use_key_a then
        (aget_ELR__1 ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
        (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
        (AuthIA w__0 w__1  :: ( 64 Word.word) M)))
      else
        (aget_ELR__1 ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::  64 Word.word) . 
        (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 ::  64 Word.word) . 
        (AuthIB w__3 w__4  :: ( 64 Word.word) M)))
    else return target) \<bind> (\<lambda> (target :: 64 bits) . 
   (aget_SPSR ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__6 ::  32 Word.word) . 
   AArch64_ExceptionReturn target w__6))))"


(*val AArch32_GeneralExceptionsToAArch64 : unit -> M bool*)

definition AArch32_GeneralExceptionsToAArch64  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " AArch32_GeneralExceptionsToAArch64 _ = (
   or_boolM
     (and_boolM
        (read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) .  return ((((ProcState_EL   w__0) = EL0)))))
        (ELUsingAArch32 EL1 \<bind> (\<lambda> (w__1 :: bool) .  return ((\<not> w__1)))))
     (and_boolM
        (and_boolM
           (and_boolM (return ((HaveEL EL2)))
              (IsSecure ()  \<bind> (\<lambda> (w__3 :: bool) .  return ((\<not> w__3)))))
           (ELUsingAArch32 EL2 \<bind> (\<lambda> (w__5 :: bool) .  return ((\<not> w__5)))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__7 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__7 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))))"


(*val AArch32_EnterHypMode : ExceptionRecord -> mword ty32 -> ii -> M unit*)

definition AArch32_EnterHypMode  :: " ExceptionRecord \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch32_EnterHypMode exception preferred_exception_return vect_offset = (
   (let (_ :: unit) = (SynchronizeContext () ) in
   and_boolM
     (and_boolM (return ((HaveEL EL2))) (IsSecure ()  \<bind> (\<lambda> (w__0 :: bool) .  return ((\<not> w__0)))))
     ((ELUsingAArch32 EL2)) \<bind> (\<lambda> (w__3 :: bool) . 
   (assert_exp w__3 (''((HaveEL(EL2) && !(IsSecure())) && ELUsingAArch32(EL2))'') \<then>
   (GetPSRFromPSTATE ()   :: ( 32 Word.word) M)) \<bind> (\<lambda> (spsr :: 32 bits) . 
   (((((if ((\<not> (((((((ExceptionRecord_typ   exception) = Exception_IRQ))) \<or> ((((ExceptionRecord_typ   exception) = Exception_FIQ)))))))) then
      AArch32_ReportHypEntry exception
    else return () ) \<then>
   AArch32_WriteMode M32_Hyp) \<then>
   aset_SPSR spsr) \<then>
   write_reg ELR_hyp_ref preferred_exception_return) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__4 :: ProcState) . 
   (read_reg HSCTLR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__5 :: 32 bits) . 
   (write_reg
     PSTATE_ref
     (w__4 (| ProcState_T := ((vec_of_bits [access_vec_dec w__5 (( 30 :: int)::ii)]  ::  1 Word.word))|)) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__6 :: ProcState) . 
   (write_reg PSTATE_ref (w__6 (| ProcState_SS := ((vec_of_bits [B0]  ::  1 Word.word))|)) \<then>
   or_boolM (return ((\<not> ((HaveEL EL3)))))
     ((aget_SCR_GEN ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__7 ::  32 Word.word) . 
      return ((((vec_of_bits [access_vec_dec w__7 (( 3 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))) \<bind> (\<lambda> (w__8 :: bool) . 
   ((if w__8 then
      read_reg PSTATE_ref \<bind> (\<lambda> (w__9 :: ProcState) . 
      write_reg PSTATE_ref (w__9 (| ProcState_A := ((vec_of_bits [B1]  ::  1 Word.word))|)))
    else return () ) \<then>
   or_boolM (return ((\<not> ((HaveEL EL3)))))
     ((aget_SCR_GEN ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__10 ::  32 Word.word) . 
      return ((((vec_of_bits [access_vec_dec w__10 (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))) \<bind> (\<lambda> (w__11 :: bool) . 
   ((if w__11 then
      read_reg PSTATE_ref \<bind> (\<lambda> (w__12 :: ProcState) . 
      write_reg PSTATE_ref (w__12 (| ProcState_I := ((vec_of_bits [B1]  ::  1 Word.word))|)))
    else return () ) \<then>
   or_boolM (return ((\<not> ((HaveEL EL3)))))
     ((aget_SCR_GEN ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__13 ::  32 Word.word) . 
      return ((((vec_of_bits [access_vec_dec w__13 (( 2 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))) \<bind> (\<lambda> (w__14 :: bool) . 
   ((if w__14 then
      read_reg PSTATE_ref \<bind> (\<lambda> (w__15 :: ProcState) . 
      write_reg PSTATE_ref (w__15 (| ProcState_F := ((vec_of_bits [B1]  ::  1 Word.word))|)))
    else return () ) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__16 :: ProcState) . 
   (read_reg HSCTLR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__17 :: 32 bits) . 
   (write_reg
     PSTATE_ref
     (w__16 (| ProcState_E := ((vec_of_bits [access_vec_dec w__17 (( 25 :: int)::ii)]  ::  1 Word.word))|)) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__18 :: ProcState) . 
   (write_reg PSTATE_ref (w__18 (| ProcState_IL := ((vec_of_bits [B0]  ::  1 Word.word))|)) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__19 :: ProcState) . 
   (write_reg
     PSTATE_ref
     (w__19 (| ProcState_IT := ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word))|)) \<then>
   (read_reg HVBAR_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__20 :: 32 bits) . 
   BranchTo
     ((concat_vec ((slice w__20 (( 5 :: int)::ii) (( 27 :: int)::ii)  ::  27 Word.word))
         ((GetSlice_int ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) vect_offset (( 0 :: int)::ii)  ::  5 Word.word))
        ::  32 Word.word)) BranchType_UNKNOWN \<then>
   EndOfInstruction () )))))))))))))))"


(*val AArch32_TakeUndefInstrException__0 : unit -> M unit*)

(*val AArch32_TakeUndefInstrException__1 : ExceptionRecord -> M unit*)

definition AArch32_TakeUndefInstrException__1  :: " ExceptionRecord \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch32_TakeUndefInstrException__1 exception = (
   and_boolM
     (and_boolM
        (and_boolM (return ((HaveEL EL2)))
           (IsSecure ()  \<bind> (\<lambda> (w__0 :: bool) .  return ((\<not> w__0)))))
        (read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) .  return ((((ProcState_EL   w__2) = EL0))))))
     ((read_reg HCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__4 :: 32 bits) . 
      return ((((vec_of_bits [access_vec_dec w__4 (( 27 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (route_to_hyp :: bool) . 
   (ThisInstrAddr (( 32 :: int)::ii) ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (preferred_exception_return :: 32 bits) . 
   (let (vect_offset :: ii) = ((( 4 :: int)::ii)) in
   CurrentInstrSet ()  \<bind> (\<lambda> (w__5 :: InstrSet) . 
   (let (lr_offset :: ii) = (if (((w__5 = InstrSet_A32))) then (( 4 :: int)::ii) else (( 2 :: int)::ii)) in
   read_reg PSTATE_ref \<bind> (\<lambda> (w__6 :: ProcState) . 
   if ((((ProcState_EL   w__6) = EL2))) then
     AArch32_EnterHypMode exception preferred_exception_return vect_offset
   else if route_to_hyp then AArch32_EnterHypMode exception preferred_exception_return (( 20 :: int)::ii)
   else AArch32_EnterMode M32_Undef preferred_exception_return lr_offset vect_offset)))))))"


definition AArch32_TakeUndefInstrException__0  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch32_TakeUndefInstrException__0 _ = (
   ExceptionSyndrome Exception_Uncategorized \<bind> (\<lambda> (exception :: ExceptionRecord) . 
   AArch32_TakeUndefInstrException__1 exception))"


(*val UnallocatedEncoding : unit -> M unit*)

definition UnallocatedEncoding  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " UnallocatedEncoding _ = (
   and_boolM ((UsingAArch32 () )) ((AArch32_ExecutingCP10or11Instr () )) \<bind> (\<lambda> (w__2 :: bool) . 
   ((if w__2 then
      (read_reg FPEXC_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__3 :: 32 bits) . 
      write_reg
        FPEXC_ref
        ((set_slice (( 32 :: int)::ii) (( 1 :: int)::ii) w__3 (( 29 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word)))
    else return () ) \<then>
   and_boolM ((UsingAArch32 () ))
     (AArch32_GeneralExceptionsToAArch64 ()  \<bind> (\<lambda> (w__5 :: bool) .  return ((\<not> w__5))))) \<bind> (\<lambda> (w__6 ::
     bool) . 
   if w__6 then AArch32_TakeUndefInstrException__0 () 
   else AArch64_UndefinedFault () )))"


(*val aarch64_system_exceptions_runtime_hvc : mword ty16 -> M unit*)

definition aarch64_system_exceptions_runtime_hvc  :: "(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_system_exceptions_runtime_hvc imm = (
   or_boolM
     (or_boolM (return ((\<not> ((HaveEL EL2)))))
        (read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) .  return ((((ProcState_EL   w__0) = EL0))))))
     (and_boolM
        (read_reg PSTATE_ref \<bind> (\<lambda> (w__2 :: ProcState) .  return ((((ProcState_EL   w__2) = EL1)))))
        ((IsSecure () ))) \<bind> (\<lambda> (w__5 :: bool) . 
   ((if w__5 then UnallocatedEncoding () 
    else return () ) \<then>
   (if ((HaveEL EL3)) then
      (read_reg SCR_EL3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__6 :: 32 bits) . 
      return (vec_of_bits [access_vec_dec w__6 (( 8 :: int)::ii)]  ::  1 Word.word))
    else
      (read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__7 :: 64 bits) . 
      return ((not_vec (vec_of_bits [access_vec_dec w__7 (( 29 :: int)::ii)]  ::  1 Word.word)  ::  1 Word.word))))) \<bind> (\<lambda> (hvc_enable :: 1
     bits) . 
   if (((hvc_enable = (vec_of_bits [B0]  ::  1 Word.word)))) then AArch64_UndefinedFault () 
   else AArch64_CallHypervisor imm)))"


(*val system_exceptions_runtime_hvc_decode : mword ty3 -> mword ty16 -> mword ty3 -> mword ty2 -> M unit*)

definition system_exceptions_runtime_hvc_decode  :: "(3)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " system_exceptions_runtime_hvc_decode opc imm16 op2 LL = (
   write_reg unconditional_ref True \<then>
   ((let (imm :: 16 bits) = imm16 in
   aarch64_system_exceptions_runtime_hvc imm)))"


(*val aarch64_memory_single_general_register : forall 'regsize. Size 'regsize => AccType -> ii -> ExtendType -> ii -> MemOp -> ii -> bool -> itself 'regsize -> ii -> bool -> ii -> bool -> M unit*)

definition aarch64_memory_single_general_register  :: " AccType \<Rightarrow> int \<Rightarrow> ExtendType \<Rightarrow> int \<Rightarrow> MemOp \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>('regsize::len)itself \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_memory_single_general_register acctype l__40 extend_type m memop n postindex regsize shift signed t wback__arg = (
   if (((l__40 = (( 8 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let wback = wback__arg in
     (ExtendReg (( 64 :: int)::ii) m extend_type shift  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> (\<lambda> (data :: 8 bits) . 
     (let (wb_unknown :: bool) = False in
     (let (rt_unknown :: bool) = False in
     undefined_Constraint ()  \<bind> (\<lambda> (c :: Constraint) . 
     (if ((((((((((((memop = MemOp_LOAD))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_WBSUPPRESS in
        assert_exp ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \<or> (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) (''((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return wback) \<bind> (\<lambda> (wback :: bool) . 
     (if ((((((((((((memop = MemOp_STORE))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_NONE in
        assert_exp ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
     (if (((n = (( 31 :: int)::ii)))) then
        (if (((memop \<noteq> MemOp_PREFETCH))) then CheckSPAlignment () 
         else return () ) \<then>
        (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M)
         else (aget_X (( 8 :: int)::ii) t  :: ( 8 Word.word) M)) \<bind> (\<lambda> (data :: 8 bits) . 
        aset_Mem address (((( 8 :: int)::ii) div (( 8 :: int)::ii))) acctype data)
     | MemOp_LOAD =>
        (aget_Mem address (((( 8 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__4 ::
           8 Word.word) . 
        (let data = w__4 in
        if signed then
          (SignExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__5 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__5)
        else
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__6 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__6)))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) t (( 0 :: int)::ii)  ::  5 Word.word))
     ) \<then>
     (if wback then
       (if wb_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
        else
          (let (address :: 64 bits) =
            (if postindex then (add_vec address offset  ::  64 Word.word)
            else address) in
          return address)) \<bind> (\<lambda> (address :: 64 bits) . 
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () ))))))))))))))))
   else if (((l__40 = (( 16 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let wback = wback__arg in
     (ExtendReg (( 64 :: int)::ii) m extend_type shift  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (data :: 16 bits) . 
     (let (wb_unknown :: bool) = False in
     (let (rt_unknown :: bool) = False in
     undefined_Constraint ()  \<bind> (\<lambda> (c :: Constraint) . 
     (if ((((((((((((memop = MemOp_LOAD))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_WBSUPPRESS in
        assert_exp ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \<or> (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) (''((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return wback) \<bind> (\<lambda> (wback :: bool) . 
     (if ((((((((((((memop = MemOp_STORE))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_NONE in
        assert_exp ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
     (if (((n = (( 31 :: int)::ii)))) then
        (if (((memop \<noteq> MemOp_PREFETCH))) then CheckSPAlignment () 
         else return () ) \<then>
        (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M)
         else (aget_X (( 16 :: int)::ii) t  :: ( 16 Word.word) M)) \<bind> (\<lambda> (data :: 16 bits) . 
        aset_Mem address (((( 16 :: int)::ii) div (( 8 :: int)::ii))) acctype data)
     | MemOp_LOAD =>
        (aget_Mem address (((( 16 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__12 ::
           16 Word.word) . 
        (let data = w__12 in
        if signed then
          (SignExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__13 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__13)
        else
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__14 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__14)))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) t (( 0 :: int)::ii)  ::  5 Word.word))
     ) \<then>
     (if wback then
       (if wb_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
        else
          (let (address :: 64 bits) =
            (if postindex then (add_vec address offset  ::  64 Word.word)
            else address) in
          return address)) \<bind> (\<lambda> (address :: 64 bits) . 
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () ))))))))))))))))
   else if (((l__40 = (( 32 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let wback = wback__arg in
     (ExtendReg (( 64 :: int)::ii) m extend_type shift  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (data :: 32 bits) . 
     (let (wb_unknown :: bool) = False in
     (let (rt_unknown :: bool) = False in
     undefined_Constraint ()  \<bind> (\<lambda> (c :: Constraint) . 
     (if ((((((((((((memop = MemOp_LOAD))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_WBSUPPRESS in
        assert_exp ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \<or> (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) (''((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return wback) \<bind> (\<lambda> (wback :: bool) . 
     (if ((((((((((((memop = MemOp_STORE))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_NONE in
        assert_exp ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
     (if (((n = (( 31 :: int)::ii)))) then
        (if (((memop \<noteq> MemOp_PREFETCH))) then CheckSPAlignment () 
         else return () ) \<then>
        (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)
         else (aget_X (( 32 :: int)::ii) t  :: ( 32 Word.word) M)) \<bind> (\<lambda> (data :: 32 bits) . 
        aset_Mem address (((( 32 :: int)::ii) div (( 8 :: int)::ii))) acctype data)
     | MemOp_LOAD =>
        (aget_Mem address (((( 32 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__20 ::
           32 Word.word) . 
        (let data = w__20 in
        if signed then
          (SignExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__21 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__21)
        else
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__22 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__22)))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) t (( 0 :: int)::ii)  ::  5 Word.word))
     ) \<then>
     (if wback then
       (if wb_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
        else
          (let (address :: 64 bits) =
            (if postindex then (add_vec address offset  ::  64 Word.word)
            else address) in
          return address)) \<bind> (\<lambda> (address :: 64 bits) . 
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () ))))))))))))))))
   else if (((l__40 = (( 64 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let wback = wback__arg in
     (ExtendReg (( 64 :: int)::ii) m extend_type shift  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (data :: 64 bits) . 
     (let (wb_unknown :: bool) = False in
     (let (rt_unknown :: bool) = False in
     undefined_Constraint ()  \<bind> (\<lambda> (c :: Constraint) . 
     (if ((((((((((((memop = MemOp_LOAD))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_WBSUPPRESS in
        assert_exp ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \<or> (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) (''((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return wback) \<bind> (\<lambda> (wback :: bool) . 
     (if ((((((((((((memop = MemOp_STORE))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_NONE in
        assert_exp ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
     (if (((n = (( 31 :: int)::ii)))) then
        (if (((memop \<noteq> MemOp_PREFETCH))) then CheckSPAlignment () 
         else return () ) \<then>
        (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
         else (aget_X (( 64 :: int)::ii) t  :: ( 64 Word.word) M)) \<bind> (\<lambda> (data :: 64 bits) . 
        aset_Mem address (((( 64 :: int)::ii) div (( 8 :: int)::ii))) acctype data)
     | MemOp_LOAD =>
        (aget_Mem address (((( 64 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__28 ::
           64 Word.word) . 
        (let data = w__28 in
        if signed then
          (SignExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__29 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__29)
        else
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__30 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__30)))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) t (( 0 :: int)::ii)  ::  5 Word.word))
     ) \<then>
     (if wback then
       (if wb_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
        else
          (let (address :: 64 bits) =
            (if postindex then (add_vec address offset  ::  64 Word.word)
            else address) in
          return address)) \<bind> (\<lambda> (address :: 64 bits) . 
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () ))))))))))))))))
   else if (((l__40 = (( 128 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let wback = wback__arg in
     (ExtendReg (( 64 :: int)::ii) m extend_type shift  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> (\<lambda> (data :: 128 bits) . 
     (let (wb_unknown :: bool) = False in
     (let (rt_unknown :: bool) = False in
     undefined_Constraint ()  \<bind> (\<lambda> (c :: Constraint) . 
     (if ((((((((((((memop = MemOp_LOAD))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_WBSUPPRESS in
        assert_exp ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \<or> (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) (''((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return wback) \<bind> (\<lambda> (wback :: bool) . 
     (if ((((((((((((memop = MemOp_STORE))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_NONE in
        assert_exp ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
     (if (((n = (( 31 :: int)::ii)))) then
        (if (((memop \<noteq> MemOp_PREFETCH))) then CheckSPAlignment () 
         else return () ) \<then>
        (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M)
         else (aget_X (( 128 :: int)::ii) t  :: ( 128 Word.word) M)) \<bind> (\<lambda> (data :: 128 bits) . 
        aset_Mem address (((( 128 :: int)::ii) div (( 8 :: int)::ii))) acctype data)
     | MemOp_LOAD =>
        (aget_Mem address (((( 128 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__36 ::
           128 Word.word) . 
        (let data = w__36 in
        if signed then
          (SignExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__37 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__37)
        else
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__38 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__38)))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) t (( 0 :: int)::ii)  ::  5 Word.word))
     ) \<then>
     (if wback then
       (if wb_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
        else
          (let (address :: 64 bits) =
            (if postindex then (add_vec address offset  ::  64 Word.word)
            else address) in
          return address)) \<bind> (\<lambda> (address :: 64 bits) . 
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () ))))))))))))))))
   else
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int ((l__40 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))))"


(*val aarch64_memory_single_general_immediate_unsigned : forall 'regsize. Size 'regsize => AccType -> ii -> MemOp -> ii -> mword ty64 -> bool -> itself 'regsize -> bool -> ii -> bool -> M unit*)

definition aarch64_memory_single_general_immediate_unsigned  :: " AccType \<Rightarrow> int \<Rightarrow> MemOp \<Rightarrow> int \<Rightarrow>(64)Word.word \<Rightarrow> bool \<Rightarrow>('regsize::len)itself \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_memory_single_general_immediate_unsigned acctype l__35 memop n offset postindex regsize signed t wback__arg = (
   if (((l__35 = (( 8 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let wback = wback__arg in
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> (\<lambda> (data :: 8 bits) . 
     (let (wb_unknown :: bool) = False in
     (let (rt_unknown :: bool) = False in
     undefined_Constraint ()  \<bind> (\<lambda> (c :: Constraint) . 
     (if ((((((((((((memop = MemOp_LOAD))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_WBSUPPRESS in
        assert_exp ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \<or> (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) (''((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return wback) \<bind> (\<lambda> (wback :: bool) . 
     (if ((((((((((((memop = MemOp_STORE))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_NONE in
        assert_exp ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
     (if (((n = (( 31 :: int)::ii)))) then
        (if (((memop \<noteq> MemOp_PREFETCH))) then CheckSPAlignment () 
         else return () ) \<then>
        (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M)
         else (aget_X (( 8 :: int)::ii) t  :: ( 8 Word.word) M)) \<bind> (\<lambda> (data :: 8 bits) . 
        aset_Mem address (((( 8 :: int)::ii) div (( 8 :: int)::ii))) acctype data)
     | MemOp_LOAD =>
        (aget_Mem address (((( 8 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__4 ::
           8 Word.word) . 
        (let data = w__4 in
        if signed then
          (SignExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__5 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__5)
        else
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__6 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__6)))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) t (( 0 :: int)::ii)  ::  5 Word.word))
     ) \<then>
     (if wback then
       (if wb_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
        else
          (let (address :: 64 bits) =
            (if postindex then (add_vec address offset  ::  64 Word.word)
            else address) in
          return address)) \<bind> (\<lambda> (address :: 64 bits) . 
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () )))))))))))))))
   else if (((l__35 = (( 16 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let wback = wback__arg in
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (data :: 16 bits) . 
     (let (wb_unknown :: bool) = False in
     (let (rt_unknown :: bool) = False in
     undefined_Constraint ()  \<bind> (\<lambda> (c :: Constraint) . 
     (if ((((((((((((memop = MemOp_LOAD))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_WBSUPPRESS in
        assert_exp ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \<or> (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) (''((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return wback) \<bind> (\<lambda> (wback :: bool) . 
     (if ((((((((((((memop = MemOp_STORE))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_NONE in
        assert_exp ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
     (if (((n = (( 31 :: int)::ii)))) then
        (if (((memop \<noteq> MemOp_PREFETCH))) then CheckSPAlignment () 
         else return () ) \<then>
        (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M)
         else (aget_X (( 16 :: int)::ii) t  :: ( 16 Word.word) M)) \<bind> (\<lambda> (data :: 16 bits) . 
        aset_Mem address (((( 16 :: int)::ii) div (( 8 :: int)::ii))) acctype data)
     | MemOp_LOAD =>
        (aget_Mem address (((( 16 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__12 ::
           16 Word.word) . 
        (let data = w__12 in
        if signed then
          (SignExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__13 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__13)
        else
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__14 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__14)))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) t (( 0 :: int)::ii)  ::  5 Word.word))
     ) \<then>
     (if wback then
       (if wb_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
        else
          (let (address :: 64 bits) =
            (if postindex then (add_vec address offset  ::  64 Word.word)
            else address) in
          return address)) \<bind> (\<lambda> (address :: 64 bits) . 
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () )))))))))))))))
   else if (((l__35 = (( 32 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let wback = wback__arg in
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (data :: 32 bits) . 
     (let (wb_unknown :: bool) = False in
     (let (rt_unknown :: bool) = False in
     undefined_Constraint ()  \<bind> (\<lambda> (c :: Constraint) . 
     (if ((((((((((((memop = MemOp_LOAD))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_WBSUPPRESS in
        assert_exp ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \<or> (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) (''((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return wback) \<bind> (\<lambda> (wback :: bool) . 
     (if ((((((((((((memop = MemOp_STORE))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_NONE in
        assert_exp ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
     (if (((n = (( 31 :: int)::ii)))) then
        (if (((memop \<noteq> MemOp_PREFETCH))) then CheckSPAlignment () 
         else return () ) \<then>
        (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)
         else (aget_X (( 32 :: int)::ii) t  :: ( 32 Word.word) M)) \<bind> (\<lambda> (data :: 32 bits) . 
        aset_Mem address (((( 32 :: int)::ii) div (( 8 :: int)::ii))) acctype data)
     | MemOp_LOAD =>
        (aget_Mem address (((( 32 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__20 ::
           32 Word.word) . 
        (let data = w__20 in
        if signed then
          (SignExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__21 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__21)
        else
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__22 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__22)))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) t (( 0 :: int)::ii)  ::  5 Word.word))
     ) \<then>
     (if wback then
       (if wb_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
        else
          (let (address :: 64 bits) =
            (if postindex then (add_vec address offset  ::  64 Word.word)
            else address) in
          return address)) \<bind> (\<lambda> (address :: 64 bits) . 
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () )))))))))))))))
   else if (((l__35 = (( 64 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let wback = wback__arg in
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (data :: 64 bits) . 
     (let (wb_unknown :: bool) = False in
     (let (rt_unknown :: bool) = False in
     undefined_Constraint ()  \<bind> (\<lambda> (c :: Constraint) . 
     (if ((((((((((((memop = MemOp_LOAD))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_WBSUPPRESS in
        assert_exp ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \<or> (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) (''((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return wback) \<bind> (\<lambda> (wback :: bool) . 
     (if ((((((((((((memop = MemOp_STORE))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_NONE in
        assert_exp ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
     (if (((n = (( 31 :: int)::ii)))) then
        (if (((memop \<noteq> MemOp_PREFETCH))) then CheckSPAlignment () 
         else return () ) \<then>
        (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
         else (aget_X (( 64 :: int)::ii) t  :: ( 64 Word.word) M)) \<bind> (\<lambda> (data :: 64 bits) . 
        aset_Mem address (((( 64 :: int)::ii) div (( 8 :: int)::ii))) acctype data)
     | MemOp_LOAD =>
        (aget_Mem address (((( 64 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__28 ::
           64 Word.word) . 
        (let data = w__28 in
        if signed then
          (SignExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__29 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__29)
        else
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__30 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__30)))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) t (( 0 :: int)::ii)  ::  5 Word.word))
     ) \<then>
     (if wback then
       (if wb_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
        else
          (let (address :: 64 bits) =
            (if postindex then (add_vec address offset  ::  64 Word.word)
            else address) in
          return address)) \<bind> (\<lambda> (address :: 64 bits) . 
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () )))))))))))))))
   else if (((l__35 = (( 128 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let wback = wback__arg in
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> (\<lambda> (data :: 128 bits) . 
     (let (wb_unknown :: bool) = False in
     (let (rt_unknown :: bool) = False in
     undefined_Constraint ()  \<bind> (\<lambda> (c :: Constraint) . 
     (if ((((((((((((memop = MemOp_LOAD))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_WBSUPPRESS in
        assert_exp ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \<or> (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) (''((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return wback) \<bind> (\<lambda> (wback :: bool) . 
     (if ((((((((((((memop = MemOp_STORE))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_NONE in
        assert_exp ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
     (if (((n = (( 31 :: int)::ii)))) then
        (if (((memop \<noteq> MemOp_PREFETCH))) then CheckSPAlignment () 
         else return () ) \<then>
        (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M)
         else (aget_X (( 128 :: int)::ii) t  :: ( 128 Word.word) M)) \<bind> (\<lambda> (data :: 128 bits) . 
        aset_Mem address (((( 128 :: int)::ii) div (( 8 :: int)::ii))) acctype data)
     | MemOp_LOAD =>
        (aget_Mem address (((( 128 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__36 ::
           128 Word.word) . 
        (let data = w__36 in
        if signed then
          (SignExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__37 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__37)
        else
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__38 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__38)))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) t (( 0 :: int)::ii)  ::  5 Word.word))
     ) \<then>
     (if wback then
       (if wb_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
        else
          (let (address :: 64 bits) =
            (if postindex then (add_vec address offset  ::  64 Word.word)
            else address) in
          return address)) \<bind> (\<lambda> (address :: 64 bits) . 
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () )))))))))))))))
   else
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int ((l__35 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))))"


(*val aarch64_memory_single_general_immediate_signed_postidx : forall 'regsize. Size 'regsize => AccType -> ii -> MemOp -> ii -> mword ty64 -> bool -> itself 'regsize -> bool -> ii -> bool -> M unit*)

definition aarch64_memory_single_general_immediate_signed_postidx  :: " AccType \<Rightarrow> int \<Rightarrow> MemOp \<Rightarrow> int \<Rightarrow>(64)Word.word \<Rightarrow> bool \<Rightarrow>('regsize::len)itself \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_memory_single_general_immediate_signed_postidx acctype l__30 memop n offset postindex regsize signed t wback__arg = (
   if (((l__30 = (( 8 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let wback = wback__arg in
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> (\<lambda> (data :: 8 bits) . 
     (let (wb_unknown :: bool) = False in
     (let (rt_unknown :: bool) = False in
     undefined_Constraint ()  \<bind> (\<lambda> (c :: Constraint) . 
     (if ((((((((((((memop = MemOp_LOAD))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_WBSUPPRESS in
        assert_exp ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \<or> (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) (''((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return wback) \<bind> (\<lambda> (wback :: bool) . 
     (if ((((((((((((memop = MemOp_STORE))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_NONE in
        assert_exp ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
     (if (((n = (( 31 :: int)::ii)))) then
        (if (((memop \<noteq> MemOp_PREFETCH))) then CheckSPAlignment () 
         else return () ) \<then>
        (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M)
         else (aget_X (( 8 :: int)::ii) t  :: ( 8 Word.word) M)) \<bind> (\<lambda> (data :: 8 bits) . 
        aset_Mem address (((( 8 :: int)::ii) div (( 8 :: int)::ii))) acctype data)
     | MemOp_LOAD =>
        (aget_Mem address (((( 8 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__4 ::
           8 Word.word) . 
        (let data = w__4 in
        if signed then
          (SignExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__5 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__5)
        else
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__6 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__6)))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) t (( 0 :: int)::ii)  ::  5 Word.word))
     ) \<then>
     (if wback then
       (if wb_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
        else
          (let (address :: 64 bits) =
            (if postindex then (add_vec address offset  ::  64 Word.word)
            else address) in
          return address)) \<bind> (\<lambda> (address :: 64 bits) . 
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () )))))))))))))))
   else if (((l__30 = (( 16 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let wback = wback__arg in
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (data :: 16 bits) . 
     (let (wb_unknown :: bool) = False in
     (let (rt_unknown :: bool) = False in
     undefined_Constraint ()  \<bind> (\<lambda> (c :: Constraint) . 
     (if ((((((((((((memop = MemOp_LOAD))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_WBSUPPRESS in
        assert_exp ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \<or> (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) (''((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return wback) \<bind> (\<lambda> (wback :: bool) . 
     (if ((((((((((((memop = MemOp_STORE))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_NONE in
        assert_exp ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
     (if (((n = (( 31 :: int)::ii)))) then
        (if (((memop \<noteq> MemOp_PREFETCH))) then CheckSPAlignment () 
         else return () ) \<then>
        (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M)
         else (aget_X (( 16 :: int)::ii) t  :: ( 16 Word.word) M)) \<bind> (\<lambda> (data :: 16 bits) . 
        aset_Mem address (((( 16 :: int)::ii) div (( 8 :: int)::ii))) acctype data)
     | MemOp_LOAD =>
        (aget_Mem address (((( 16 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__12 ::
           16 Word.word) . 
        (let data = w__12 in
        if signed then
          (SignExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__13 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__13)
        else
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__14 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__14)))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) t (( 0 :: int)::ii)  ::  5 Word.word))
     ) \<then>
     (if wback then
       (if wb_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
        else
          (let (address :: 64 bits) =
            (if postindex then (add_vec address offset  ::  64 Word.word)
            else address) in
          return address)) \<bind> (\<lambda> (address :: 64 bits) . 
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () )))))))))))))))
   else if (((l__30 = (( 32 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let wback = wback__arg in
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (data :: 32 bits) . 
     (let (wb_unknown :: bool) = False in
     (let (rt_unknown :: bool) = False in
     undefined_Constraint ()  \<bind> (\<lambda> (c :: Constraint) . 
     (if ((((((((((((memop = MemOp_LOAD))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_WBSUPPRESS in
        assert_exp ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \<or> (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) (''((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return wback) \<bind> (\<lambda> (wback :: bool) . 
     (if ((((((((((((memop = MemOp_STORE))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_NONE in
        assert_exp ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
     (if (((n = (( 31 :: int)::ii)))) then
        (if (((memop \<noteq> MemOp_PREFETCH))) then CheckSPAlignment () 
         else return () ) \<then>
        (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)
         else (aget_X (( 32 :: int)::ii) t  :: ( 32 Word.word) M)) \<bind> (\<lambda> (data :: 32 bits) . 
        aset_Mem address (((( 32 :: int)::ii) div (( 8 :: int)::ii))) acctype data)
     | MemOp_LOAD =>
        (aget_Mem address (((( 32 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__20 ::
           32 Word.word) . 
        (let data = w__20 in
        if signed then
          (SignExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__21 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__21)
        else
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__22 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__22)))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) t (( 0 :: int)::ii)  ::  5 Word.word))
     ) \<then>
     (if wback then
       (if wb_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
        else
          (let (address :: 64 bits) =
            (if postindex then (add_vec address offset  ::  64 Word.word)
            else address) in
          return address)) \<bind> (\<lambda> (address :: 64 bits) . 
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () )))))))))))))))
   else if (((l__30 = (( 64 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let wback = wback__arg in
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (data :: 64 bits) . 
     (let (wb_unknown :: bool) = False in
     (let (rt_unknown :: bool) = False in
     undefined_Constraint ()  \<bind> (\<lambda> (c :: Constraint) . 
     (if ((((((((((((memop = MemOp_LOAD))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_WBSUPPRESS in
        assert_exp ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \<or> (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) (''((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return wback) \<bind> (\<lambda> (wback :: bool) . 
     (if ((((((((((((memop = MemOp_STORE))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_NONE in
        assert_exp ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
     (if (((n = (( 31 :: int)::ii)))) then
        (if (((memop \<noteq> MemOp_PREFETCH))) then CheckSPAlignment () 
         else return () ) \<then>
        (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
         else (aget_X (( 64 :: int)::ii) t  :: ( 64 Word.word) M)) \<bind> (\<lambda> (data :: 64 bits) . 
        aset_Mem address (((( 64 :: int)::ii) div (( 8 :: int)::ii))) acctype data)
     | MemOp_LOAD =>
        (aget_Mem address (((( 64 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__28 ::
           64 Word.word) . 
        (let data = w__28 in
        if signed then
          (SignExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__29 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__29)
        else
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__30 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__30)))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) t (( 0 :: int)::ii)  ::  5 Word.word))
     ) \<then>
     (if wback then
       (if wb_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
        else
          (let (address :: 64 bits) =
            (if postindex then (add_vec address offset  ::  64 Word.word)
            else address) in
          return address)) \<bind> (\<lambda> (address :: 64 bits) . 
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () )))))))))))))))
   else if (((l__30 = (( 128 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let wback = wback__arg in
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> (\<lambda> (data :: 128 bits) . 
     (let (wb_unknown :: bool) = False in
     (let (rt_unknown :: bool) = False in
     undefined_Constraint ()  \<bind> (\<lambda> (c :: Constraint) . 
     (if ((((((((((((memop = MemOp_LOAD))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_WBSUPPRESS in
        assert_exp ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \<or> (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) (''((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return wback) \<bind> (\<lambda> (wback :: bool) . 
     (if ((((((((((((memop = MemOp_STORE))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_NONE in
        assert_exp ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
     (if (((n = (( 31 :: int)::ii)))) then
        (if (((memop \<noteq> MemOp_PREFETCH))) then CheckSPAlignment () 
         else return () ) \<then>
        (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M)
         else (aget_X (( 128 :: int)::ii) t  :: ( 128 Word.word) M)) \<bind> (\<lambda> (data :: 128 bits) . 
        aset_Mem address (((( 128 :: int)::ii) div (( 8 :: int)::ii))) acctype data)
     | MemOp_LOAD =>
        (aget_Mem address (((( 128 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__36 ::
           128 Word.word) . 
        (let data = w__36 in
        if signed then
          (SignExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__37 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__37)
        else
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__38 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__38)))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) t (( 0 :: int)::ii)  ::  5 Word.word))
     ) \<then>
     (if wback then
       (if wb_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
        else
          (let (address :: 64 bits) =
            (if postindex then (add_vec address offset  ::  64 Word.word)
            else address) in
          return address)) \<bind> (\<lambda> (address :: 64 bits) . 
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () )))))))))))))))
   else
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int ((l__30 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))))"


(*val aarch64_memory_single_general_immediate_signed_pac : ii -> mword ty64 -> ii -> bool -> bool -> M unit*)

definition aarch64_memory_single_general_immediate_signed_pac  :: " int \<Rightarrow>(64)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_memory_single_general_immediate_signed_pac n offset t use_key_a wback__arg = (
   (let wback = wback__arg in
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (address :: 64 bits) . 
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (data :: 64 bits) . 
   (let (wb_unknown :: bool) = False in
   undefined_Constraint ()  \<bind> (\<lambda> (c :: Constraint) . 
   (if ((((((wback \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
      (let c = (ConstrainUnpredictable Unpredictable_WBOVERLAPLD) in
      assert_exp ((((((c = Constraint_WBSUPPRESS))) \<or> ((((((c = Constraint_UNKNOWN))) \<or> ((((((c = Constraint_UNDEF))) \<or> (((c = Constraint_NOP)))))))))))) (''((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
      (case  c of
        Constraint_WBSUPPRESS =>
         (let (wback :: bool) = False in
         return (wb_unknown, wback))
      | Constraint_UNKNOWN =>
         (let (wb_unknown :: bool) = True in
         return (wb_unknown, wback))
      | Constraint_UNDEF => UnallocatedEncoding ()  \<then> return (wb_unknown, wback)
      | Constraint_NOP => EndOfInstruction ()  \<then> return (wb_unknown, wback)
      ))
    else return (wb_unknown, wback)) \<bind> (\<lambda> varstup .  (let ((wb_unknown :: bool), (wback :: bool)) = varstup in
   (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
    else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
   (if use_key_a then
      (aget_X (( 64 :: int)::ii) (( 31 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::  64 Word.word) . 
      (AuthDA address w__2  :: ( 64 Word.word) M))
    else
      (aget_X (( 64 :: int)::ii) (( 31 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 ::  64 Word.word) . 
      (AuthDB address w__4  :: ( 64 Word.word) M))) \<bind> (\<lambda> (address :: 64 bits) . 
   (let address = ((add_vec address offset  ::  64 Word.word)) in
   (aget_Mem address (( 8 :: int)::ii) AccType_NORMAL  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__6 ::  64 Word.word) . 
   (let data = w__6 in
   aset_X t data \<then>
   (if wback then
     (if wb_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
      else return address) \<bind> (\<lambda> (address :: 64 bits) . 
     if (((n = (( 31 :: int)::ii)))) then aset_SP address
     else aset_X n address)
   else return () ))))))))))))))"


(*val aarch64_memory_single_general_immediate_signed_offset_unpriv : forall 'regsize. Size 'regsize => AccType -> ii -> MemOp -> ii -> mword ty64 -> bool -> itself 'regsize -> bool -> ii -> bool -> M unit*)

definition aarch64_memory_single_general_immediate_signed_offset_unpriv  :: " AccType \<Rightarrow> int \<Rightarrow> MemOp \<Rightarrow> int \<Rightarrow>(64)Word.word \<Rightarrow> bool \<Rightarrow>('regsize::len)itself \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_memory_single_general_immediate_signed_offset_unpriv acctype l__25 memop n offset postindex regsize signed t wback__arg = (
   if (((l__25 = (( 8 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let wback = wback__arg in
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> (\<lambda> (data :: 8 bits) . 
     (let (wb_unknown :: bool) = False in
     (let (rt_unknown :: bool) = False in
     undefined_Constraint ()  \<bind> (\<lambda> (c :: Constraint) . 
     (if ((((((((((((memop = MemOp_LOAD))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_WBSUPPRESS in
        assert_exp ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \<or> (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) (''((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return wback) \<bind> (\<lambda> (wback :: bool) . 
     (if ((((((((((((memop = MemOp_STORE))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_NONE in
        assert_exp ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
     (if (((n = (( 31 :: int)::ii)))) then
        (if (((memop \<noteq> MemOp_PREFETCH))) then CheckSPAlignment () 
         else return () ) \<then>
        (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M)
         else (aget_X (( 8 :: int)::ii) t  :: ( 8 Word.word) M)) \<bind> (\<lambda> (data :: 8 bits) . 
        aset_Mem address (((( 8 :: int)::ii) div (( 8 :: int)::ii))) acctype data)
     | MemOp_LOAD =>
        (aget_Mem address (((( 8 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__4 ::
           8 Word.word) . 
        (let data = w__4 in
        if signed then
          (SignExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__5 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__5)
        else
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__6 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__6)))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) t (( 0 :: int)::ii)  ::  5 Word.word))
     ) \<then>
     (if wback then
       (if wb_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
        else
          (let (address :: 64 bits) =
            (if postindex then (add_vec address offset  ::  64 Word.word)
            else address) in
          return address)) \<bind> (\<lambda> (address :: 64 bits) . 
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () )))))))))))))))
   else if (((l__25 = (( 16 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let wback = wback__arg in
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (data :: 16 bits) . 
     (let (wb_unknown :: bool) = False in
     (let (rt_unknown :: bool) = False in
     undefined_Constraint ()  \<bind> (\<lambda> (c :: Constraint) . 
     (if ((((((((((((memop = MemOp_LOAD))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_WBSUPPRESS in
        assert_exp ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \<or> (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) (''((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return wback) \<bind> (\<lambda> (wback :: bool) . 
     (if ((((((((((((memop = MemOp_STORE))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_NONE in
        assert_exp ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
     (if (((n = (( 31 :: int)::ii)))) then
        (if (((memop \<noteq> MemOp_PREFETCH))) then CheckSPAlignment () 
         else return () ) \<then>
        (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M)
         else (aget_X (( 16 :: int)::ii) t  :: ( 16 Word.word) M)) \<bind> (\<lambda> (data :: 16 bits) . 
        aset_Mem address (((( 16 :: int)::ii) div (( 8 :: int)::ii))) acctype data)
     | MemOp_LOAD =>
        (aget_Mem address (((( 16 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__12 ::
           16 Word.word) . 
        (let data = w__12 in
        if signed then
          (SignExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__13 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__13)
        else
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__14 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__14)))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) t (( 0 :: int)::ii)  ::  5 Word.word))
     ) \<then>
     (if wback then
       (if wb_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
        else
          (let (address :: 64 bits) =
            (if postindex then (add_vec address offset  ::  64 Word.word)
            else address) in
          return address)) \<bind> (\<lambda> (address :: 64 bits) . 
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () )))))))))))))))
   else if (((l__25 = (( 32 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let wback = wback__arg in
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (data :: 32 bits) . 
     (let (wb_unknown :: bool) = False in
     (let (rt_unknown :: bool) = False in
     undefined_Constraint ()  \<bind> (\<lambda> (c :: Constraint) . 
     (if ((((((((((((memop = MemOp_LOAD))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_WBSUPPRESS in
        assert_exp ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \<or> (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) (''((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return wback) \<bind> (\<lambda> (wback :: bool) . 
     (if ((((((((((((memop = MemOp_STORE))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_NONE in
        assert_exp ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
     (if (((n = (( 31 :: int)::ii)))) then
        (if (((memop \<noteq> MemOp_PREFETCH))) then CheckSPAlignment () 
         else return () ) \<then>
        (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)
         else (aget_X (( 32 :: int)::ii) t  :: ( 32 Word.word) M)) \<bind> (\<lambda> (data :: 32 bits) . 
        aset_Mem address (((( 32 :: int)::ii) div (( 8 :: int)::ii))) acctype data)
     | MemOp_LOAD =>
        (aget_Mem address (((( 32 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__20 ::
           32 Word.word) . 
        (let data = w__20 in
        if signed then
          (SignExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__21 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__21)
        else
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__22 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__22)))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) t (( 0 :: int)::ii)  ::  5 Word.word))
     ) \<then>
     (if wback then
       (if wb_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
        else
          (let (address :: 64 bits) =
            (if postindex then (add_vec address offset  ::  64 Word.word)
            else address) in
          return address)) \<bind> (\<lambda> (address :: 64 bits) . 
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () )))))))))))))))
   else if (((l__25 = (( 64 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let wback = wback__arg in
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (data :: 64 bits) . 
     (let (wb_unknown :: bool) = False in
     (let (rt_unknown :: bool) = False in
     undefined_Constraint ()  \<bind> (\<lambda> (c :: Constraint) . 
     (if ((((((((((((memop = MemOp_LOAD))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_WBSUPPRESS in
        assert_exp ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \<or> (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) (''((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return wback) \<bind> (\<lambda> (wback :: bool) . 
     (if ((((((((((((memop = MemOp_STORE))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_NONE in
        assert_exp ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
     (if (((n = (( 31 :: int)::ii)))) then
        (if (((memop \<noteq> MemOp_PREFETCH))) then CheckSPAlignment () 
         else return () ) \<then>
        (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
         else (aget_X (( 64 :: int)::ii) t  :: ( 64 Word.word) M)) \<bind> (\<lambda> (data :: 64 bits) . 
        aset_Mem address (((( 64 :: int)::ii) div (( 8 :: int)::ii))) acctype data)
     | MemOp_LOAD =>
        (aget_Mem address (((( 64 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__28 ::
           64 Word.word) . 
        (let data = w__28 in
        if signed then
          (SignExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__29 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__29)
        else
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__30 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__30)))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) t (( 0 :: int)::ii)  ::  5 Word.word))
     ) \<then>
     (if wback then
       (if wb_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
        else
          (let (address :: 64 bits) =
            (if postindex then (add_vec address offset  ::  64 Word.word)
            else address) in
          return address)) \<bind> (\<lambda> (address :: 64 bits) . 
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () )))))))))))))))
   else if (((l__25 = (( 128 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let wback = wback__arg in
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> (\<lambda> (data :: 128 bits) . 
     (let (wb_unknown :: bool) = False in
     (let (rt_unknown :: bool) = False in
     undefined_Constraint ()  \<bind> (\<lambda> (c :: Constraint) . 
     (if ((((((((((((memop = MemOp_LOAD))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_WBSUPPRESS in
        assert_exp ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \<or> (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) (''((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return wback) \<bind> (\<lambda> (wback :: bool) . 
     (if ((((((((((((memop = MemOp_STORE))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_NONE in
        assert_exp ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
     (if (((n = (( 31 :: int)::ii)))) then
        (if (((memop \<noteq> MemOp_PREFETCH))) then CheckSPAlignment () 
         else return () ) \<then>
        (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M)
         else (aget_X (( 128 :: int)::ii) t  :: ( 128 Word.word) M)) \<bind> (\<lambda> (data :: 128 bits) . 
        aset_Mem address (((( 128 :: int)::ii) div (( 8 :: int)::ii))) acctype data)
     | MemOp_LOAD =>
        (aget_Mem address (((( 128 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__36 ::
           128 Word.word) . 
        (let data = w__36 in
        if signed then
          (SignExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__37 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__37)
        else
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__38 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__38)))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) t (( 0 :: int)::ii)  ::  5 Word.word))
     ) \<then>
     (if wback then
       (if wb_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
        else
          (let (address :: 64 bits) =
            (if postindex then (add_vec address offset  ::  64 Word.word)
            else address) in
          return address)) \<bind> (\<lambda> (address :: 64 bits) . 
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () )))))))))))))))
   else
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int ((l__25 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))))"


(*val aarch64_memory_single_general_immediate_signed_offset_normal : forall 'regsize. Size 'regsize => AccType -> ii -> MemOp -> ii -> mword ty64 -> bool -> itself 'regsize -> bool -> ii -> bool -> M unit*)

definition aarch64_memory_single_general_immediate_signed_offset_normal  :: " AccType \<Rightarrow> int \<Rightarrow> MemOp \<Rightarrow> int \<Rightarrow>(64)Word.word \<Rightarrow> bool \<Rightarrow>('regsize::len)itself \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_memory_single_general_immediate_signed_offset_normal acctype l__20 memop n offset postindex regsize signed t wback__arg = (
   if (((l__20 = (( 8 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let wback = wback__arg in
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> (\<lambda> (data :: 8 bits) . 
     (let (wb_unknown :: bool) = False in
     (let (rt_unknown :: bool) = False in
     undefined_Constraint ()  \<bind> (\<lambda> (c :: Constraint) . 
     (if ((((((((((((memop = MemOp_LOAD))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_WBSUPPRESS in
        assert_exp ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \<or> (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) (''((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return wback) \<bind> (\<lambda> (wback :: bool) . 
     (if ((((((((((((memop = MemOp_STORE))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_NONE in
        assert_exp ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
     (if (((n = (( 31 :: int)::ii)))) then
        (if (((memop \<noteq> MemOp_PREFETCH))) then CheckSPAlignment () 
         else return () ) \<then>
        (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M)
         else (aget_X (( 8 :: int)::ii) t  :: ( 8 Word.word) M)) \<bind> (\<lambda> (data :: 8 bits) . 
        aset_Mem address (((( 8 :: int)::ii) div (( 8 :: int)::ii))) acctype data)
     | MemOp_LOAD =>
        (aget_Mem address (((( 8 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__4 ::
           8 Word.word) . 
        (let data = w__4 in
        if signed then
          (SignExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__5 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__5)
        else
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__6 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__6)))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) t (( 0 :: int)::ii)  ::  5 Word.word))
     ) \<then>
     (if wback then
       (if wb_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
        else
          (let (address :: 64 bits) =
            (if postindex then (add_vec address offset  ::  64 Word.word)
            else address) in
          return address)) \<bind> (\<lambda> (address :: 64 bits) . 
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () )))))))))))))))
   else if (((l__20 = (( 16 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let wback = wback__arg in
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (data :: 16 bits) . 
     (let (wb_unknown :: bool) = False in
     (let (rt_unknown :: bool) = False in
     undefined_Constraint ()  \<bind> (\<lambda> (c :: Constraint) . 
     (if ((((((((((((memop = MemOp_LOAD))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_WBSUPPRESS in
        assert_exp ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \<or> (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) (''((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return wback) \<bind> (\<lambda> (wback :: bool) . 
     (if ((((((((((((memop = MemOp_STORE))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_NONE in
        assert_exp ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
     (if (((n = (( 31 :: int)::ii)))) then
        (if (((memop \<noteq> MemOp_PREFETCH))) then CheckSPAlignment () 
         else return () ) \<then>
        (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M)
         else (aget_X (( 16 :: int)::ii) t  :: ( 16 Word.word) M)) \<bind> (\<lambda> (data :: 16 bits) . 
        aset_Mem address (((( 16 :: int)::ii) div (( 8 :: int)::ii))) acctype data)
     | MemOp_LOAD =>
        (aget_Mem address (((( 16 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__12 ::
           16 Word.word) . 
        (let data = w__12 in
        if signed then
          (SignExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__13 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__13)
        else
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__14 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__14)))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) t (( 0 :: int)::ii)  ::  5 Word.word))
     ) \<then>
     (if wback then
       (if wb_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
        else
          (let (address :: 64 bits) =
            (if postindex then (add_vec address offset  ::  64 Word.word)
            else address) in
          return address)) \<bind> (\<lambda> (address :: 64 bits) . 
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () )))))))))))))))
   else if (((l__20 = (( 32 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let wback = wback__arg in
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (data :: 32 bits) . 
     (let (wb_unknown :: bool) = False in
     (let (rt_unknown :: bool) = False in
     undefined_Constraint ()  \<bind> (\<lambda> (c :: Constraint) . 
     (if ((((((((((((memop = MemOp_LOAD))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_WBSUPPRESS in
        assert_exp ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \<or> (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) (''((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return wback) \<bind> (\<lambda> (wback :: bool) . 
     (if ((((((((((((memop = MemOp_STORE))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_NONE in
        assert_exp ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
     (if (((n = (( 31 :: int)::ii)))) then
        (if (((memop \<noteq> MemOp_PREFETCH))) then CheckSPAlignment () 
         else return () ) \<then>
        (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)
         else (aget_X (( 32 :: int)::ii) t  :: ( 32 Word.word) M)) \<bind> (\<lambda> (data :: 32 bits) . 
        aset_Mem address (((( 32 :: int)::ii) div (( 8 :: int)::ii))) acctype data)
     | MemOp_LOAD =>
        (aget_Mem address (((( 32 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__20 ::
           32 Word.word) . 
        (let data = w__20 in
        if signed then
          (SignExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__21 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__21)
        else
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__22 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__22)))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) t (( 0 :: int)::ii)  ::  5 Word.word))
     ) \<then>
     (if wback then
       (if wb_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
        else
          (let (address :: 64 bits) =
            (if postindex then (add_vec address offset  ::  64 Word.word)
            else address) in
          return address)) \<bind> (\<lambda> (address :: 64 bits) . 
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () )))))))))))))))
   else if (((l__20 = (( 64 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let wback = wback__arg in
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (data :: 64 bits) . 
     (let (wb_unknown :: bool) = False in
     (let (rt_unknown :: bool) = False in
     undefined_Constraint ()  \<bind> (\<lambda> (c :: Constraint) . 
     (if ((((((((((((memop = MemOp_LOAD))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_WBSUPPRESS in
        assert_exp ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \<or> (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) (''((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return wback) \<bind> (\<lambda> (wback :: bool) . 
     (if ((((((((((((memop = MemOp_STORE))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_NONE in
        assert_exp ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
     (if (((n = (( 31 :: int)::ii)))) then
        (if (((memop \<noteq> MemOp_PREFETCH))) then CheckSPAlignment () 
         else return () ) \<then>
        (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
         else (aget_X (( 64 :: int)::ii) t  :: ( 64 Word.word) M)) \<bind> (\<lambda> (data :: 64 bits) . 
        aset_Mem address (((( 64 :: int)::ii) div (( 8 :: int)::ii))) acctype data)
     | MemOp_LOAD =>
        (aget_Mem address (((( 64 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__28 ::
           64 Word.word) . 
        (let data = w__28 in
        if signed then
          (SignExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__29 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__29)
        else
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__30 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__30)))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) t (( 0 :: int)::ii)  ::  5 Word.word))
     ) \<then>
     (if wback then
       (if wb_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
        else
          (let (address :: 64 bits) =
            (if postindex then (add_vec address offset  ::  64 Word.word)
            else address) in
          return address)) \<bind> (\<lambda> (address :: 64 bits) . 
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () )))))))))))))))
   else if (((l__20 = (( 128 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     (assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     ((let wback = wback__arg in
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> (\<lambda> (data :: 128 bits) . 
     (let (wb_unknown :: bool) = False in
     (let (rt_unknown :: bool) = False in
     undefined_Constraint ()  \<bind> (\<lambda> (c :: Constraint) . 
     (if ((((((((((((memop = MemOp_LOAD))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_WBSUPPRESS in
        assert_exp ((((((Constraint_WBSUPPRESS = Constraint_WBSUPPRESS))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNKNOWN))) \<or> ((((((Constraint_WBSUPPRESS = Constraint_UNDEF))) \<or> (((Constraint_WBSUPPRESS = Constraint_NOP)))))))))))) (''((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return wback) \<bind> (\<lambda> (wback :: bool) . 
     (if ((((((((((((memop = MemOp_STORE))) \<and> wback))) \<and> (((n = t)))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
        (let c = Constraint_NONE in
        assert_exp ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
        return False)
      else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
     (if (((n = (( 31 :: int)::ii)))) then
        (if (((memop \<noteq> MemOp_PREFETCH))) then CheckSPAlignment () 
         else return () ) \<then>
        (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (let (address :: 64 bits) =
       (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
       else address) in
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M)
         else (aget_X (( 128 :: int)::ii) t  :: ( 128 Word.word) M)) \<bind> (\<lambda> (data :: 128 bits) . 
        aset_Mem address (((( 128 :: int)::ii) div (( 8 :: int)::ii))) acctype data)
     | MemOp_LOAD =>
        (aget_Mem address (((( 128 :: int)::ii) div (( 8 :: int)::ii))) acctype  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__36 ::
           128 Word.word) . 
        (let data = w__36 in
        if signed then
          (SignExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__37 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__37)
        else
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__38 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__38)))
     | MemOp_PREFETCH =>
        Prefetch address
          ((GetSlice_int ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) t (( 0 :: int)::ii)  ::  5 Word.word))
     ) \<then>
     (if wback then
       (if wb_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
        else
          (let (address :: 64 bits) =
            (if postindex then (add_vec address offset  ::  64 Word.word)
            else address) in
          return address)) \<bind> (\<lambda> (address :: 64 bits) . 
       if (((n = (( 31 :: int)::ii)))) then aset_SP address
       else aset_X n address)
     else return () )))))))))))))))
   else
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int ((l__20 div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint'')))))"


(*val aarch64_memory_pair_simdfp_postidx : forall 'datasize. Size 'datasize => AccType -> itself 'datasize -> MemOp -> ii -> mword ty64 -> bool -> ii -> ii -> bool -> M unit*)

definition aarch64_memory_pair_simdfp_postidx  :: " AccType \<Rightarrow>('datasize::len)itself \<Rightarrow> MemOp \<Rightarrow> int \<Rightarrow>(64)Word.word \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_memory_pair_simdfp_postidx acctype datasize memop n offset postindex t t2 wback = (
   (let datasize = (size_itself_int datasize) in
   (let dbytes = (ex_int ((datasize div (( 8 :: int)::ii)))) in
   (((assert_exp True (''datasize constraint'') \<then>
   assert_exp True (''dbytes constraint'')) \<then>
   CheckFPAdvSIMDEnabled64 () ) \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
   (undefined_bitvector datasize  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> data1 . 
   (undefined_bitvector ((int (size data1)))  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> data2 . 
   (let (rt_unknown :: bool) = False in
   (if ((((((memop = MemOp_LOAD))) \<and> (((t = t2)))))) then
      (let (c :: Constraint) = (ConstrainUnpredictable Unpredictable_LDPOVERLAP) in
      assert_exp ((((((c = Constraint_UNKNOWN))) \<or> ((((((c = Constraint_UNDEF))) \<or> (((c = Constraint_NOP))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP)))'') \<then>
      (case  c of
        Constraint_UNKNOWN => return True
      | Constraint_UNDEF => UnallocatedEncoding ()  \<then> return rt_unknown
      | Constraint_NOP => EndOfInstruction ()  \<then> return rt_unknown
      ))
    else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
   (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
    else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
   (let (address :: 64 bits) =
     (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
     else address) in
   (case  memop of
     MemOp_STORE =>
      (aget_V ((int (size data1))) t  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> (w__2 :: ( 'datasize::len)Word.word) . 
      (let data1 = w__2 in
      (aget_V ((int (size data1))) t2  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> (w__3 :: ( 'datasize::len)Word.word) . 
      (let data2 = w__3 in
      aset_Mem ((add_vec_int address (( 0 :: int)::ii)  ::  64 Word.word)) dbytes acctype data1 \<then>
      aset_Mem ((add_vec_int address dbytes  ::  64 Word.word)) dbytes acctype data2))))
   | MemOp_LOAD =>
      (aget_Mem ((add_vec_int address (( 0 :: int)::ii)  ::  64 Word.word)) dbytes acctype  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> (w__4 ::
        ( 'datasize::len)Word.word) . 
      (let data1 = w__4 in
      (aget_Mem ((add_vec_int address dbytes  ::  64 Word.word)) dbytes acctype  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> (w__5 ::
        ( 'datasize::len)Word.word) . 
      (let data2 = w__5 in
      (if rt_unknown then
         (undefined_bitvector ((int (size data1)))  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> (w__6 ::
           ( 'datasize::len)Word.word) . 
         (let data1 = w__6 in
         (undefined_bitvector ((int (size data1)))  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> (w__7 ::
           ( 'datasize::len)Word.word) . 
         (let data2 = w__7 in
         return (data1, data2)))))
       else return (data1, data2)) \<bind> (\<lambda> varstup .  (let (data1, data2) = varstup in
      aset_V t data1 \<then> aset_V t2 data2))))))
   ) \<then>
   (if wback then
     (let (address :: 64 bits) =
       (if postindex then (add_vec address offset  ::  64 Word.word)
       else address) in
     if (((n = (( 31 :: int)::ii)))) then aset_SP address
     else aset_X n address)
   else return () )))))))))))"


(*val aarch64_memory_pair_simdfp_noalloc : forall 'datasize. Size 'datasize => AccType -> itself 'datasize -> MemOp -> ii -> mword ty64 -> bool -> ii -> ii -> bool -> M unit*)

definition aarch64_memory_pair_simdfp_noalloc  :: " AccType \<Rightarrow>('datasize::len)itself \<Rightarrow> MemOp \<Rightarrow> int \<Rightarrow>(64)Word.word \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_memory_pair_simdfp_noalloc acctype datasize memop n offset postindex t t2 wback = (
   (let datasize = (size_itself_int datasize) in
   (let dbytes = (ex_int ((datasize div (( 8 :: int)::ii)))) in
   (((assert_exp True (''datasize constraint'') \<then>
   assert_exp True (''dbytes constraint'')) \<then>
   CheckFPAdvSIMDEnabled64 () ) \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
   (undefined_bitvector datasize  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> data1 . 
   (undefined_bitvector ((int (size data1)))  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> data2 . 
   (let (rt_unknown :: bool) = False in
   (if ((((((memop = MemOp_LOAD))) \<and> (((t = t2)))))) then
      (let (c :: Constraint) = (ConstrainUnpredictable Unpredictable_LDPOVERLAP) in
      assert_exp ((((((c = Constraint_UNKNOWN))) \<or> ((((((c = Constraint_UNDEF))) \<or> (((c = Constraint_NOP))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP)))'') \<then>
      (case  c of
        Constraint_UNKNOWN => return True
      | Constraint_UNDEF => UnallocatedEncoding ()  \<then> return rt_unknown
      | Constraint_NOP => EndOfInstruction ()  \<then> return rt_unknown
      ))
    else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
   (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
    else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
   (let (address :: 64 bits) =
     (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
     else address) in
   (case  memop of
     MemOp_STORE =>
      (aget_V ((int (size data1))) t  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> (w__2 :: ( 'datasize::len)Word.word) . 
      (let data1 = w__2 in
      (aget_V ((int (size data1))) t2  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> (w__3 :: ( 'datasize::len)Word.word) . 
      (let data2 = w__3 in
      aset_Mem ((add_vec_int address (( 0 :: int)::ii)  ::  64 Word.word)) dbytes acctype data1 \<then>
      aset_Mem ((add_vec_int address dbytes  ::  64 Word.word)) dbytes acctype data2))))
   | MemOp_LOAD =>
      (aget_Mem ((add_vec_int address (( 0 :: int)::ii)  ::  64 Word.word)) dbytes acctype  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> (w__4 ::
        ( 'datasize::len)Word.word) . 
      (let data1 = w__4 in
      (aget_Mem ((add_vec_int address dbytes  ::  64 Word.word)) dbytes acctype  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> (w__5 ::
        ( 'datasize::len)Word.word) . 
      (let data2 = w__5 in
      (if rt_unknown then
         (undefined_bitvector ((int (size data1)))  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> (w__6 ::
           ( 'datasize::len)Word.word) . 
         (let data1 = w__6 in
         (undefined_bitvector ((int (size data1)))  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> (w__7 ::
           ( 'datasize::len)Word.word) . 
         (let data2 = w__7 in
         return (data1, data2)))))
       else return (data1, data2)) \<bind> (\<lambda> varstup .  (let (data1, data2) = varstup in
      aset_V t data1 \<then> aset_V t2 data2))))))
   ) \<then>
   (if wback then
     (let (address :: 64 bits) =
       (if postindex then (add_vec address offset  ::  64 Word.word)
       else address) in
     if (((n = (( 31 :: int)::ii)))) then aset_SP address
     else aset_X n address)
   else return () )))))))))))"


(*val aarch64_memory_pair_general_postidx : forall 'datasize. Size 'datasize => AccType -> itself 'datasize -> MemOp -> ii -> mword ty64 -> bool -> bool -> ii -> ii -> bool -> M unit*)

definition aarch64_memory_pair_general_postidx  :: " AccType \<Rightarrow>('datasize::len)itself \<Rightarrow> MemOp \<Rightarrow> int \<Rightarrow>(64)Word.word \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_memory_pair_general_postidx acctype datasize memop n offset postindex signed t t2 wback__arg = (
   (let datasize = (size_itself_int datasize) in
   (let dbytes = (ex_int ((datasize div (( 8 :: int)::ii)))) in
   (assert_exp True (''datasize constraint'') \<then>
   assert_exp True (''dbytes constraint'')) \<then>
   ((let wback = wback__arg in
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (address :: 64 bits) . 
   (undefined_bitvector datasize  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> data1 . 
   (undefined_bitvector ((int (size data1)))  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> data2 . 
   (let (rt_unknown :: bool) = False in
   (let (wb_unknown :: bool) = False in
   (if ((((((((((((memop = MemOp_LOAD))) \<and> wback))) \<and> ((((((t = n))) \<or> (((t2 = n))))))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
      (let (c :: Constraint) = (ConstrainUnpredictable Unpredictable_WBOVERLAPLD) in
      assert_exp ((((((c = Constraint_WBSUPPRESS))) \<or> ((((((c = Constraint_UNKNOWN))) \<or> ((((((c = Constraint_UNDEF))) \<or> (((c = Constraint_NOP)))))))))))) (''((c == Constraint_WBSUPPRESS) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
      (case  c of
        Constraint_WBSUPPRESS =>
         (let (wback :: bool) = False in
         return (wb_unknown, wback))
      | Constraint_UNKNOWN =>
         (let (wb_unknown :: bool) = True in
         return (wb_unknown, wback))
      | Constraint_UNDEF => UnallocatedEncoding ()  \<then> return (wb_unknown, wback)
      | Constraint_NOP => EndOfInstruction ()  \<then> return (wb_unknown, wback)
      ))
    else return (wb_unknown, wback)) \<bind> (\<lambda> varstup .  (let ((wb_unknown :: bool), (wback :: bool)) = varstup in
   (if ((((((((((((memop = MemOp_STORE))) \<and> wback))) \<and> ((((((t = n))) \<or> (((t2 = n))))))))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
      (let (c :: Constraint) = (ConstrainUnpredictable Unpredictable_WBOVERLAPST) in
      assert_exp ((((((c = Constraint_NONE))) \<or> ((((((c = Constraint_UNKNOWN))) \<or> ((((((c = Constraint_UNDEF))) \<or> (((c = Constraint_NOP)))))))))))) (''((c == Constraint_NONE) || ((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
      (case  c of
        Constraint_NONE => return False
      | Constraint_UNKNOWN => return True
      | Constraint_UNDEF => UnallocatedEncoding ()  \<then> return rt_unknown
      | Constraint_NOP => EndOfInstruction ()  \<then> return rt_unknown
      ))
    else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
   (if ((((((memop = MemOp_LOAD))) \<and> (((t = t2)))))) then
      (let (c :: Constraint) = (ConstrainUnpredictable Unpredictable_LDPOVERLAP) in
      assert_exp ((((((c = Constraint_UNKNOWN))) \<or> ((((((c = Constraint_UNDEF))) \<or> (((c = Constraint_NOP))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP)))'') \<then>
      (case  c of
        Constraint_UNKNOWN => return True
      | Constraint_UNDEF => UnallocatedEncoding ()  \<then> return rt_unknown
      | Constraint_NOP => EndOfInstruction ()  \<then> return rt_unknown
      ))
    else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
   (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
    else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
   (let (address :: 64 bits) =
     (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
     else address) in
   (case  memop of
     MemOp_STORE =>
      (if (((rt_unknown \<and> (((t = n)))))) then
         (undefined_bitvector ((int (size data1)))  :: (( 'datasize::len)Word.word) M)
       else (aget_X ((int (size data1))) t  :: (( 'datasize::len)Word.word) M)) \<bind> (\<lambda> data1 . 
      (if (((rt_unknown \<and> (((t2 = n)))))) then
         (undefined_bitvector ((int (size data1)))  :: (( 'datasize::len)Word.word) M)
       else (aget_X ((int (size data1))) t2  :: (( 'datasize::len)Word.word) M)) \<bind> (\<lambda> data2 . 
      aset_Mem ((add_vec_int address (( 0 :: int)::ii)  ::  64 Word.word)) dbytes acctype data1 \<then>
      aset_Mem ((add_vec_int address dbytes  ::  64 Word.word)) dbytes acctype data2))
   | MemOp_LOAD =>
      (aget_Mem ((add_vec_int address (( 0 :: int)::ii)  ::  64 Word.word)) dbytes acctype  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> (w__6 ::
        ( 'datasize::len)Word.word) . 
      (let data1 = w__6 in
      (aget_Mem ((add_vec_int address dbytes  ::  64 Word.word)) dbytes acctype  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> (w__7 ::
        ( 'datasize::len)Word.word) . 
      (let data2 = w__7 in
      (if rt_unknown then
         (undefined_bitvector ((int (size data1)))  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> (w__8 ::
           ( 'datasize::len)Word.word) . 
         (let data1 = w__8 in
         (undefined_bitvector ((int (size data1)))  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> (w__9 ::
           ( 'datasize::len)Word.word) . 
         (let data2 = w__9 in
         return (data1, data2)))))
       else return (data1, data2)) \<bind> (\<lambda> varstup .  (let (data1, data2) = varstup in
      if signed then
        (SignExtend__0 data1 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__10 ::
           64 Word.word) . 
        (aset_X t w__10 \<then>
        (SignExtend__0 data2 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__11 ::
           64 Word.word) . 
        aset_X t2 w__11))
      else aset_X t data1 \<then> aset_X t2 data2))))))
   ) \<then>
   (if wback then
     (if wb_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
      else
        (let (address :: 64 bits) =
          (if postindex then (add_vec address offset  ::  64 Word.word)
          else address) in
        return address)) \<bind> (\<lambda> (address :: 64 bits) . 
     if (((n = (( 31 :: int)::ii)))) then aset_SP address
     else aset_X n address)
   else return () )))))))))))))))))"


(*val aarch64_memory_pair_general_noalloc : forall 'datasize. Size 'datasize => AccType -> itself 'datasize -> MemOp -> ii -> mword ty64 -> bool -> ii -> ii -> bool -> M unit*)

definition aarch64_memory_pair_general_noalloc  :: " AccType \<Rightarrow>('datasize::len)itself \<Rightarrow> MemOp \<Rightarrow> int \<Rightarrow>(64)Word.word \<Rightarrow> bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_memory_pair_general_noalloc acctype datasize memop n offset postindex t t2 wback = (
   (let datasize = (size_itself_int datasize) in
   (let dbytes = (ex_int ((datasize div (( 8 :: int)::ii)))) in
   ((assert_exp True (''datasize constraint'') \<then>
   assert_exp True (''dbytes constraint'')) \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
   (undefined_bitvector datasize  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> data1 . 
   (undefined_bitvector ((int (size data1)))  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> data2 . 
   (let (rt_unknown :: bool) = False in
   (if ((((((memop = MemOp_LOAD))) \<and> (((t = t2)))))) then
      (let (c :: Constraint) = (ConstrainUnpredictable Unpredictable_LDPOVERLAP) in
      assert_exp ((((((c = Constraint_UNKNOWN))) \<or> ((((((c = Constraint_UNDEF))) \<or> (((c = Constraint_NOP))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP)))'') \<then>
      (case  c of
        Constraint_UNKNOWN => return True
      | Constraint_UNDEF => UnallocatedEncoding ()  \<then> return rt_unknown
      | Constraint_NOP => EndOfInstruction ()  \<then> return rt_unknown
      ))
    else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
   (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
    else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
   (let (address :: 64 bits) =
     (if ((\<not> postindex)) then (add_vec address offset  ::  64 Word.word)
     else address) in
   (case  memop of
     MemOp_STORE =>
      (if (((rt_unknown \<and> (((t = n)))))) then
         (undefined_bitvector ((int (size data1)))  :: (( 'datasize::len)Word.word) M)
       else (aget_X ((int (size data1))) t  :: (( 'datasize::len)Word.word) M)) \<bind> (\<lambda> data1 . 
      (if (((rt_unknown \<and> (((t2 = n)))))) then
         (undefined_bitvector ((int (size data1)))  :: (( 'datasize::len)Word.word) M)
       else (aget_X ((int (size data1))) t2  :: (( 'datasize::len)Word.word) M)) \<bind> (\<lambda> data2 . 
      aset_Mem ((add_vec_int address (( 0 :: int)::ii)  ::  64 Word.word)) dbytes acctype data1 \<then>
      aset_Mem ((add_vec_int address dbytes  ::  64 Word.word)) dbytes acctype data2))
   | MemOp_LOAD =>
      (aget_Mem ((add_vec_int address (( 0 :: int)::ii)  ::  64 Word.word)) dbytes acctype  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> (w__6 ::
        ( 'datasize::len)Word.word) . 
      (let data1 = w__6 in
      (aget_Mem ((add_vec_int address dbytes  ::  64 Word.word)) dbytes acctype  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> (w__7 ::
        ( 'datasize::len)Word.word) . 
      (let data2 = w__7 in
      (if rt_unknown then
         (undefined_bitvector ((int (size data1)))  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> (w__8 ::
           ( 'datasize::len)Word.word) . 
         (let data1 = w__8 in
         (undefined_bitvector ((int (size data1)))  :: (( 'datasize::len)Word.word) M) \<bind> (\<lambda> (w__9 ::
           ( 'datasize::len)Word.word) . 
         (let data2 = w__9 in
         return (data1, data2)))))
       else return (data1, data2)) \<bind> (\<lambda> varstup .  (let (data1, data2) = varstup in
      aset_X t data1 \<then> aset_X t2 data2))))))
   ) \<then>
   (if wback then
     (let (address :: 64 bits) =
       (if postindex then (add_vec address offset  ::  64 Word.word)
       else address) in
     if (((n = (( 31 :: int)::ii)))) then aset_SP address
     else aset_X n address)
   else return () )))))))))))"


(*val aarch64_memory_exclusive_single : forall 'datasize  'regsize. Size 'datasize, Size 'regsize => AccType -> itself 'datasize -> integer -> MemOp -> ii -> bool -> itself 'regsize -> ii -> ii -> ii -> M unit*)

definition aarch64_memory_exclusive_single  :: " AccType \<Rightarrow>('datasize::len)itself \<Rightarrow> int \<Rightarrow> MemOp \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>('regsize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_memory_exclusive_single acctype p_1 elsize memop n pair regsize s t t2 = (
   if (((((size_itself_int p_1)) = (( 8 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''destsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> (\<lambda> (data :: 8 bits) . 
     (let (rt_unknown :: bool) = False in
     (let (rn_unknown :: bool) = False in
     ((if (((((((((memop = MemOp_LOAD))) \<and> pair))) \<and> (((t = t2)))))) then
        (let (c :: Constraint) = Constraint_UNDEF in
        assert_exp ((((((Constraint_UNDEF = Constraint_UNKNOWN))) \<or> ((((((Constraint_UNDEF = Constraint_UNDEF))) \<or> (((Constraint_UNDEF = Constraint_NOP))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP)))'') \<then>
        UnallocatedEncoding () )
      else return () ) \<then>
     (if (((memop = MemOp_STORE))) then
        (if ((((((s = t))) \<or> (((pair \<and> (((s = t2))))))))) then
           (let (c :: Constraint) = Constraint_NONE in
           assert_exp ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
           return False)
         else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
        (if ((((((s = n))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
           (let (c :: Constraint) = Constraint_NONE in
           assert_exp ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
           return False)
         else return rn_unknown) \<bind> (\<lambda> (rn_unknown :: bool) . 
        return (rn_unknown, rt_unknown)))
      else return (rn_unknown, rt_unknown))) \<bind> (\<lambda> varstup .  (let ((rn_unknown :: bool), (rt_unknown ::
       bool)) = varstup in
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else if rn_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     undefined_bool ()  \<bind> (\<lambda> (secondstage :: bool) . 
     undefined_bool ()  \<bind> (\<lambda> (iswrite :: bool) . 
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M)
         else if pair then
           (let v = (ex_int (((( 8 :: int)::ii) div (( 2 :: int)::ii)))) in
           (assert_exp True ('''') \<then>
           (aget_X ((int (size DebugException_VectorCatch))) t  :: ( 4 Word.word) M)) \<bind> (\<lambda> el1 . 
           (aget_X ((int (size DebugException_VectorCatch))) t2  :: ( 4 Word.word) M) \<bind> (\<lambda> el2 . 
           BigEndian ()  \<bind> (\<lambda> (w__4 :: bool) . 
           (let (data :: 8 bits) =
             (if w__4 then (concat_vec el1 el2  ::  8 Word.word)
             else (concat_vec el2 el1  ::  8 Word.word)) in
           return data)))))
         else (aget_X (( 8 :: int)::ii) t  :: ( 8 Word.word) M)) \<bind> (\<lambda> (data :: 8 bits) . 
        (let (status :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
        AArch64_ExclusiveMonitorsPass address dbytes \<bind> (\<lambda> (w__6 :: bool) . 
        (if w__6 then
           aset_Mem address dbytes acctype data \<then> (ExclusiveMonitorsStatus ()   :: ( 1 Word.word) M)
         else return status) \<bind> (\<lambda> (status :: 1 bits) . 
        (ZeroExtend__0 status ((make_the_value (( 32 :: int)::ii)  ::  32 itself))  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__8 ::
           32 Word.word) . 
        aset_X s w__8)))))
     | MemOp_LOAD =>
        AArch64_SetExclusiveMonitors address dbytes \<then>
        (if pair then
          assert_exp True ('''') \<then>
          (if rt_unknown then
            (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__9 ::  32 Word.word) . 
            aset_X t w__9)
          else
            ((if (((address \<noteq> ((Align__1 address dbytes  ::  64 Word.word))))) then
               (let iswrite = False in
               (let secondstage = False in
               AArch64_AlignmentFault acctype False False \<bind> (\<lambda> (w__10 :: FaultRecord) . 
               AArch64_Abort address w__10)))
             else return () ) \<then>
            (aget_Mem ((add_vec_int address (( 0 :: int)::ii)  ::  64 Word.word)) (( 8 :: int)::ii) acctype  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__11 ::
               64 Word.word) . 
            (aset_X t w__11 \<then>
            (aget_Mem ((add_vec_int address (( 8 :: int)::ii)  ::  64 Word.word)) (( 8 :: int)::ii) acctype  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__12 ::
               64 Word.word) . 
            aset_X t2 w__12)))
        else
          (aget_Mem address dbytes acctype  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__13 ::  8 Word.word) . 
          (let data = w__13 in
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__14 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__14))))
     )))))))))))))
   else if (((((size_itself_int p_1)) = (( 16 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''destsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (data :: 16 bits) . 
     (let (rt_unknown :: bool) = False in
     (let (rn_unknown :: bool) = False in
     ((if (((((((((memop = MemOp_LOAD))) \<and> pair))) \<and> (((t = t2)))))) then
        (let (c :: Constraint) = Constraint_UNDEF in
        assert_exp ((((((Constraint_UNDEF = Constraint_UNKNOWN))) \<or> ((((((Constraint_UNDEF = Constraint_UNDEF))) \<or> (((Constraint_UNDEF = Constraint_NOP))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP)))'') \<then>
        UnallocatedEncoding () )
      else return () ) \<then>
     (if (((memop = MemOp_STORE))) then
        (if ((((((s = t))) \<or> (((pair \<and> (((s = t2))))))))) then
           (let (c :: Constraint) = Constraint_NONE in
           assert_exp ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
           return False)
         else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
        (if ((((((s = n))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
           (let (c :: Constraint) = Constraint_NONE in
           assert_exp ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
           return False)
         else return rn_unknown) \<bind> (\<lambda> (rn_unknown :: bool) . 
        return (rn_unknown, rt_unknown)))
      else return (rn_unknown, rt_unknown))) \<bind> (\<lambda> varstup .  (let ((rn_unknown :: bool), (rt_unknown ::
       bool)) = varstup in
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else if rn_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     undefined_bool ()  \<bind> (\<lambda> (secondstage :: bool) . 
     undefined_bool ()  \<bind> (\<lambda> (iswrite :: bool) . 
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M)
         else if pair then
           (let v = (ex_int (((( 16 :: int)::ii) div (( 2 :: int)::ii)))) in
           (assert_exp True ('''') \<then>
           (aget_X v t  :: ( 8 Word.word) M)) \<bind> (\<lambda> el1 . 
           (aget_X ((int (size el1))) t2  :: ( 8 Word.word) M) \<bind> (\<lambda> el2 . 
           BigEndian ()  \<bind> (\<lambda> (w__19 :: bool) . 
           (let (data :: 16 bits) =
             (if w__19 then (concat_vec el1 el2  ::  16 Word.word)
             else (concat_vec el2 el1  ::  16 Word.word)) in
           return data)))))
         else (aget_X (( 16 :: int)::ii) t  :: ( 16 Word.word) M)) \<bind> (\<lambda> (data :: 16 bits) . 
        (let (status :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
        AArch64_ExclusiveMonitorsPass address dbytes \<bind> (\<lambda> (w__21 :: bool) . 
        (if w__21 then
           aset_Mem address dbytes acctype data \<then> (ExclusiveMonitorsStatus ()   :: ( 1 Word.word) M)
         else return status) \<bind> (\<lambda> (status :: 1 bits) . 
        (ZeroExtend__0 status ((make_the_value (( 32 :: int)::ii)  ::  32 itself))  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__23 ::
           32 Word.word) . 
        aset_X s w__23)))))
     | MemOp_LOAD =>
        AArch64_SetExclusiveMonitors address dbytes \<then>
        (if pair then
          assert_exp True ('''') \<then>
          (if rt_unknown then
            (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__24 ::  32 Word.word) . 
            aset_X t w__24)
          else
            ((if (((address \<noteq> ((Align__1 address dbytes  ::  64 Word.word))))) then
               (let iswrite = False in
               (let secondstage = False in
               AArch64_AlignmentFault acctype False False \<bind> (\<lambda> (w__25 :: FaultRecord) . 
               AArch64_Abort address w__25)))
             else return () ) \<then>
            (aget_Mem ((add_vec_int address (( 0 :: int)::ii)  ::  64 Word.word)) (( 8 :: int)::ii) acctype  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__26 ::
               64 Word.word) . 
            (aset_X t w__26 \<then>
            (aget_Mem ((add_vec_int address (( 8 :: int)::ii)  ::  64 Word.word)) (( 8 :: int)::ii) acctype  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__27 ::
               64 Word.word) . 
            aset_X t2 w__27)))
        else
          (aget_Mem address dbytes acctype  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__28 ::  16 Word.word) . 
          (let data = w__28 in
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__29 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__29))))
     )))))))))))))
   else if (((((size_itself_int p_1)) = (( 32 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''destsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (data :: 32 bits) . 
     (let (rt_unknown :: bool) = False in
     (let (rn_unknown :: bool) = False in
     ((if (((((((((memop = MemOp_LOAD))) \<and> pair))) \<and> (((t = t2)))))) then
        (let (c :: Constraint) = Constraint_UNDEF in
        assert_exp ((((((Constraint_UNDEF = Constraint_UNKNOWN))) \<or> ((((((Constraint_UNDEF = Constraint_UNDEF))) \<or> (((Constraint_UNDEF = Constraint_NOP))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP)))'') \<then>
        UnallocatedEncoding () )
      else return () ) \<then>
     (if (((memop = MemOp_STORE))) then
        (if ((((((s = t))) \<or> (((pair \<and> (((s = t2))))))))) then
           (let (c :: Constraint) = Constraint_NONE in
           assert_exp ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
           return False)
         else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
        (if ((((((s = n))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
           (let (c :: Constraint) = Constraint_NONE in
           assert_exp ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
           return False)
         else return rn_unknown) \<bind> (\<lambda> (rn_unknown :: bool) . 
        return (rn_unknown, rt_unknown)))
      else return (rn_unknown, rt_unknown))) \<bind> (\<lambda> varstup .  (let ((rn_unknown :: bool), (rt_unknown ::
       bool)) = varstup in
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else if rn_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     undefined_bool ()  \<bind> (\<lambda> (secondstage :: bool) . 
     undefined_bool ()  \<bind> (\<lambda> (iswrite :: bool) . 
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)
         else if pair then
           (let v = (ex_int (((( 32 :: int)::ii) div (( 2 :: int)::ii)))) in
           (assert_exp True ('''') \<then>
           (aget_X v t  :: ( 16 Word.word) M)) \<bind> (\<lambda> el1 . 
           (aget_X ((int (size el1))) t2  :: ( 16 Word.word) M) \<bind> (\<lambda> el2 . 
           BigEndian ()  \<bind> (\<lambda> (w__34 :: bool) . 
           (let (data :: 32 bits) =
             (if w__34 then (concat_vec el1 el2  ::  32 Word.word)
             else (concat_vec el2 el1  ::  32 Word.word)) in
           return data)))))
         else (aget_X (( 32 :: int)::ii) t  :: ( 32 Word.word) M)) \<bind> (\<lambda> (data :: 32 bits) . 
        (let (status :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
        AArch64_ExclusiveMonitorsPass address dbytes \<bind> (\<lambda> (w__36 :: bool) . 
        (if w__36 then
           aset_Mem address dbytes acctype data \<then> (ExclusiveMonitorsStatus ()   :: ( 1 Word.word) M)
         else return status) \<bind> (\<lambda> (status :: 1 bits) . 
        (ZeroExtend__0 status ((make_the_value (( 32 :: int)::ii)  ::  32 itself))  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__38 ::
           32 Word.word) . 
        aset_X s w__38)))))
     | MemOp_LOAD =>
        AArch64_SetExclusiveMonitors address dbytes \<then>
        (if pair then
          assert_exp True ('''') \<then>
          (if rt_unknown then
            (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__39 ::  32 Word.word) . 
            aset_X t w__39)
          else
            ((if (((address \<noteq> ((Align__1 address dbytes  ::  64 Word.word))))) then
               (let iswrite = False in
               (let secondstage = False in
               AArch64_AlignmentFault acctype False False \<bind> (\<lambda> (w__40 :: FaultRecord) . 
               AArch64_Abort address w__40)))
             else return () ) \<then>
            (aget_Mem ((add_vec_int address (( 0 :: int)::ii)  ::  64 Word.word)) (( 8 :: int)::ii) acctype  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__41 ::
               64 Word.word) . 
            (aset_X t w__41 \<then>
            (aget_Mem ((add_vec_int address (( 8 :: int)::ii)  ::  64 Word.word)) (( 8 :: int)::ii) acctype  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__42 ::
               64 Word.word) . 
            aset_X t2 w__42)))
        else
          (aget_Mem address dbytes acctype  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__43 ::  32 Word.word) . 
          (let data = w__43 in
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__44 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__44))))
     )))))))))))))
   else if (((((size_itself_int p_1)) = (( 64 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''destsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (data :: 64 bits) . 
     (let (rt_unknown :: bool) = False in
     (let (rn_unknown :: bool) = False in
     ((if (((((((((memop = MemOp_LOAD))) \<and> pair))) \<and> (((t = t2)))))) then
        (let (c :: Constraint) = Constraint_UNDEF in
        assert_exp ((((((Constraint_UNDEF = Constraint_UNKNOWN))) \<or> ((((((Constraint_UNDEF = Constraint_UNDEF))) \<or> (((Constraint_UNDEF = Constraint_NOP))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP)))'') \<then>
        UnallocatedEncoding () )
      else return () ) \<then>
     (if (((memop = MemOp_STORE))) then
        (if ((((((s = t))) \<or> (((pair \<and> (((s = t2))))))))) then
           (let (c :: Constraint) = Constraint_NONE in
           assert_exp ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
           return False)
         else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
        (if ((((((s = n))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
           (let (c :: Constraint) = Constraint_NONE in
           assert_exp ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
           return False)
         else return rn_unknown) \<bind> (\<lambda> (rn_unknown :: bool) . 
        return (rn_unknown, rt_unknown)))
      else return (rn_unknown, rt_unknown))) \<bind> (\<lambda> varstup .  (let ((rn_unknown :: bool), (rt_unknown ::
       bool)) = varstup in
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else if rn_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     undefined_bool ()  \<bind> (\<lambda> (secondstage :: bool) . 
     undefined_bool ()  \<bind> (\<lambda> (iswrite :: bool) . 
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
         else if pair then
           (let v = (ex_int (((( 64 :: int)::ii) div (( 2 :: int)::ii)))) in
           (assert_exp True ('''') \<then>
           (aget_X v t  :: ( 32 Word.word) M)) \<bind> (\<lambda> el1 . 
           (aget_X ((int (size el1))) t2  :: ( 32 Word.word) M) \<bind> (\<lambda> el2 . 
           BigEndian ()  \<bind> (\<lambda> (w__49 :: bool) . 
           (let (data :: 64 bits) =
             (if w__49 then (concat_vec el1 el2  ::  64 Word.word)
             else (concat_vec el2 el1  ::  64 Word.word)) in
           return data)))))
         else (aget_X (( 64 :: int)::ii) t  :: ( 64 Word.word) M)) \<bind> (\<lambda> (data :: 64 bits) . 
        (let (status :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
        AArch64_ExclusiveMonitorsPass address dbytes \<bind> (\<lambda> (w__51 :: bool) . 
        (if w__51 then
           aset_Mem address dbytes acctype data \<then> (ExclusiveMonitorsStatus ()   :: ( 1 Word.word) M)
         else return status) \<bind> (\<lambda> (status :: 1 bits) . 
        (ZeroExtend__0 status ((make_the_value (( 32 :: int)::ii)  ::  32 itself))  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__53 ::
           32 Word.word) . 
        aset_X s w__53)))))
     | MemOp_LOAD =>
        AArch64_SetExclusiveMonitors address dbytes \<then>
        (if pair then
          assert_exp True ('''') \<then>
          (if rt_unknown then
            (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__54 ::  32 Word.word) . 
            aset_X t w__54)
          else if (((elsize = (( 32 :: int)::ii)))) then
            (aget_Mem address dbytes acctype  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__55 ::  64 Word.word) . 
            (let data = w__55 in
            BigEndian ()  \<bind> (\<lambda> (w__56 :: bool) . 
            if w__56 then
              aset_X t
                ((slice data (( 32 :: int)::ii) ((((- (( 32 :: int)::ii))) + (( 64 :: int)::ii)))  ::  32 Word.word)) \<then>
              aset_X t2 ((slice data (( 0 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
            else
              aset_X t ((slice data (( 0 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) \<then>
              aset_X t2
                ((slice data (( 32 :: int)::ii) ((((- (( 32 :: int)::ii))) + (( 64 :: int)::ii)))  ::  32 Word.word)))))
          else
            ((if (((address \<noteq> ((Align__1 address dbytes  ::  64 Word.word))))) then
               (let iswrite = False in
               (let secondstage = False in
               AArch64_AlignmentFault acctype False False \<bind> (\<lambda> (w__57 :: FaultRecord) . 
               AArch64_Abort address w__57)))
             else return () ) \<then>
            (aget_Mem ((add_vec_int address (( 0 :: int)::ii)  ::  64 Word.word)) (( 8 :: int)::ii) acctype  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__58 ::
               64 Word.word) . 
            (aset_X t w__58 \<then>
            (aget_Mem ((add_vec_int address (( 8 :: int)::ii)  ::  64 Word.word)) (( 8 :: int)::ii) acctype  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__59 ::
               64 Word.word) . 
            aset_X t2 w__59)))
        else
          (aget_Mem address dbytes acctype  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__60 ::  64 Word.word) . 
          (let data = w__60 in
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__61 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__61))))
     )))))))))))))
   else if (((((size_itself_int p_1)) = (( 128 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''destsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> (\<lambda> (data :: 128 bits) . 
     (let (rt_unknown :: bool) = False in
     (let (rn_unknown :: bool) = False in
     ((if (((((((((memop = MemOp_LOAD))) \<and> pair))) \<and> (((t = t2)))))) then
        (let (c :: Constraint) = Constraint_UNDEF in
        assert_exp ((((((Constraint_UNDEF = Constraint_UNKNOWN))) \<or> ((((((Constraint_UNDEF = Constraint_UNDEF))) \<or> (((Constraint_UNDEF = Constraint_NOP))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP)))'') \<then>
        UnallocatedEncoding () )
      else return () ) \<then>
     (if (((memop = MemOp_STORE))) then
        (if ((((((s = t))) \<or> (((pair \<and> (((s = t2))))))))) then
           (let (c :: Constraint) = Constraint_NONE in
           assert_exp ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
           return False)
         else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
        (if ((((((s = n))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
           (let (c :: Constraint) = Constraint_NONE in
           assert_exp ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
           return False)
         else return rn_unknown) \<bind> (\<lambda> (rn_unknown :: bool) . 
        return (rn_unknown, rt_unknown)))
      else return (rn_unknown, rt_unknown))) \<bind> (\<lambda> varstup .  (let ((rn_unknown :: bool), (rt_unknown ::
       bool)) = varstup in
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else if rn_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     undefined_bool ()  \<bind> (\<lambda> (secondstage :: bool) . 
     undefined_bool ()  \<bind> (\<lambda> (iswrite :: bool) . 
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M)
         else if pair then
           (let v = (ex_int (((( 128 :: int)::ii) div (( 2 :: int)::ii)))) in
           (assert_exp True ('''') \<then>
           (aget_X ((int (size address))) t  :: ( 64 Word.word) M)) \<bind> (\<lambda> el1 . 
           (aget_X ((int (size address))) t2  :: ( 64 Word.word) M) \<bind> (\<lambda> el2 . 
           BigEndian ()  \<bind> (\<lambda> (w__66 :: bool) . 
           (let (data :: 128 bits) =
             (if w__66 then (concat_vec el1 el2  ::  128 Word.word)
             else (concat_vec el2 el1  ::  128 Word.word)) in
           return data)))))
         else (aget_X (( 128 :: int)::ii) t  :: ( 128 Word.word) M)) \<bind> (\<lambda> (data :: 128 bits) . 
        (let (status :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
        AArch64_ExclusiveMonitorsPass address dbytes \<bind> (\<lambda> (w__68 :: bool) . 
        (if w__68 then
           aset_Mem address dbytes acctype data \<then> (ExclusiveMonitorsStatus ()   :: ( 1 Word.word) M)
         else return status) \<bind> (\<lambda> (status :: 1 bits) . 
        (ZeroExtend__0 status ((make_the_value (( 32 :: int)::ii)  ::  32 itself))  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__70 ::
           32 Word.word) . 
        aset_X s w__70)))))
     | MemOp_LOAD =>
        AArch64_SetExclusiveMonitors address dbytes \<then>
        (if pair then
          assert_exp True ('''') \<then>
          (if rt_unknown then
            (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__71 ::  32 Word.word) . 
            aset_X t w__71)
          else if (((elsize = (( 32 :: int)::ii)))) then
            (aget_Mem address dbytes acctype  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__72 ::  128 Word.word) . 
            (let data = w__72 in
            BigEndian ()  \<bind> (\<lambda> (w__73 :: bool) . 
            if w__73 then
              aset_X t
                ((slice data (( 32 :: int)::ii) ((((- (( 32 :: int)::ii))) + (( 128 :: int)::ii)))  ::  96 Word.word)) \<then>
              aset_X t2 ((slice data (( 0 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
            else
              aset_X t ((slice data (( 0 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) \<then>
              aset_X t2
                ((slice data (( 32 :: int)::ii) ((((- (( 32 :: int)::ii))) + (( 128 :: int)::ii)))  ::  96 Word.word)))))
          else
            ((if (((address \<noteq> ((Align__1 address dbytes  ::  64 Word.word))))) then
               (let iswrite = False in
               (let secondstage = False in
               AArch64_AlignmentFault acctype False False \<bind> (\<lambda> (w__74 :: FaultRecord) . 
               AArch64_Abort address w__74)))
             else return () ) \<then>
            (aget_Mem ((add_vec_int address (( 0 :: int)::ii)  ::  64 Word.word)) (( 8 :: int)::ii) acctype  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__75 ::
               64 Word.word) . 
            (aset_X t w__75 \<then>
            (aget_Mem ((add_vec_int address (( 8 :: int)::ii)  ::  64 Word.word)) (( 8 :: int)::ii) acctype  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__76 ::
               64 Word.word) . 
            aset_X t2 w__76)))
        else
          (aget_Mem address dbytes acctype  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__77 ::  128 Word.word) . 
          (let data = w__77 in
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__78 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__78))))
     )))))))))))))
   else
     (let regsize = (size_itself_int regsize) in
     (let datasize = (size_itself_int p_1) in
     assert_exp True (''destsize constraint'') \<then>
     ((let dbytes = (ex_int ((datasize div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint''))))))"


(*val memory_exclusive_single_decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_exclusive_single_decode  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_exclusive_single_decode b__0 o2 L o1 Rs o0 Rt2 Rn Rt = (
   if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (s :: ii) = (Word.uint Rs) in
     (let (acctype :: AccType) =
       (if (((o0 = (vec_of_bits [B1]  ::  1 Word.word)))) then AccType_ORDERED
       else AccType_ATOMIC) in
     (let (pair :: bool) = False in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (elsize :: ii) = ((( 8 :: int)::ii)) in
     (let (regsize :: ii) = ((( 32 :: int)::ii)) in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_exclusive_single acctype ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) (( 8 :: int)::ii) memop n
       False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) s t t2)))))))))))
   else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (s :: ii) = (Word.uint Rs) in
     (let (acctype :: AccType) =
       (if (((o0 = (vec_of_bits [B1]  ::  1 Word.word)))) then AccType_ORDERED
       else AccType_ATOMIC) in
     (let (pair :: bool) = False in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (elsize :: ii) = ((( 16 :: int)::ii)) in
     (let (regsize :: ii) = ((( 32 :: int)::ii)) in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_exclusive_single acctype ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) (( 16 :: int)::ii) memop
       n False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) s t t2)))))))))))
   else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (s :: ii) = (Word.uint Rs) in
     (let (acctype :: AccType) =
       (if (((o0 = (vec_of_bits [B1]  ::  1 Word.word)))) then AccType_ORDERED
       else AccType_ATOMIC) in
     (let (pair :: bool) = False in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (elsize :: ii) = ((( 32 :: int)::ii)) in
     (let (regsize :: ii) = ((( 32 :: int)::ii)) in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_exclusive_single acctype ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) (( 32 :: int)::ii) memop
       n False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) s t t2)))))))))))
   else
     write_reg unconditional_ref True \<then>
     ((let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (s :: ii) = (Word.uint Rs) in
     (let (acctype :: AccType) =
       (if (((o0 = (vec_of_bits [B1]  ::  1 Word.word)))) then AccType_ORDERED
       else AccType_ATOMIC) in
     (let (pair :: bool) = False in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (elsize :: ii) = ((( 64 :: int)::ii)) in
     (let (regsize :: ii) = ((( 64 :: int)::ii)) in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     aarch64_memory_exclusive_single acctype ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) (( 64 :: int)::ii) memop
       n False ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) s t t2))))))))))))"


(*val aarch64_memory_exclusive_pair : forall 'datasize 'regsize . Size 'datasize, Size 'regsize => AccType -> itself 'datasize -> integer -> MemOp -> ii -> bool -> itself 'regsize -> ii -> ii -> ii -> M unit*)

definition aarch64_memory_exclusive_pair  :: " AccType \<Rightarrow>('datasize::len)itself \<Rightarrow> int \<Rightarrow> MemOp \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>('regsize::len)itself \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_memory_exclusive_pair acctype p_1 elsize memop n pair regsize s t t2 = (
   if (((((size_itself_int p_1)) = (( 8 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 8 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> (\<lambda> (data :: 8 bits) . 
     (let (rt_unknown :: bool) = False in
     (let (rn_unknown :: bool) = False in
     ((if (((((((((memop = MemOp_LOAD))) \<and> pair))) \<and> (((t = t2)))))) then
        (let (c :: Constraint) = Constraint_UNDEF in
        assert_exp ((((((Constraint_UNDEF = Constraint_UNKNOWN))) \<or> ((((((Constraint_UNDEF = Constraint_UNDEF))) \<or> (((Constraint_UNDEF = Constraint_NOP))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP)))'') \<then>
        UnallocatedEncoding () )
      else return () ) \<then>
     (if (((memop = MemOp_STORE))) then
        (if ((((((s = t))) \<or> (((pair \<and> (((s = t2))))))))) then
           (let (c :: Constraint) = Constraint_NONE in
           assert_exp ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
           return False)
         else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
        (if ((((((s = n))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
           (let (c :: Constraint) = Constraint_NONE in
           assert_exp ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
           return False)
         else return rn_unknown) \<bind> (\<lambda> (rn_unknown :: bool) . 
        return (rn_unknown, rt_unknown)))
      else return (rn_unknown, rt_unknown))) \<bind> (\<lambda> varstup .  (let ((rn_unknown :: bool), (rt_unknown ::
       bool)) = varstup in
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else if rn_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     undefined_bool ()  \<bind> (\<lambda> (secondstage :: bool) . 
     undefined_bool ()  \<bind> (\<lambda> (iswrite :: bool) . 
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 8 :: int)::ii)  :: ( 8 Word.word) M)
         else if pair then
           (let v = (ex_int (((( 8 :: int)::ii) div (( 2 :: int)::ii)))) in
           (assert_exp True ('''') \<then>
           (aget_X ((int (size DebugException_VectorCatch))) t  :: ( 4 Word.word) M)) \<bind> (\<lambda> el1 . 
           (aget_X ((int (size DebugException_VectorCatch))) t2  :: ( 4 Word.word) M) \<bind> (\<lambda> el2 . 
           BigEndian ()  \<bind> (\<lambda> (w__4 :: bool) . 
           (let (data :: 8 bits) =
             (if w__4 then (concat_vec el1 el2  ::  8 Word.word)
             else (concat_vec el2 el1  ::  8 Word.word)) in
           return data)))))
         else (aget_X (( 8 :: int)::ii) t  :: ( 8 Word.word) M)) \<bind> (\<lambda> (data :: 8 bits) . 
        (let (status :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
        AArch64_ExclusiveMonitorsPass address dbytes \<bind> (\<lambda> (w__6 :: bool) . 
        (if w__6 then
           aset_Mem address dbytes acctype data \<then> (ExclusiveMonitorsStatus ()   :: ( 1 Word.word) M)
         else return status) \<bind> (\<lambda> (status :: 1 bits) . 
        (ZeroExtend__0 status ((make_the_value (( 32 :: int)::ii)  ::  32 itself))  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__8 ::
           32 Word.word) . 
        aset_X s w__8)))))
     | MemOp_LOAD =>
        AArch64_SetExclusiveMonitors address dbytes \<then>
        (if pair then
          assert_exp True (''datasize constraint'') \<then>
          (if rt_unknown then
            (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__9 ::  32 Word.word) . 
            aset_X t w__9)
          else
            ((if (((address \<noteq> ((Align__1 address dbytes  ::  64 Word.word))))) then
               (let iswrite = False in
               (let secondstage = False in
               AArch64_AlignmentFault acctype False False \<bind> (\<lambda> (w__10 :: FaultRecord) . 
               AArch64_Abort address w__10)))
             else return () ) \<then>
            (aget_Mem ((add_vec_int address (( 0 :: int)::ii)  ::  64 Word.word)) (( 8 :: int)::ii) acctype  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__11 ::
               64 Word.word) . 
            (aset_X t w__11 \<then>
            (aget_Mem ((add_vec_int address (( 8 :: int)::ii)  ::  64 Word.word)) (( 8 :: int)::ii) acctype  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__12 ::
               64 Word.word) . 
            aset_X t2 w__12)))
        else
          (aget_Mem address dbytes acctype  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__13 ::  8 Word.word) . 
          (let data = w__13 in
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__14 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__14))))
     )))))))))))))
   else if (((((size_itself_int p_1)) = (( 16 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 16 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (data :: 16 bits) . 
     (let (rt_unknown :: bool) = False in
     (let (rn_unknown :: bool) = False in
     ((if (((((((((memop = MemOp_LOAD))) \<and> pair))) \<and> (((t = t2)))))) then
        (let (c :: Constraint) = Constraint_UNDEF in
        assert_exp ((((((Constraint_UNDEF = Constraint_UNKNOWN))) \<or> ((((((Constraint_UNDEF = Constraint_UNDEF))) \<or> (((Constraint_UNDEF = Constraint_NOP))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP)))'') \<then>
        UnallocatedEncoding () )
      else return () ) \<then>
     (if (((memop = MemOp_STORE))) then
        (if ((((((s = t))) \<or> (((pair \<and> (((s = t2))))))))) then
           (let (c :: Constraint) = Constraint_NONE in
           assert_exp ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
           return False)
         else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
        (if ((((((s = n))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
           (let (c :: Constraint) = Constraint_NONE in
           assert_exp ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
           return False)
         else return rn_unknown) \<bind> (\<lambda> (rn_unknown :: bool) . 
        return (rn_unknown, rt_unknown)))
      else return (rn_unknown, rt_unknown))) \<bind> (\<lambda> varstup .  (let ((rn_unknown :: bool), (rt_unknown ::
       bool)) = varstup in
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else if rn_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     undefined_bool ()  \<bind> (\<lambda> (secondstage :: bool) . 
     undefined_bool ()  \<bind> (\<lambda> (iswrite :: bool) . 
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 16 :: int)::ii)  :: ( 16 Word.word) M)
         else if pair then
           (let v = (ex_int (((( 16 :: int)::ii) div (( 2 :: int)::ii)))) in
           (assert_exp True ('''') \<then>
           (aget_X v t  :: ( 8 Word.word) M)) \<bind> (\<lambda> el1 . 
           (aget_X ((int (size el1))) t2  :: ( 8 Word.word) M) \<bind> (\<lambda> el2 . 
           BigEndian ()  \<bind> (\<lambda> (w__19 :: bool) . 
           (let (data :: 16 bits) =
             (if w__19 then (concat_vec el1 el2  ::  16 Word.word)
             else (concat_vec el2 el1  ::  16 Word.word)) in
           return data)))))
         else (aget_X (( 16 :: int)::ii) t  :: ( 16 Word.word) M)) \<bind> (\<lambda> (data :: 16 bits) . 
        (let (status :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
        AArch64_ExclusiveMonitorsPass address dbytes \<bind> (\<lambda> (w__21 :: bool) . 
        (if w__21 then
           aset_Mem address dbytes acctype data \<then> (ExclusiveMonitorsStatus ()   :: ( 1 Word.word) M)
         else return status) \<bind> (\<lambda> (status :: 1 bits) . 
        (ZeroExtend__0 status ((make_the_value (( 32 :: int)::ii)  ::  32 itself))  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__23 ::
           32 Word.word) . 
        aset_X s w__23)))))
     | MemOp_LOAD =>
        AArch64_SetExclusiveMonitors address dbytes \<then>
        (if pair then
          assert_exp True (''datasize constraint'') \<then>
          (if rt_unknown then
            (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__24 ::  32 Word.word) . 
            aset_X t w__24)
          else
            ((if (((address \<noteq> ((Align__1 address dbytes  ::  64 Word.word))))) then
               (let iswrite = False in
               (let secondstage = False in
               AArch64_AlignmentFault acctype False False \<bind> (\<lambda> (w__25 :: FaultRecord) . 
               AArch64_Abort address w__25)))
             else return () ) \<then>
            (aget_Mem ((add_vec_int address (( 0 :: int)::ii)  ::  64 Word.word)) (( 8 :: int)::ii) acctype  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__26 ::
               64 Word.word) . 
            (aset_X t w__26 \<then>
            (aget_Mem ((add_vec_int address (( 8 :: int)::ii)  ::  64 Word.word)) (( 8 :: int)::ii) acctype  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__27 ::
               64 Word.word) . 
            aset_X t2 w__27)))
        else
          (aget_Mem address dbytes acctype  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__28 ::  16 Word.word) . 
          (let data = w__28 in
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__29 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__29))))
     )))))))))))))
   else if (((((size_itself_int p_1)) = (( 32 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 32 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (data :: 32 bits) . 
     (let (rt_unknown :: bool) = False in
     (let (rn_unknown :: bool) = False in
     ((if (((((((((memop = MemOp_LOAD))) \<and> pair))) \<and> (((t = t2)))))) then
        (let (c :: Constraint) = Constraint_UNDEF in
        assert_exp ((((((Constraint_UNDEF = Constraint_UNKNOWN))) \<or> ((((((Constraint_UNDEF = Constraint_UNDEF))) \<or> (((Constraint_UNDEF = Constraint_NOP))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP)))'') \<then>
        UnallocatedEncoding () )
      else return () ) \<then>
     (if (((memop = MemOp_STORE))) then
        (if ((((((s = t))) \<or> (((pair \<and> (((s = t2))))))))) then
           (let (c :: Constraint) = Constraint_NONE in
           assert_exp ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
           return False)
         else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
        (if ((((((s = n))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
           (let (c :: Constraint) = Constraint_NONE in
           assert_exp ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
           return False)
         else return rn_unknown) \<bind> (\<lambda> (rn_unknown :: bool) . 
        return (rn_unknown, rt_unknown)))
      else return (rn_unknown, rt_unknown))) \<bind> (\<lambda> varstup .  (let ((rn_unknown :: bool), (rt_unknown ::
       bool)) = varstup in
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else if rn_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     undefined_bool ()  \<bind> (\<lambda> (secondstage :: bool) . 
     undefined_bool ()  \<bind> (\<lambda> (iswrite :: bool) . 
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)
         else if pair then
           (let v = (ex_int (((( 32 :: int)::ii) div (( 2 :: int)::ii)))) in
           (assert_exp True ('''') \<then>
           (aget_X v t  :: ( 16 Word.word) M)) \<bind> (\<lambda> el1 . 
           (aget_X ((int (size el1))) t2  :: ( 16 Word.word) M) \<bind> (\<lambda> el2 . 
           BigEndian ()  \<bind> (\<lambda> (w__34 :: bool) . 
           (let (data :: 32 bits) =
             (if w__34 then (concat_vec el1 el2  ::  32 Word.word)
             else (concat_vec el2 el1  ::  32 Word.word)) in
           return data)))))
         else (aget_X (( 32 :: int)::ii) t  :: ( 32 Word.word) M)) \<bind> (\<lambda> (data :: 32 bits) . 
        (let (status :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
        AArch64_ExclusiveMonitorsPass address dbytes \<bind> (\<lambda> (w__36 :: bool) . 
        (if w__36 then
           aset_Mem address dbytes acctype data \<then> (ExclusiveMonitorsStatus ()   :: ( 1 Word.word) M)
         else return status) \<bind> (\<lambda> (status :: 1 bits) . 
        (ZeroExtend__0 status ((make_the_value (( 32 :: int)::ii)  ::  32 itself))  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__38 ::
           32 Word.word) . 
        aset_X s w__38)))))
     | MemOp_LOAD =>
        AArch64_SetExclusiveMonitors address dbytes \<then>
        (if pair then
          assert_exp True (''datasize constraint'') \<then>
          (if rt_unknown then
            (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__39 ::  32 Word.word) . 
            aset_X t w__39)
          else
            ((if (((address \<noteq> ((Align__1 address dbytes  ::  64 Word.word))))) then
               (let iswrite = False in
               (let secondstage = False in
               AArch64_AlignmentFault acctype False False \<bind> (\<lambda> (w__40 :: FaultRecord) . 
               AArch64_Abort address w__40)))
             else return () ) \<then>
            (aget_Mem ((add_vec_int address (( 0 :: int)::ii)  ::  64 Word.word)) (( 8 :: int)::ii) acctype  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__41 ::
               64 Word.word) . 
            (aset_X t w__41 \<then>
            (aget_Mem ((add_vec_int address (( 8 :: int)::ii)  ::  64 Word.word)) (( 8 :: int)::ii) acctype  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__42 ::
               64 Word.word) . 
            aset_X t2 w__42)))
        else
          (aget_Mem address dbytes acctype  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__43 ::  32 Word.word) . 
          (let data = w__43 in
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__44 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__44))))
     )))))))))))))
   else if (((((size_itself_int p_1)) = (( 64 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 64 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (data :: 64 bits) . 
     (let (rt_unknown :: bool) = False in
     (let (rn_unknown :: bool) = False in
     ((if (((((((((memop = MemOp_LOAD))) \<and> pair))) \<and> (((t = t2)))))) then
        (let (c :: Constraint) = Constraint_UNDEF in
        assert_exp ((((((Constraint_UNDEF = Constraint_UNKNOWN))) \<or> ((((((Constraint_UNDEF = Constraint_UNDEF))) \<or> (((Constraint_UNDEF = Constraint_NOP))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP)))'') \<then>
        UnallocatedEncoding () )
      else return () ) \<then>
     (if (((memop = MemOp_STORE))) then
        (if ((((((s = t))) \<or> (((pair \<and> (((s = t2))))))))) then
           (let (c :: Constraint) = Constraint_NONE in
           assert_exp ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
           return False)
         else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
        (if ((((((s = n))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
           (let (c :: Constraint) = Constraint_NONE in
           assert_exp ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
           return False)
         else return rn_unknown) \<bind> (\<lambda> (rn_unknown :: bool) . 
        return (rn_unknown, rt_unknown)))
      else return (rn_unknown, rt_unknown))) \<bind> (\<lambda> varstup .  (let ((rn_unknown :: bool), (rt_unknown ::
       bool)) = varstup in
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else if rn_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     undefined_bool ()  \<bind> (\<lambda> (secondstage :: bool) . 
     undefined_bool ()  \<bind> (\<lambda> (iswrite :: bool) . 
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
         else if pair then
           (let v = (ex_int (((( 64 :: int)::ii) div (( 2 :: int)::ii)))) in
           (assert_exp True ('''') \<then>
           (aget_X v t  :: ( 32 Word.word) M)) \<bind> (\<lambda> el1 . 
           (aget_X ((int (size el1))) t2  :: ( 32 Word.word) M) \<bind> (\<lambda> el2 . 
           BigEndian ()  \<bind> (\<lambda> (w__49 :: bool) . 
           (let (data :: 64 bits) =
             (if w__49 then (concat_vec el1 el2  ::  64 Word.word)
             else (concat_vec el2 el1  ::  64 Word.word)) in
           return data)))))
         else (aget_X (( 64 :: int)::ii) t  :: ( 64 Word.word) M)) \<bind> (\<lambda> (data :: 64 bits) . 
        (let (status :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
        AArch64_ExclusiveMonitorsPass address dbytes \<bind> (\<lambda> (w__51 :: bool) . 
        (if w__51 then
           aset_Mem address dbytes acctype data \<then> (ExclusiveMonitorsStatus ()   :: ( 1 Word.word) M)
         else return status) \<bind> (\<lambda> (status :: 1 bits) . 
        (ZeroExtend__0 status ((make_the_value (( 32 :: int)::ii)  ::  32 itself))  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__53 ::
           32 Word.word) . 
        aset_X s w__53)))))
     | MemOp_LOAD =>
        AArch64_SetExclusiveMonitors address dbytes \<then>
        (if pair then
          assert_exp True (''datasize constraint'') \<then>
          (if rt_unknown then
            (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__54 ::  32 Word.word) . 
            aset_X t w__54)
          else if (((elsize = (( 32 :: int)::ii)))) then
            (aget_Mem address dbytes acctype  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__55 ::  64 Word.word) . 
            (let data = w__55 in
            BigEndian ()  \<bind> (\<lambda> (w__56 :: bool) . 
            if w__56 then
              aset_X t
                ((slice data (( 32 :: int)::ii) ((((- (( 32 :: int)::ii))) + (( 64 :: int)::ii)))  ::  32 Word.word)) \<then>
              aset_X t2 ((slice data (( 0 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
            else
              aset_X t ((slice data (( 0 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) \<then>
              aset_X t2
                ((slice data (( 32 :: int)::ii) ((((- (( 32 :: int)::ii))) + (( 64 :: int)::ii)))  ::  32 Word.word)))))
          else
            ((if (((address \<noteq> ((Align__1 address dbytes  ::  64 Word.word))))) then
               (let iswrite = False in
               (let secondstage = False in
               AArch64_AlignmentFault acctype False False \<bind> (\<lambda> (w__57 :: FaultRecord) . 
               AArch64_Abort address w__57)))
             else return () ) \<then>
            (aget_Mem ((add_vec_int address (( 0 :: int)::ii)  ::  64 Word.word)) (( 8 :: int)::ii) acctype  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__58 ::
               64 Word.word) . 
            (aset_X t w__58 \<then>
            (aget_Mem ((add_vec_int address (( 8 :: int)::ii)  ::  64 Word.word)) (( 8 :: int)::ii) acctype  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__59 ::
               64 Word.word) . 
            aset_X t2 w__59)))
        else
          (aget_Mem address dbytes acctype  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__60 ::  64 Word.word) . 
          (let data = w__60 in
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__61 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__61))))
     )))))))))))))
   else if (((((size_itself_int p_1)) = (( 128 :: int)::ii)))) then
     (let regsize = (size_itself_int regsize) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int (((( 128 :: int)::ii) div (( 8 :: int)::ii)))) in
     ((assert_exp True (''datasize constraint'') \<then>
     assert_exp True (''dbytes constraint'')) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M) \<bind> (\<lambda> (data :: 128 bits) . 
     (let (rt_unknown :: bool) = False in
     (let (rn_unknown :: bool) = False in
     ((if (((((((((memop = MemOp_LOAD))) \<and> pair))) \<and> (((t = t2)))))) then
        (let (c :: Constraint) = Constraint_UNDEF in
        assert_exp ((((((Constraint_UNDEF = Constraint_UNKNOWN))) \<or> ((((((Constraint_UNDEF = Constraint_UNDEF))) \<or> (((Constraint_UNDEF = Constraint_NOP))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_UNDEF) || (c == Constraint_NOP)))'') \<then>
        UnallocatedEncoding () )
      else return () ) \<then>
     (if (((memop = MemOp_STORE))) then
        (if ((((((s = t))) \<or> (((pair \<and> (((s = t2))))))))) then
           (let (c :: Constraint) = Constraint_NONE in
           assert_exp ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
           return False)
         else return rt_unknown) \<bind> (\<lambda> (rt_unknown :: bool) . 
        (if ((((((s = n))) \<and> (((n \<noteq> (( 31 :: int)::ii))))))) then
           (let (c :: Constraint) = Constraint_NONE in
           assert_exp ((((((Constraint_NONE = Constraint_UNKNOWN))) \<or> ((((((Constraint_NONE = Constraint_NONE))) \<or> ((((((Constraint_NONE = Constraint_UNDEF))) \<or> (((Constraint_NONE = Constraint_NOP)))))))))))) (''((c == Constraint_UNKNOWN) || ((c == Constraint_NONE) || ((c == Constraint_UNDEF) || (c == Constraint_NOP))))'') \<then>
           return False)
         else return rn_unknown) \<bind> (\<lambda> (rn_unknown :: bool) . 
        return (rn_unknown, rt_unknown)))
      else return (rn_unknown, rt_unknown))) \<bind> (\<lambda> varstup .  (let ((rn_unknown :: bool), (rt_unknown ::
       bool)) = varstup in
     (if (((n = (( 31 :: int)::ii)))) then CheckSPAlignment ()  \<then> (aget_SP (( 64 :: int)::ii) ()   :: ( 64 Word.word) M)
      else if rn_unknown then (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)
      else (aget_X (( 64 :: int)::ii) n  :: ( 64 Word.word) M)) \<bind> (\<lambda> (address :: 64 bits) . 
     undefined_bool ()  \<bind> (\<lambda> (secondstage :: bool) . 
     undefined_bool ()  \<bind> (\<lambda> (iswrite :: bool) . 
     (case  memop of
       MemOp_STORE =>
        (if rt_unknown then (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M)
         else if pair then
           (let v = (ex_int (((( 128 :: int)::ii) div (( 2 :: int)::ii)))) in
           (assert_exp True ('''') \<then>
           (aget_X ((int (size address))) t  :: ( 64 Word.word) M)) \<bind> (\<lambda> el1 . 
           (aget_X ((int (size address))) t2  :: ( 64 Word.word) M) \<bind> (\<lambda> el2 . 
           BigEndian ()  \<bind> (\<lambda> (w__66 :: bool) . 
           (let (data :: 128 bits) =
             (if w__66 then (concat_vec el1 el2  ::  128 Word.word)
             else (concat_vec el2 el1  ::  128 Word.word)) in
           return data)))))
         else (aget_X (( 128 :: int)::ii) t  :: ( 128 Word.word) M)) \<bind> (\<lambda> (data :: 128 bits) . 
        (let (status :: 1 bits) = ((vec_of_bits [B1]  ::  1 Word.word)) in
        AArch64_ExclusiveMonitorsPass address dbytes \<bind> (\<lambda> (w__68 :: bool) . 
        (if w__68 then
           aset_Mem address dbytes acctype data \<then> (ExclusiveMonitorsStatus ()   :: ( 1 Word.word) M)
         else return status) \<bind> (\<lambda> (status :: 1 bits) . 
        (ZeroExtend__0 status ((make_the_value (( 32 :: int)::ii)  ::  32 itself))  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__70 ::
           32 Word.word) . 
        aset_X s w__70)))))
     | MemOp_LOAD =>
        AArch64_SetExclusiveMonitors address dbytes \<then>
        (if pair then
          assert_exp True (''datasize constraint'') \<then>
          (if rt_unknown then
            (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__71 ::  32 Word.word) . 
            aset_X t w__71)
          else if (((elsize = (( 32 :: int)::ii)))) then
            (aget_Mem address dbytes acctype  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__72 ::  128 Word.word) . 
            (let data = w__72 in
            BigEndian ()  \<bind> (\<lambda> (w__73 :: bool) . 
            if w__73 then
              aset_X t
                ((slice data (( 32 :: int)::ii) ((((- (( 32 :: int)::ii))) + (( 128 :: int)::ii)))  ::  96 Word.word)) \<then>
              aset_X t2 ((slice data (( 0 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
            else
              aset_X t ((slice data (( 0 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)) \<then>
              aset_X t2
                ((slice data (( 32 :: int)::ii) ((((- (( 32 :: int)::ii))) + (( 128 :: int)::ii)))  ::  96 Word.word)))))
          else
            ((if (((address \<noteq> ((Align__1 address dbytes  ::  64 Word.word))))) then
               (let iswrite = False in
               (let secondstage = False in
               AArch64_AlignmentFault acctype False False \<bind> (\<lambda> (w__74 :: FaultRecord) . 
               AArch64_Abort address w__74)))
             else return () ) \<then>
            (aget_Mem ((add_vec_int address (( 0 :: int)::ii)  ::  64 Word.word)) (( 8 :: int)::ii) acctype  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__75 ::
               64 Word.word) . 
            (aset_X t w__75 \<then>
            (aget_Mem ((add_vec_int address (( 8 :: int)::ii)  ::  64 Word.word)) (( 8 :: int)::ii) acctype  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__76 ::
               64 Word.word) . 
            aset_X t2 w__76)))
        else
          (aget_Mem address dbytes acctype  :: ( 128 Word.word) M) \<bind> (\<lambda> (w__77 ::  128 Word.word) . 
          (let data = w__77 in
          (ZeroExtend__0 data ((make_the_value regsize ))  :: (( 'regsize::len)Word.word) M) \<bind> (\<lambda> (w__78 ::
            ( 'regsize::len)Word.word) . 
          aset_X t w__78))))
     )))))))))))))
   else
     (let regsize = (size_itself_int regsize) in
     (let datasize = (size_itself_int p_1) in
     assert_exp True (''regsize constraint'') \<then>
     ((let dbytes = (ex_int ((datasize div (( 8 :: int)::ii)))) in
     assert_exp True (''datasize constraint''))))))"


(*val memory_exclusive_pair_decode : mword ty1 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_exclusive_pair_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_exclusive_pair_decode b__0 o2 L o1 Rs o0 Rt2 Rn Rt = (
   if (((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (s :: ii) = (Word.uint Rs) in
     (let (acctype :: AccType) =
       (if (((o0 = (vec_of_bits [B1]  ::  1 Word.word)))) then AccType_ORDERED
       else AccType_ATOMIC) in
     (let (pair :: bool) = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (elsize :: ii) = ((( 32 :: int)::ii)) in
     (let (regsize :: ii) = ((( 32 :: int)::ii)) in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     aarch64_memory_exclusive_pair acctype ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) (( 32 :: int)::ii) memop n
       True ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) s t t2)))))))))))
   else
     write_reg unconditional_ref True \<then>
     ((let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (s :: ii) = (Word.uint Rs) in
     (let (acctype :: AccType) =
       (if (((o0 = (vec_of_bits [B1]  ::  1 Word.word)))) then AccType_ORDERED
       else AccType_ATOMIC) in
     (let (pair :: bool) = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (elsize :: ii) = ((( 64 :: int)::ii)) in
     (let (regsize :: ii) = ((( 64 :: int)::ii)) in
     (let (datasize :: ii) = ((( 128 :: int)::ii)) in
     aarch64_memory_exclusive_pair acctype ((make_the_value (( 128 :: int)::ii)  ::  128 itself)) (( 64 :: int)::ii) memop
       n True ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) s t t2))))))))))))"


(*val aarch64_integer_crc : bool -> ii -> ii -> ii -> integer -> M unit*)

definition aarch64_integer_crc  :: " bool \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_integer_crc crc32c d m n l__16 = (
   if (((l__16 = (( 8 :: int)::ii)))) then
     ((assert_exp True ('''') \<then>
     (if ((\<not> ((HaveCRCExt () )))) then UnallocatedEncoding () 
      else return () )) \<then>
     (aget_X (( 32 :: int)::ii) n  :: ( 32 Word.word) M)) \<bind> (\<lambda> (acc1 :: 32 bits) . 
     (aget_X (( 8 :: int)::ii) m  :: ( 8 Word.word) M) \<bind> (\<lambda> (val_name :: 8 bits) . 
     (let (poly :: 32 bits) =
       ((GetSlice_int ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
          (if crc32c then (( 517762881 :: int)::ii)
           else (( 79764919 :: int)::ii)) (( 0 :: int)::ii)
         ::  32 Word.word)) in
     (BitReverse acc1  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 ::  32 Word.word) . 
     (let (tempacc :: 40 bits) =
       ((concat_vec w__0 ((Zeros__0 ((make_the_value (( 8 :: int)::ii)  ::  8 itself))  ::  8 Word.word))
         ::  40 Word.word)) in
     (BitReverse val_name  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__1 ::  8 Word.word) . 
     (let (tempval :: 40 bits) =
       ((concat_vec w__1 ((Zeros__0 ((make_the_value (( 32 :: int)::ii)  ::  32 itself))  ::  32 Word.word))
         ::  40 Word.word)) in
     (Poly32Mod2 ((xor_vec tempacc tempval  ::  40 Word.word)) poly  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__2 ::
        32 Word.word) . 
     (BitReverse w__2  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__3 ::  32 Word.word) .  aset_X d w__3)))))))))
   else if (((l__16 = (( 16 :: int)::ii)))) then
     ((assert_exp True ('''') \<then>
     (if ((\<not> ((HaveCRCExt () )))) then UnallocatedEncoding () 
      else return () )) \<then>
     (aget_X (( 32 :: int)::ii) n  :: ( 32 Word.word) M)) \<bind> (\<lambda> (acc1 :: 32 bits) . 
     (aget_X (( 16 :: int)::ii) m  :: ( 16 Word.word) M) \<bind> (\<lambda> (val_name :: 16 bits) . 
     (let (poly :: 32 bits) =
       ((GetSlice_int ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
          (if crc32c then (( 517762881 :: int)::ii)
           else (( 79764919 :: int)::ii)) (( 0 :: int)::ii)
         ::  32 Word.word)) in
     (BitReverse acc1  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__4 ::  32 Word.word) . 
     (let (tempacc :: 48 bits) =
       ((concat_vec w__4 ((Zeros__0 ((make_the_value (( 16 :: int)::ii)  ::  16 itself))  ::  16 Word.word))
         ::  48 Word.word)) in
     (BitReverse val_name  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__5 ::  16 Word.word) . 
     (let (tempval :: 48 bits) =
       ((concat_vec w__5 ((Zeros__0 ((make_the_value (( 32 :: int)::ii)  ::  32 itself))  ::  32 Word.word))
         ::  48 Word.word)) in
     (Poly32Mod2 ((xor_vec tempacc tempval  ::  48 Word.word)) poly  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__6 ::
        32 Word.word) . 
     (BitReverse w__6  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__7 ::  32 Word.word) .  aset_X d w__7)))))))))
   else if (((l__16 = (( 32 :: int)::ii)))) then
     ((assert_exp True ('''') \<then>
     (if ((\<not> ((HaveCRCExt () )))) then UnallocatedEncoding () 
      else return () )) \<then>
     (aget_X (( 32 :: int)::ii) n  :: ( 32 Word.word) M)) \<bind> (\<lambda> (acc1 :: 32 bits) . 
     (aget_X (( 32 :: int)::ii) m  :: ( 32 Word.word) M) \<bind> (\<lambda> (val_name :: 32 bits) . 
     (let (poly :: 32 bits) =
       ((GetSlice_int ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
          (if crc32c then (( 517762881 :: int)::ii)
           else (( 79764919 :: int)::ii)) (( 0 :: int)::ii)
         ::  32 Word.word)) in
     (BitReverse acc1  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__8 ::  32 Word.word) . 
     (let (tempacc :: 64 bits) =
       ((concat_vec w__8 ((Zeros__0 ((make_the_value (( 32 :: int)::ii)  ::  32 itself))  ::  32 Word.word))
         ::  64 Word.word)) in
     (BitReverse val_name  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__9 ::  32 Word.word) . 
     (let (tempval :: 64 bits) =
       ((concat_vec w__9 ((Zeros__0 ((make_the_value (( 32 :: int)::ii)  ::  32 itself))  ::  32 Word.word))
         ::  64 Word.word)) in
     (Poly32Mod2 ((xor_vec tempacc tempval  ::  64 Word.word)) poly  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__10 ::
        32 Word.word) . 
     (BitReverse w__10  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__11 ::  32 Word.word) .  aset_X d w__11)))))))))
   else if (((l__16 = (( 64 :: int)::ii)))) then
     ((assert_exp True ('''') \<then>
     (if ((\<not> ((HaveCRCExt () )))) then UnallocatedEncoding () 
      else return () )) \<then>
     (aget_X (( 32 :: int)::ii) n  :: ( 32 Word.word) M)) \<bind> (\<lambda> (acc1 :: 32 bits) . 
     (aget_X (( 64 :: int)::ii) m  :: ( 64 Word.word) M) \<bind> (\<lambda> (val_name :: 64 bits) . 
     (let (poly :: 32 bits) =
       ((GetSlice_int ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
          (if crc32c then (( 517762881 :: int)::ii)
           else (( 79764919 :: int)::ii)) (( 0 :: int)::ii)
         ::  32 Word.word)) in
     (BitReverse acc1  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__12 ::  32 Word.word) . 
     (let (tempacc :: 96 bits) =
       ((concat_vec w__12 ((Zeros__0 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  ::  64 Word.word))
         ::  96 Word.word)) in
     (BitReverse val_name  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__13 ::  64 Word.word) . 
     (let (tempval :: 96 bits) =
       ((concat_vec w__13 ((Zeros__0 ((make_the_value (( 32 :: int)::ii)  ::  32 itself))  ::  32 Word.word))
         ::  96 Word.word)) in
     (Poly32Mod2 ((xor_vec tempacc tempval  ::  96 Word.word)) poly  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__14 ::
        32 Word.word) . 
     (BitReverse w__14  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__15 ::  32 Word.word) .  aset_X d w__15)))))))))
   else assert_exp True (''''))"


(*val system_exceptions_debug_exception_decode : mword ty3 -> mword ty16 -> mword ty3 -> mword ty2 -> M unit*)

definition system_exceptions_debug_exception_decode  :: "(3)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " system_exceptions_debug_exception_decode opc imm16 op2 LL = (
   write_reg unconditional_ref True \<then>
   ((let (target_level :: 2 bits) = LL in
   ((if (((LL = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then UnallocatedEncoding () 
    else return () ) \<then>
   Halted () ) \<bind> (\<lambda> (w__0 :: bool) . 
   (if ((\<not> w__0)) then AArch64_UndefinedFault () 
    else return () ) \<then>
   aarch64_system_exceptions_debug_exception target_level))))"


(*val system_barriers_decode : mword ty1 -> mword ty2 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty2 -> mword ty5 -> M unit*)

definition system_barriers_decode  :: "(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " system_barriers_decode L op0 op1 CRn CRm opc Rt = (
   (write_reg unconditional_ref True \<then>
   undefined_MemBarrierOp () ) \<bind> (\<lambda> (op1 :: MemBarrierOp) . 
   undefined_MBReqDomain ()  \<bind> (\<lambda> (domain1 :: MBReqDomain) . 
   undefined_MBReqTypes ()  \<bind> (\<lambda> (types1 :: MBReqTypes) . 
   (let b__0 = opc in
   (if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then return MemBarrierOp_DSB
    else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then return MemBarrierOp_DMB
    else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then return MemBarrierOp_ISB
    else UnallocatedEncoding ()  \<then> return op1) \<bind> (\<lambda> (op1 :: MemBarrierOp) . 
   (let b__3 = ((slice CRm (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) in
   (let (domain1 :: MBReqDomain) =
     (if (((b__3 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then MBReqDomain_OuterShareable
     else if (((b__3 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then MBReqDomain_Nonshareable
     else if (((b__3 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then MBReqDomain_InnerShareable
     else MBReqDomain_FullSystem) in
   (let b__7 = ((slice CRm (( 0 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) in
   (let ((domain1 :: MBReqDomain), (types1 :: MBReqTypes)) =
     (if (((b__7 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
       (let (types1 :: MBReqTypes) = MBReqTypes_Reads in
       (domain1, types1))
     else
       (let ((domain1 :: MBReqDomain), (types1 :: MBReqTypes)) =
         (if (((b__7 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
           (let (types1 :: MBReqTypes) = MBReqTypes_Writes in
           (domain1, types1))
         else
           (let ((domain1 :: MBReqDomain), (types1 :: MBReqTypes)) =
             (if (((b__7 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) then
               (let (types1 :: MBReqTypes) = MBReqTypes_All in
               (domain1, types1))
             else
               (let (types1 :: MBReqTypes) = MBReqTypes_All in
               (let (domain1 :: MBReqDomain) = MBReqDomain_FullSystem in
               (domain1, types1)))) in
           (domain1, types1))) in
       (domain1, types1))) in
   return ((aarch64_system_barriers domain1 op1 types1))))))))))))"


(*val memory_vector_single_postinc_aarch64_memory_vector_single_nowb__decode : mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty3 -> mword ty1 -> mword ty2 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_vector_single_postinc_aarch64_memory_vector_single_nowb__decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_vector_single_postinc_aarch64_memory_vector_single_nowb__decode b__0 L R1 Rm b__1 S b__2 Rn Rt = (
   if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0,B0]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 m memop n False ((ex_int selem)) t True))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0,B1]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 m memop n False ((ex_int selem)) t True))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1,B0]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 m memop n False ((ex_int selem)) t True))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1,B1]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 m memop n False ((ex_int selem)) t True))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0,B0]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 m memop n False ((ex_int selem)) t True))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0,B1]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 m memop n False ((ex_int selem)) t True))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1,B0]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 m memop n False ((ex_int selem)) t True))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1,B1]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 m memop n False ((ex_int selem)) t True))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 m memop n False ((ex_int selem)) t True))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 m memop n False ((ex_int selem)) t True)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 m memop n False ((ex_int selem)) t True))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 m memop n False ((ex_int selem)) t True)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 m memop n False ((ex_int selem)) t True))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 m memop n False ((ex_int selem)) t True)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 m memop n False ((ex_int selem)) t True))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 m memop n False ((ex_int selem)) t True)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 = (Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) index1 m memop n False ((ex_int selem)) t True))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let index1 = ((( 0 :: int)::ii)) in
     (let scale = ((( 3 :: int)::ii)) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 64 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) (( 0 :: int)::ii) m memop n False ((ex_int selem)) t True))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let index1 = (Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) index1 m memop n False ((ex_int selem)) t True)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (UnallocatedEncoding ()  \<then>
     (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then UnallocatedEncoding () 
      else return () )) \<then>
     ((let index1 = ((( 0 :: int)::ii)) in
     (let scale = ((( 3 :: int)::ii)) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 64 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) (( 0 :: int)::ii) m memop n False ((ex_int selem)) t True))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 = (Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) index1 m memop n False ((ex_int selem)) t True))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let index1 = ((( 0 :: int)::ii)) in
     (let scale = ((( 3 :: int)::ii)) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 64 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) (( 0 :: int)::ii) m memop n False ((ex_int selem)) t True))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let index1 = (Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) index1 m memop n False ((ex_int selem)) t True)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (UnallocatedEncoding ()  \<then>
     (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then UnallocatedEncoding () 
      else return () )) \<then>
     ((let index1 = ((( 0 :: int)::ii)) in
     (let scale = ((( 3 :: int)::ii)) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 64 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) (( 0 :: int)::ii) m memop n False ((ex_int selem)) t True))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 0 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__0 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) w__0 m memop n True ((ex_int selem)) t True)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 1 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__1 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) w__1 m memop n True ((ex_int selem)) t True)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 2 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 32 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__2 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) w__2 m memop n True ((ex_int selem)) t True)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 3 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 64 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__3 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) w__3 m memop n True ((ex_int selem)) t True)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 0 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__4 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) w__4 m memop n True ((ex_int selem)) t True)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 1 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__5 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) w__5 m memop n True ((ex_int selem)) t True)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 2 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 32 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__6 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) w__6 m memop n True ((ex_int selem)) t True)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 3 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 64 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__7 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) w__7 m memop n True ((ex_int selem)) t True)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0,B0]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 m memop n False ((ex_int selem)) t True))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0,B1]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 m memop n False ((ex_int selem)) t True))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1,B0]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 m memop n False ((ex_int selem)) t True))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1,B1]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 m memop n False ((ex_int selem)) t True))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0,B0]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 m memop n False ((ex_int selem)) t True))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0,B1]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 m memop n False ((ex_int selem)) t True))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1,B0]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 m memop n False ((ex_int selem)) t True))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1,B1]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 m memop n False ((ex_int selem)) t True))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 m memop n False ((ex_int selem)) t True))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 m memop n False ((ex_int selem)) t True)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 m memop n False ((ex_int selem)) t True))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 m memop n False ((ex_int selem)) t True)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 m memop n False ((ex_int selem)) t True))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 m memop n False ((ex_int selem)) t True)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 m memop n False ((ex_int selem)) t True))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 m memop n False ((ex_int selem)) t True)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 = (Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) index1 m memop n False ((ex_int selem)) t True))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let index1 = ((( 1 :: int)::ii)) in
     (let scale = ((( 3 :: int)::ii)) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 64 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) (( 1 :: int)::ii) m memop n False ((ex_int selem)) t True))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let index1 = (Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) index1 m memop n False ((ex_int selem)) t True)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (UnallocatedEncoding ()  \<then>
     (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then UnallocatedEncoding () 
      else return () )) \<then>
     ((let index1 = ((( 1 :: int)::ii)) in
     (let scale = ((( 3 :: int)::ii)) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 64 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) (( 1 :: int)::ii) m memop n False ((ex_int selem)) t True))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 = (Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) index1 m memop n False ((ex_int selem)) t True))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let index1 = ((( 1 :: int)::ii)) in
     (let scale = ((( 3 :: int)::ii)) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 64 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) (( 1 :: int)::ii) m memop n False ((ex_int selem)) t True))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let index1 = (Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) index1 m memop n False ((ex_int selem)) t True)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (UnallocatedEncoding ()  \<then>
     (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then UnallocatedEncoding () 
      else return () )) \<then>
     ((let index1 = ((( 1 :: int)::ii)) in
     (let scale = ((( 3 :: int)::ii)) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 64 :: int)::ii)) in
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) (( 1 :: int)::ii) m memop n False ((ex_int selem)) t True))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 0 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__8 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) w__8 m memop n True ((ex_int selem)) t True)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 1 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__9 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) w__9 m memop n True ((ex_int selem)) t True)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 2 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 32 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__10 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) w__10 m memop n True ((ex_int selem)) t True)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 3 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 64 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__11 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) w__11 m memop n True ((ex_int selem)) t True)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 0 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__12 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) w__12 m memop n True ((ex_int selem)) t True)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 1 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__13 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) w__13 m memop n True ((ex_int selem)) t True)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 2 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 32 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__14 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) w__14 m memop n True ((ex_int selem)) t True)))))))))))))))
   else
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 3 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 64 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__15 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) w__15 m memop n True ((ex_int selem)) t True))))))))))))))))"


(*val memory_vector_single_nowb_aarch64_memory_vector_single_nowb__decode : mword ty1 -> mword ty1 -> mword ty1 -> mword ty3 -> mword ty1 -> mword ty2 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_vector_single_nowb_aarch64_memory_vector_single_nowb__decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_vector_single_nowb_aarch64_memory_vector_single_nowb__decode b__0 L R1 b__1 S b__2 Rn Rt = (
   if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0,B0]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__0 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 w__0 memop n False ((ex_int selem)) t False)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0,B1]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__1 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 w__1 memop n False ((ex_int selem)) t False)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1,B0]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__2 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 w__2 memop n False ((ex_int selem)) t False)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1,B1]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__3 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 w__3 memop n False ((ex_int selem)) t False)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0,B0]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__4 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 w__4 memop n False ((ex_int selem)) t False)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0,B1]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__5 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 w__5 memop n False ((ex_int selem)) t False)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1,B0]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__6 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 w__6 memop n False ((ex_int selem)) t False)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1,B1]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__7 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 w__7 memop n False ((ex_int selem)) t False)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__8 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 w__8 memop n False ((ex_int selem)) t False)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__9 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 w__9 memop n False ((ex_int selem)) t False))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__10 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 w__10 memop n False ((ex_int selem)) t False)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__11 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 w__11 memop n False ((ex_int selem)) t False))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__12 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 w__12 memop n False ((ex_int selem)) t False)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__13 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 w__13 memop n False ((ex_int selem)) t False))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__14 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 w__14 memop n False ((ex_int selem)) t False)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__15 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 w__15 memop n False ((ex_int selem)) t False))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 = (Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 32 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__16 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) index1 w__16 memop n False ((ex_int selem)) t False)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let index1 = ((( 0 :: int)::ii)) in
     (let scale = ((( 3 :: int)::ii)) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 64 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__17 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) (( 0 :: int)::ii) w__17 memop n False ((ex_int selem)) t False)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let index1 = (Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 32 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__18 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) index1 w__18 memop n False ((ex_int selem)) t False))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (UnallocatedEncoding ()  \<then>
     (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then UnallocatedEncoding () 
      else return () )) \<then>
     ((let index1 = ((( 0 :: int)::ii)) in
     (let scale = ((( 3 :: int)::ii)) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 64 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__19 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) (( 0 :: int)::ii) w__19 memop n False ((ex_int selem)) t False)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 = (Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 32 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__20 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) index1 w__20 memop n False ((ex_int selem)) t False)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let index1 = ((( 0 :: int)::ii)) in
     (let scale = ((( 3 :: int)::ii)) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 64 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__21 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) (( 0 :: int)::ii) w__21 memop n False ((ex_int selem)) t False)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let index1 = (Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) S  ::  2 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 32 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__22 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) index1 w__22 memop n False ((ex_int selem)) t False))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (UnallocatedEncoding ()  \<then>
     (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then UnallocatedEncoding () 
      else return () )) \<then>
     ((let index1 = ((( 0 :: int)::ii)) in
     (let scale = ((( 3 :: int)::ii)) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 64 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__23 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) (( 0 :: int)::ii) w__23 memop n False ((ex_int selem)) t False)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 0 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__24 :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (w__25 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) w__24 w__25 memop n True ((ex_int selem)) t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 1 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__26 :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (w__27 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) w__26 w__27 memop n True ((ex_int selem)) t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 2 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 32 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__28 :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (w__29 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) w__28 w__29 memop n True ((ex_int selem)) t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 3 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 64 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__30 :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (w__31 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) w__30 w__31 memop n True ((ex_int selem)) t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 0 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__32 :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (w__33 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) w__32 w__33 memop n True ((ex_int selem)) t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 1 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__34 :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (w__35 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) w__34 w__35 memop n True ((ex_int selem)) t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 2 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 32 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__36 :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (w__37 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) w__36 w__37 memop n True ((ex_int selem)) t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 3 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 64 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__38 :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (w__39 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) w__38 w__39 memop n True ((ex_int selem)) t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0,B0]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__40 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 w__40 memop n False ((ex_int selem)) t False)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0,B1]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__41 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 w__41 memop n False ((ex_int selem)) t False)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1,B0]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__42 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 w__42 memop n False ((ex_int selem)) t False)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1,B1]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__43 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 w__43 memop n False ((ex_int selem)) t False)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0,B0]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__44 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 w__44 memop n False ((ex_int selem)) t False)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0,B1]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__45 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 w__45 memop n False ((ex_int selem)) t False)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1,B0]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__46 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 w__46 memop n False ((ex_int selem)) t False)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1,B1]  ::  2 Word.word)
            ::  4 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__47 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) index1 w__47 memop n False ((ex_int selem)) t False)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__48 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 w__48 memop n False ((ex_int selem)) t False)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__49 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 w__49 memop n False ((ex_int selem)) t False))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__50 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 w__50 memop n False ((ex_int selem)) t False)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__51 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 w__51 memop n False ((ex_int selem)) t False))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__52 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 w__52 memop n False ((ex_int selem)) t False)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B0]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__53 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 w__53 memop n False ((ex_int selem)) t False))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__54 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 w__54 memop n False ((ex_int selem)) t False)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let index1 =
       (Word.uint ((concat_vec ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))
             (vec_of_bits [B1]  ::  1 Word.word)
            ::  3 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__55 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) index1 w__55 memop n False ((ex_int selem)) t False))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 = (Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 32 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__56 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) index1 w__56 memop n False ((ex_int selem)) t False)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let index1 = ((( 1 :: int)::ii)) in
     (let scale = ((( 3 :: int)::ii)) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 64 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__57 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) (( 1 :: int)::ii) w__57 memop n False ((ex_int selem)) t False)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let index1 = (Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 32 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__58 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) index1 w__58 memop n False ((ex_int selem)) t False))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (UnallocatedEncoding ()  \<then>
     (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then UnallocatedEncoding () 
      else return () )) \<then>
     ((let index1 = ((( 1 :: int)::ii)) in
     (let scale = ((( 3 :: int)::ii)) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 64 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__59 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) (( 1 :: int)::ii) w__59 memop n False ((ex_int selem)) t False)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (let index1 = (Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 32 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__60 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) index1 w__60 memop n False ((ex_int selem)) t False)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let index1 = ((( 1 :: int)::ii)) in
     (let scale = ((( 3 :: int)::ii)) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 64 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__61 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) (( 1 :: int)::ii) w__61 memop n False ((ex_int selem)) t False)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let index1 = (Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) S  ::  2 Word.word))) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 32 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__62 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) index1 w__62 memop n False ((ex_int selem)) t False))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (UnallocatedEncoding ()  \<then>
     (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then UnallocatedEncoding () 
      else return () )) \<then>
     ((let index1 = ((( 1 :: int)::ii)) in
     (let scale = ((( 3 :: int)::ii)) in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 64 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__63 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) (( 1 :: int)::ii) w__63 memop n False ((ex_int selem)) t False)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 0 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__64 :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (w__65 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) w__64 w__65 memop n True ((ex_int selem)) t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 1 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__66 :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (w__67 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) w__66 w__67 memop n True ((ex_int selem)) t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 2 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 32 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__68 :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (w__69 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) w__68 w__69 memop n True ((ex_int selem)) t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 3 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 64 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__70 :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (w__71 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) w__70 w__71 memop n True ((ex_int selem)) t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 0 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__72 :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (w__73 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) w__72 w__73 memop n True ((ex_int selem)) t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 1 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__74 :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (w__75 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) w__74 w__75 memop n True ((ex_int selem)) t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((b__1 = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> (((b__2 = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 2 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 32 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__76 :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (w__77 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) w__76 w__77 memop n True ((ex_int selem)) t False))))))))))))))))
   else
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (selem :: ii) =
       (((Word.uint ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) R1  ::  2 Word.word)))) + (( 1 :: int)::ii)) in
     (let (replicate1 :: bool) = False in
     undefined_int ()  \<bind> (\<lambda> (index1 :: ii) . 
     (if ((((((L = (vec_of_bits [B0]  ::  1 Word.word)))) \<or> (((S = (vec_of_bits [B1]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let scale = ((( 3 :: int)::ii)) in
     (let replicate1 = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 64 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (w__78 :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (w__79 :: ii) . 
     aarch64_memory_vector_single_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) w__78 w__79 memop n True ((ex_int selem)) t False)))))))))))))))))"


(*val memory_single_simdfp_register_aarch64_memory_single_simdfp_register__decode : mword ty2 -> mword ty1 -> mword ty2 -> mword ty5 -> mword ty3 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_single_simdfp_register_aarch64_memory_single_simdfp_register__decode  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_single_simdfp_register_aarch64_memory_single_simdfp_register__decode size1 V1 opc Rm option_name S Rn Rt = (
   write_reg unconditional_ref True \<then>
   ((let (wback :: bool) = False in
   (let (postindex :: bool) = False in
   (let (scale :: ii) =
     (Word.uint ((concat_vec (vec_of_bits [access_vec_dec opc (( 1 :: int)::ii)]  ::  1 Word.word) size1  ::  3 Word.word))) in
   ((if ((((ex_int scale)) > (( 4 :: int)::ii))) then UnallocatedEncoding () 
    else return () ) \<then>
   (if ((((vec_of_bits [access_vec_dec option_name (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))) then
      UnallocatedEncoding () 
    else return () )) \<then>
   ((let (extend_type :: ExtendType) = (DecodeRegExtend option_name) in
   (let (shift :: ii) = (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then scale else (( 0 :: int)::ii)) in
   (let (n :: ii) = (Word.uint Rn) in
   (let (t :: ii) = (Word.uint Rt) in
   (let (m :: ii) = (Word.uint Rm) in
   (let (acctype :: AccType) = AccType_VEC in
   (let (memop :: MemOp) =
     (if ((((vec_of_bits [access_vec_dec opc (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
       MemOp_LOAD
     else MemOp_STORE) in
   (let (datasize :: ii) = (shl_int (( 8 :: int)::ii) scale) in
   aarch64_memory_single_simdfp_register acctype datasize extend_type m memop n postindex shift t
     wback))))))))))))))"


(*val memory_single_simdfp_immediate_unsigned_aarch64_memory_single_simdfp_immediate_signed_postidx__decode : mword ty2 -> mword ty1 -> mword ty2 -> mword ty12 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_single_simdfp_immediate_unsigned_aarch64_memory_single_simdfp_immediate_signed_postidx__decode  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_single_simdfp_immediate_unsigned_aarch64_memory_single_simdfp_immediate_signed_postidx__decode size1 V1 opc imm12 Rn Rt = (
   write_reg unconditional_ref True \<then>
   ((let (wback :: bool) = False in
   (let (postindex :: bool) = False in
   (let (scale :: ii) =
     (Word.uint ((concat_vec (vec_of_bits [access_vec_dec opc (( 1 :: int)::ii)]  ::  1 Word.word) size1  ::  3 Word.word))) in
   ((if ((((ex_int scale)) > (( 4 :: int)::ii))) then UnallocatedEncoding () 
    else return () ) \<then>
   (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__0 ::
      64 Word.word) . 
   (LSL w__0 scale  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
   (let (n :: ii) = (Word.uint Rn) in
   (let (t :: ii) = (Word.uint Rt) in
   (let (acctype :: AccType) = AccType_VEC in
   (let (memop :: MemOp) =
     (if ((((vec_of_bits [access_vec_dec opc (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
       MemOp_LOAD
     else MemOp_STORE) in
   (let (datasize :: ii) = (shl_int (( 8 :: int)::ii) scale) in
   aarch64_memory_single_simdfp_immediate_signed_postidx acctype datasize memop n offset postindex t
     wback))))))))))))"


(*val memory_single_simdfp_immediate_signed_preidx_aarch64_memory_single_simdfp_immediate_signed_postidx__decode : mword ty2 -> mword ty1 -> mword ty2 -> mword ty9 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_single_simdfp_immediate_signed_preidx_aarch64_memory_single_simdfp_immediate_signed_postidx__decode  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(9)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_single_simdfp_immediate_signed_preidx_aarch64_memory_single_simdfp_immediate_signed_postidx__decode size1 V1 opc imm9 Rn Rt = (
   write_reg unconditional_ref True \<then>
   ((let (wback :: bool) = True in
   (let (postindex :: bool) = False in
   (let (scale :: ii) =
     (Word.uint ((concat_vec (vec_of_bits [access_vec_dec opc (( 1 :: int)::ii)]  ::  1 Word.word) size1  ::  3 Word.word))) in
   ((if ((((ex_int scale)) > (( 4 :: int)::ii))) then UnallocatedEncoding () 
    else return () ) \<then>
   (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M)) \<bind> (\<lambda> (offset :: 64
     bits) . 
   (let (n :: ii) = (Word.uint Rn) in
   (let (t :: ii) = (Word.uint Rt) in
   (let (acctype :: AccType) = AccType_VEC in
   (let (memop :: MemOp) =
     (if ((((vec_of_bits [access_vec_dec opc (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
       MemOp_LOAD
     else MemOp_STORE) in
   (let (datasize :: ii) = (shl_int (( 8 :: int)::ii) scale) in
   aarch64_memory_single_simdfp_immediate_signed_postidx acctype datasize memop n offset postindex t
     wback)))))))))))"


(*val memory_single_simdfp_immediate_signed_postidx_aarch64_memory_single_simdfp_immediate_signed_postidx__decode : mword ty2 -> mword ty1 -> mword ty2 -> mword ty9 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_single_simdfp_immediate_signed_postidx_aarch64_memory_single_simdfp_immediate_signed_postidx__decode  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(9)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_single_simdfp_immediate_signed_postidx_aarch64_memory_single_simdfp_immediate_signed_postidx__decode size1 V1 opc imm9 Rn Rt = (
   write_reg unconditional_ref True \<then>
   ((let (wback :: bool) = True in
   (let (postindex :: bool) = True in
   (let (scale :: ii) =
     (Word.uint ((concat_vec (vec_of_bits [access_vec_dec opc (( 1 :: int)::ii)]  ::  1 Word.word) size1  ::  3 Word.word))) in
   ((if ((((ex_int scale)) > (( 4 :: int)::ii))) then UnallocatedEncoding () 
    else return () ) \<then>
   (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M)) \<bind> (\<lambda> (offset :: 64
     bits) . 
   (let (n :: ii) = (Word.uint Rn) in
   (let (t :: ii) = (Word.uint Rt) in
   (let (acctype :: AccType) = AccType_VEC in
   (let (memop :: MemOp) =
     (if ((((vec_of_bits [access_vec_dec opc (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
       MemOp_LOAD
     else MemOp_STORE) in
   (let (datasize :: ii) = (shl_int (( 8 :: int)::ii) scale) in
   aarch64_memory_single_simdfp_immediate_signed_postidx acctype datasize memop n offset postindex t
     wback)))))))))))"


(*val memory_single_simdfp_immediate_signed_offset_normal_aarch64_memory_single_simdfp_immediate_signed_offset_normal__decode : mword ty2 -> mword ty1 -> mword ty2 -> mword ty9 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_single_simdfp_immediate_signed_offset_normal_aarch64_memory_single_simdfp_immediate_signed_offset_normal__decode  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(9)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_single_simdfp_immediate_signed_offset_normal_aarch64_memory_single_simdfp_immediate_signed_offset_normal__decode size1 V1 opc imm9 Rn Rt = (
   write_reg unconditional_ref True \<then>
   ((let (wback :: bool) = False in
   (let (postindex :: bool) = False in
   (let (scale :: ii) =
     (Word.uint ((concat_vec (vec_of_bits [access_vec_dec opc (( 1 :: int)::ii)]  ::  1 Word.word) size1  ::  3 Word.word))) in
   ((if ((((ex_int scale)) > (( 4 :: int)::ii))) then UnallocatedEncoding () 
    else return () ) \<then>
   (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M)) \<bind> (\<lambda> (offset :: 64
     bits) . 
   (let (n :: ii) = (Word.uint Rn) in
   (let (t :: ii) = (Word.uint Rt) in
   (let (acctype :: AccType) = AccType_VEC in
   (let (memop :: MemOp) =
     (if ((((vec_of_bits [access_vec_dec opc (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
       MemOp_LOAD
     else MemOp_STORE) in
   (let (datasize :: ii) = (shl_int (( 8 :: int)::ii) scale) in
   aarch64_memory_single_simdfp_immediate_signed_offset_normal acctype datasize memop n offset
     postindex t wback)))))))))))"


(*val memory_single_general_register_aarch64_memory_single_general_register__decode : mword ty2 -> mword ty1 -> mword ty2 -> mword ty5 -> mword ty3 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_single_general_register_aarch64_memory_single_general_register__decode  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_single_general_register_aarch64_memory_single_general_register__decode b__0 V1 b__1 Rm option_name S Rn Rt = (
   if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (extend_type :: ExtendType) = (DecodeRegExtend option_name) in
     (let (shift :: ii) = (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 0 :: int)::ii) else (( 0 :: int)::ii)) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_STORE in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_single_general_register AccType_NORMAL (( 8 :: int)::ii) extend_type m MemOp_STORE n False
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) shift False t False))))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (extend_type :: ExtendType) = (DecodeRegExtend option_name) in
     (let (shift :: ii) = (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 0 :: int)::ii) else (( 0 :: int)::ii)) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_single_general_register AccType_NORMAL (( 8 :: int)::ii) extend_type m MemOp_LOAD n False
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) shift False t False))))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (extend_type :: ExtendType) = (DecodeRegExtend option_name) in
     (let (shift :: ii) = (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 0 :: int)::ii) else (( 0 :: int)::ii)) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((False \<and> False))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 64 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_single_general_register AccType_NORMAL (( 8 :: int)::ii) extend_type m MemOp_LOAD n False
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) shift True t False)))))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (extend_type :: ExtendType) = (DecodeRegExtend option_name) in
     (let (shift :: ii) = (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 0 :: int)::ii) else (( 0 :: int)::ii)) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((False \<and> True))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 32 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_single_general_register AccType_NORMAL (( 8 :: int)::ii) extend_type m MemOp_LOAD n False
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) shift True t False)))))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (extend_type :: ExtendType) = (DecodeRegExtend option_name) in
     (let (shift :: ii) = (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 0 :: int)::ii)) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_STORE in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_single_general_register AccType_NORMAL (( 16 :: int)::ii) extend_type m MemOp_STORE n False
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) shift False t False))))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (extend_type :: ExtendType) = (DecodeRegExtend option_name) in
     (let (shift :: ii) = (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 0 :: int)::ii)) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_single_general_register AccType_NORMAL (( 16 :: int)::ii) extend_type m MemOp_LOAD n False
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) shift False t False))))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (extend_type :: ExtendType) = (DecodeRegExtend option_name) in
     (let (shift :: ii) = (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 0 :: int)::ii)) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((False \<and> False))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 64 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_single_general_register AccType_NORMAL (( 16 :: int)::ii) extend_type m MemOp_LOAD n False
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) shift True t False)))))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (extend_type :: ExtendType) = (DecodeRegExtend option_name) in
     (let (shift :: ii) = (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 1 :: int)::ii) else (( 0 :: int)::ii)) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((False \<and> True))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 32 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_single_general_register AccType_NORMAL (( 16 :: int)::ii) extend_type m MemOp_LOAD n False
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) shift True t False)))))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (extend_type :: ExtendType) = (DecodeRegExtend option_name) in
     (let (shift :: ii) = (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 2 :: int)::ii) else (( 0 :: int)::ii)) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_STORE in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_single_general_register AccType_NORMAL (( 32 :: int)::ii) extend_type m MemOp_STORE n False
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) shift False t False))))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (extend_type :: ExtendType) = (DecodeRegExtend option_name) in
     (let (shift :: ii) = (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 2 :: int)::ii) else (( 0 :: int)::ii)) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_single_general_register AccType_NORMAL (( 32 :: int)::ii) extend_type m MemOp_LOAD n False
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) shift False t False))))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (extend_type :: ExtendType) = (DecodeRegExtend option_name) in
     (let (shift :: ii) = (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 2 :: int)::ii) else (( 0 :: int)::ii)) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((True \<and> False))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 64 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_single_general_register AccType_NORMAL (( 32 :: int)::ii) extend_type m MemOp_LOAD n False
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) shift True t False)))))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (extend_type :: ExtendType) = (DecodeRegExtend option_name) in
     (let (shift :: ii) = (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 2 :: int)::ii) else (( 0 :: int)::ii)) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((True \<and> True))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 32 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_single_general_register AccType_NORMAL (( 32 :: int)::ii) extend_type m MemOp_LOAD n False
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) shift True t False)))))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (extend_type :: ExtendType) = (DecodeRegExtend option_name) in
     (let (shift :: ii) = (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 3 :: int)::ii) else (( 0 :: int)::ii)) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_STORE in
     (let regsize = ((( 64 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     aarch64_memory_single_general_register AccType_NORMAL (( 64 :: int)::ii) extend_type m MemOp_STORE n False
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) shift False t False))))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (extend_type :: ExtendType) = (DecodeRegExtend option_name) in
     (let (shift :: ii) = (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 3 :: int)::ii) else (( 0 :: int)::ii)) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (let regsize = ((( 64 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     aarch64_memory_single_general_register AccType_NORMAL (( 64 :: int)::ii) extend_type m MemOp_LOAD n False
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) shift False t False))))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (extend_type :: ExtendType) = (DecodeRegExtend option_name) in
     (let (shift :: ii) = (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 3 :: int)::ii) else (( 0 :: int)::ii)) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_PREFETCH in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     undefined_bool ()  \<bind> (\<lambda> (w__0 :: bool) . 
     aarch64_memory_single_general_register AccType_NORMAL (( 64 :: int)::ii) extend_type m MemOp_PREFETCH n
       False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) shift w__0 t False)))))))))))))))))
   else
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (if ((((vec_of_bits [access_vec_dec option_name (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word)))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (extend_type :: ExtendType) = (DecodeRegExtend option_name) in
     (let (shift :: ii) = (if (((S = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 3 :: int)::ii) else (( 0 :: int)::ii)) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_PREFETCH in
     UnallocatedEncoding ()  \<then>
     ((let (datasize :: ii) = ((( 64 :: int)::ii)) in
     undefined_bool ()  \<bind> (\<lambda> (w__1 :: bool) . 
     aarch64_memory_single_general_register AccType_NORMAL (( 64 :: int)::ii) extend_type m MemOp_PREFETCH n
       False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) shift w__1 t False)))))))))))))))))))"


(*val memory_single_general_immediate_unsigned_aarch64_memory_single_general_immediate_unsigned__decode : mword ty2 -> mword ty1 -> mword ty2 -> mword ty12 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_single_general_immediate_unsigned_aarch64_memory_single_general_immediate_unsigned__decode  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_single_general_immediate_unsigned_aarch64_memory_single_general_immediate_unsigned__decode b__0 V1 b__1 imm12 Rn Rt = (
   if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::
        64 Word.word) . 
     (LSL w__0 (( 0 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_STORE in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 8 :: int)::ii) MemOp_STORE n offset
       False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::
        64 Word.word) . 
     (LSL w__1 (( 0 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 8 :: int)::ii) MemOp_LOAD n offset
       False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::
        64 Word.word) . 
     (LSL w__2 (( 0 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((False \<and> False))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 64 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 8 :: int)::ii) MemOp_LOAD n offset
       False ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) True t False)))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::
        64 Word.word) . 
     (LSL w__3 (( 0 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((False \<and> True))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 32 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 8 :: int)::ii) MemOp_LOAD n offset
       False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) True t False)))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 ::
        64 Word.word) . 
     (LSL w__4 (( 1 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_STORE in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 16 :: int)::ii) MemOp_STORE n offset
       False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 ::
        64 Word.word) . 
     (LSL w__5 (( 1 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 16 :: int)::ii) MemOp_LOAD n offset
       False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__6 ::
        64 Word.word) . 
     (LSL w__6 (( 1 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((False \<and> False))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 64 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 16 :: int)::ii) MemOp_LOAD n offset
       False ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) True t False)))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__7 ::
        64 Word.word) . 
     (LSL w__7 (( 1 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((False \<and> True))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 32 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 16 :: int)::ii) MemOp_LOAD n offset
       False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) True t False)))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__8 ::
        64 Word.word) . 
     (LSL w__8 (( 2 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_STORE in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 32 :: int)::ii) MemOp_STORE n offset
       False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__9 ::
        64 Word.word) . 
     (LSL w__9 (( 2 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 32 :: int)::ii) MemOp_LOAD n offset
       False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__10 ::
        64 Word.word) . 
     (LSL w__10 (( 2 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((True \<and> False))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 64 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 32 :: int)::ii) MemOp_LOAD n offset
       False ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) True t False)))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__11 ::
        64 Word.word) . 
     (LSL w__11 (( 2 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((True \<and> True))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 32 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 32 :: int)::ii) MemOp_LOAD n offset
       False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) True t False)))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__12 ::
        64 Word.word) . 
     (LSL w__12 (( 3 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_STORE in
     (let regsize = ((( 64 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 64 :: int)::ii) MemOp_STORE n offset
       False ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) False t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__13 ::
        64 Word.word) . 
     (LSL w__13 (( 3 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (let regsize = ((( 64 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 64 :: int)::ii) MemOp_LOAD n offset
       False ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) False t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__14 ::
        64 Word.word) . 
     (LSL w__14 (( 3 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_PREFETCH in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     undefined_bool ()  \<bind> (\<lambda> (w__15 :: bool) . 
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 64 :: int)::ii) MemOp_PREFETCH n offset
       False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) w__15 t False)))))))))))))))
   else
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__16 ::
        64 Word.word) . 
     (LSL w__16 (( 3 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_PREFETCH in
     UnallocatedEncoding ()  \<then>
     ((let (datasize :: ii) = ((( 64 :: int)::ii)) in
     undefined_bool ()  \<bind> (\<lambda> (w__17 :: bool) . 
     aarch64_memory_single_general_immediate_unsigned AccType_NORMAL (( 64 :: int)::ii) MemOp_PREFETCH n offset
       False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) w__17 t False)))))))))))))))))"


(*val memory_single_general_immediate_unsigned_aarch64_memory_single_general_immediate_signed_postidx__decode : mword ty2 -> mword ty1 -> mword ty2 -> mword ty12 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_single_general_immediate_unsigned_aarch64_memory_single_general_immediate_signed_postidx__decode  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_single_general_immediate_unsigned_aarch64_memory_single_general_immediate_signed_postidx__decode b__0 V1 b__1 imm12 Rn Rt = (
   if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::
        64 Word.word) . 
     (LSL w__0 (( 0 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_STORE in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 8 :: int)::ii) MemOp_STORE n
       offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::
        64 Word.word) . 
     (LSL w__1 (( 0 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 8 :: int)::ii) MemOp_LOAD n
       offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::
        64 Word.word) . 
     (LSL w__2 (( 0 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((False \<and> False))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 64 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 8 :: int)::ii) MemOp_LOAD n
       offset False ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) True t False)))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::
        64 Word.word) . 
     (LSL w__3 (( 0 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((False \<and> True))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 32 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 8 :: int)::ii) MemOp_LOAD n
       offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) True t False)))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 ::
        64 Word.word) . 
     (LSL w__4 (( 1 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_STORE in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 16 :: int)::ii) MemOp_STORE n
       offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 ::
        64 Word.word) . 
     (LSL w__5 (( 1 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 16 :: int)::ii) MemOp_LOAD n
       offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__6 ::
        64 Word.word) . 
     (LSL w__6 (( 1 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((False \<and> False))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 64 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 16 :: int)::ii) MemOp_LOAD n
       offset False ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) True t False)))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__7 ::
        64 Word.word) . 
     (LSL w__7 (( 1 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((False \<and> True))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 32 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 16 :: int)::ii) MemOp_LOAD n
       offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) True t False)))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__8 ::
        64 Word.word) . 
     (LSL w__8 (( 2 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_STORE in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 32 :: int)::ii) MemOp_STORE n
       offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__9 ::
        64 Word.word) . 
     (LSL w__9 (( 2 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 32 :: int)::ii) MemOp_LOAD n
       offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__10 ::
        64 Word.word) . 
     (LSL w__10 (( 2 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((True \<and> False))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 64 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 32 :: int)::ii) MemOp_LOAD n
       offset False ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) True t False)))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__11 ::
        64 Word.word) . 
     (LSL w__11 (( 2 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((True \<and> True))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 32 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 32 :: int)::ii) MemOp_LOAD n
       offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) True t False)))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__12 ::
        64 Word.word) . 
     (LSL w__12 (( 3 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_STORE in
     (let regsize = ((( 64 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 64 :: int)::ii) MemOp_STORE n
       offset False ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) False t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__13 ::
        64 Word.word) . 
     (LSL w__13 (( 3 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (let regsize = ((( 64 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 64 :: int)::ii) MemOp_LOAD n
       offset False ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) False t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__14 ::
        64 Word.word) . 
     (LSL w__14 (( 3 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let (datasize :: ii) = ((( 64 :: int)::ii)) in
     undefined_MemOp ()  \<bind> (\<lambda> (w__15 :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (w__16 :: bool) . 
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 64 :: int)::ii) w__15 n offset
       False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) w__16 t False))))))))))))))))
   else
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__17 ::
        64 Word.word) . 
     (LSL w__17 (( 3 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let (datasize :: ii) = ((( 64 :: int)::ii)) in
     undefined_MemOp ()  \<bind> (\<lambda> (w__18 :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (w__19 :: bool) . 
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 64 :: int)::ii) w__18 n offset
       False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) w__19 t False)))))))))))))))))"


(*val memory_single_general_immediate_signed_preidx_aarch64_memory_single_general_immediate_signed_postidx__decode : mword ty2 -> mword ty1 -> mword ty2 -> mword ty9 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_single_general_immediate_signed_preidx_aarch64_memory_single_general_immediate_signed_postidx__decode  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(9)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_single_general_immediate_signed_preidx_aarch64_memory_single_general_immediate_signed_postidx__decode b__0 V1 b__1 imm9 Rn Rt = (
   if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_STORE in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 8 :: int)::ii) MemOp_STORE n
       offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t True)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 8 :: int)::ii) MemOp_LOAD n
       offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t True)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((False \<and> False))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 64 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 8 :: int)::ii) MemOp_LOAD n
       offset False ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) True t True))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((False \<and> True))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 32 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 8 :: int)::ii) MemOp_LOAD n
       offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) True t True))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_STORE in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 16 :: int)::ii) MemOp_STORE n
       offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t True)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 16 :: int)::ii) MemOp_LOAD n
       offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t True)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((False \<and> False))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 64 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 16 :: int)::ii) MemOp_LOAD n
       offset False ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) True t True))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((False \<and> True))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 32 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 16 :: int)::ii) MemOp_LOAD n
       offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) True t True))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_STORE in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 32 :: int)::ii) MemOp_STORE n
       offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t True)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 32 :: int)::ii) MemOp_LOAD n
       offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t True)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((True \<and> False))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 64 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 32 :: int)::ii) MemOp_LOAD n
       offset False ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) True t True))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((True \<and> True))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 32 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 32 :: int)::ii) MemOp_LOAD n
       offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) True t True))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_STORE in
     (let regsize = ((( 64 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 64 :: int)::ii) MemOp_STORE n
       offset False ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) False t True)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (let regsize = ((( 64 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 64 :: int)::ii) MemOp_LOAD n
       offset False ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) False t True)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let (datasize :: ii) = ((( 64 :: int)::ii)) in
     undefined_MemOp ()  \<bind> (\<lambda> (w__0 :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (w__1 :: bool) . 
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 64 :: int)::ii) w__0 n offset
       False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) w__1 t True)))))))))))))))
   else
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let (datasize :: ii) = ((( 64 :: int)::ii)) in
     undefined_MemOp ()  \<bind> (\<lambda> (w__2 :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (w__3 :: bool) . 
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 64 :: int)::ii) w__2 n offset
       False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) w__3 t True))))))))))))))))"


(*val memory_single_general_immediate_signed_postidx_aarch64_memory_single_general_immediate_signed_postidx__decode : mword ty2 -> mword ty1 -> mword ty2 -> mword ty9 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_single_general_immediate_signed_postidx_aarch64_memory_single_general_immediate_signed_postidx__decode  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(9)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_single_general_immediate_signed_postidx_aarch64_memory_single_general_immediate_signed_postidx__decode b__0 V1 b__1 imm9 Rn Rt = (
   if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = True in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_STORE in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 8 :: int)::ii) MemOp_STORE n
       offset True ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t True)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = True in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 8 :: int)::ii) MemOp_LOAD n
       offset True ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t True)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = True in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((False \<and> False))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 64 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 8 :: int)::ii) MemOp_LOAD n
       offset True ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) True t True))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = True in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((False \<and> True))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 32 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 8 :: int)::ii) MemOp_LOAD n
       offset True ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) True t True))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = True in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_STORE in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 16 :: int)::ii) MemOp_STORE n
       offset True ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t True)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = True in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 16 :: int)::ii) MemOp_LOAD n
       offset True ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t True)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = True in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((False \<and> False))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 64 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 16 :: int)::ii) MemOp_LOAD n
       offset True ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) True t True))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = True in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((False \<and> True))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 32 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 16 :: int)::ii) MemOp_LOAD n
       offset True ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) True t True))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = True in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_STORE in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 32 :: int)::ii) MemOp_STORE n
       offset True ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t True)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = True in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 32 :: int)::ii) MemOp_LOAD n
       offset True ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t True)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = True in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((True \<and> False))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 64 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 32 :: int)::ii) MemOp_LOAD n
       offset True ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) True t True))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = True in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((True \<and> True))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 32 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 32 :: int)::ii) MemOp_LOAD n
       offset True ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) True t True))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = True in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_STORE in
     (let regsize = ((( 64 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 64 :: int)::ii) MemOp_STORE n
       offset True ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) False t True)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = True in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (let regsize = ((( 64 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 64 :: int)::ii) MemOp_LOAD n
       offset True ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) False t True)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = True in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let (datasize :: ii) = ((( 64 :: int)::ii)) in
     undefined_MemOp ()  \<bind> (\<lambda> (w__0 :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (w__1 :: bool) . 
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 64 :: int)::ii) w__0 n offset
       True ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) w__1 t True)))))))))))))))
   else
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = True in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let (datasize :: ii) = ((( 64 :: int)::ii)) in
     undefined_MemOp ()  \<bind> (\<lambda> (w__2 :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (w__3 :: bool) . 
     aarch64_memory_single_general_immediate_signed_postidx AccType_NORMAL (( 64 :: int)::ii) w__2 n offset
       True ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) w__3 t True))))))))))))))))"


(*val memory_single_general_immediate_signed_pac_decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty9 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_single_general_immediate_signed_pac_decode  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(9)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_single_general_immediate_signed_pac_decode size1 V1 M S imm9 W Rn Rt = (
   (write_reg unconditional_ref True \<then>
   (if (((((\<not> ((HavePACExt () )))) \<or> (((size1 \<noteq> (vec_of_bits [B1,B1]  ::  2 Word.word)))))))
    then
      UnallocatedEncoding () 
    else return () )) \<then>
   ((let (t :: ii) = (Word.uint Rt) in
   (let (n :: ii) = (Word.uint Rn) in
   (let (wback :: bool) = (W = (vec_of_bits [B1]  ::  1 Word.word)) in
   (let (use_key_a :: bool) = (M = (vec_of_bits [B0]  ::  1 Word.word)) in
   (let (S10 :: 10 bits) = ((concat_vec S imm9  ::  10 Word.word)) in
   (let (scale :: ii) = ((( 3 :: int)::ii)) in
   (SignExtend__0 S10 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::
      64 Word.word) . 
   (LSL w__0 scale  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
   aarch64_memory_single_general_immediate_signed_pac n offset t use_key_a wback))))))))))"


(*val memory_single_general_immediate_signed_offset_unpriv_aarch64_memory_single_general_immediate_signed_offset_unpriv__decode : mword ty2 -> mword ty1 -> mword ty2 -> mword ty9 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_single_general_immediate_signed_offset_unpriv_aarch64_memory_single_general_immediate_signed_offset_unpriv__decode  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(9)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_single_general_immediate_signed_offset_unpriv_aarch64_memory_single_general_immediate_signed_offset_unpriv__decode b__0 V1 b__1 imm9 Rn Rt = (
   if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_UNPRIV in
     and_boolM
       (and_boolM (return (((((HaveNVExt () )) \<and> ((HaveEL EL2))))))
          ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 :: 64 bits) . 
           return ((((vec_of_bits [access_vec_dec w__0 (( 42 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
       ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 :: 64 bits) . 
        return ((((vec_of_bits [access_vec_dec w__2 (( 43 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__3 :: bool) . 
     (let (acctype :: AccType) = (if w__3 then AccType_NORMAL else acctype) in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_STORE in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 8 :: int)::ii) MemOp_STORE n
       offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t False)))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_UNPRIV in
     and_boolM
       (and_boolM (return (((((HaveNVExt () )) \<and> ((HaveEL EL2))))))
          ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 :: 64 bits) . 
           return ((((vec_of_bits [access_vec_dec w__4 (( 42 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
       ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__6 :: 64 bits) . 
        return ((((vec_of_bits [access_vec_dec w__6 (( 43 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__7 :: bool) . 
     (let (acctype :: AccType) = (if w__7 then AccType_NORMAL else acctype) in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 8 :: int)::ii) MemOp_LOAD n offset
       False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t False)))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_UNPRIV in
     and_boolM
       (and_boolM (return (((((HaveNVExt () )) \<and> ((HaveEL EL2))))))
          ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__8 :: 64 bits) . 
           return ((((vec_of_bits [access_vec_dec w__8 (( 42 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
       ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__10 :: 64 bits) . 
        return ((((vec_of_bits [access_vec_dec w__10 (( 43 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__11 :: bool) . 
     (let (acctype :: AccType) = (if w__11 then AccType_NORMAL else acctype) in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((False \<and> False))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 64 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 8 :: int)::ii) MemOp_LOAD n offset
       False ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) True t False))))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_UNPRIV in
     and_boolM
       (and_boolM (return (((((HaveNVExt () )) \<and> ((HaveEL EL2))))))
          ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__12 :: 64 bits) . 
           return ((((vec_of_bits [access_vec_dec w__12 (( 42 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
       ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__14 :: 64 bits) . 
        return ((((vec_of_bits [access_vec_dec w__14 (( 43 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__15 :: bool) . 
     (let (acctype :: AccType) = (if w__15 then AccType_NORMAL else acctype) in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((False \<and> True))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 32 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 8 :: int)::ii) MemOp_LOAD n offset
       False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) True t False))))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_UNPRIV in
     and_boolM
       (and_boolM (return (((((HaveNVExt () )) \<and> ((HaveEL EL2))))))
          ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__16 :: 64 bits) . 
           return ((((vec_of_bits [access_vec_dec w__16 (( 42 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
       ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__18 :: 64 bits) . 
        return ((((vec_of_bits [access_vec_dec w__18 (( 43 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__19 :: bool) . 
     (let (acctype :: AccType) = (if w__19 then AccType_NORMAL else acctype) in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_STORE in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 16 :: int)::ii) MemOp_STORE n
       offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t False)))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_UNPRIV in
     and_boolM
       (and_boolM (return (((((HaveNVExt () )) \<and> ((HaveEL EL2))))))
          ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__20 :: 64 bits) . 
           return ((((vec_of_bits [access_vec_dec w__20 (( 42 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
       ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__22 :: 64 bits) . 
        return ((((vec_of_bits [access_vec_dec w__22 (( 43 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__23 :: bool) . 
     (let (acctype :: AccType) = (if w__23 then AccType_NORMAL else acctype) in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 16 :: int)::ii) MemOp_LOAD n
       offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t False)))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_UNPRIV in
     and_boolM
       (and_boolM (return (((((HaveNVExt () )) \<and> ((HaveEL EL2))))))
          ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__24 :: 64 bits) . 
           return ((((vec_of_bits [access_vec_dec w__24 (( 42 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
       ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__26 :: 64 bits) . 
        return ((((vec_of_bits [access_vec_dec w__26 (( 43 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__27 :: bool) . 
     (let (acctype :: AccType) = (if w__27 then AccType_NORMAL else acctype) in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((False \<and> False))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 64 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 16 :: int)::ii) MemOp_LOAD n
       offset False ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) True t False))))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_UNPRIV in
     and_boolM
       (and_boolM (return (((((HaveNVExt () )) \<and> ((HaveEL EL2))))))
          ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__28 :: 64 bits) . 
           return ((((vec_of_bits [access_vec_dec w__28 (( 42 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
       ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__30 :: 64 bits) . 
        return ((((vec_of_bits [access_vec_dec w__30 (( 43 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__31 :: bool) . 
     (let (acctype :: AccType) = (if w__31 then AccType_NORMAL else acctype) in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((False \<and> True))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 32 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 16 :: int)::ii) MemOp_LOAD n
       offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) True t False))))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_UNPRIV in
     and_boolM
       (and_boolM (return (((((HaveNVExt () )) \<and> ((HaveEL EL2))))))
          ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__32 :: 64 bits) . 
           return ((((vec_of_bits [access_vec_dec w__32 (( 42 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
       ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__34 :: 64 bits) . 
        return ((((vec_of_bits [access_vec_dec w__34 (( 43 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__35 :: bool) . 
     (let (acctype :: AccType) = (if w__35 then AccType_NORMAL else acctype) in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_STORE in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 32 :: int)::ii) MemOp_STORE n
       offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t False)))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_UNPRIV in
     and_boolM
       (and_boolM (return (((((HaveNVExt () )) \<and> ((HaveEL EL2))))))
          ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__36 :: 64 bits) . 
           return ((((vec_of_bits [access_vec_dec w__36 (( 42 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
       ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__38 :: 64 bits) . 
        return ((((vec_of_bits [access_vec_dec w__38 (( 43 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__39 :: bool) . 
     (let (acctype :: AccType) = (if w__39 then AccType_NORMAL else acctype) in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 32 :: int)::ii) MemOp_LOAD n
       offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t False)))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_UNPRIV in
     and_boolM
       (and_boolM (return (((((HaveNVExt () )) \<and> ((HaveEL EL2))))))
          ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__40 :: 64 bits) . 
           return ((((vec_of_bits [access_vec_dec w__40 (( 42 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
       ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__42 :: 64 bits) . 
        return ((((vec_of_bits [access_vec_dec w__42 (( 43 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__43 :: bool) . 
     (let (acctype :: AccType) = (if w__43 then AccType_NORMAL else acctype) in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((True \<and> False))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 64 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 32 :: int)::ii) MemOp_LOAD n
       offset False ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) True t False))))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_UNPRIV in
     and_boolM
       (and_boolM (return (((((HaveNVExt () )) \<and> ((HaveEL EL2))))))
          ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__44 :: 64 bits) . 
           return ((((vec_of_bits [access_vec_dec w__44 (( 42 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
       ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__46 :: 64 bits) . 
        return ((((vec_of_bits [access_vec_dec w__46 (( 43 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__47 :: bool) . 
     (let (acctype :: AccType) = (if w__47 then AccType_NORMAL else acctype) in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((True \<and> True))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 32 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 32 :: int)::ii) MemOp_LOAD n
       offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) True t False))))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_UNPRIV in
     and_boolM
       (and_boolM (return (((((HaveNVExt () )) \<and> ((HaveEL EL2))))))
          ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__48 :: 64 bits) . 
           return ((((vec_of_bits [access_vec_dec w__48 (( 42 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
       ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__50 :: 64 bits) . 
        return ((((vec_of_bits [access_vec_dec w__50 (( 43 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__51 :: bool) . 
     (let (acctype :: AccType) = (if w__51 then AccType_NORMAL else acctype) in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_STORE in
     (let regsize = ((( 64 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 64 :: int)::ii) MemOp_STORE n
       offset False ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) False t False)))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_UNPRIV in
     and_boolM
       (and_boolM (return (((((HaveNVExt () )) \<and> ((HaveEL EL2))))))
          ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__52 :: 64 bits) . 
           return ((((vec_of_bits [access_vec_dec w__52 (( 42 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
       ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__54 :: 64 bits) . 
        return ((((vec_of_bits [access_vec_dec w__54 (( 43 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__55 :: bool) . 
     (let (acctype :: AccType) = (if w__55 then AccType_NORMAL else acctype) in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (let regsize = ((( 64 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 64 :: int)::ii) MemOp_LOAD n
       offset False ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) False t False)))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_UNPRIV in
     and_boolM
       (and_boolM (return (((((HaveNVExt () )) \<and> ((HaveEL EL2))))))
          ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__56 :: 64 bits) . 
           return ((((vec_of_bits [access_vec_dec w__56 (( 42 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
       ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__58 :: 64 bits) . 
        return ((((vec_of_bits [access_vec_dec w__58 (( 43 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__59 :: bool) . 
     (let (acctype :: AccType) = (if w__59 then AccType_NORMAL else acctype) in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let (datasize :: ii) = ((( 64 :: int)::ii)) in
     undefined_MemOp ()  \<bind> (\<lambda> (w__60 :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (w__61 :: bool) . 
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 64 :: int)::ii) w__60 n offset
       False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) w__61 t False)))))))))))))))))
   else
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_UNPRIV in
     and_boolM
       (and_boolM (return (((((HaveNVExt () )) \<and> ((HaveEL EL2))))))
          ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__62 :: 64 bits) . 
           return ((((vec_of_bits [access_vec_dec w__62 (( 42 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
       ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__64 :: 64 bits) . 
        return ((((vec_of_bits [access_vec_dec w__64 (( 43 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__65 :: bool) . 
     (let (acctype :: AccType) = (if w__65 then AccType_NORMAL else acctype) in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     UnallocatedEncoding ()  \<then>
     ((let (datasize :: ii) = ((( 64 :: int)::ii)) in
     undefined_MemOp ()  \<bind> (\<lambda> (w__66 :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (w__67 :: bool) . 
     aarch64_memory_single_general_immediate_signed_offset_unpriv acctype (( 64 :: int)::ii) w__66 n offset
       False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) w__67 t False))))))))))))))))))"


(*val memory_single_general_immediate_signed_offset_normal_aarch64_memory_single_general_immediate_signed_offset_normal__decode : mword ty2 -> mword ty1 -> mword ty2 -> mword ty9 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_single_general_immediate_signed_offset_normal_aarch64_memory_single_general_immediate_signed_offset_normal__decode  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(9)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_single_general_immediate_signed_offset_normal_aarch64_memory_single_general_immediate_signed_offset_normal__decode b__0 V1 b__1 imm9 Rn Rt = (
   if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_STORE in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 8 :: int)::ii) MemOp_STORE
       n offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t False)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 8 :: int)::ii) MemOp_LOAD n
       offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t False)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((False \<and> False))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 64 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 8 :: int)::ii) MemOp_LOAD n
       offset False ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) True t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 0 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((False \<and> True))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 32 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 8 :: int)::ii) MemOp_LOAD n
       offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) True t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_STORE in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 16 :: int)::ii) MemOp_STORE
       n offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t False)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 16 :: int)::ii) MemOp_LOAD
       n offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t False)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((False \<and> False))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 64 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 16 :: int)::ii) MemOp_LOAD
       n offset False ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) True t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 1 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((False \<and> True))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 32 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 16 :: int)::ii) MemOp_LOAD
       n offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) True t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_STORE in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 32 :: int)::ii) MemOp_STORE
       n offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t False)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (let regsize = ((( 32 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 32 :: int)::ii) MemOp_LOAD
       n offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) False t False)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((True \<and> False))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 64 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 32 :: int)::ii) MemOp_LOAD
       n offset False ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) True t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (if (((True \<and> True))) then UnallocatedEncoding () 
      else return () ) \<then>
     ((let regsize = ((( 32 :: int)::ii)) in
     (let signed = True in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 32 :: int)::ii) MemOp_LOAD
       n offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) True t False))))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_STORE in
     (let regsize = ((( 64 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 64 :: int)::ii) MemOp_STORE
       n offset False ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) False t False)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_LOAD in
     (let regsize = ((( 64 :: int)::ii)) in
     (let signed = False in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 64 :: int)::ii) MemOp_LOAD
       n offset False ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) False t False)))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_PREFETCH in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     undefined_bool ()  \<bind> (\<lambda> (w__0 :: bool) . 
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 64 :: int)::ii)
       MemOp_PREFETCH n offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) w__0 t False))))))))))))))
   else
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (SignExtend__0 imm9 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64
       bits) . 
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (acctype :: AccType) = AccType_NORMAL in
     undefined_MemOp ()  \<bind> (\<lambda> (memop :: MemOp) . 
     undefined_bool ()  \<bind> (\<lambda> (signed :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (regsize :: ii) . 
     (let memop = MemOp_PREFETCH in
     UnallocatedEncoding ()  \<then>
     ((let (datasize :: ii) = ((( 64 :: int)::ii)) in
     undefined_bool ()  \<bind> (\<lambda> (w__1 :: bool) . 
     aarch64_memory_single_general_immediate_signed_offset_normal AccType_NORMAL (( 64 :: int)::ii)
       MemOp_PREFETCH n offset False ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) w__1 t False))))))))))))))))"


(*val memory_pair_simdfp_preidx_aarch64_memory_pair_simdfp_postidx__decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty7 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_pair_simdfp_preidx_aarch64_memory_pair_simdfp_postidx__decode  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(7)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_pair_simdfp_preidx_aarch64_memory_pair_simdfp_postidx__decode b__0 V1 L imm7 Rt2 Rn Rt = (
   if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = False in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_VEC in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::
        64 Word.word) . 
     (LSL w__0 (( 2 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_simdfp_postidx AccType_VEC ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) memop
       n offset False t t2 True))))))))))))
   else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = False in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_VEC in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::
        64 Word.word) . 
     (LSL w__1 (( 3 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_simdfp_postidx AccType_VEC ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) memop
       n offset False t t2 True))))))))))))
   else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = False in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_VEC in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (scale :: ii) = ((( 4 :: int)::ii)) in
     (let (datasize :: ii) = ((( 128 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::
        64 Word.word) . 
     (LSL w__2 (( 4 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_simdfp_postidx AccType_VEC ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       memop n offset False t t2 True))))))))))))
   else
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = False in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_VEC in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     UnallocatedEncoding ()  \<then>
     ((let (scale :: ii) = ((( 5 :: int)::ii)) in
     (let (datasize :: ii) = ((( 256 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::
        64 Word.word) . 
     (LSL w__3 (( 5 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_simdfp_postidx AccType_VEC ((make_the_value (( 256 :: int)::ii)  ::  256 itself))
       memop n offset False t t2 True))))))))))))))"


(*val memory_pair_simdfp_postidx_aarch64_memory_pair_simdfp_postidx__decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty7 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_pair_simdfp_postidx_aarch64_memory_pair_simdfp_postidx__decode  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(7)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_pair_simdfp_postidx_aarch64_memory_pair_simdfp_postidx__decode b__0 V1 L imm7 Rt2 Rn Rt = (
   if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = True in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_VEC in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::
        64 Word.word) . 
     (LSL w__0 (( 2 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_simdfp_postidx AccType_VEC ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) memop
       n offset True t t2 True))))))))))))
   else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = True in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_VEC in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::
        64 Word.word) . 
     (LSL w__1 (( 3 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_simdfp_postidx AccType_VEC ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) memop
       n offset True t t2 True))))))))))))
   else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = True in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_VEC in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (scale :: ii) = ((( 4 :: int)::ii)) in
     (let (datasize :: ii) = ((( 128 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::
        64 Word.word) . 
     (LSL w__2 (( 4 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_simdfp_postidx AccType_VEC ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       memop n offset True t t2 True))))))))))))
   else
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = True in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_VEC in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     UnallocatedEncoding ()  \<then>
     ((let (scale :: ii) = ((( 5 :: int)::ii)) in
     (let (datasize :: ii) = ((( 256 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::
        64 Word.word) . 
     (LSL w__3 (( 5 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_simdfp_postidx AccType_VEC ((make_the_value (( 256 :: int)::ii)  ::  256 itself))
       memop n offset True t t2 True))))))))))))))"


(*val memory_pair_simdfp_offset_aarch64_memory_pair_simdfp_postidx__decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty7 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_pair_simdfp_offset_aarch64_memory_pair_simdfp_postidx__decode  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(7)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_pair_simdfp_offset_aarch64_memory_pair_simdfp_postidx__decode b__0 V1 L imm7 Rt2 Rn Rt = (
   if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_VEC in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::
        64 Word.word) . 
     (LSL w__0 (( 2 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_simdfp_postidx AccType_VEC ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) memop
       n offset False t t2 False))))))))))))
   else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_VEC in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::
        64 Word.word) . 
     (LSL w__1 (( 3 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_simdfp_postidx AccType_VEC ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) memop
       n offset False t t2 False))))))))))))
   else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_VEC in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (scale :: ii) = ((( 4 :: int)::ii)) in
     (let (datasize :: ii) = ((( 128 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::
        64 Word.word) . 
     (LSL w__2 (( 4 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_simdfp_postidx AccType_VEC ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       memop n offset False t t2 False))))))))))))
   else
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_VEC in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     UnallocatedEncoding ()  \<then>
     ((let (scale :: ii) = ((( 5 :: int)::ii)) in
     (let (datasize :: ii) = ((( 256 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::
        64 Word.word) . 
     (LSL w__3 (( 5 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_simdfp_postidx AccType_VEC ((make_the_value (( 256 :: int)::ii)  ::  256 itself))
       memop n offset False t t2 False))))))))))))))"


(*val memory_pair_simdfp_noalloc_aarch64_memory_pair_simdfp_noalloc__decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty7 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_pair_simdfp_noalloc_aarch64_memory_pair_simdfp_noalloc__decode  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(7)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_pair_simdfp_noalloc_aarch64_memory_pair_simdfp_noalloc__decode b__0 V1 L imm7 Rt2 Rn Rt = (
   if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_VECSTREAM in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::
        64 Word.word) . 
     (LSL w__0 (( 2 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_simdfp_noalloc AccType_VECSTREAM ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       memop n offset False t t2 False))))))))))))
   else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_VECSTREAM in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::
        64 Word.word) . 
     (LSL w__1 (( 3 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_simdfp_noalloc AccType_VECSTREAM ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       memop n offset False t t2 False))))))))))))
   else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_VECSTREAM in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (scale :: ii) = ((( 4 :: int)::ii)) in
     (let (datasize :: ii) = ((( 128 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::
        64 Word.word) . 
     (LSL w__2 (( 4 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_simdfp_noalloc AccType_VECSTREAM
       ((make_the_value (( 128 :: int)::ii)  ::  128 itself)) memop n offset False t t2 False))))))))))))
   else
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_VECSTREAM in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     UnallocatedEncoding ()  \<then>
     ((let (scale :: ii) = ((( 5 :: int)::ii)) in
     (let (datasize :: ii) = ((( 256 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::
        64 Word.word) . 
     (LSL w__3 (( 5 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_simdfp_noalloc AccType_VECSTREAM
       ((make_the_value (( 256 :: int)::ii)  ::  256 itself)) memop n offset False t t2 False))))))))))))))"


(*val memory_pair_general_preidx_aarch64_memory_pair_general_postidx__decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty7 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_pair_general_preidx_aarch64_memory_pair_general_postidx__decode  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(7)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_pair_general_preidx_aarch64_memory_pair_general_postidx__decode b__0 V1 L imm7 Rt2 Rn Rt = (
   if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = False in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_NORMAL in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (if ((((((((concat_vec L (vec_of_bits [B0]  ::  1 Word.word)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<or> False))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (signed :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::
        64 Word.word) . 
     (LSL w__0 (( 2 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_general_postidx AccType_NORMAL ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       memop n offset False False t t2 True))))))))))))))
   else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = False in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_NORMAL in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (if ((((((((concat_vec L (vec_of_bits [B1]  ::  1 Word.word)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<or> False))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (signed :: bool) = True in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::
        64 Word.word) . 
     (LSL w__1 (( 2 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_general_postidx AccType_NORMAL ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       memop n offset False True t t2 True))))))))))))))
   else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = False in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_NORMAL in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (if ((((((((concat_vec L (vec_of_bits [B0]  ::  1 Word.word)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<or> False))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (signed :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::
        64 Word.word) . 
     (LSL w__2 (( 3 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_general_postidx AccType_NORMAL ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       memop n offset False False t t2 True))))))))))))))
   else
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = False in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_NORMAL in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (if ((((((((concat_vec L (vec_of_bits [B1]  ::  1 Word.word)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<or> True))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (signed :: bool) = True in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::
        64 Word.word) . 
     (LSL w__3 (( 3 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_general_postidx AccType_NORMAL ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       memop n offset False True t t2 True)))))))))))))))"


(*val memory_pair_general_postidx_aarch64_memory_pair_general_postidx__decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty7 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_pair_general_postidx_aarch64_memory_pair_general_postidx__decode  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(7)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_pair_general_postidx_aarch64_memory_pair_general_postidx__decode b__0 V1 L imm7 Rt2 Rn Rt = (
   if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = True in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_NORMAL in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (if ((((((((concat_vec L (vec_of_bits [B0]  ::  1 Word.word)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<or> False))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (signed :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::
        64 Word.word) . 
     (LSL w__0 (( 2 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_general_postidx AccType_NORMAL ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       memop n offset True False t t2 True))))))))))))))
   else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = True in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_NORMAL in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (if ((((((((concat_vec L (vec_of_bits [B1]  ::  1 Word.word)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<or> False))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (signed :: bool) = True in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::
        64 Word.word) . 
     (LSL w__1 (( 2 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_general_postidx AccType_NORMAL ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       memop n offset True True t t2 True))))))))))))))
   else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = True in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_NORMAL in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (if ((((((((concat_vec L (vec_of_bits [B0]  ::  1 Word.word)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<or> False))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (signed :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::
        64 Word.word) . 
     (LSL w__2 (( 3 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_general_postidx AccType_NORMAL ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       memop n offset True False t t2 True))))))))))))))
   else
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = True in
     (let (postindex :: bool) = True in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_NORMAL in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (if ((((((((concat_vec L (vec_of_bits [B1]  ::  1 Word.word)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<or> True))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (signed :: bool) = True in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::
        64 Word.word) . 
     (LSL w__3 (( 3 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_general_postidx AccType_NORMAL ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       memop n offset True True t t2 True)))))))))))))))"


(*val memory_pair_general_offset_aarch64_memory_pair_general_postidx__decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty7 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_pair_general_offset_aarch64_memory_pair_general_postidx__decode  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(7)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_pair_general_offset_aarch64_memory_pair_general_postidx__decode b__0 V1 L imm7 Rt2 Rn Rt = (
   if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_NORMAL in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (if ((((((((concat_vec L (vec_of_bits [B0]  ::  1 Word.word)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<or> False))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (signed :: bool) = False in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::
        64 Word.word) . 
     (LSL w__0 (( 2 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_general_postidx AccType_NORMAL ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       memop n offset False False t t2 False))))))))))))))
   else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_NORMAL in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (if ((((((((concat_vec L (vec_of_bits [B1]  ::  1 Word.word)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<or> False))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (signed :: bool) = True in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::
        64 Word.word) . 
     (LSL w__1 (( 2 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_general_postidx AccType_NORMAL ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       memop n offset False True t t2 False))))))))))))))
   else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_NORMAL in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (if ((((((((concat_vec L (vec_of_bits [B0]  ::  1 Word.word)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<or> False))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (signed :: bool) = False in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::
        64 Word.word) . 
     (LSL w__2 (( 3 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_general_postidx AccType_NORMAL ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       memop n offset False False t t2 False))))))))))))))
   else
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_NORMAL in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (if ((((((((concat_vec L (vec_of_bits [B1]  ::  1 Word.word)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<or> True))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (signed :: bool) = True in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::
        64 Word.word) . 
     (LSL w__3 (( 3 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_general_postidx AccType_NORMAL ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       memop n offset False True t t2 False)))))))))))))))"


(*val memory_pair_general_noalloc_aarch64_memory_pair_general_noalloc__decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty7 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_pair_general_noalloc_aarch64_memory_pair_general_noalloc__decode  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(7)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_pair_general_noalloc_aarch64_memory_pair_general_noalloc__decode b__0 V1 L imm7 Rt2 Rn Rt = (
   if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_STREAM in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::
        64 Word.word) . 
     (LSL w__0 (( 2 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_general_noalloc AccType_STREAM ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       memop n offset False t t2 False))))))))))))
   else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_STREAM in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     UnallocatedEncoding ()  \<then>
     ((let (scale :: ii) = ((( 2 :: int)::ii)) in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::
        64 Word.word) . 
     (LSL w__1 (( 2 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_general_noalloc AccType_STREAM ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       memop n offset False t t2 False)))))))))))))
   else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_STREAM in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::
        64 Word.word) . 
     (LSL w__2 (( 3 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_general_noalloc AccType_STREAM ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       memop n offset False t t2 False))))))))))))
   else
     write_reg unconditional_ref True \<then>
     ((let (wback :: bool) = False in
     (let (postindex :: bool) = False in
     (let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (t2 :: ii) = (Word.uint Rt2) in
     (let (acctype :: AccType) = AccType_STREAM in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     UnallocatedEncoding ()  \<then>
     ((let (scale :: ii) = ((( 3 :: int)::ii)) in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     (SignExtend__0 imm7 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::
        64 Word.word) . 
     (LSL w__3 (( 3 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
     aarch64_memory_pair_general_noalloc AccType_STREAM ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       memop n offset False t t2 False))))))))))))))"


(*val memory_literal_simdfp_decode : mword ty2 -> mword ty1 -> mword ty19 -> mword ty5 -> M unit*)

definition memory_literal_simdfp_decode  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(19)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_literal_simdfp_decode opc V1 imm19 Rt = (
   write_reg unconditional_ref True \<then>
   ((let (t :: ii) = (Word.uint Rt) in
   undefined_int ()  \<bind> (\<lambda> (size1 :: ii) . 
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (offset :: 64 bits) . 
   (let b__0 = opc in
   (if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then return (( 4 :: int)::ii)
    else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then return (( 8 :: int)::ii)
    else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then return (( 16 :: int)::ii)
    else UnallocatedEncoding ()  \<then> return size1) \<bind> (\<lambda> (size1 :: ii) . 
   (SignExtend__0 ((concat_vec imm19 (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  21 Word.word))
      ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
     :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (let offset = w__0 in
   aarch64_memory_literal_simdfp offset ((ex_int size1)) t)))))))))"


(*val memory_atomicops_swp_decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty3 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_atomicops_swp_decode  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_atomicops_swp_decode b__0 V1 A R1 Rs o3 opc Rn Rt = (
   if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
     (write_reg unconditional_ref True \<then>
     (if ((\<not> ((HaveAtomicExt () )))) then UnallocatedEncoding () 
      else return () )) \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (s :: ii) = (Word.uint Rs) in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     (let (regsize :: ii) = ((( 32 :: int)::ii)) in
     (let (ldacctype :: AccType) =
       (if ((((((A = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((Rt \<noteq> (vec_of_bits [B1,B1,B1,B1,B1]  ::  5 Word.word))))))) then
         AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     (let (stacctype :: AccType) =
       (if (((R1 = (vec_of_bits [B1]  ::  1 Word.word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     aarch64_memory_atomicops_swp (( 8 :: int)::ii) ldacctype n ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) s
       stacctype t))))))))
   else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
     (write_reg unconditional_ref True \<then>
     (if ((\<not> ((HaveAtomicExt () )))) then UnallocatedEncoding () 
      else return () )) \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (s :: ii) = (Word.uint Rs) in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     (let (regsize :: ii) = ((( 32 :: int)::ii)) in
     (let (ldacctype :: AccType) =
       (if ((((((A = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((Rt \<noteq> (vec_of_bits [B1,B1,B1,B1,B1]  ::  5 Word.word))))))) then
         AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     (let (stacctype :: AccType) =
       (if (((R1 = (vec_of_bits [B1]  ::  1 Word.word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     aarch64_memory_atomicops_swp (( 16 :: int)::ii) ldacctype n ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) s
       stacctype t))))))))
   else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
     (write_reg unconditional_ref True \<then>
     (if ((\<not> ((HaveAtomicExt () )))) then UnallocatedEncoding () 
      else return () )) \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (s :: ii) = (Word.uint Rs) in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     (let (regsize :: ii) = ((( 32 :: int)::ii)) in
     (let (ldacctype :: AccType) =
       (if ((((((A = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((Rt \<noteq> (vec_of_bits [B1,B1,B1,B1,B1]  ::  5 Word.word))))))) then
         AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     (let (stacctype :: AccType) =
       (if (((R1 = (vec_of_bits [B1]  ::  1 Word.word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     aarch64_memory_atomicops_swp (( 32 :: int)::ii) ldacctype n ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) s
       stacctype t))))))))
   else
     (write_reg unconditional_ref True \<then>
     (if ((\<not> ((HaveAtomicExt () )))) then UnallocatedEncoding () 
      else return () )) \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (s :: ii) = (Word.uint Rs) in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     (let (regsize :: ii) = ((( 64 :: int)::ii)) in
     (let (ldacctype :: AccType) =
       (if ((((((A = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((Rt \<noteq> (vec_of_bits [B1,B1,B1,B1,B1]  ::  5 Word.word))))))) then
         AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     (let (stacctype :: AccType) =
       (if (((R1 = (vec_of_bits [B1]  ::  1 Word.word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     aarch64_memory_atomicops_swp (( 64 :: int)::ii) ldacctype n ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) s
       stacctype t)))))))))"


(*val memory_atomicops_st_decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty3 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_atomicops_st_decode  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_atomicops_st_decode size1 V1 A R1 Rs o3 opc Rn Rt = (
   (write_reg unconditional_ref True \<then>
   (if ((\<not> ((HaveAtomicExt () )))) then UnallocatedEncoding () 
    else return () )) \<then>
   ((let (n :: ii) = (Word.uint Rn) in
   (let (s :: ii) = (Word.uint Rs) in
   (let (datasize :: ii) = (shl_int (( 8 :: int)::ii) ((Word.uint size1))) in
   (let (regsize :: ii) = (if (((((ex_int datasize)) = (( 64 :: int)::ii)))) then (( 64 :: int)::ii) else (( 32 :: int)::ii)) in
   (let (ldacctype :: AccType) = AccType_ATOMICRW in
   (let (stacctype :: AccType) =
     (if (((R1 = (vec_of_bits [B1]  ::  1 Word.word)))) then AccType_ORDEREDRW
     else AccType_ATOMICRW) in
   undefined_MemAtomicOp ()  \<bind> (\<lambda> (op1 :: MemAtomicOp) . 
   (let b__0 = opc in
   (let (op1 :: MemAtomicOp) =
     (if (((b__0 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) then MemAtomicOp_ADD
     else if (((b__0 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) then MemAtomicOp_BIC
     else if (((b__0 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) then MemAtomicOp_EOR
     else if (((b__0 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) then MemAtomicOp_ORR
     else if (((b__0 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) then MemAtomicOp_SMAX
     else if (((b__0 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) then MemAtomicOp_SMIN
     else if (((b__0 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) then MemAtomicOp_UMAX
     else MemAtomicOp_UMIN) in
   aarch64_memory_atomicops_st datasize ldacctype n op1 s stacctype)))))))))))"


(*val memory_atomicops_ld_decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty3 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_atomicops_ld_decode  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_atomicops_ld_decode b__0 V1 A R1 Rs o3 opc Rn Rt = (
   if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
     (write_reg unconditional_ref True \<then>
     (if ((\<not> ((HaveAtomicExt () )))) then UnallocatedEncoding () 
      else return () )) \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (s :: ii) = (Word.uint Rs) in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     (let (regsize :: ii) = ((( 32 :: int)::ii)) in
     (let (ldacctype :: AccType) =
       (if ((((((A = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((Rt \<noteq> (vec_of_bits [B1,B1,B1,B1,B1]  ::  5 Word.word))))))) then
         AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     (let (stacctype :: AccType) =
       (if (((R1 = (vec_of_bits [B1]  ::  1 Word.word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     undefined_MemAtomicOp ()  \<bind> (\<lambda> (op1 :: MemAtomicOp) . 
     (let b__1 = opc in
     (let (op1 :: MemAtomicOp) =
       (if (((b__1 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) then MemAtomicOp_ADD
       else if (((b__1 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) then MemAtomicOp_BIC
       else if (((b__1 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) then MemAtomicOp_EOR
       else if (((b__1 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) then MemAtomicOp_ORR
       else if (((b__1 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) then MemAtomicOp_SMAX
       else if (((b__1 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) then MemAtomicOp_SMIN
       else if (((b__1 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) then MemAtomicOp_UMAX
       else MemAtomicOp_UMIN) in
     aarch64_memory_atomicops_ld (( 8 :: int)::ii) ldacctype n op1 ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) s
       stacctype t)))))))))))
   else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
     (write_reg unconditional_ref True \<then>
     (if ((\<not> ((HaveAtomicExt () )))) then UnallocatedEncoding () 
      else return () )) \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (s :: ii) = (Word.uint Rs) in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     (let (regsize :: ii) = ((( 32 :: int)::ii)) in
     (let (ldacctype :: AccType) =
       (if ((((((A = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((Rt \<noteq> (vec_of_bits [B1,B1,B1,B1,B1]  ::  5 Word.word))))))) then
         AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     (let (stacctype :: AccType) =
       (if (((R1 = (vec_of_bits [B1]  ::  1 Word.word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     undefined_MemAtomicOp ()  \<bind> (\<lambda> (op1 :: MemAtomicOp) . 
     (let b__10 = opc in
     (let (op1 :: MemAtomicOp) =
       (if (((b__10 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) then MemAtomicOp_ADD
       else if (((b__10 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) then MemAtomicOp_BIC
       else if (((b__10 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) then MemAtomicOp_EOR
       else if (((b__10 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) then MemAtomicOp_ORR
       else if (((b__10 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) then MemAtomicOp_SMAX
       else if (((b__10 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) then MemAtomicOp_SMIN
       else if (((b__10 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) then MemAtomicOp_UMAX
       else MemAtomicOp_UMIN) in
     aarch64_memory_atomicops_ld (( 16 :: int)::ii) ldacctype n op1 ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) s
       stacctype t)))))))))))
   else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
     (write_reg unconditional_ref True \<then>
     (if ((\<not> ((HaveAtomicExt () )))) then UnallocatedEncoding () 
      else return () )) \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (s :: ii) = (Word.uint Rs) in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     (let (regsize :: ii) = ((( 32 :: int)::ii)) in
     (let (ldacctype :: AccType) =
       (if ((((((A = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((Rt \<noteq> (vec_of_bits [B1,B1,B1,B1,B1]  ::  5 Word.word))))))) then
         AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     (let (stacctype :: AccType) =
       (if (((R1 = (vec_of_bits [B1]  ::  1 Word.word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     undefined_MemAtomicOp ()  \<bind> (\<lambda> (op1 :: MemAtomicOp) . 
     (let b__19 = opc in
     (let (op1 :: MemAtomicOp) =
       (if (((b__19 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) then MemAtomicOp_ADD
       else if (((b__19 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) then MemAtomicOp_BIC
       else if (((b__19 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) then MemAtomicOp_EOR
       else if (((b__19 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) then MemAtomicOp_ORR
       else if (((b__19 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) then MemAtomicOp_SMAX
       else if (((b__19 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) then MemAtomicOp_SMIN
       else if (((b__19 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) then MemAtomicOp_UMAX
       else MemAtomicOp_UMIN) in
     aarch64_memory_atomicops_ld (( 32 :: int)::ii) ldacctype n op1 ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) s
       stacctype t)))))))))))
   else
     (write_reg unconditional_ref True \<then>
     (if ((\<not> ((HaveAtomicExt () )))) then UnallocatedEncoding () 
      else return () )) \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (s :: ii) = (Word.uint Rs) in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     (let (regsize :: ii) = ((( 64 :: int)::ii)) in
     (let (ldacctype :: AccType) =
       (if ((((((A = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((Rt \<noteq> (vec_of_bits [B1,B1,B1,B1,B1]  ::  5 Word.word))))))) then
         AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     (let (stacctype :: AccType) =
       (if (((R1 = (vec_of_bits [B1]  ::  1 Word.word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     undefined_MemAtomicOp ()  \<bind> (\<lambda> (op1 :: MemAtomicOp) . 
     (let b__28 = opc in
     (let (op1 :: MemAtomicOp) =
       (if (((b__28 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) then MemAtomicOp_ADD
       else if (((b__28 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) then MemAtomicOp_BIC
       else if (((b__28 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) then MemAtomicOp_EOR
       else if (((b__28 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) then MemAtomicOp_ORR
       else if (((b__28 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) then MemAtomicOp_SMAX
       else if (((b__28 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) then MemAtomicOp_SMIN
       else if (((b__28 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) then MemAtomicOp_UMAX
       else MemAtomicOp_UMIN) in
     aarch64_memory_atomicops_ld (( 64 :: int)::ii) ldacctype n op1 ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) s
       stacctype t))))))))))))"


(*val memory_atomicops_cas_single_decode : mword ty2 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_atomicops_cas_single_decode  :: "(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_atomicops_cas_single_decode b__0 o2 L o1 Rs o0 Rt2 Rn Rt = (
   if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
     (write_reg unconditional_ref True \<then>
     (if ((\<not> ((HaveAtomicExt () )))) then UnallocatedEncoding () 
      else return () )) \<then>
     ((let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (s :: ii) = (Word.uint Rs) in
     (let (datasize :: ii) = ((( 8 :: int)::ii)) in
     (let (regsize :: ii) = ((( 32 :: int)::ii)) in
     (let (ldacctype :: AccType) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     (let (stacctype :: AccType) =
       (if (((o0 = (vec_of_bits [B1]  ::  1 Word.word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     aarch64_memory_atomicops_cas_single (( 8 :: int)::ii) ldacctype n
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) s stacctype t))))))))
   else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
     (write_reg unconditional_ref True \<then>
     (if ((\<not> ((HaveAtomicExt () )))) then UnallocatedEncoding () 
      else return () )) \<then>
     ((let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (s :: ii) = (Word.uint Rs) in
     (let (datasize :: ii) = ((( 16 :: int)::ii)) in
     (let (regsize :: ii) = ((( 32 :: int)::ii)) in
     (let (ldacctype :: AccType) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     (let (stacctype :: AccType) =
       (if (((o0 = (vec_of_bits [B1]  ::  1 Word.word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     aarch64_memory_atomicops_cas_single (( 16 :: int)::ii) ldacctype n
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) s stacctype t))))))))
   else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
     (write_reg unconditional_ref True \<then>
     (if ((\<not> ((HaveAtomicExt () )))) then UnallocatedEncoding () 
      else return () )) \<then>
     ((let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (s :: ii) = (Word.uint Rs) in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     (let (regsize :: ii) = ((( 32 :: int)::ii)) in
     (let (ldacctype :: AccType) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     (let (stacctype :: AccType) =
       (if (((o0 = (vec_of_bits [B1]  ::  1 Word.word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     aarch64_memory_atomicops_cas_single (( 32 :: int)::ii) ldacctype n
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) s stacctype t))))))))
   else
     (write_reg unconditional_ref True \<then>
     (if ((\<not> ((HaveAtomicExt () )))) then UnallocatedEncoding () 
      else return () )) \<then>
     ((let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (s :: ii) = (Word.uint Rs) in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     (let (regsize :: ii) = ((( 64 :: int)::ii)) in
     (let (ldacctype :: AccType) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     (let (stacctype :: AccType) =
       (if (((o0 = (vec_of_bits [B1]  ::  1 Word.word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     aarch64_memory_atomicops_cas_single (( 64 :: int)::ii) ldacctype n
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) s stacctype t)))))))))"


(*val memory_atomicops_cas_pair_decode : mword ty1 -> mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_atomicops_cas_pair_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_atomicops_cas_pair_decode b__0 o2 L o1 Rs o0 Rt2 Rn Rt = (
   if (((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) then
     (((write_reg unconditional_ref True \<then>
     (if ((\<not> ((HaveAtomicExt () )))) then UnallocatedEncoding () 
      else return () )) \<then>
     (if ((((vec_of_bits [access_vec_dec Rs (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
        UnallocatedEncoding () 
      else return () )) \<then>
     (if ((((vec_of_bits [access_vec_dec Rt (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
        UnallocatedEncoding () 
      else return () )) \<then>
     ((let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (s :: ii) = (Word.uint Rs) in
     (let (datasize :: ii) = ((( 32 :: int)::ii)) in
     (let (regsize :: ii) = ((( 32 :: int)::ii)) in
     (let (ldacctype :: AccType) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     (let (stacctype :: AccType) =
       (if (((o0 = (vec_of_bits [B1]  ::  1 Word.word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     aarch64_memory_atomicops_cas_pair (( 32 :: int)::ii) ldacctype n ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       s stacctype t))))))))
   else
     (((write_reg unconditional_ref True \<then>
     (if ((\<not> ((HaveAtomicExt () )))) then UnallocatedEncoding () 
      else return () )) \<then>
     (if ((((vec_of_bits [access_vec_dec Rs (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
        UnallocatedEncoding () 
      else return () )) \<then>
     (if ((((vec_of_bits [access_vec_dec Rt (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
        UnallocatedEncoding () 
      else return () )) \<then>
     ((let (n :: ii) = (Word.uint Rn) in
     (let (t :: ii) = (Word.uint Rt) in
     (let (s :: ii) = (Word.uint Rs) in
     (let (datasize :: ii) = ((( 64 :: int)::ii)) in
     (let (regsize :: ii) = ((( 64 :: int)::ii)) in
     (let (ldacctype :: AccType) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     (let (stacctype :: AccType) =
       (if (((o0 = (vec_of_bits [B1]  ::  1 Word.word)))) then AccType_ORDEREDRW
       else AccType_ATOMICRW) in
     aarch64_memory_atomicops_cas_pair (( 64 :: int)::ii) ldacctype n ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       s stacctype t)))))))))"


(*val integer_pac_strip_dp_1src_decode : mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

definition integer_pac_strip_dp_1src_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_pac_strip_dp_1src_decode sf S opcode2 D Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (data :: bool) = (D = (vec_of_bits [B1]  ::  1 Word.word)) in
   (let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   ((if ((\<not> ((HavePACExt () )))) then UnallocatedEncoding () 
    else return () ) \<then>
   (if (((((ex_int n)) \<noteq> (( 31 :: int)::ii)))) then UnallocatedEncoding () 
    else return () )) \<then>
   aarch64_integer_pac_strip_dp_1src d data)))))"


(*val integer_pac_pacib_dp_1src_decode : mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

definition integer_pac_pacib_dp_1src_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_pac_pacib_dp_1src_decode sf S opcode2 Z Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (source_is_sp :: bool) = False in
   (let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   ((if ((\<not> ((HavePACExt () )))) then UnallocatedEncoding () 
    else return () ) \<then>
   (if (((Z = (vec_of_bits [B0]  ::  1 Word.word)))) then
      (let (source_is_sp :: bool) = (if (((((ex_int n)) = (( 31 :: int)::ii)))) then True else source_is_sp) in
      return source_is_sp)
    else
      (if (((((ex_int n)) \<noteq> (( 31 :: int)::ii)))) then UnallocatedEncoding () 
       else return () ) \<then>
      return source_is_sp)) \<bind> (\<lambda> (source_is_sp :: bool) . 
   aarch64_integer_pac_pacib_dp_1src d n source_is_sp))))))"


(*val integer_pac_pacia_dp_1src_decode : mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

definition integer_pac_pacia_dp_1src_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_pac_pacia_dp_1src_decode sf S opcode2 Z Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (source_is_sp :: bool) = False in
   (let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   ((if ((\<not> ((HavePACExt () )))) then UnallocatedEncoding () 
    else return () ) \<then>
   (if (((Z = (vec_of_bits [B0]  ::  1 Word.word)))) then
      (let (source_is_sp :: bool) = (if (((((ex_int n)) = (( 31 :: int)::ii)))) then True else source_is_sp) in
      return source_is_sp)
    else
      (if (((((ex_int n)) \<noteq> (( 31 :: int)::ii)))) then UnallocatedEncoding () 
       else return () ) \<then>
      return source_is_sp)) \<bind> (\<lambda> (source_is_sp :: bool) . 
   aarch64_integer_pac_pacia_dp_1src d n source_is_sp))))))"


(*val integer_pac_pacga_dp_2src_decode : mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty6 -> mword ty5 -> mword ty5 -> M unit*)

definition integer_pac_pacga_dp_2src_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_pac_pacga_dp_2src_decode sf op1 S Rm opcode2 Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (source_is_sp :: bool) = False in
   (let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   (let (m :: ii) = (Word.uint Rm) in
   (if ((\<not> ((HavePACExt () )))) then UnallocatedEncoding () 
    else return () ) \<then>
   ((let (source_is_sp :: bool) = (if (((((ex_int m)) = (( 31 :: int)::ii)))) then True else source_is_sp) in
   aarch64_integer_pac_pacga_dp_2src d m n source_is_sp))))))))"


(*val integer_pac_pacdb_dp_1src_decode : mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

definition integer_pac_pacdb_dp_1src_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_pac_pacdb_dp_1src_decode sf S opcode2 Z Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (source_is_sp :: bool) = False in
   (let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   ((if ((\<not> ((HavePACExt () )))) then UnallocatedEncoding () 
    else return () ) \<then>
   (if (((Z = (vec_of_bits [B0]  ::  1 Word.word)))) then
      (let (source_is_sp :: bool) = (if (((((ex_int n)) = (( 31 :: int)::ii)))) then True else source_is_sp) in
      return source_is_sp)
    else
      (if (((((ex_int n)) \<noteq> (( 31 :: int)::ii)))) then UnallocatedEncoding () 
       else return () ) \<then>
      return source_is_sp)) \<bind> (\<lambda> (source_is_sp :: bool) . 
   aarch64_integer_pac_pacdb_dp_1src d n source_is_sp))))))"


(*val integer_pac_pacda_dp_1src_decode : mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

definition integer_pac_pacda_dp_1src_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_pac_pacda_dp_1src_decode sf S opcode2 Z Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (source_is_sp :: bool) = False in
   (let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   ((if ((\<not> ((HavePACExt () )))) then UnallocatedEncoding () 
    else return () ) \<then>
   (if (((Z = (vec_of_bits [B0]  ::  1 Word.word)))) then
      (let (source_is_sp :: bool) = (if (((((ex_int n)) = (( 31 :: int)::ii)))) then True else source_is_sp) in
      return source_is_sp)
    else
      (if (((((ex_int n)) \<noteq> (( 31 :: int)::ii)))) then UnallocatedEncoding () 
       else return () ) \<then>
      return source_is_sp)) \<bind> (\<lambda> (source_is_sp :: bool) . 
   aarch64_integer_pac_pacda_dp_1src d n source_is_sp))))))"


(*val integer_pac_autib_dp_1src_decode : mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

definition integer_pac_autib_dp_1src_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_pac_autib_dp_1src_decode sf S opcode2 Z Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (source_is_sp :: bool) = False in
   (let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   ((if ((\<not> ((HavePACExt () )))) then UnallocatedEncoding () 
    else return () ) \<then>
   (if (((Z = (vec_of_bits [B0]  ::  1 Word.word)))) then
      (let (source_is_sp :: bool) = (if (((((ex_int n)) = (( 31 :: int)::ii)))) then True else source_is_sp) in
      return source_is_sp)
    else
      (if (((((ex_int n)) \<noteq> (( 31 :: int)::ii)))) then UnallocatedEncoding () 
       else return () ) \<then>
      return source_is_sp)) \<bind> (\<lambda> (source_is_sp :: bool) . 
   aarch64_integer_pac_autib_dp_1src d n source_is_sp))))))"


(*val integer_pac_autia_dp_1src_decode : mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

definition integer_pac_autia_dp_1src_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_pac_autia_dp_1src_decode sf S opcode2 Z Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (source_is_sp :: bool) = False in
   (let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   ((if ((\<not> ((HavePACExt () )))) then UnallocatedEncoding () 
    else return () ) \<then>
   (if (((Z = (vec_of_bits [B0]  ::  1 Word.word)))) then
      (let (source_is_sp :: bool) = (if (((((ex_int n)) = (( 31 :: int)::ii)))) then True else source_is_sp) in
      return source_is_sp)
    else
      (if (((((ex_int n)) \<noteq> (( 31 :: int)::ii)))) then UnallocatedEncoding () 
       else return () ) \<then>
      return source_is_sp)) \<bind> (\<lambda> (source_is_sp :: bool) . 
   aarch64_integer_pac_autia_dp_1src d n source_is_sp))))))"


(*val integer_pac_autdb_dp_1src_decode : mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

definition integer_pac_autdb_dp_1src_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_pac_autdb_dp_1src_decode sf S opcode2 Z Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (source_is_sp :: bool) = False in
   (let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   ((if ((\<not> ((HavePACExt () )))) then UnallocatedEncoding () 
    else return () ) \<then>
   (if (((Z = (vec_of_bits [B0]  ::  1 Word.word)))) then
      (let (source_is_sp :: bool) = (if (((((ex_int n)) = (( 31 :: int)::ii)))) then True else source_is_sp) in
      return source_is_sp)
    else
      (if (((((ex_int n)) \<noteq> (( 31 :: int)::ii)))) then UnallocatedEncoding () 
       else return () ) \<then>
      return source_is_sp)) \<bind> (\<lambda> (source_is_sp :: bool) . 
   aarch64_integer_pac_autdb_dp_1src d n source_is_sp))))))"


(*val integer_pac_autda_dp_1src_decode : mword ty1 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

definition integer_pac_autda_dp_1src_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_pac_autda_dp_1src_decode sf S opcode2 Z Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (source_is_sp :: bool) = False in
   (let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   ((if ((\<not> ((HavePACExt () )))) then UnallocatedEncoding () 
    else return () ) \<then>
   (if (((Z = (vec_of_bits [B0]  ::  1 Word.word)))) then
      (let (source_is_sp :: bool) = (if (((((ex_int n)) = (( 31 :: int)::ii)))) then True else source_is_sp) in
      return source_is_sp)
    else
      (if (((((ex_int n)) \<noteq> (( 31 :: int)::ii)))) then UnallocatedEncoding () 
       else return () ) \<then>
      return source_is_sp)) \<bind> (\<lambda> (source_is_sp :: bool) . 
   aarch64_integer_pac_autda_dp_1src d n source_is_sp))))))"


(*val integer_insext_insert_movewide_decode : mword ty1 -> mword ty2 -> mword ty2 -> mword ty16 -> mword ty5 -> M unit*)

definition integer_insext_insert_movewide_decode  :: "(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_insext_insert_movewide_decode sf opc hw imm16 Rd = (
   write_reg unconditional_ref True \<then>
   ((let (d :: ii) = (Word.uint Rd) in
   (let (datasize :: int) =
     (if (((sf = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 64 :: int)::ii)
     else (( 32 :: int)::ii)) in
   (let (imm :: 16 bits) = imm16 in
   undefined_int ()  \<bind> (\<lambda> (pos :: ii) . 
   undefined_MoveWideOp ()  \<bind> (\<lambda> (opcode :: MoveWideOp) . 
   (let b__0 = opc in
   (if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then return MoveWideOp_N
    else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then return MoveWideOp_Z
    else if (((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) then return MoveWideOp_K
    else UnallocatedEncoding ()  \<then> return opcode) \<bind> (\<lambda> (opcode :: MoveWideOp) . 
   (if ((((((sf = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec hw (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))) then
      UnallocatedEncoding () 
    else return () ) \<then>
   ((let pos = (Word.uint ((concat_vec hw (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)  ::  6 Word.word))) in
   aarch64_integer_insext_insert_movewide d datasize imm opcode pos)))))))))))"


(*val integer_crc_decode : mword ty1 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty3 -> mword ty1 -> mword ty2 -> mword ty5 -> mword ty5 -> M unit*)

definition integer_crc_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_crc_decode sf op1 S Rm opcode2 C b__0 Rn Rd = (
   if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     ((if ((((((sf = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> True))) then UnallocatedEncoding () 
      else return () ) \<then>
     (if ((((((sf = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> False))) then
        UnallocatedEncoding () 
      else return () )) \<then>
     ((let (size1 :: ii) = ((( 8 :: int)::ii)) in
     (let (crc32c :: bool) = (C = (vec_of_bits [B1]  ::  1 Word.word)) in
     aarch64_integer_crc crc32c d m n (( 8 :: int)::ii))))))))
   else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     ((if ((((((sf = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> True))) then UnallocatedEncoding () 
      else return () ) \<then>
     (if ((((((sf = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> False))) then
        UnallocatedEncoding () 
      else return () )) \<then>
     ((let (size1 :: ii) = ((( 16 :: int)::ii)) in
     (let (crc32c :: bool) = (C = (vec_of_bits [B1]  ::  1 Word.word)) in
     aarch64_integer_crc crc32c d m n (( 16 :: int)::ii))))))))
   else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     ((if ((((((sf = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> True))) then UnallocatedEncoding () 
      else return () ) \<then>
     (if ((((((sf = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> False))) then
        UnallocatedEncoding () 
      else return () )) \<then>
     ((let (size1 :: ii) = ((( 32 :: int)::ii)) in
     (let (crc32c :: bool) = (C = (vec_of_bits [B1]  ::  1 Word.word)) in
     aarch64_integer_crc crc32c d m n (( 32 :: int)::ii))))))))
   else
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     ((if ((((((sf = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> False))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     (if ((((((sf = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> True))) then UnallocatedEncoding () 
      else return () )) \<then>
     ((let (size1 :: ii) = ((( 64 :: int)::ii)) in
     (let (crc32c :: bool) = (C = (vec_of_bits [B1]  ::  1 Word.word)) in
     aarch64_integer_crc crc32c d m n (( 64 :: int)::ii)))))))))"


(*val integer_arithmetic_rev_decode : mword ty1 -> mword ty1 -> mword ty5 -> mword ty2 -> mword ty5 -> mword ty5 -> M unit*)

definition integer_arithmetic_rev_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_arithmetic_rev_decode sf S opcode2 opc Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   (let (datasize :: int) =
     (if (((sf = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 64 :: int)::ii)
     else (( 32 :: int)::ii)) in
   undefined_int ()  \<bind> (\<lambda> (container_size :: ii) . 
   (let b__0 = opc in
   (if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
      Unreachable ()  \<then> return container_size
    else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then return (( 16 :: int)::ii)
    else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then return (( 32 :: int)::ii)
    else
      (if (((sf = (vec_of_bits [B0]  ::  1 Word.word)))) then UnallocatedEncoding () 
       else return () ) \<then>
      return (( 64 :: int)::ii)) \<bind> (\<lambda> (container_size :: ii) . 
   aarch64_integer_arithmetic_rev container_size d datasize n))))))))"


(*val float_move_fp_select_decode : mword ty1 -> mword ty1 -> mword ty2 -> mword ty5 -> mword ty4 -> mword ty5 -> mword ty5 -> M unit*)

definition float_move_fp_select_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " float_move_fp_select_decode M S typ1 Rm cond Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   (let (m :: ii) = (Word.uint Rm) in
   undefined_int ()  \<bind> (\<lambda> (datasize :: ii) . 
   (let b__0 = typ1 in
   (if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then return (( 32 :: int)::ii)
    else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then return (( 64 :: int)::ii)
    else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
      UnallocatedEncoding ()  \<then> return datasize
    else if ((HaveFP16Ext () )) then return (( 16 :: int)::ii)
    else UnallocatedEncoding ()  \<then> return datasize) \<bind> (\<lambda> (datasize :: ii) . 
   (let (condition :: 4 bits) = cond in
   aarch64_float_move_fp_select condition d datasize m n)))))))))"


(*val float_move_fp_imm_decode : mword ty1 -> mword ty1 -> mword ty2 -> mword ty8 -> mword ty5 -> mword ty5 -> M unit*)

definition float_move_fp_imm_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(8)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " float_move_fp_imm_decode M S b__0 imm8 imm5 Rd = (
   if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     undefined_int ()  \<bind> (\<lambda> (datasize :: ii) . 
     (let datasize = ((( 32 :: int)::ii)) in
     (assert_exp True ('''') \<then>
     (VFPExpandImm (( 32 :: int)::ii) imm8  :: ( 32 Word.word) M)) \<bind> (\<lambda> (imm :: 32 bits) . 
     aarch64_float_move_fp_imm d ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) imm)))))
   else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     undefined_int ()  \<bind> (\<lambda> (datasize :: ii) . 
     (let datasize = ((( 64 :: int)::ii)) in
     (assert_exp True ('''') \<then>
     (VFPExpandImm (( 64 :: int)::ii) imm8  :: ( 64 Word.word) M)) \<bind> (\<lambda> (imm :: 64 bits) . 
     aarch64_float_move_fp_imm d ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) imm)))))
   else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     undefined_int ()  \<bind> (\<lambda> (datasize :: ii) . 
     ((UnallocatedEncoding ()  \<then>
     assert_exp True ('''')) \<then>
     (VFPExpandImm (( 32 :: int)::ii) imm8  :: ( 32 Word.word) M)) \<bind> (\<lambda> (imm :: 32 bits) . 
     aarch64_float_move_fp_imm d ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) imm))))
   else
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     undefined_int ()  \<bind> (\<lambda> (datasize :: ii) . 
     (let datasize = ((( 16 :: int)::ii)) in
     (assert_exp True ('''') \<then>
     (VFPExpandImm (( 16 :: int)::ii) imm8  :: ( 16 Word.word) M)) \<bind> (\<lambda> (imm :: 16 bits) . 
     aarch64_float_move_fp_imm d ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) imm))))))"


(*val aarch64_float_convert_int_split : ii -> ii -> ii -> ii -> FPConvOp -> ii -> FPRounding -> bool -> M unit*)

definition aarch64_float_convert_int_split  :: " int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow> FPConvOp \<Rightarrow> int \<Rightarrow> FPRounding \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_float_convert_int_split d l__0 l__1 n op1 part rounding unsigned = (
   if ((((((l__0 = (( 16 :: int)::ii)))) \<and> (((l__1 = (( 32 :: int)::ii))))))) then
     aarch64_float_convert_int d ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) n op1 part rounding unsigned
   else if ((((((l__0 = (( 16 :: int)::ii)))) \<and> (((l__1 = (( 64 :: int)::ii))))))) then
     aarch64_float_convert_int d ((make_the_value (( 16 :: int)::ii)  ::  16 itself))
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) n op1 part rounding unsigned
   else if ((((((l__0 = (( 32 :: int)::ii)))) \<and> (((l__1 = (( 32 :: int)::ii))))))) then
     aarch64_float_convert_int d ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) n op1 part rounding unsigned
   else if ((((((l__0 = (( 32 :: int)::ii)))) \<and> (((l__1 = (( 64 :: int)::ii))))))) then
     aarch64_float_convert_int d ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) n op1 part rounding unsigned
   else if ((((((l__0 = (( 64 :: int)::ii)))) \<and> (((l__1 = (( 32 :: int)::ii))))))) then
     aarch64_float_convert_int d ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) n op1 part rounding unsigned
   else if ((((((l__0 = (( 64 :: int)::ii)))) \<and> (((l__1 = (( 64 :: int)::ii))))))) then
     aarch64_float_convert_int d ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) n op1 part rounding unsigned
   else if ((((((l__0 = (( 128 :: int)::ii)))) \<and> (((l__1 = (( 32 :: int)::ii))))))) then
     aarch64_float_convert_int d ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) n op1 part rounding unsigned
   else
     aarch64_float_convert_int d ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) n op1 part rounding unsigned )"


(*val float_convert_int_decode : mword ty1 -> mword ty1 -> mword ty2 -> mword ty2 -> mword ty3 -> mword ty5 -> mword ty5 -> M unit*)

definition float_convert_int_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " float_convert_int_decode sf S typ1 rmode opcode Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   (let (intsize :: int) =
     (if (((sf = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 64 :: int)::ii)
     else (( 32 :: int)::ii)) in
   undefined_int ()  \<bind> (\<lambda> (fltsize :: ii) . 
   undefined_FPConvOp ()  \<bind> (\<lambda> (op1 :: FPConvOp) . 
   undefined_FPRounding ()  \<bind> (\<lambda> (rounding :: FPRounding) . 
   undefined_bool ()  \<bind> (\<lambda> (unsigned :: bool) . 
   undefined_int ()  \<bind> (\<lambda> (part :: ii) . 
   (let b__0 = typ1 in
   (if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then return (( 32 :: int)::ii)
    else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then return (( 64 :: int)::ii)
    else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
      (if (((((concat_vec ((slice opcode (( 1 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) rmode  ::  4 Word.word)) \<noteq> (vec_of_bits [B1,B1,B0,B1]  ::  4 Word.word)))) then
         UnallocatedEncoding () 
       else return () ) \<then>
      return (( 128 :: int)::ii)
    else if ((HaveFP16Ext () )) then return (( 16 :: int)::ii)
    else UnallocatedEncoding ()  \<then> return fltsize) \<bind> (\<lambda> (fltsize :: ii) . 
   (let v__98 = ((concat_vec ((slice opcode (( 1 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) rmode  ::  4 Word.word)) in
   (if (((((subrange_vec_dec v__98 (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
      (let (rounding :: FPRounding) = (FPDecodeRounding rmode) in
      (let (unsigned :: bool) =
        ((vec_of_bits [access_vec_dec opcode (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
      (let (op1 :: FPConvOp) = FPConvOp_CVT_FtoI in
      return (fltsize, op1, part, rounding, unsigned))))
    else if (((v__98 = (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)))) then
      (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 :: 32 bits) . 
      (let (rounding :: FPRounding) = (FPRoundingMode w__0) in
      (let (unsigned :: bool) =
        ((vec_of_bits [access_vec_dec opcode (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
      (let (op1 :: FPConvOp) = FPConvOp_CVT_ItoF in
      return (fltsize, op1, part, rounding, unsigned)))))
    else if (((v__98 = (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)))) then
      (let (rounding :: FPRounding) = FPRounding_TIEAWAY in
      (let (unsigned :: bool) =
        ((vec_of_bits [access_vec_dec opcode (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
      (let (op1 :: FPConvOp) = FPConvOp_CVT_FtoI in
      return (fltsize, op1, part, rounding, unsigned))))
    else if (((v__98 = (vec_of_bits [B1,B1,B0,B0]  ::  4 Word.word)))) then
      (if ((((((((ex_int fltsize)) \<noteq> (( 16 :: int)::ii)))) \<and> (((((ex_int fltsize)) \<noteq> intsize)))))) then
         UnallocatedEncoding () 
       else return () ) \<then>
      ((let (op1 :: FPConvOp) =
        (if ((((vec_of_bits [access_vec_dec opcode (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
          FPConvOp_MOV_ItoF
        else FPConvOp_MOV_FtoI) in
      (let (part :: ii) = ((( 0 :: int)::ii)) in
      return (fltsize, op1, part, rounding, unsigned))))
    else if (((v__98 = (vec_of_bits [B1,B1,B0,B1]  ::  4 Word.word)))) then
      (if ((((((((ex_int intsize)) \<noteq> (( 64 :: int)::ii)))) \<or> (((((ex_int fltsize)) \<noteq> (( 128 :: int)::ii))))))) then
         UnallocatedEncoding () 
       else return () ) \<then>
      ((let (op1 :: FPConvOp) =
        (if ((((vec_of_bits [access_vec_dec opcode (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
          FPConvOp_MOV_ItoF
        else FPConvOp_MOV_FtoI) in
      (let (part :: ii) = ((( 1 :: int)::ii)) in
      (let (fltsize :: ii) = ((( 64 :: int)::ii)) in
      return (fltsize, op1, part, rounding, unsigned)))))
    else
      (if (((v__98 = (vec_of_bits [B1,B1,B1,B1]  ::  4 Word.word)))) then
         (if ((\<not> ((HaveFJCVTZSExt () )))) then UnallocatedEncoding () 
          else return () ) \<then>
         ((let (rounding :: FPRounding) = FPRounding_ZERO in
         (let (unsigned :: bool) =
           ((vec_of_bits [access_vec_dec opcode (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
         (let (op1 :: FPConvOp) = FPConvOp_CVT_FtoI_JS in
         return (op1, rounding, unsigned)))))
       else UnallocatedEncoding ()  \<then> return (op1, rounding, unsigned)) \<bind> (\<lambda> varstup .  (let ((op1 ::
        FPConvOp), (rounding :: FPRounding), (unsigned :: bool)) = varstup in
      return (fltsize, op1, part, rounding, unsigned)))) \<bind> (\<lambda> varstup .  (let ((fltsize :: ii), (op1 ::
     FPConvOp), (part :: ii), (rounding :: FPRounding), (unsigned :: bool)) = varstup in
   (let fltsize2 = (ex_int fltsize) in
   assert_exp True ('''') \<then>
   aarch64_float_convert_int_split d fltsize2 intsize n op1 part rounding unsigned))))))))))))))))"


(*val float_convert_fp_decode : mword ty1 -> mword ty1 -> mword ty2 -> mword ty2 -> mword ty5 -> mword ty5 -> M unit*)

definition float_convert_fp_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " float_convert_fp_decode M S b__0 b__1 Rn Rd = (
   if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     (UnallocatedEncoding ()  \<then>
     undefined_int () ) \<bind> (\<lambda> (srcsize :: ii) . 
     (let srcsize = ((( 32 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (dstsize :: ii) . 
     (let dstsize = ((( 32 :: int)::ii)) in
     assert_exp True ('''') \<then>
     aarch64_float_convert_fp d ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) n
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (srcsize :: ii) . 
     (let srcsize = ((( 32 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (dstsize :: ii) . 
     (let dstsize = ((( 64 :: int)::ii)) in
     assert_exp True ('''') \<then>
     aarch64_float_convert_fp d ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) n
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (srcsize :: ii) . 
     (let srcsize = ((( 32 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (dstsize :: ii) . 
     (UnallocatedEncoding ()  \<then>
     assert_exp True ('''')) \<then>
     aarch64_float_convert_fp d ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) n
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (srcsize :: ii) . 
     (let srcsize = ((( 32 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (dstsize :: ii) . 
     (let dstsize = ((( 16 :: int)::ii)) in
     assert_exp True ('''') \<then>
     aarch64_float_convert_fp d ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) n
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (srcsize :: ii) . 
     (let srcsize = ((( 64 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (dstsize :: ii) . 
     (let dstsize = ((( 32 :: int)::ii)) in
     assert_exp True ('''') \<then>
     aarch64_float_convert_fp d ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) n
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     (UnallocatedEncoding ()  \<then>
     undefined_int () ) \<bind> (\<lambda> (srcsize :: ii) . 
     (let srcsize = ((( 64 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (dstsize :: ii) . 
     (let dstsize = ((( 64 :: int)::ii)) in
     assert_exp True ('''') \<then>
     aarch64_float_convert_fp d ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) n
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (srcsize :: ii) . 
     (let srcsize = ((( 64 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (dstsize :: ii) . 
     (UnallocatedEncoding ()  \<then>
     assert_exp True ('''')) \<then>
     aarch64_float_convert_fp d ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) n
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself))))))))
   else if ((((((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (srcsize :: ii) . 
     (let srcsize = ((( 64 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (dstsize :: ii) . 
     (let dstsize = ((( 16 :: int)::ii)) in
     assert_exp True ('''') \<then>
     aarch64_float_convert_fp d ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) n
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (srcsize :: ii) . 
     (UnallocatedEncoding ()  \<then>
     undefined_int () ) \<bind> (\<lambda> (dstsize :: ii) . 
     (let dstsize = ((( 32 :: int)::ii)) in
     assert_exp True ('''') \<then>
     aarch64_float_convert_fp d ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) n
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (srcsize :: ii) . 
     (UnallocatedEncoding ()  \<then>
     undefined_int () ) \<bind> (\<lambda> (dstsize :: ii) . 
     (let dstsize = ((( 64 :: int)::ii)) in
     assert_exp True ('''') \<then>
     aarch64_float_convert_fp d ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) n
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     (UnallocatedEncoding ()  \<then>
     undefined_int () ) \<bind> (\<lambda> (srcsize :: ii) . 
     (UnallocatedEncoding ()  \<then>
     undefined_int () ) \<bind> (\<lambda> (dstsize :: ii) . 
     (UnallocatedEncoding ()  \<then>
     assert_exp True ('''')) \<then>
     aarch64_float_convert_fp d ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) n
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)))))))
   else if ((((((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (srcsize :: ii) . 
     (UnallocatedEncoding ()  \<then>
     undefined_int () ) \<bind> (\<lambda> (dstsize :: ii) . 
     (let dstsize = ((( 16 :: int)::ii)) in
     assert_exp True ('''') \<then>
     aarch64_float_convert_fp d ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) n
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (srcsize :: ii) . 
     (let srcsize = ((( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (dstsize :: ii) . 
     (let dstsize = ((( 32 :: int)::ii)) in
     assert_exp True ('''') \<then>
     aarch64_float_convert_fp d ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) n
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (srcsize :: ii) . 
     (let srcsize = ((( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (dstsize :: ii) . 
     (let dstsize = ((( 64 :: int)::ii)) in
     assert_exp True ('''') \<then>
     aarch64_float_convert_fp d ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) n
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself)))))))))
   else if ((((((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (srcsize :: ii) . 
     (let srcsize = ((( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (dstsize :: ii) . 
     (UnallocatedEncoding ()  \<then>
     assert_exp True ('''')) \<then>
     aarch64_float_convert_fp d ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) n
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself))))))))
   else
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     (UnallocatedEncoding ()  \<then>
     undefined_int () ) \<bind> (\<lambda> (srcsize :: ii) . 
     (let srcsize = ((( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (dstsize :: ii) . 
     (let dstsize = ((( 16 :: int)::ii)) in
     assert_exp True ('''') \<then>
     aarch64_float_convert_fp d ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) n
       ((make_the_value (( 16 :: int)::ii)  ::  16 itself))))))))))"


(*val float_convert_fix_decode : mword ty1 -> mword ty1 -> mword ty2 -> mword ty2 -> mword ty3 -> mword ty6 -> mword ty5 -> mword ty5 -> M unit*)

definition float_convert_fix_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " float_convert_fix_decode b__0 S b__1 rmode opcode scale Rn Rd = (
   if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (intsize :: ii) = ((( 32 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (fltsize :: ii) . 
     undefined_FPConvOp ()  \<bind> (\<lambda> (op1 :: FPConvOp) . 
     undefined_FPRounding ()  \<bind> (\<lambda> (rounding :: FPRounding) . 
     undefined_bool ()  \<bind> (\<lambda> (unsigned :: bool) . 
     (let fltsize = ((( 32 :: int)::ii)) in
     (if (((True \<and> ((((vec_of_bits [access_vec_dec scale (( 5 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (fracbits :: ii) = ((( 64 :: int)::ii) - ((Word.uint scale))) in
     (let b__2 = ((concat_vec ((slice opcode (( 1 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) rmode  ::  4 Word.word)) in
     (if (((b__2 = (vec_of_bits [B0,B0,B1,B1]  ::  4 Word.word)))) then
        (let (rounding :: FPRounding) = FPRounding_ZERO in
        (let (unsigned :: bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
        (let (op1 :: FPConvOp) = FPConvOp_CVT_FtoI in
        return (op1, rounding, unsigned))))
      else if (((b__2 = (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)))) then
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 :: 32 bits) . 
        (let (rounding :: FPRounding) = (FPRoundingMode w__0) in
        (let (unsigned :: bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
        (let (op1 :: FPConvOp) = FPConvOp_CVT_ItoF in
        return (op1, rounding, unsigned)))))
      else UnallocatedEncoding ()  \<then> return (op1, rounding, unsigned)) \<bind> (\<lambda> varstup .  (let ((op1 ::
       FPConvOp), (rounding :: FPRounding), (unsigned :: bool)) = varstup in
     assert_exp True ('''') \<then>
     aarch64_float_convert_fix d ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) fracbits
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) n op1 rounding unsigned))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (intsize :: ii) = ((( 32 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (fltsize :: ii) . 
     undefined_FPConvOp ()  \<bind> (\<lambda> (op1 :: FPConvOp) . 
     undefined_FPRounding ()  \<bind> (\<lambda> (rounding :: FPRounding) . 
     undefined_bool ()  \<bind> (\<lambda> (unsigned :: bool) . 
     (let fltsize = ((( 64 :: int)::ii)) in
     (if (((True \<and> ((((vec_of_bits [access_vec_dec scale (( 5 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (fracbits :: ii) = ((( 64 :: int)::ii) - ((Word.uint scale))) in
     (let b__6 = ((concat_vec ((slice opcode (( 1 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) rmode  ::  4 Word.word)) in
     (if (((b__6 = (vec_of_bits [B0,B0,B1,B1]  ::  4 Word.word)))) then
        (let (rounding :: FPRounding) = FPRounding_ZERO in
        (let (unsigned :: bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
        (let (op1 :: FPConvOp) = FPConvOp_CVT_FtoI in
        return (op1, rounding, unsigned))))
      else if (((b__6 = (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)))) then
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 :: 32 bits) . 
        (let (rounding :: FPRounding) = (FPRoundingMode w__1) in
        (let (unsigned :: bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
        (let (op1 :: FPConvOp) = FPConvOp_CVT_ItoF in
        return (op1, rounding, unsigned)))))
      else UnallocatedEncoding ()  \<then> return (op1, rounding, unsigned)) \<bind> (\<lambda> varstup .  (let ((op1 ::
       FPConvOp), (rounding :: FPRounding), (unsigned :: bool)) = varstup in
     assert_exp True ('''') \<then>
     aarch64_float_convert_fix d ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) fracbits
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) n op1 rounding unsigned))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (intsize :: ii) = ((( 32 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (fltsize :: ii) . 
     undefined_FPConvOp ()  \<bind> (\<lambda> (op1 :: FPConvOp) . 
     undefined_FPRounding ()  \<bind> (\<lambda> (rounding :: FPRounding) . 
     undefined_bool ()  \<bind> (\<lambda> (unsigned :: bool) . 
     (UnallocatedEncoding ()  \<then>
     (if (((True \<and> ((((vec_of_bits [access_vec_dec scale (( 5 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () )) \<then>
     ((let (fracbits :: ii) = ((( 64 :: int)::ii) - ((Word.uint scale))) in
     (let b__10 = ((concat_vec ((slice opcode (( 1 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) rmode  ::  4 Word.word)) in
     (if (((b__10 = (vec_of_bits [B0,B0,B1,B1]  ::  4 Word.word)))) then
        (let (rounding :: FPRounding) = FPRounding_ZERO in
        (let (unsigned :: bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
        (let (op1 :: FPConvOp) = FPConvOp_CVT_FtoI in
        return (op1, rounding, unsigned))))
      else if (((b__10 = (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)))) then
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__2 :: 32 bits) . 
        (let (rounding :: FPRounding) = (FPRoundingMode w__2) in
        (let (unsigned :: bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
        (let (op1 :: FPConvOp) = FPConvOp_CVT_ItoF in
        return (op1, rounding, unsigned)))))
      else UnallocatedEncoding ()  \<then> return (op1, rounding, unsigned)) \<bind> (\<lambda> varstup .  (let ((op1 ::
       FPConvOp), (rounding :: FPRounding), (unsigned :: bool)) = varstup in
     assert_exp True ('''') \<then>
     aarch64_float_convert_fix d ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) fracbits
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) n op1 rounding unsigned)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (intsize :: ii) = ((( 32 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (fltsize :: ii) . 
     undefined_FPConvOp ()  \<bind> (\<lambda> (op1 :: FPConvOp) . 
     undefined_FPRounding ()  \<bind> (\<lambda> (rounding :: FPRounding) . 
     undefined_bool ()  \<bind> (\<lambda> (unsigned :: bool) . 
     (let fltsize = ((( 16 :: int)::ii)) in
     (if (((True \<and> ((((vec_of_bits [access_vec_dec scale (( 5 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (fracbits :: ii) = ((( 64 :: int)::ii) - ((Word.uint scale))) in
     (let b__14 = ((concat_vec ((slice opcode (( 1 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) rmode  ::  4 Word.word)) in
     (if (((b__14 = (vec_of_bits [B0,B0,B1,B1]  ::  4 Word.word)))) then
        (let (rounding :: FPRounding) = FPRounding_ZERO in
        (let (unsigned :: bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
        (let (op1 :: FPConvOp) = FPConvOp_CVT_FtoI in
        return (op1, rounding, unsigned))))
      else if (((b__14 = (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)))) then
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__3 :: 32 bits) . 
        (let (rounding :: FPRounding) = (FPRoundingMode w__3) in
        (let (unsigned :: bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
        (let (op1 :: FPConvOp) = FPConvOp_CVT_ItoF in
        return (op1, rounding, unsigned)))))
      else UnallocatedEncoding ()  \<then> return (op1, rounding, unsigned)) \<bind> (\<lambda> varstup .  (let ((op1 ::
       FPConvOp), (rounding :: FPRounding), (unsigned :: bool)) = varstup in
     assert_exp True ('''') \<then>
     aarch64_float_convert_fix d ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) fracbits
       ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) n op1 rounding unsigned))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (intsize :: ii) = ((( 64 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (fltsize :: ii) . 
     undefined_FPConvOp ()  \<bind> (\<lambda> (op1 :: FPConvOp) . 
     undefined_FPRounding ()  \<bind> (\<lambda> (rounding :: FPRounding) . 
     undefined_bool ()  \<bind> (\<lambda> (unsigned :: bool) . 
     (let fltsize = ((( 32 :: int)::ii)) in
     (if (((False \<and> ((((vec_of_bits [access_vec_dec scale (( 5 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (fracbits :: ii) = ((( 64 :: int)::ii) - ((Word.uint scale))) in
     (let b__18 = ((concat_vec ((slice opcode (( 1 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) rmode  ::  4 Word.word)) in
     (if (((b__18 = (vec_of_bits [B0,B0,B1,B1]  ::  4 Word.word)))) then
        (let (rounding :: FPRounding) = FPRounding_ZERO in
        (let (unsigned :: bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
        (let (op1 :: FPConvOp) = FPConvOp_CVT_FtoI in
        return (op1, rounding, unsigned))))
      else if (((b__18 = (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)))) then
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__4 :: 32 bits) . 
        (let (rounding :: FPRounding) = (FPRoundingMode w__4) in
        (let (unsigned :: bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
        (let (op1 :: FPConvOp) = FPConvOp_CVT_ItoF in
        return (op1, rounding, unsigned)))))
      else UnallocatedEncoding ()  \<then> return (op1, rounding, unsigned)) \<bind> (\<lambda> varstup .  (let ((op1 ::
       FPConvOp), (rounding :: FPRounding), (unsigned :: bool)) = varstup in
     assert_exp True ('''') \<then>
     aarch64_float_convert_fix d ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) fracbits
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) n op1 rounding unsigned))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (intsize :: ii) = ((( 64 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (fltsize :: ii) . 
     undefined_FPConvOp ()  \<bind> (\<lambda> (op1 :: FPConvOp) . 
     undefined_FPRounding ()  \<bind> (\<lambda> (rounding :: FPRounding) . 
     undefined_bool ()  \<bind> (\<lambda> (unsigned :: bool) . 
     (let fltsize = ((( 64 :: int)::ii)) in
     (if (((False \<and> ((((vec_of_bits [access_vec_dec scale (( 5 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (fracbits :: ii) = ((( 64 :: int)::ii) - ((Word.uint scale))) in
     (let b__22 = ((concat_vec ((slice opcode (( 1 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) rmode  ::  4 Word.word)) in
     (if (((b__22 = (vec_of_bits [B0,B0,B1,B1]  ::  4 Word.word)))) then
        (let (rounding :: FPRounding) = FPRounding_ZERO in
        (let (unsigned :: bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
        (let (op1 :: FPConvOp) = FPConvOp_CVT_FtoI in
        return (op1, rounding, unsigned))))
      else if (((b__22 = (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)))) then
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__5 :: 32 bits) . 
        (let (rounding :: FPRounding) = (FPRoundingMode w__5) in
        (let (unsigned :: bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
        (let (op1 :: FPConvOp) = FPConvOp_CVT_ItoF in
        return (op1, rounding, unsigned)))))
      else UnallocatedEncoding ()  \<then> return (op1, rounding, unsigned)) \<bind> (\<lambda> varstup .  (let ((op1 ::
       FPConvOp), (rounding :: FPRounding), (unsigned :: bool)) = varstup in
     assert_exp True ('''') \<then>
     aarch64_float_convert_fix d ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) fracbits
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) n op1 rounding unsigned))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (intsize :: ii) = ((( 64 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (fltsize :: ii) . 
     undefined_FPConvOp ()  \<bind> (\<lambda> (op1 :: FPConvOp) . 
     undefined_FPRounding ()  \<bind> (\<lambda> (rounding :: FPRounding) . 
     undefined_bool ()  \<bind> (\<lambda> (unsigned :: bool) . 
     (UnallocatedEncoding ()  \<then>
     (if (((False \<and> ((((vec_of_bits [access_vec_dec scale (( 5 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () )) \<then>
     ((let (fracbits :: ii) = ((( 64 :: int)::ii) - ((Word.uint scale))) in
     (let b__26 = ((concat_vec ((slice opcode (( 1 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) rmode  ::  4 Word.word)) in
     (if (((b__26 = (vec_of_bits [B0,B0,B1,B1]  ::  4 Word.word)))) then
        (let (rounding :: FPRounding) = FPRounding_ZERO in
        (let (unsigned :: bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
        (let (op1 :: FPConvOp) = FPConvOp_CVT_FtoI in
        return (op1, rounding, unsigned))))
      else if (((b__26 = (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)))) then
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__6 :: 32 bits) . 
        (let (rounding :: FPRounding) = (FPRoundingMode w__6) in
        (let (unsigned :: bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
        (let (op1 :: FPConvOp) = FPConvOp_CVT_ItoF in
        return (op1, rounding, unsigned)))))
      else UnallocatedEncoding ()  \<then> return (op1, rounding, unsigned)) \<bind> (\<lambda> varstup .  (let ((op1 ::
       FPConvOp), (rounding :: FPRounding), (unsigned :: bool)) = varstup in
     assert_exp True ('''') \<then>
     aarch64_float_convert_fix d ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) fracbits
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) n op1 rounding unsigned)))))))))))))
   else
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (intsize :: ii) = ((( 64 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (fltsize :: ii) . 
     undefined_FPConvOp ()  \<bind> (\<lambda> (op1 :: FPConvOp) . 
     undefined_FPRounding ()  \<bind> (\<lambda> (rounding :: FPRounding) . 
     undefined_bool ()  \<bind> (\<lambda> (unsigned :: bool) . 
     (let fltsize = ((( 16 :: int)::ii)) in
     (if (((False \<and> ((((vec_of_bits [access_vec_dec scale (( 5 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))) then
        UnallocatedEncoding () 
      else return () ) \<then>
     ((let (fracbits :: ii) = ((( 64 :: int)::ii) - ((Word.uint scale))) in
     (let b__30 = ((concat_vec ((slice opcode (( 1 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) rmode  ::  4 Word.word)) in
     (if (((b__30 = (vec_of_bits [B0,B0,B1,B1]  ::  4 Word.word)))) then
        (let (rounding :: FPRounding) = FPRounding_ZERO in
        (let (unsigned :: bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
        (let (op1 :: FPConvOp) = FPConvOp_CVT_FtoI in
        return (op1, rounding, unsigned))))
      else if (((b__30 = (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)))) then
        (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__7 :: 32 bits) . 
        (let (rounding :: FPRounding) = (FPRoundingMode w__7) in
        (let (unsigned :: bool) =
          ((vec_of_bits [access_vec_dec opcode (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
        (let (op1 :: FPConvOp) = FPConvOp_CVT_ItoF in
        return (op1, rounding, unsigned)))))
      else UnallocatedEncoding ()  \<then> return (op1, rounding, unsigned)) \<bind> (\<lambda> varstup .  (let ((op1 ::
       FPConvOp), (rounding :: FPRounding), (unsigned :: bool)) = varstup in
     assert_exp True ('''') \<then>
     aarch64_float_convert_fix d ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) fracbits
       ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) n op1 rounding unsigned)))))))))))))))"


(*val float_compare_uncond_decode : mword ty1 -> mword ty1 -> mword ty2 -> mword ty5 -> mword ty2 -> mword ty5 -> mword ty2 -> M unit*)

definition float_compare_uncond_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " float_compare_uncond_decode M S typ1 Rm op1 Rn opc = (
   write_reg unconditional_ref True \<then>
   ((let (n :: ii) = (Word.uint Rn) in
   (let (m :: ii) = (Word.uint Rm) in
   undefined_int ()  \<bind> (\<lambda> (datasize :: ii) . 
   (let b__0 = typ1 in
   (if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then return (( 32 :: int)::ii)
    else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then return (( 64 :: int)::ii)
    else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
      UnallocatedEncoding ()  \<then> return datasize
    else if ((HaveFP16Ext () )) then return (( 16 :: int)::ii)
    else UnallocatedEncoding ()  \<then> return datasize) \<bind> (\<lambda> (datasize :: ii) . 
   (let (signal_all_nans :: bool) =
     ((vec_of_bits [access_vec_dec opc (( 1 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
   (let (cmp_with_zero :: bool) =
     ((vec_of_bits [access_vec_dec opc (( 0 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)) in
   aarch64_float_compare_uncond cmp_with_zero datasize m n signal_all_nans)))))))))"


(*val float_compare_cond_decode : mword ty1 -> mword ty1 -> mword ty2 -> mword ty5 -> mword ty4 -> mword ty5 -> mword ty1 -> mword ty4 -> M unit*)

definition float_compare_cond_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " float_compare_cond_decode M S typ1 Rm cond Rn op1 nzcv = (
   write_reg unconditional_ref True \<then>
   ((let (n :: ii) = (Word.uint Rn) in
   (let (m :: ii) = (Word.uint Rm) in
   undefined_int ()  \<bind> (\<lambda> (datasize :: ii) . 
   (let b__0 = typ1 in
   (if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then return (( 32 :: int)::ii)
    else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then return (( 64 :: int)::ii)
    else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
      UnallocatedEncoding ()  \<then> return datasize
    else if ((HaveFP16Ext () )) then return (( 16 :: int)::ii)
    else UnallocatedEncoding ()  \<then> return datasize) \<bind> (\<lambda> (datasize :: ii) . 
   (let (signal_all_nans :: bool) = (op1 = (vec_of_bits [B1]  ::  1 Word.word)) in
   (let (condition :: 4 bits) = cond in
   (let (flags :: 4 bits) = nzcv in
   aarch64_float_compare_cond condition datasize flags m n signal_all_nans))))))))))"


(*val float_arithmetic_unary_decode : mword ty1 -> mword ty1 -> mword ty2 -> mword ty2 -> mword ty5 -> mword ty5 -> M unit*)

definition float_arithmetic_unary_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " float_arithmetic_unary_decode M S typ1 opc Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   undefined_int ()  \<bind> (\<lambda> (datasize :: ii) . 
   (let b__0 = typ1 in
   (if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then return (( 32 :: int)::ii)
    else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then return (( 64 :: int)::ii)
    else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
      UnallocatedEncoding ()  \<then> return datasize
    else if ((HaveFP16Ext () )) then return (( 16 :: int)::ii)
    else UnallocatedEncoding ()  \<then> return datasize) \<bind> (\<lambda> (datasize :: ii) . 
   undefined_FPUnaryOp ()  \<bind> (\<lambda> (fpop :: FPUnaryOp) . 
   (let b__4 = opc in
   (let (fpop :: FPUnaryOp) =
     (if (((b__4 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then FPUnaryOp_MOV
     else if (((b__4 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then FPUnaryOp_ABS
     else if (((b__4 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then FPUnaryOp_NEG
     else FPUnaryOp_SQRT) in
   aarch64_float_arithmetic_unary d datasize fpop n))))))))))"


(*val float_arithmetic_round_decode : mword ty1 -> mword ty1 -> mword ty2 -> mword ty3 -> mword ty5 -> mword ty5 -> M unit*)

definition float_arithmetic_round_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " float_arithmetic_round_decode M S typ1 rmode Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   undefined_int ()  \<bind> (\<lambda> (datasize :: ii) . 
   (let b__0 = typ1 in
   (if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then return (( 32 :: int)::ii)
    else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then return (( 64 :: int)::ii)
    else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
      UnallocatedEncoding ()  \<then> return datasize
    else if ((HaveFP16Ext () )) then return (( 16 :: int)::ii)
    else UnallocatedEncoding ()  \<then> return datasize) \<bind> (\<lambda> (datasize :: ii) . 
   (let (exact :: bool) = False in
   undefined_FPRounding ()  \<bind> (\<lambda> (rounding :: FPRounding) . 
   (let v__101 = rmode in
   (if (((((subrange_vec_dec v__101 (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))) then
      (let (rounding :: FPRounding) = (FPDecodeRounding ((slice rmode (( 0 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word))) in
      return (exact, rounding))
    else if (((v__101 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) then
      (let (rounding :: FPRounding) = FPRounding_TIEAWAY in
      return (exact, rounding))
    else if (((v__101 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) then
      UnallocatedEncoding ()  \<then> return (exact, rounding)
    else if (((v__101 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) then
      (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 :: 32 bits) . 
      (let (rounding :: FPRounding) = (FPRoundingMode w__0) in
      (let (exact :: bool) = True in
      return (exact, rounding))))
    else
      (read_reg FPCR_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 :: 32 bits) . 
      (let (rounding :: FPRounding) = (FPRoundingMode w__1) in
      return (exact, rounding)))) \<bind> (\<lambda> varstup .  (let ((exact :: bool), (rounding :: FPRounding)) = varstup in
   aarch64_float_arithmetic_round d datasize exact n rounding))))))))))))"


(*val float_arithmetic_mul_product_decode : mword ty1 -> mword ty1 -> mword ty2 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

definition float_arithmetic_mul_product_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " float_arithmetic_mul_product_decode M S typ1 Rm op1 Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   (let (m :: ii) = (Word.uint Rm) in
   undefined_int ()  \<bind> (\<lambda> (datasize :: ii) . 
   (let b__0 = typ1 in
   (if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then return (( 32 :: int)::ii)
    else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then return (( 64 :: int)::ii)
    else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
      UnallocatedEncoding ()  \<then> return datasize
    else if ((HaveFP16Ext () )) then return (( 16 :: int)::ii)
    else UnallocatedEncoding ()  \<then> return datasize) \<bind> (\<lambda> (datasize :: ii) . 
   (let (negated :: bool) = (op1 = (vec_of_bits [B1]  ::  1 Word.word)) in
   aarch64_float_arithmetic_mul_product d datasize m n negated)))))))))"


(*val float_arithmetic_mul_addsub_decode : mword ty1 -> mword ty1 -> mword ty2 -> mword ty1 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition float_arithmetic_mul_addsub_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " float_arithmetic_mul_addsub_decode M S typ1 o1 Rm o0 Ra Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (d :: ii) = (Word.uint Rd) in
   (let (a :: ii) = (Word.uint Ra) in
   (let (n :: ii) = (Word.uint Rn) in
   (let (m :: ii) = (Word.uint Rm) in
   undefined_int ()  \<bind> (\<lambda> (datasize :: ii) . 
   (let b__0 = typ1 in
   (if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then return (( 32 :: int)::ii)
    else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then return (( 64 :: int)::ii)
    else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
      UnallocatedEncoding ()  \<then> return datasize
    else if ((HaveFP16Ext () )) then return (( 16 :: int)::ii)
    else UnallocatedEncoding ()  \<then> return datasize) \<bind> (\<lambda> (datasize :: ii) . 
   (let (opa_neg :: bool) = (o1 = (vec_of_bits [B1]  ::  1 Word.word)) in
   (let (op1_neg :: bool) = (o0 \<noteq> o1) in
   aarch64_float_arithmetic_mul_addsub a d datasize m n op1_neg opa_neg)))))))))))"


(*val float_arithmetic_maxmin_decode : mword ty1 -> mword ty1 -> mword ty2 -> mword ty5 -> mword ty2 -> mword ty5 -> mword ty5 -> M unit*)

definition float_arithmetic_maxmin_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " float_arithmetic_maxmin_decode M S typ1 Rm op1 Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   (let (m :: ii) = (Word.uint Rm) in
   undefined_int ()  \<bind> (\<lambda> (datasize :: ii) . 
   (let b__0 = typ1 in
   (if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then return (( 32 :: int)::ii)
    else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then return (( 64 :: int)::ii)
    else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
      UnallocatedEncoding ()  \<then> return datasize
    else if ((HaveFP16Ext () )) then return (( 16 :: int)::ii)
    else UnallocatedEncoding ()  \<then> return datasize) \<bind> (\<lambda> (datasize :: ii) . 
   undefined_FPMaxMinOp ()  \<bind> (\<lambda> (operation :: FPMaxMinOp) . 
   (let b__4 = op1 in
   (let (operation :: FPMaxMinOp) =
     (if (((b__4 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then FPMaxMinOp_MAX
     else if (((b__4 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then FPMaxMinOp_MIN
     else if (((b__4 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then FPMaxMinOp_MAXNUM
     else FPMaxMinOp_MINNUM) in
   aarch64_float_arithmetic_maxmin d datasize m n operation)))))))))))"


(*val float_arithmetic_div_decode : mword ty1 -> mword ty1 -> mword ty2 -> mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition float_arithmetic_div_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " float_arithmetic_div_decode M S typ1 Rm Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   (let (m :: ii) = (Word.uint Rm) in
   undefined_int ()  \<bind> (\<lambda> (datasize :: ii) . 
   (let b__0 = typ1 in
   (if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then return (( 32 :: int)::ii)
    else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then return (( 64 :: int)::ii)
    else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
      UnallocatedEncoding ()  \<then> return datasize
    else if ((HaveFP16Ext () )) then return (( 16 :: int)::ii)
    else UnallocatedEncoding ()  \<then> return datasize) \<bind> (\<lambda> (datasize :: ii) . 
   aarch64_float_arithmetic_div d datasize m n))))))))"


(*val float_arithmetic_addsub_decode : mword ty1 -> mword ty1 -> mword ty2 -> mword ty5 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

definition float_arithmetic_addsub_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " float_arithmetic_addsub_decode M S typ1 Rm op1 Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   (let (m :: ii) = (Word.uint Rm) in
   undefined_int ()  \<bind> (\<lambda> (datasize :: ii) . 
   (let b__0 = typ1 in
   (if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then return (( 32 :: int)::ii)
    else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then return (( 64 :: int)::ii)
    else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
      UnallocatedEncoding ()  \<then> return datasize
    else if ((HaveFP16Ext () )) then return (( 16 :: int)::ii)
    else UnallocatedEncoding ()  \<then> return datasize) \<bind> (\<lambda> (datasize :: ii) . 
   (let (sub_op :: bool) = (op1 = (vec_of_bits [B1]  ::  1 Word.word)) in
   aarch64_float_arithmetic_addsub d datasize m n sub_op)))))))))"


(*val branch_unconditional_register_decode : mword ty1 -> mword ty1 -> mword ty2 -> mword ty5 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

definition branch_unconditional_register_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " branch_unconditional_register_decode Z opc op1 op2 op3 A M Rn Rm = (
   write_reg unconditional_ref True \<then>
   ((let (n :: ii) = (Word.uint Rn) in
   undefined_BranchType ()  \<bind> (\<lambda> (branch_type :: BranchType) . 
   (let (m :: ii) = (Word.uint Rm) in
   (let (pac :: bool) = (A = (vec_of_bits [B1]  ::  1 Word.word)) in
   (let (use_key_a :: bool) = (M = (vec_of_bits [B0]  ::  1 Word.word)) in
   (let (source_is_sp :: bool) =
     ((((Z = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((((ex_int m)) = (( 31 :: int)::ii))))) in
   (if (((((\<not> pac)) \<and> (((((ex_int m)) \<noteq> (( 0 :: int)::ii))))))) then UnallocatedEncoding () 
    else if (((pac \<and> ((\<not> ((HavePACExt () ))))))) then UnallocatedEncoding () 
    else return () ) \<then>
   ((let b__0 = op1 in
   (if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then return BranchType_JMP
    else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then return BranchType_CALL
    else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then return BranchType_RET
    else UnallocatedEncoding ()  \<then> return branch_type) \<bind> (\<lambda> (branch_type :: BranchType) . 
   (if pac then
      (if ((((((Z = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((((ex_int m)) \<noteq> (( 31 :: int)::ii)))))))
       then
         UnallocatedEncoding () 
       else return () ) \<then>
      (if (((branch_type = BranchType_RET))) then
        (if (((((ex_int n)) \<noteq> (( 31 :: int)::ii)))) then UnallocatedEncoding () 
         else return () ) \<then>
        ((let (n :: ii) = ((( 30 :: int)::ii)) in
        (let (source_is_sp :: bool) = True in
        return (n, source_is_sp))))
      else return (n, source_is_sp))
    else return (n, source_is_sp)) \<bind> (\<lambda> varstup .  (let ((n :: ii), (source_is_sp :: bool)) = varstup in
   aarch64_branch_unconditional_register branch_type m n pac source_is_sp use_key_a)))))))))))))"


(*val branch_unconditional_eret_decode : mword ty4 -> mword ty5 -> mword ty4 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty5 -> M unit*)

definition branch_unconditional_eret_decode  :: "(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " branch_unconditional_eret_decode opc op2 op3 A M Rn op4 = (
   (write_reg unconditional_ref True \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__0 :: ProcState) . 
   (if ((((ProcState_EL   w__0) = EL0))) then UnallocatedEncoding () 
    else return () ) \<then>
   ((let (pac :: bool) = (A = (vec_of_bits [B1]  ::  1 Word.word)) in
   (let (use_key_a :: bool) = (M = (vec_of_bits [B0]  ::  1 Word.word)) in
   ((if (((((\<not> pac)) \<and> (((op4 \<noteq> (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word))))))) then
      UnallocatedEncoding () 
    else if (((pac \<and> (((((\<not> ((HavePACExt () )))) \<or> (((op4 \<noteq> (vec_of_bits [B1,B1,B1,B1,B1]  ::  5 Word.word)))))))))) then
      UnallocatedEncoding () 
    else return () ) \<then>
   (if (((Rn \<noteq> (vec_of_bits [B1,B1,B1,B1,B1]  ::  5 Word.word)))) then UnallocatedEncoding () 
    else return () )) \<then>
   aarch64_branch_unconditional_eret pac use_key_a)))))"


(*val branch_unconditional_dret_decode : mword ty4 -> mword ty5 -> mword ty6 -> mword ty5 -> mword ty5 -> M unit*)

definition branch_unconditional_dret_decode  :: "(4)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " branch_unconditional_dret_decode opc op2 op3 Rt op4 = (
   (write_reg unconditional_ref True \<then>
   or_boolM (Halted ()  \<bind> (\<lambda> (w__0 :: bool) .  return ((\<not> w__0))))
     (read_reg PSTATE_ref \<bind> (\<lambda> (w__1 :: ProcState) .  return ((((ProcState_EL   w__1) = EL0)))))) \<bind> (\<lambda> (w__2 ::
     bool) . 
   (if w__2 then UnallocatedEncoding ()  else return () ) \<then> aarch64_branch_unconditional_dret () ))"


(*val AArch64_CheckSystemAccess : mword ty2 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty3 -> mword ty5 -> mword ty1 -> M unit*)

definition AArch64_CheckSystemAccess  :: "(2)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_CheckSystemAccess op0 op1 crn crm op2 rt read = (
   (let (unallocated :: bool) = False in
   (let (need_secure :: bool) = False in
   (undefined_bitvector (( 2 :: int)::ii)  :: ( 2 Word.word) M) \<bind> (\<lambda> (min_EL :: 2 bits) . 
   undefined_bool ()  \<bind> (\<lambda> (rcs_el0_trap :: bool) . 
   and_boolM
     (and_boolM
        (and_boolM
           (and_boolM (return ((HaveEL EL2)))
              (IsSecure ()  \<bind> (\<lambda> (w__0 :: bool) .  return ((\<not> w__0)))))
           ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 :: 64 bits) . 
            return ((((vec_of_bits [access_vec_dec w__2 (( 20 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
        (return (((((and_vec op0 (vec_of_bits [B0,B1]  ::  2 Word.word)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word))))))
     (return (((((and_vec crn (vec_of_bits [B1,B0,B1,B1]  ::  4 Word.word)  ::  4 Word.word)) = (vec_of_bits [B1,B0,B1,B1]  ::  4 Word.word))))) \<bind> (\<lambda> (w__5 :: bool) . 
   (if w__5 then
      undefined_bool ()  \<bind> (\<lambda> (w__6 :: bool) . 
      (let rcs_el0_trap = w__6 in
      and_boolM
        (read_reg PSTATE_ref \<bind> (\<lambda> (w__7 :: ProcState) .  return ((((ProcState_EL   w__7) = EL0)))))
        (return rcs_el0_trap) \<bind> (\<lambda> (w__8 :: bool) . 
      if w__8 then AArch64_SystemRegisterTrap EL2 op0 op2 op1 crn rt crm read
      else
        read_reg PSTATE_ref \<bind> (\<lambda> (w__9 :: ProcState) . 
        if ((((ProcState_EL   w__9) = EL1))) then
          AArch64_SystemRegisterTrap EL2 op0 op2 op1 crn rt crm read
        else return () ))))
    else return () ) \<then>
   ((let v__103 = op1 in
   (if (((((subrange_vec_dec v__103 (( 2 :: int)::ii) (( 1 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
      (let (min_EL :: 2 bits) = EL1 in
      return (min_EL, need_secure))
    else if (((v__103 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) then
      (let (min_EL :: 2 bits) = EL1 in
      return (min_EL, need_secure))
    else if (((v__103 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) then
      (let (min_EL :: 2 bits) = EL0 in
      return (min_EL, need_secure))
    else if (((v__103 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) then
      (let (min_EL :: 2 bits) = EL2 in
      return (min_EL, need_secure))
    else if (((v__103 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) then
      (if ((\<not> ((HaveVirtHostExt () )))) then UnallocatedEncoding () 
       else return () ) \<then>
      ((let (min_EL :: 2 bits) = EL2 in
      return (min_EL, need_secure)))
    else
      (let ((min_EL :: 2 bits), (need_secure :: bool)) =
        (if (((v__103 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) then
          (let (min_EL :: 2 bits) = EL3 in
          (min_EL, need_secure))
        else
          (let (min_EL :: 2 bits) = EL1 in
          (let (need_secure :: bool) = True in
          (min_EL, need_secure)))) in
      return (min_EL, need_secure))) \<bind> (\<lambda> varstup .  (let ((min_EL :: 2 bits), (need_secure :: bool)) = varstup in
   read_reg PSTATE_ref \<bind> (\<lambda> (w__10 :: ProcState) . 
   ((if ((((Word.uint(ProcState_EL   w__10))) < ((Word.uint min_EL)))) then
      and_boolM
        (and_boolM
           (and_boolM
              (and_boolM
                 (and_boolM
                    (read_reg PSTATE_ref \<bind> (\<lambda> (w__11 :: ProcState) . 
                     return ((((ProcState_EL   w__11) = EL1))))) (return (((min_EL = EL2)))))
                 (return ((HaveNVExt () ))))
              (IsSecure ()  \<bind> (\<lambda> (w__14 :: bool) .  return ((\<not> w__14))))) (return ((HaveEL EL2))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__17 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__17 (( 42 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__18 :: bool) . 
      if w__18 then AArch64_SystemRegisterTrap EL2 op0 op2 op1 crn rt crm read
      else UnallocatedEncoding () )
    else
      and_boolM (return need_secure) (IsSecure ()  \<bind> (\<lambda> (w__19 :: bool) .  return ((\<not> w__19)))) \<bind> (\<lambda> (w__20 ::
        bool) . 
      if w__20 then UnallocatedEncoding () 
      else
        AArch64_CheckUnallocatedSystemAccess op0 op1 crn crm op2 read \<bind> (\<lambda> (w__21 :: bool) . 
        if w__21 then UnallocatedEncoding () 
        else return () ))) \<then>
   (undefined_bitvector (( 2 :: int)::ii)  :: ( 2 Word.word) M)) \<bind> (\<lambda> (target_el :: 2 bits) . 
   undefined_bool ()  \<bind> (\<lambda> (take_trap :: bool) . 
   (AArch64_CheckAdvSIMDFPSystemRegisterTraps op0 op1 crn crm op2 read  :: ((bool *  2 Word.word)) M) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1) = varstup in
   (let take_trap = tup__0 in
   (let target_el = tup__1 in
   ((if take_trap then AArch64_AdvSIMDFPAccessTrap target_el
    else return () ) \<then>
   (AArch64_CheckSystemRegisterTraps op0 op1 crn crm op2 read  :: ((bool *  2 Word.word)) M)) \<bind> (\<lambda> varstup .  (let (tup__0, tup__1) = varstup in
   (let take_trap = tup__0 in
   (let target_el = tup__1 in
   if take_trap then AArch64_SystemRegisterTrap target_el op0 op2 op1 crn rt crm read
   else return () )))))))))))))))))))))"


(*val system_sysops_decode : mword ty1 -> mword ty2 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty3 -> mword ty5 -> M unit*)

definition system_sysops_decode  :: "(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " system_sysops_decode L op0 op1 CRn CRm op2 Rt = (
   (write_reg unconditional_ref True \<then>
   AArch64_CheckSystemAccess (vec_of_bits [B0,B1]  ::  2 Word.word) op1 CRn CRm op2 Rt L) \<then>
   ((let (t :: ii) = (Word.uint Rt) in
   (let (sys_op0 :: ii) = ((( 1 :: int)::ii)) in
   (let (sys_op1 :: ii) = (Word.uint op1) in
   (let (sys_op2 :: ii) = (Word.uint op2) in
   (let (sys_crn :: ii) = (Word.uint CRn) in
   (let (sys_crm :: ii) = (Word.uint CRm) in
   (let (has_result :: bool) = (L = (vec_of_bits [B1]  ::  1 Word.word)) in
   aarch64_system_sysops has_result sys_crm sys_crn sys_op0 sys_op1 sys_op2 t)))))))))"


(*val system_register_system_decode : mword ty1 -> mword ty1 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty3 -> mword ty5 -> M unit*)

definition system_register_system_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " system_register_system_decode L o0 op1 CRn CRm op2 Rt = (
   (write_reg unconditional_ref True \<then>
   AArch64_CheckSystemAccess ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) o0  ::  2 Word.word)) op1 CRn
     CRm op2 Rt L) \<then>
   ((let (t :: ii) = (Word.uint Rt) in
   (let (sys_op0 :: ii) = ((( 2 :: int)::ii) + ((Word.uint o0))) in
   (let (sys_op1 :: ii) = (Word.uint op1) in
   (let (sys_op2 :: ii) = (Word.uint op2) in
   (let (sys_crn :: ii) = (Word.uint CRn) in
   (let (sys_crm :: ii) = (Word.uint CRm) in
   (let (read :: bool) = (L = (vec_of_bits [B1]  ::  1 Word.word)) in
   aarch64_system_register_system read sys_crm sys_crn sys_op0 sys_op1 sys_op2 t)))))))))"


(*val system_register_cpsr_decode : mword ty1 -> mword ty2 -> mword ty3 -> mword ty4 -> mword ty4 -> mword ty3 -> mword ty5 -> M unit*)

definition system_register_cpsr_decode  :: "(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " system_register_cpsr_decode L op0 op1 CRn CRm op2 Rt = (
   (write_reg unconditional_ref True \<then>
   AArch64_CheckSystemAccess (vec_of_bits [B0,B0]  ::  2 Word.word) op1
     (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word) CRm op2 (vec_of_bits [B1,B1,B1,B1,B1]  ::  5 Word.word)
     (vec_of_bits [B0]  ::  1 Word.word)) \<then>
   ((let (operand :: 4 bits) = CRm in
   undefined_PSTATEField ()  \<bind> (\<lambda> (field' :: PSTATEField) . 
   (let b__0 = ((concat_vec op1 op2  ::  6 Word.word)) in
   (if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B1,B1]  ::  6 Word.word)))) then
      (if ((\<not> ((HaveUAOExt () )))) then UnallocatedEncoding () 
       else return () ) \<then>
      return PSTATEField_UAO
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0]  ::  6 Word.word)))) then
      (if ((\<not> ((HavePANExt () )))) then UnallocatedEncoding () 
       else return () ) \<then>
      return PSTATEField_PAN
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1]  ::  6 Word.word)))) then
      return PSTATEField_SP
    else if (((b__0 = (vec_of_bits [B0,B1,B1,B1,B1,B0]  ::  6 Word.word)))) then
      return PSTATEField_DAIFSet
    else if (((b__0 = (vec_of_bits [B0,B1,B1,B1,B1,B1]  ::  6 Word.word)))) then
      return PSTATEField_DAIFClr
    else UnallocatedEncoding ()  \<then> return field') \<bind> (\<lambda> (field' :: PSTATEField) . 
   and_boolM
     (and_boolM (return (((op1 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))))
        (read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) .  return ((((ProcState_EL   w__0) = EL0))))))
     (or_boolM ((IsInHost () ))
        ((read_reg SCTLR_EL1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__3 :: 32 bits) . 
         return ((((vec_of_bits [access_vec_dec w__3 (( 9 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B0]  ::  1 Word.word))))))) \<bind> (\<lambda> (w__5 :: bool) . 
   (if w__5 then
      AArch64_SystemRegisterTrap EL1 (vec_of_bits [B0,B0]  ::  2 Word.word) op2 op1
        (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word) (vec_of_bits [B1,B1,B1,B1,B1]  ::  5 Word.word) CRm
        (vec_of_bits [B0]  ::  1 Word.word)
    else return () ) \<then>
   aarch64_system_register_cpsr field' operand)))))))"


(*val AArch64_CheckForSMCUndefOrTrap : mword ty16 -> M unit*)

definition AArch64_CheckForSMCUndefOrTrap  :: "(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " AArch64_CheckForSMCUndefOrTrap imm = (
   read_reg PSTATE_ref \<bind> (\<lambda> (w__0 :: ProcState) . 
   ((if ((((ProcState_EL   w__0) = EL0))) then UnallocatedEncoding () 
    else return () ) \<then>
   undefined_bool () ) \<bind> (\<lambda> (route_to_el2 :: bool) . 
   (if ((\<not> ((HaveEL EL3)))) then
      and_boolM
        (and_boolM (return ((HaveEL EL2)))
           (IsSecure ()  \<bind> (\<lambda> (w__1 :: bool) .  return ((\<not> w__1)))))
        (read_reg PSTATE_ref \<bind> (\<lambda> (w__3 :: ProcState) .  return ((((ProcState_EL   w__3) = EL1))))) \<bind> (\<lambda> (w__4 ::
        bool) . 
      if w__4 then
        and_boolM
          (and_boolM (return ((HaveNVExt () )))
             ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 :: 64 bits) . 
              return ((((vec_of_bits [access_vec_dec w__5 (( 42 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))))
          ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__7 :: 64 bits) . 
           return ((((vec_of_bits [access_vec_dec w__7 (( 19 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))))) \<bind> (\<lambda> (w__8 :: bool) . 
        if w__8 then return True
        else UnallocatedEncoding ()  \<then> return route_to_el2)
      else UnallocatedEncoding ()  \<then> return route_to_el2)
    else
      and_boolM
        (and_boolM
           (and_boolM (return ((HaveEL EL2)))
              (IsSecure ()  \<bind> (\<lambda> (w__9 :: bool) .  return ((\<not> w__9)))))
           (read_reg PSTATE_ref \<bind> (\<lambda> (w__11 :: ProcState) . 
            return ((((ProcState_EL   w__11) = EL1))))))
        ((read_reg HCR_EL2_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__13 :: 64 bits) . 
         return ((((vec_of_bits [access_vec_dec w__13 (( 19 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))) \<bind> (\<lambda> (route_to_el2 :: bool) . 
   undefined_ExceptionRecord ()  \<bind> (\<lambda> (exception :: ExceptionRecord) . 
   undefined_int ()  \<bind> (\<lambda> (vect_offset :: ii) . 
   if route_to_el2 then
     (ThisInstrAddr (( 64 :: int)::ii) ()   :: ( 64 Word.word) M) \<bind> (\<lambda> (preferred_exception_return :: 64 bits) . 
     (let vect_offset = ((( 0 :: int)::ii)) in
     ExceptionSyndrome Exception_MonitorCall \<bind> (\<lambda> (w__15 :: ExceptionRecord) . 
     (let exception = w__15 in
     (let (tmp_40 :: 25 bits) = ((ExceptionRecord_syndrome   exception)) in
     (let tmp_40 = ((set_slice (( 25 :: int)::ii) (( 16 :: int)::ii) tmp_40 (( 0 :: int)::ii) imm  ::  25 Word.word)) in
     (let exception = ((exception (| ExceptionRecord_syndrome := tmp_40 |))) in
     AArch64_TakeException EL2 exception preferred_exception_return vect_offset)))))))
   else return () ))))))"


(*val aarch64_system_exceptions_runtime_smc : mword ty16 -> M unit*)

definition aarch64_system_exceptions_runtime_smc  :: "(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " aarch64_system_exceptions_runtime_smc imm = (
   (AArch64_CheckForSMCUndefOrTrap imm \<then>
   (read_reg SCR_EL3_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__0 :: 32 bits) . 
   if ((((vec_of_bits [access_vec_dec w__0 (( 7 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word)))) then
     AArch64_UndefinedFault () 
   else AArch64_CallSecureMonitor imm))"


(*val system_exceptions_runtime_smc_decode : mword ty3 -> mword ty16 -> mword ty3 -> mword ty2 -> M unit*)

definition system_exceptions_runtime_smc_decode  :: "(3)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " system_exceptions_runtime_smc_decode opc imm16 op2 LL = (
   write_reg unconditional_ref True \<then>
   ((let (imm :: 16 bits) = imm16 in
   aarch64_system_exceptions_runtime_smc imm)))"


(*val ReservedValue : unit -> M unit*)

definition ReservedValue  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " ReservedValue _ = (
   and_boolM ((UsingAArch32 () ))
     (AArch32_GeneralExceptionsToAArch64 ()  \<bind> (\<lambda> (w__1 :: bool) .  return ((\<not> w__1)))) \<bind> (\<lambda> (w__2 ::
     bool) . 
   if w__2 then AArch32_TakeUndefInstrException__0 () 
   else AArch64_UndefinedFault () ))"


(*val memory_vector_multiple_postinc_aarch64_memory_vector_multiple_nowb__decode : mword ty1 -> mword ty1 -> mword ty5 -> mword ty4 -> mword ty2 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_vector_multiple_postinc_aarch64_memory_vector_multiple_nowb__decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_vector_multiple_postinc_aarch64_memory_vector_multiple_nowb__decode b__0 L Rm opcode b__1 Rn Rt = (
   if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     (let (elements :: ii) = ((( 64 :: int)::ii) div (( 8 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (rpt :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (selem :: ii) . 
     (let b__2 = opcode in
     (if (((b__2 = (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 4 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__2 = (vec_of_bits [B0,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 4 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__2 = (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 3 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__2 = (vec_of_bits [B0,B1,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 3 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__2 = (vec_of_bits [B0,B1,B1,B1]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__2 = (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 2 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__2 = (vec_of_bits [B1,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 2 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else UnallocatedEncoding ()  \<then> return (rpt, selem)) \<bind> (\<lambda> varstup .  (let ((rpt :: ii), (selem ::
       ii)) = varstup in
     (if (((False \<and> (((((ex_int selem)) \<noteq> (( 1 :: int)::ii))))))) then ReservedValue () 
      else return () ) \<then>
     aarch64_memory_vector_multiple_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((ex_int elements)) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m memop n ((ex_int rpt))
       ((ex_int selem)) t True)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     (let (elements :: ii) = ((( 64 :: int)::ii) div (( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (rpt :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (selem :: ii) . 
     (let b__11 = opcode in
     (if (((b__11 = (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 4 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__11 = (vec_of_bits [B0,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 4 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__11 = (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 3 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__11 = (vec_of_bits [B0,B1,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 3 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__11 = (vec_of_bits [B0,B1,B1,B1]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__11 = (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 2 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__11 = (vec_of_bits [B1,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 2 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else UnallocatedEncoding ()  \<then> return (rpt, selem)) \<bind> (\<lambda> varstup .  (let ((rpt :: ii), (selem ::
       ii)) = varstup in
     (if (((False \<and> (((((ex_int selem)) \<noteq> (( 1 :: int)::ii))))))) then ReservedValue () 
      else return () ) \<then>
     aarch64_memory_vector_multiple_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((ex_int elements)) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m memop n ((ex_int rpt))
       ((ex_int selem)) t True)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 32 :: int)::ii)) in
     (let (elements :: ii) = ((( 64 :: int)::ii) div (( 32 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (rpt :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (selem :: ii) . 
     (let b__20 = opcode in
     (if (((b__20 = (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 4 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__20 = (vec_of_bits [B0,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 4 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__20 = (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 3 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__20 = (vec_of_bits [B0,B1,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 3 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__20 = (vec_of_bits [B0,B1,B1,B1]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__20 = (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 2 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__20 = (vec_of_bits [B1,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 2 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else UnallocatedEncoding ()  \<then> return (rpt, selem)) \<bind> (\<lambda> varstup .  (let ((rpt :: ii), (selem ::
       ii)) = varstup in
     (if (((False \<and> (((((ex_int selem)) \<noteq> (( 1 :: int)::ii))))))) then ReservedValue () 
      else return () ) \<then>
     aarch64_memory_vector_multiple_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((ex_int elements)) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m memop n ((ex_int rpt))
       ((ex_int selem)) t True)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 64 :: int)::ii)) in
     (let (elements :: ii) = ((( 64 :: int)::ii) div (( 64 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (rpt :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (selem :: ii) . 
     (let b__29 = opcode in
     (if (((b__29 = (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 4 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__29 = (vec_of_bits [B0,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 4 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__29 = (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 3 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__29 = (vec_of_bits [B0,B1,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 3 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__29 = (vec_of_bits [B0,B1,B1,B1]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__29 = (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 2 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__29 = (vec_of_bits [B1,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 2 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else UnallocatedEncoding ()  \<then> return (rpt, selem)) \<bind> (\<lambda> varstup .  (let ((rpt :: ii), (selem ::
       ii)) = varstup in
     (if (((True \<and> (((((ex_int selem)) \<noteq> (( 1 :: int)::ii))))))) then ReservedValue () 
      else return () ) \<then>
     aarch64_memory_vector_multiple_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((ex_int elements)) ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m memop n ((ex_int rpt))
       ((ex_int selem)) t True)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     (let (elements :: ii) = ((( 128 :: int)::ii) div (( 8 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (rpt :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (selem :: ii) . 
     (let b__38 = opcode in
     (if (((b__38 = (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 4 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__38 = (vec_of_bits [B0,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 4 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__38 = (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 3 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__38 = (vec_of_bits [B0,B1,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 3 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__38 = (vec_of_bits [B0,B1,B1,B1]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__38 = (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 2 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__38 = (vec_of_bits [B1,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 2 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else UnallocatedEncoding ()  \<then> return (rpt, selem)) \<bind> (\<lambda> varstup .  (let ((rpt :: ii), (selem ::
       ii)) = varstup in
     (if (((False \<and> (((((ex_int selem)) \<noteq> (( 1 :: int)::ii))))))) then ReservedValue () 
      else return () ) \<then>
     aarch64_memory_vector_multiple_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((ex_int elements)) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) m memop n ((ex_int rpt))
       ((ex_int selem)) t True)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     (let (elements :: ii) = ((( 128 :: int)::ii) div (( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (rpt :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (selem :: ii) . 
     (let b__47 = opcode in
     (if (((b__47 = (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 4 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__47 = (vec_of_bits [B0,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 4 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__47 = (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 3 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__47 = (vec_of_bits [B0,B1,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 3 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__47 = (vec_of_bits [B0,B1,B1,B1]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__47 = (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 2 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__47 = (vec_of_bits [B1,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 2 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else UnallocatedEncoding ()  \<then> return (rpt, selem)) \<bind> (\<lambda> varstup .  (let ((rpt :: ii), (selem ::
       ii)) = varstup in
     (if (((False \<and> (((((ex_int selem)) \<noteq> (( 1 :: int)::ii))))))) then ReservedValue () 
      else return () ) \<then>
     aarch64_memory_vector_multiple_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((ex_int elements)) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) m memop n ((ex_int rpt))
       ((ex_int selem)) t True)))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 32 :: int)::ii)) in
     (let (elements :: ii) = ((( 128 :: int)::ii) div (( 32 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (rpt :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (selem :: ii) . 
     (let b__56 = opcode in
     (if (((b__56 = (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 4 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__56 = (vec_of_bits [B0,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 4 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__56 = (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 3 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__56 = (vec_of_bits [B0,B1,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 3 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__56 = (vec_of_bits [B0,B1,B1,B1]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__56 = (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 2 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__56 = (vec_of_bits [B1,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 2 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else UnallocatedEncoding ()  \<then> return (rpt, selem)) \<bind> (\<lambda> varstup .  (let ((rpt :: ii), (selem ::
       ii)) = varstup in
     (if (((False \<and> (((((ex_int selem)) \<noteq> (( 1 :: int)::ii))))))) then ReservedValue () 
      else return () ) \<then>
     aarch64_memory_vector_multiple_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((ex_int elements)) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) m memop n ((ex_int rpt))
       ((ex_int selem)) t True)))))))))))))
   else
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (m :: ii) = (Word.uint Rm) in
     (let (wback :: bool) = True in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 64 :: int)::ii)) in
     (let (elements :: ii) = ((( 128 :: int)::ii) div (( 64 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (rpt :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (selem :: ii) . 
     (let b__65 = opcode in
     (if (((b__65 = (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 4 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__65 = (vec_of_bits [B0,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 4 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__65 = (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 3 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__65 = (vec_of_bits [B0,B1,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 3 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__65 = (vec_of_bits [B0,B1,B1,B1]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__65 = (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 2 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__65 = (vec_of_bits [B1,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 2 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else UnallocatedEncoding ()  \<then> return (rpt, selem)) \<bind> (\<lambda> varstup .  (let ((rpt :: ii), (selem ::
       ii)) = varstup in
     (if (((False \<and> (((((ex_int selem)) \<noteq> (( 1 :: int)::ii))))))) then ReservedValue () 
      else return () ) \<then>
     aarch64_memory_vector_multiple_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((ex_int elements)) ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) m memop n ((ex_int rpt))
       ((ex_int selem)) t True))))))))))))))"


(*val memory_vector_multiple_nowb_aarch64_memory_vector_multiple_nowb__decode : mword ty1 -> mword ty1 -> mword ty4 -> mword ty2 -> mword ty5 -> mword ty5 -> M unit*)

definition memory_vector_multiple_nowb_aarch64_memory_vector_multiple_nowb__decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " memory_vector_multiple_nowb_aarch64_memory_vector_multiple_nowb__decode b__0 L opcode b__1 Rn Rt = (
   if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     (let (elements :: ii) = ((( 64 :: int)::ii) div (( 8 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (rpt :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (selem :: ii) . 
     (let b__2 = opcode in
     (if (((b__2 = (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 4 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__2 = (vec_of_bits [B0,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 4 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__2 = (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 3 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__2 = (vec_of_bits [B0,B1,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 3 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__2 = (vec_of_bits [B0,B1,B1,B1]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__2 = (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 2 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__2 = (vec_of_bits [B1,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 2 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else UnallocatedEncoding ()  \<then> return (rpt, selem)) \<bind> (\<lambda> varstup .  (let ((rpt :: ii), (selem ::
       ii)) = varstup in
     ((if (((False \<and> (((((ex_int selem)) \<noteq> (( 1 :: int)::ii))))))) then ReservedValue () 
      else return () ) \<then>
     undefined_int () ) \<bind> (\<lambda> (w__0 :: ii) . 
     aarch64_memory_vector_multiple_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((ex_int elements)) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) w__0 memop n ((ex_int rpt))
       ((ex_int selem)) t False))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     (let (elements :: ii) = ((( 64 :: int)::ii) div (( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (rpt :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (selem :: ii) . 
     (let b__11 = opcode in
     (if (((b__11 = (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 4 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__11 = (vec_of_bits [B0,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 4 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__11 = (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 3 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__11 = (vec_of_bits [B0,B1,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 3 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__11 = (vec_of_bits [B0,B1,B1,B1]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__11 = (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 2 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__11 = (vec_of_bits [B1,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 2 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else UnallocatedEncoding ()  \<then> return (rpt, selem)) \<bind> (\<lambda> varstup .  (let ((rpt :: ii), (selem ::
       ii)) = varstup in
     ((if (((False \<and> (((((ex_int selem)) \<noteq> (( 1 :: int)::ii))))))) then ReservedValue () 
      else return () ) \<then>
     undefined_int () ) \<bind> (\<lambda> (w__1 :: ii) . 
     aarch64_memory_vector_multiple_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((ex_int elements)) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) w__1 memop n ((ex_int rpt))
       ((ex_int selem)) t False))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 32 :: int)::ii)) in
     (let (elements :: ii) = ((( 64 :: int)::ii) div (( 32 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (rpt :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (selem :: ii) . 
     (let b__20 = opcode in
     (if (((b__20 = (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 4 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__20 = (vec_of_bits [B0,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 4 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__20 = (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 3 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__20 = (vec_of_bits [B0,B1,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 3 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__20 = (vec_of_bits [B0,B1,B1,B1]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__20 = (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 2 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__20 = (vec_of_bits [B1,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 2 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else UnallocatedEncoding ()  \<then> return (rpt, selem)) \<bind> (\<lambda> varstup .  (let ((rpt :: ii), (selem ::
       ii)) = varstup in
     ((if (((False \<and> (((((ex_int selem)) \<noteq> (( 1 :: int)::ii))))))) then ReservedValue () 
      else return () ) \<then>
     undefined_int () ) \<bind> (\<lambda> (w__2 :: ii) . 
     aarch64_memory_vector_multiple_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((ex_int elements)) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) w__2 memop n ((ex_int rpt))
       ((ex_int selem)) t False))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 64 :: int)::ii)) in
     (let (elements :: ii) = ((( 64 :: int)::ii) div (( 64 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (rpt :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (selem :: ii) . 
     (let b__29 = opcode in
     (if (((b__29 = (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 4 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__29 = (vec_of_bits [B0,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 4 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__29 = (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 3 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__29 = (vec_of_bits [B0,B1,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 3 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__29 = (vec_of_bits [B0,B1,B1,B1]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__29 = (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 2 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__29 = (vec_of_bits [B1,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 2 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else UnallocatedEncoding ()  \<then> return (rpt, selem)) \<bind> (\<lambda> varstup .  (let ((rpt :: ii), (selem ::
       ii)) = varstup in
     ((if (((True \<and> (((((ex_int selem)) \<noteq> (( 1 :: int)::ii))))))) then ReservedValue () 
      else return () ) \<then>
     undefined_int () ) \<bind> (\<lambda> (w__3 :: ii) . 
     aarch64_memory_vector_multiple_nowb ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
       ((ex_int elements)) ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) w__3 memop n ((ex_int rpt))
       ((ex_int selem)) t False))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 8 :: int)::ii)) in
     (let (elements :: ii) = ((( 128 :: int)::ii) div (( 8 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (rpt :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (selem :: ii) . 
     (let b__38 = opcode in
     (if (((b__38 = (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 4 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__38 = (vec_of_bits [B0,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 4 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__38 = (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 3 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__38 = (vec_of_bits [B0,B1,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 3 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__38 = (vec_of_bits [B0,B1,B1,B1]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__38 = (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 2 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__38 = (vec_of_bits [B1,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 2 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else UnallocatedEncoding ()  \<then> return (rpt, selem)) \<bind> (\<lambda> varstup .  (let ((rpt :: ii), (selem ::
       ii)) = varstup in
     ((if (((False \<and> (((((ex_int selem)) \<noteq> (( 1 :: int)::ii))))))) then ReservedValue () 
      else return () ) \<then>
     undefined_int () ) \<bind> (\<lambda> (w__4 :: ii) . 
     aarch64_memory_vector_multiple_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((ex_int elements)) ((make_the_value (( 8 :: int)::ii)  ::  8 itself)) w__4 memop n ((ex_int rpt))
       ((ex_int selem)) t False))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 16 :: int)::ii)) in
     (let (elements :: ii) = ((( 128 :: int)::ii) div (( 16 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (rpt :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (selem :: ii) . 
     (let b__47 = opcode in
     (if (((b__47 = (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 4 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__47 = (vec_of_bits [B0,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 4 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__47 = (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 3 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__47 = (vec_of_bits [B0,B1,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 3 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__47 = (vec_of_bits [B0,B1,B1,B1]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__47 = (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 2 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__47 = (vec_of_bits [B1,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 2 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else UnallocatedEncoding ()  \<then> return (rpt, selem)) \<bind> (\<lambda> varstup .  (let ((rpt :: ii), (selem ::
       ii)) = varstup in
     ((if (((False \<and> (((((ex_int selem)) \<noteq> (( 1 :: int)::ii))))))) then ReservedValue () 
      else return () ) \<then>
     undefined_int () ) \<bind> (\<lambda> (w__5 :: ii) . 
     aarch64_memory_vector_multiple_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((ex_int elements)) ((make_the_value (( 16 :: int)::ii)  ::  16 itself)) w__5 memop n ((ex_int rpt))
       ((ex_int selem)) t False))))))))))))))
   else if ((((((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 32 :: int)::ii)) in
     (let (elements :: ii) = ((( 128 :: int)::ii) div (( 32 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (rpt :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (selem :: ii) . 
     (let b__56 = opcode in
     (if (((b__56 = (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 4 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__56 = (vec_of_bits [B0,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 4 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__56 = (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 3 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__56 = (vec_of_bits [B0,B1,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 3 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__56 = (vec_of_bits [B0,B1,B1,B1]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__56 = (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 2 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__56 = (vec_of_bits [B1,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 2 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else UnallocatedEncoding ()  \<then> return (rpt, selem)) \<bind> (\<lambda> varstup .  (let ((rpt :: ii), (selem ::
       ii)) = varstup in
     ((if (((False \<and> (((((ex_int selem)) \<noteq> (( 1 :: int)::ii))))))) then ReservedValue () 
      else return () ) \<then>
     undefined_int () ) \<bind> (\<lambda> (w__6 :: ii) . 
     aarch64_memory_vector_multiple_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((ex_int elements)) ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) w__6 memop n ((ex_int rpt))
       ((ex_int selem)) t False))))))))))))))
   else
     write_reg unconditional_ref True \<then>
     ((let (t :: ii) = (Word.uint Rt) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_int ()  \<bind> (\<lambda> (m :: ii) . 
     (let (wback :: bool) = False in
     (let (memop :: MemOp) =
       (if (((L = (vec_of_bits [B1]  ::  1 Word.word)))) then MemOp_LOAD
       else MemOp_STORE) in
     (let (esize :: ii) = ((( 64 :: int)::ii)) in
     (let (elements :: ii) = ((( 128 :: int)::ii) div (( 64 :: int)::ii)) in
     undefined_int ()  \<bind> (\<lambda> (rpt :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (selem :: ii) . 
     (let b__65 = opcode in
     (if (((b__65 = (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 4 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__65 = (vec_of_bits [B0,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 4 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__65 = (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 3 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__65 = (vec_of_bits [B0,B1,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 3 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__65 = (vec_of_bits [B0,B1,B1,B1]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__65 = (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 1 :: int)::ii)) in
        (let (selem :: ii) = ((( 2 :: int)::ii)) in
        return (rpt, selem)))
      else if (((b__65 = (vec_of_bits [B1,B0,B1,B0]  ::  4 Word.word)))) then
        (let (rpt :: ii) = ((( 2 :: int)::ii)) in
        (let (selem :: ii) = ((( 1 :: int)::ii)) in
        return (rpt, selem)))
      else UnallocatedEncoding ()  \<then> return (rpt, selem)) \<bind> (\<lambda> varstup .  (let ((rpt :: ii), (selem ::
       ii)) = varstup in
     ((if (((False \<and> (((((ex_int selem)) \<noteq> (( 1 :: int)::ii))))))) then ReservedValue () 
      else return () ) \<then>
     undefined_int () ) \<bind> (\<lambda> (w__7 :: ii) . 
     aarch64_memory_vector_multiple_nowb ((make_the_value (( 128 :: int)::ii)  ::  128 itself))
       ((ex_int elements)) ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) w__7 memop n ((ex_int rpt))
       ((ex_int selem)) t False)))))))))))))))"


(*val integer_logical_shiftedreg_decode : mword ty1 -> mword ty2 -> mword ty2 -> mword ty1 -> mword ty5 -> mword ty6 -> mword ty5 -> mword ty5 -> M unit*)

definition integer_logical_shiftedreg_decode  :: "(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_logical_shiftedreg_decode sf opc shift N Rm imm6 Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   (let (m :: ii) = (Word.uint Rm) in
   (let (datasize :: int) =
     (if (((sf = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 64 :: int)::ii)
     else (( 32 :: int)::ii)) in
   undefined_bool ()  \<bind> (\<lambda> (setflags :: bool) . 
   undefined_LogicalOp ()  \<bind> (\<lambda> (op1 :: LogicalOp) . 
   (let b__0 = opc in
   (let ((op1 :: LogicalOp), (setflags :: bool)) =
     (if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
       (let (op1 :: LogicalOp) = LogicalOp_AND in
       (let (setflags :: bool) = False in
       (op1, setflags)))
     else
       (let ((op1 :: LogicalOp), (setflags :: bool)) =
         (if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
           (let (op1 :: LogicalOp) = LogicalOp_ORR in
           (let (setflags :: bool) = False in
           (op1, setflags)))
         else
           (let ((op1 :: LogicalOp), (setflags :: bool)) =
             (if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
               (let (op1 :: LogicalOp) = LogicalOp_EOR in
               (let (setflags :: bool) = False in
               (op1, setflags)))
             else
               (let (op1 :: LogicalOp) = LogicalOp_AND in
               (let (setflags :: bool) = True in
               (op1, setflags)))) in
           (op1, setflags))) in
       (op1, setflags))) in
   (if ((((((sf = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec imm6 (( 5 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))) then
      ReservedValue () 
    else return () ) \<then>
   ((let (shift_type :: ShiftType) = (DecodeShift shift) in
   (let (shift_amount :: ii) = (Word.uint imm6) in
   (let (invert :: bool) = (N = (vec_of_bits [B1]  ::  1 Word.word)) in
   aarch64_integer_logical_shiftedreg d datasize invert m n op1 setflags shift_amount shift_type))))))))))))))"


(*val integer_insext_extract_immediate_decode : mword ty1 -> mword ty2 -> mword ty1 -> mword ty1 -> mword ty5 -> mword ty6 -> mword ty5 -> mword ty5 -> M unit*)

definition integer_insext_extract_immediate_decode  :: "(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_insext_extract_immediate_decode sf op21 N o0 Rm imms Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   (let (m :: ii) = (Word.uint Rm) in
   (let (datasize :: int) =
     (if (((sf = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 64 :: int)::ii)
     else (( 32 :: int)::ii)) in
   undefined_int ()  \<bind> (\<lambda> (lsb1 :: ii) . 
   ((if (((N \<noteq> sf))) then UnallocatedEncoding () 
    else return () ) \<then>
   (if ((((((sf = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec imms (( 5 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))) then
      ReservedValue () 
    else return () )) \<then>
   ((let lsb1 = (Word.uint imms) in
   aarch64_integer_insext_extract_immediate d datasize lsb1 m n)))))))))"


(*val integer_arithmetic_addsub_shiftedreg_decode : mword ty1 -> mword ty1 -> mword ty1 -> mword ty2 -> mword ty5 -> mword ty6 -> mword ty5 -> mword ty5 -> M unit*)

definition integer_arithmetic_addsub_shiftedreg_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_arithmetic_addsub_shiftedreg_decode sf op1 S shift Rm imm6 Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   (let (m :: ii) = (Word.uint Rm) in
   (let (datasize :: int) =
     (if (((sf = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 64 :: int)::ii)
     else (( 32 :: int)::ii)) in
   (let (sub_op :: bool) = (op1 = (vec_of_bits [B1]  ::  1 Word.word)) in
   (let (setflags :: bool) = (S = (vec_of_bits [B1]  ::  1 Word.word)) in
   ((if (((shift = (vec_of_bits [B1,B1]  ::  2 Word.word)))) then ReservedValue () 
    else return () ) \<then>
   (if ((((((sf = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((vec_of_bits [access_vec_dec imm6 (( 5 :: int)::ii)]  ::  1 Word.word) = (vec_of_bits [B1]  ::  1 Word.word))))))) then
      ReservedValue () 
    else return () )) \<then>
   ((let (shift_type :: ShiftType) = (DecodeShift shift) in
   (let (shift_amount :: ii) = (Word.uint imm6) in
   aarch64_integer_arithmetic_addsub_shiftedreg d datasize m n setflags shift_amount shift_type
     sub_op)))))))))))"


(*val integer_arithmetic_addsub_immediate_decode : mword ty1 -> mword ty1 -> mword ty1 -> mword ty2 -> mword ty12 -> mword ty5 -> mword ty5 -> M unit*)

definition integer_arithmetic_addsub_immediate_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(12)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_arithmetic_addsub_immediate_decode b__0 op1 S shift imm12 Rn Rd = (
   if (((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (sub_op :: bool) = (op1 = (vec_of_bits [B1]  ::  1 Word.word)) in
     (let (setflags :: bool) = (S = (vec_of_bits [B1]  ::  1 Word.word)) in
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (imm :: 32 bits) . 
     (let b__1 = shift in
     (if (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
        (ZeroExtend__0 imm12 ((make_the_value (( 32 :: int)::ii)  ::  32 itself))  :: ( 32 Word.word) M)
      else if (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
        (ZeroExtend__0
           ((concat_vec imm12 ((Zeros__0 ((make_the_value (( 12 :: int)::ii)  ::  12 itself))  ::  12 Word.word))
              ::  24 Word.word)) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
          :: ( 32 Word.word) M)
      else ReservedValue ()  \<then> return imm) \<bind> (\<lambda> (imm :: 32 bits) . 
     aarch64_integer_arithmetic_addsub_immediate d ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) imm n
       setflags sub_op))))))))
   else
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     (let (sub_op :: bool) = (op1 = (vec_of_bits [B1]  ::  1 Word.word)) in
     (let (setflags :: bool) = (S = (vec_of_bits [B1]  ::  1 Word.word)) in
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (imm :: 64 bits) . 
     (let b__4 = shift in
     (if (((b__4 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
        (ZeroExtend__0 imm12 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  :: ( 64 Word.word) M)
      else if (((b__4 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
        (ZeroExtend__0
           ((concat_vec imm12 ((Zeros__0 ((make_the_value (( 12 :: int)::ii)  ::  12 itself))  ::  12 Word.word))
              ::  24 Word.word)) ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
          :: ( 64 Word.word) M)
      else ReservedValue ()  \<then> return imm) \<bind> (\<lambda> (imm :: 64 bits) . 
     aarch64_integer_arithmetic_addsub_immediate d ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) imm n
       setflags sub_op)))))))))"


(*val integer_arithmetic_addsub_extendedreg_decode : mword ty1 -> mword ty1 -> mword ty1 -> mword ty2 -> mword ty5 -> mword ty3 -> mword ty3 -> mword ty5 -> mword ty5 -> M unit*)

definition integer_arithmetic_addsub_extendedreg_decode  :: "(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(3)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_arithmetic_addsub_extendedreg_decode sf op1 S opt Rm option_name imm3 Rn Rd = (
   write_reg unconditional_ref True \<then>
   ((let (d :: ii) = (Word.uint Rd) in
   (let (n :: ii) = (Word.uint Rn) in
   (let (m :: ii) = (Word.uint Rm) in
   (let (datasize :: int) =
     (if (((sf = (vec_of_bits [B1]  ::  1 Word.word)))) then (( 64 :: int)::ii)
     else (( 32 :: int)::ii)) in
   (let (sub_op :: bool) = (op1 = (vec_of_bits [B1]  ::  1 Word.word)) in
   (let (setflags :: bool) = (S = (vec_of_bits [B1]  ::  1 Word.word)) in
   (let (extend_type :: ExtendType) = (DecodeRegExtend option_name) in
   (let (shift :: ii) = (Word.uint imm3) in
   (if ((((ex_int shift)) > (( 4 :: int)::ii))) then ReservedValue () 
    else return () ) \<then>
   aarch64_integer_arithmetic_addsub_extendedreg d datasize extend_type m n setflags shift sub_op))))))))))"


(*val DecodeBitMasks : forall 'M . Size 'M => integer -> mword ty1 -> mword ty6 -> mword ty6 -> bool -> M (mword 'M * mword 'M)*)

definition DecodeBitMasks  :: " int \<Rightarrow>(1)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(6)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(('M::len)Word.word*('M::len)Word.word),(exception))monad "  where 
     " DecodeBitMasks (M__tv :: int) immN imms immr immediate = (
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (tmask :: 64 bits) . 
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (wmask :: 64 bits) . 
   (undefined_bitvector (( 6 :: int)::ii)  :: ( 6 Word.word) M) \<bind> (\<lambda> (tmask_and :: 6 bits) . 
   (undefined_bitvector (( 6 :: int)::ii)  :: ( 6 Word.word) M) \<bind> (\<lambda> (wmask_and :: 6 bits) . 
   (undefined_bitvector (( 6 :: int)::ii)  :: ( 6 Word.word) M) \<bind> (\<lambda> (tmask_or :: 6 bits) . 
   (undefined_bitvector (( 6 :: int)::ii)  :: ( 6 Word.word) M) \<bind> (\<lambda> (wmask_or :: 6 bits) . 
   (undefined_bitvector (( 6 :: int)::ii)  :: ( 6 Word.word) M) \<bind> (\<lambda> (levels :: 6 bits) . 
   HighestSetBit ((concat_vec immN ((not_vec imms  ::  6 Word.word))  ::  7 Word.word)) \<bind> (\<lambda> len . 
   ((assert_exp ((len \<ge> (( 0 :: int)::ii))) ('''') \<then>
   (if ((len < (( 1 :: int)::ii))) then ReservedValue () 
    else return () )) \<then>
   assert_exp ((M__tv \<ge> ((ex_int ((shl_int (( 1 :: int)::ii) len)))))) (''(M >= (1 << len))'')) \<then>
   ((let levels = ((zext_ones (( 6 :: int)::ii) len  ::  6 Word.word)) in
   (if (((immediate \<and> (((((and_vec imms levels  ::  6 Word.word)) = levels)))))) then
      ReservedValue () 
    else return () ) \<then>
   ((let (S :: ii) = (Word.uint ((and_vec imms levels  ::  6 Word.word))) in
   (let (R1 :: ii) = (Word.uint ((and_vec immr levels  ::  6 Word.word))) in
   (let (diff :: ii) = (((ex_int S)) - ((ex_int R1))) in
   (let (tmask_and :: 6 bits) =
     ((or_vec ((GetSlice_int ((make_the_value (( 6 :: int)::ii)  ::  6 itself)) diff (( 0 :: int)::ii)  ::  6 Word.word))
        ((not_vec levels  ::  6 Word.word))
       ::  6 Word.word)) in
   (let (tmask_or :: 6 bits) =
     ((and_vec ((GetSlice_int ((make_the_value (( 6 :: int)::ii)  ::  6 itself)) diff (( 0 :: int)::ii)  ::  6 Word.word))
        levels
       ::  6 Word.word)) in
   (let (tmask :: 64 bits) = ((Ones__0 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  ::  64 Word.word)) in
   (let (tmask :: 64 bits) =
     ((or_vec
        ((and_vec tmask
            ((replicate_bits
                ((concat_vec
                    ((replicate_bits (vec_of_bits [access_vec_dec tmask_and (( 0 :: int)::ii)]  ::  1 Word.word)
                        (( 1 :: int)::ii)
                       ::  1 Word.word))
                    ((Ones__0 ((make_the_value (( 1 :: int)::ii)  ::  1 itself))  ::  1 Word.word))
                   ::  2 Word.word)) (( 32 :: int)::ii)
               ::  64 Word.word))
           ::  64 Word.word))
        ((replicate_bits
            ((concat_vec ((Zeros__0 ((make_the_value (( 1 :: int)::ii)  ::  1 itself))  ::  1 Word.word))
                ((replicate_bits (vec_of_bits [access_vec_dec tmask_or (( 0 :: int)::ii)]  ::  1 Word.word) (( 1 :: int)::ii)
                   ::  1 Word.word))
               ::  2 Word.word)) (( 32 :: int)::ii)
           ::  64 Word.word))
       ::  64 Word.word)) in
   (let (tmask :: 64 bits) =
     ((or_vec
        ((and_vec tmask
            ((replicate_bits
                ((concat_vec
                    ((replicate_bits (vec_of_bits [access_vec_dec tmask_and (( 1 :: int)::ii)]  ::  1 Word.word)
                        (( 2 :: int)::ii)
                       ::  2 Word.word))
                    ((Ones__0 ((make_the_value (( 2 :: int)::ii)  ::  2 itself))  ::  2 Word.word))
                   ::  4 Word.word)) (( 16 :: int)::ii)
               ::  64 Word.word))
           ::  64 Word.word))
        ((replicate_bits
            ((concat_vec ((Zeros__0 ((make_the_value (( 2 :: int)::ii)  ::  2 itself))  ::  2 Word.word))
                ((replicate_bits (vec_of_bits [access_vec_dec tmask_or (( 1 :: int)::ii)]  ::  1 Word.word) (( 2 :: int)::ii)
                   ::  2 Word.word))
               ::  4 Word.word)) (( 16 :: int)::ii)
           ::  64 Word.word))
       ::  64 Word.word)) in
   (let (tmask :: 64 bits) =
     ((or_vec
        ((and_vec tmask
            ((replicate_bits
                ((concat_vec
                    ((replicate_bits (vec_of_bits [access_vec_dec tmask_and (( 2 :: int)::ii)]  ::  1 Word.word)
                        (( 4 :: int)::ii)
                       ::  4 Word.word))
                    ((Ones__0 ((make_the_value (( 4 :: int)::ii)  ::  4 itself))  ::  4 Word.word))
                   ::  8 Word.word)) (( 8 :: int)::ii)
               ::  64 Word.word))
           ::  64 Word.word))
        ((replicate_bits
            ((concat_vec ((Zeros__0 ((make_the_value (( 4 :: int)::ii)  ::  4 itself))  ::  4 Word.word))
                ((replicate_bits (vec_of_bits [access_vec_dec tmask_or (( 2 :: int)::ii)]  ::  1 Word.word) (( 4 :: int)::ii)
                   ::  4 Word.word))
               ::  8 Word.word)) (( 8 :: int)::ii)
           ::  64 Word.word))
       ::  64 Word.word)) in
   (let (tmask :: 64 bits) =
     ((or_vec
        ((and_vec tmask
            ((replicate_bits
                ((concat_vec
                    ((replicate_bits (vec_of_bits [access_vec_dec tmask_and (( 3 :: int)::ii)]  ::  1 Word.word)
                        (( 8 :: int)::ii)
                       ::  8 Word.word))
                    ((Ones__0 ((make_the_value (( 8 :: int)::ii)  ::  8 itself))  ::  8 Word.word))
                   ::  16 Word.word)) (( 4 :: int)::ii)
               ::  64 Word.word))
           ::  64 Word.word))
        ((replicate_bits
            ((concat_vec ((Zeros__0 ((make_the_value (( 8 :: int)::ii)  ::  8 itself))  ::  8 Word.word))
                ((replicate_bits (vec_of_bits [access_vec_dec tmask_or (( 3 :: int)::ii)]  ::  1 Word.word) (( 8 :: int)::ii)
                   ::  8 Word.word))
               ::  16 Word.word)) (( 4 :: int)::ii)
           ::  64 Word.word))
       ::  64 Word.word)) in
   (let (tmask :: 64 bits) =
     ((or_vec
        ((and_vec tmask
            ((replicate_bits
                ((concat_vec
                    ((replicate_bits (vec_of_bits [access_vec_dec tmask_and (( 4 :: int)::ii)]  ::  1 Word.word)
                        (( 16 :: int)::ii)
                       ::  16 Word.word))
                    ((Ones__0 ((make_the_value (( 16 :: int)::ii)  ::  16 itself))  ::  16 Word.word))
                   ::  32 Word.word)) (( 2 :: int)::ii)
               ::  64 Word.word))
           ::  64 Word.word))
        ((replicate_bits
            ((concat_vec ((Zeros__0 ((make_the_value (( 16 :: int)::ii)  ::  16 itself))  ::  16 Word.word))
                ((replicate_bits (vec_of_bits [access_vec_dec tmask_or (( 4 :: int)::ii)]  ::  1 Word.word) (( 16 :: int)::ii)
                   ::  16 Word.word))
               ::  32 Word.word)) (( 2 :: int)::ii)
           ::  64 Word.word))
       ::  64 Word.word)) in
   (let (tmask :: 64 bits) =
     ((or_vec
        ((and_vec tmask
            ((replicate_bits
                ((concat_vec
                    ((replicate_bits (vec_of_bits [access_vec_dec tmask_and (( 5 :: int)::ii)]  ::  1 Word.word)
                        (( 32 :: int)::ii)
                       ::  32 Word.word))
                    ((Ones__0 ((make_the_value (( 32 :: int)::ii)  ::  32 itself))  ::  32 Word.word))
                   ::  64 Word.word)) (( 1 :: int)::ii)
               ::  64 Word.word))
           ::  64 Word.word))
        ((replicate_bits
            ((concat_vec ((Zeros__0 ((make_the_value (( 32 :: int)::ii)  ::  32 itself))  ::  32 Word.word))
                ((replicate_bits (vec_of_bits [access_vec_dec tmask_or (( 5 :: int)::ii)]  ::  1 Word.word) (( 32 :: int)::ii)
                   ::  32 Word.word))
               ::  64 Word.word)) (( 1 :: int)::ii)
           ::  64 Word.word))
       ::  64 Word.word)) in
   (let (wmask_and :: 6 bits) = ((or_vec immr ((not_vec levels  ::  6 Word.word))  ::  6 Word.word)) in
   (let (wmask_or :: 6 bits) = ((and_vec immr levels  ::  6 Word.word)) in
   (let (wmask :: 64 bits) = ((Zeros__0 ((make_the_value (( 64 :: int)::ii)  ::  64 itself))  ::  64 Word.word)) in
   (let (wmask :: 64 bits) =
     ((or_vec
        ((and_vec wmask
            ((replicate_bits
                ((concat_vec ((Ones__0 ((make_the_value (( 1 :: int)::ii)  ::  1 itself))  ::  1 Word.word))
                    ((replicate_bits (vec_of_bits [access_vec_dec wmask_and (( 0 :: int)::ii)]  ::  1 Word.word)
                        (( 1 :: int)::ii)
                       ::  1 Word.word))
                   ::  2 Word.word)) (( 32 :: int)::ii)
               ::  64 Word.word))
           ::  64 Word.word))
        ((replicate_bits
            ((concat_vec
                ((replicate_bits (vec_of_bits [access_vec_dec wmask_or (( 0 :: int)::ii)]  ::  1 Word.word) (( 1 :: int)::ii)
                   ::  1 Word.word)) ((Zeros__0 ((make_the_value (( 1 :: int)::ii)  ::  1 itself))  ::  1 Word.word))
               ::  2 Word.word)) (( 32 :: int)::ii)
           ::  64 Word.word))
       ::  64 Word.word)) in
   (let (wmask :: 64 bits) =
     ((or_vec
        ((and_vec wmask
            ((replicate_bits
                ((concat_vec ((Ones__0 ((make_the_value (( 2 :: int)::ii)  ::  2 itself))  ::  2 Word.word))
                    ((replicate_bits (vec_of_bits [access_vec_dec wmask_and (( 1 :: int)::ii)]  ::  1 Word.word)
                        (( 2 :: int)::ii)
                       ::  2 Word.word))
                   ::  4 Word.word)) (( 16 :: int)::ii)
               ::  64 Word.word))
           ::  64 Word.word))
        ((replicate_bits
            ((concat_vec
                ((replicate_bits (vec_of_bits [access_vec_dec wmask_or (( 1 :: int)::ii)]  ::  1 Word.word) (( 2 :: int)::ii)
                   ::  2 Word.word)) ((Zeros__0 ((make_the_value (( 2 :: int)::ii)  ::  2 itself))  ::  2 Word.word))
               ::  4 Word.word)) (( 16 :: int)::ii)
           ::  64 Word.word))
       ::  64 Word.word)) in
   (let (wmask :: 64 bits) =
     ((or_vec
        ((and_vec wmask
            ((replicate_bits
                ((concat_vec ((Ones__0 ((make_the_value (( 4 :: int)::ii)  ::  4 itself))  ::  4 Word.word))
                    ((replicate_bits (vec_of_bits [access_vec_dec wmask_and (( 2 :: int)::ii)]  ::  1 Word.word)
                        (( 4 :: int)::ii)
                       ::  4 Word.word))
                   ::  8 Word.word)) (( 8 :: int)::ii)
               ::  64 Word.word))
           ::  64 Word.word))
        ((replicate_bits
            ((concat_vec
                ((replicate_bits (vec_of_bits [access_vec_dec wmask_or (( 2 :: int)::ii)]  ::  1 Word.word) (( 4 :: int)::ii)
                   ::  4 Word.word)) ((Zeros__0 ((make_the_value (( 4 :: int)::ii)  ::  4 itself))  ::  4 Word.word))
               ::  8 Word.word)) (( 8 :: int)::ii)
           ::  64 Word.word))
       ::  64 Word.word)) in
   (let (wmask :: 64 bits) =
     ((or_vec
        ((and_vec wmask
            ((replicate_bits
                ((concat_vec ((Ones__0 ((make_the_value (( 8 :: int)::ii)  ::  8 itself))  ::  8 Word.word))
                    ((replicate_bits (vec_of_bits [access_vec_dec wmask_and (( 3 :: int)::ii)]  ::  1 Word.word)
                        (( 8 :: int)::ii)
                       ::  8 Word.word))
                   ::  16 Word.word)) (( 4 :: int)::ii)
               ::  64 Word.word))
           ::  64 Word.word))
        ((replicate_bits
            ((concat_vec
                ((replicate_bits (vec_of_bits [access_vec_dec wmask_or (( 3 :: int)::ii)]  ::  1 Word.word) (( 8 :: int)::ii)
                   ::  8 Word.word)) ((Zeros__0 ((make_the_value (( 8 :: int)::ii)  ::  8 itself))  ::  8 Word.word))
               ::  16 Word.word)) (( 4 :: int)::ii)
           ::  64 Word.word))
       ::  64 Word.word)) in
   (let (wmask :: 64 bits) =
     ((or_vec
        ((and_vec wmask
            ((replicate_bits
                ((concat_vec ((Ones__0 ((make_the_value (( 16 :: int)::ii)  ::  16 itself))  ::  16 Word.word))
                    ((replicate_bits (vec_of_bits [access_vec_dec wmask_and (( 4 :: int)::ii)]  ::  1 Word.word)
                        (( 16 :: int)::ii)
                       ::  16 Word.word))
                   ::  32 Word.word)) (( 2 :: int)::ii)
               ::  64 Word.word))
           ::  64 Word.word))
        ((replicate_bits
            ((concat_vec
                ((replicate_bits (vec_of_bits [access_vec_dec wmask_or (( 4 :: int)::ii)]  ::  1 Word.word) (( 16 :: int)::ii)
                   ::  16 Word.word))
                ((Zeros__0 ((make_the_value (( 16 :: int)::ii)  ::  16 itself))  ::  16 Word.word))
               ::  32 Word.word)) (( 2 :: int)::ii)
           ::  64 Word.word))
       ::  64 Word.word)) in
   (let (wmask :: 64 bits) =
     ((or_vec
        ((and_vec wmask
            ((replicate_bits
                ((concat_vec ((Ones__0 ((make_the_value (( 32 :: int)::ii)  ::  32 itself))  ::  32 Word.word))
                    ((replicate_bits (vec_of_bits [access_vec_dec wmask_and (( 5 :: int)::ii)]  ::  1 Word.word)
                        (( 32 :: int)::ii)
                       ::  32 Word.word))
                   ::  64 Word.word)) (( 1 :: int)::ii)
               ::  64 Word.word))
           ::  64 Word.word))
        ((replicate_bits
            ((concat_vec
                ((replicate_bits (vec_of_bits [access_vec_dec wmask_or (( 5 :: int)::ii)]  ::  1 Word.word) (( 32 :: int)::ii)
                   ::  32 Word.word))
                ((Zeros__0 ((make_the_value (( 32 :: int)::ii)  ::  32 itself))  ::  32 Word.word))
               ::  64 Word.word)) (( 1 :: int)::ii)
           ::  64 Word.word))
       ::  64 Word.word)) in
   (let (wmask :: 64 bits) =
     (if (((((GetSlice_int ((make_the_value (( 1 :: int)::ii)  ::  1 itself)) diff (( 6 :: int)::ii)  ::  1 Word.word)) \<noteq> (vec_of_bits [B0]  ::  1 Word.word)))) then
       (and_vec wmask tmask  ::  64 Word.word)
     else (or_vec wmask tmask  ::  64 Word.word)) in
   return ((slice wmask (( 0 :: int)::ii) M__tv  :: ( 'M::len)Word.word), (slice tmask (( 0 :: int)::ii) M__tv  :: ( 'M::len)Word.word))))))))))))))))))))))))))))))))))))"


(*val integer_logical_immediate_decode : mword ty1 -> mword ty2 -> mword ty1 -> mword ty6 -> mword ty6 -> mword ty5 -> mword ty5 -> M unit*)

definition integer_logical_immediate_decode  :: "(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_logical_immediate_decode b__0 opc N immr imms Rn Rd = (
   if (((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_bool ()  \<bind> (\<lambda> (setflags :: bool) . 
     undefined_LogicalOp ()  \<bind> (\<lambda> (op1 :: LogicalOp) . 
     (let b__1 = opc in
     (let ((op1 :: LogicalOp), (setflags :: bool)) =
       (if (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
         (let (op1 :: LogicalOp) = LogicalOp_AND in
         (let (setflags :: bool) = False in
         (op1, setflags)))
       else
         (let ((op1 :: LogicalOp), (setflags :: bool)) =
           (if (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
             (let (op1 :: LogicalOp) = LogicalOp_ORR in
             (let (setflags :: bool) = False in
             (op1, setflags)))
           else
             (let ((op1 :: LogicalOp), (setflags :: bool)) =
               (if (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
                 (let (op1 :: LogicalOp) = LogicalOp_EOR in
                 (let (setflags :: bool) = False in
                 (op1, setflags)))
               else
                 (let (op1 :: LogicalOp) = LogicalOp_AND in
                 (let (setflags :: bool) = True in
                 (op1, setflags)))) in
             (op1, setflags))) in
         (op1, setflags))) in
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (imm :: 32 bits) . 
     ((if (((True \<and> (((N \<noteq> (vec_of_bits [B0]  ::  1 Word.word))))))) then ReservedValue () 
      else return () ) \<then>
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (anon10 :: 32 bits) . 
     (DecodeBitMasks (( 32 :: int)::ii) N imms immr True  :: (( 32 Word.word *  32 Word.word)) M) \<bind> (\<lambda> (w__0 ::
       ( 32 Word.word *  32 Word.word)) . 
     (let (tup__0, tup__1) = w__0 in
     (let imm = tup__0 in
     (let anon10 = tup__1 in
     aarch64_integer_logical_immediate d ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) imm n op1 setflags)))))))))))))
   else
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_bool ()  \<bind> (\<lambda> (setflags :: bool) . 
     undefined_LogicalOp ()  \<bind> (\<lambda> (op1 :: LogicalOp) . 
     (let b__6 = opc in
     (let ((op1 :: LogicalOp), (setflags :: bool)) =
       (if (((b__6 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
         (let (op1 :: LogicalOp) = LogicalOp_AND in
         (let (setflags :: bool) = False in
         (op1, setflags)))
       else
         (let ((op1 :: LogicalOp), (setflags :: bool)) =
           (if (((b__6 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
             (let (op1 :: LogicalOp) = LogicalOp_ORR in
             (let (setflags :: bool) = False in
             (op1, setflags)))
           else
             (let ((op1 :: LogicalOp), (setflags :: bool)) =
               (if (((b__6 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
                 (let (op1 :: LogicalOp) = LogicalOp_EOR in
                 (let (setflags :: bool) = False in
                 (op1, setflags)))
               else
                 (let (op1 :: LogicalOp) = LogicalOp_AND in
                 (let (setflags :: bool) = True in
                 (op1, setflags)))) in
             (op1, setflags))) in
         (op1, setflags))) in
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (imm :: 64 bits) . 
     ((if (((False \<and> (((N \<noteq> (vec_of_bits [B0]  ::  1 Word.word))))))) then ReservedValue () 
      else return () ) \<then>
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (anon10 :: 64 bits) . 
     (DecodeBitMasks (( 64 :: int)::ii) N imms immr True  :: (( 64 Word.word *  64 Word.word)) M) \<bind> (\<lambda> (w__1 ::
       ( 64 Word.word *  64 Word.word)) . 
     (let (tup__0, tup__1) = w__1 in
     (let imm = tup__0 in
     (let anon10 = tup__1 in
     aarch64_integer_logical_immediate d ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) imm n op1 setflags))))))))))))))"


(*val integer_bitfield_decode : mword ty1 -> mword ty2 -> mword ty1 -> mword ty6 -> mword ty6 -> mword ty5 -> mword ty5 -> M unit*)

definition integer_bitfield_decode  :: "(1)Word.word \<Rightarrow>(2)Word.word \<Rightarrow>(1)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " integer_bitfield_decode b__0 opc N immr imms Rn Rd = (
   if (((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) then
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_bool ()  \<bind> (\<lambda> (inzero :: bool) . 
     undefined_bool ()  \<bind> (\<lambda> (extend1 :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (R1 :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (S :: ii) . 
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (wmask :: 32 bits) . 
     (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (tmask :: 32 bits) . 
     (let b__1 = opc in
     (if (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
        (let (inzero :: bool) = True in
        (let (extend1 :: bool) = True in
        return (extend1, inzero)))
      else if (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
        (let (inzero :: bool) = False in
        (let (extend1 :: bool) = False in
        return (extend1, inzero)))
      else if (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
        (let (inzero :: bool) = True in
        (let (extend1 :: bool) = False in
        return (extend1, inzero)))
      else UnallocatedEncoding ()  \<then> return (extend1, inzero)) \<bind> (\<lambda> varstup .  (let ((extend1 :: bool), (inzero ::
       bool)) = varstup in
     ((if (((False \<and> (((N \<noteq> (vec_of_bits [B1]  ::  1 Word.word))))))) then ReservedValue () 
      else return () ) \<then>
     (if (((True \<and> (((((((((N \<noteq> (vec_of_bits [B0]  ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec immr (( 5 :: int)::ii)]  ::  1 Word.word) \<noteq> (vec_of_bits [B0]  ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec imms (( 5 :: int)::ii)]  ::  1 Word.word) \<noteq> (vec_of_bits [B0]  ::  1 Word.word)))))))))) then
        ReservedValue () 
      else return () )) \<then>
     ((let R1 = (Word.uint immr) in
     (let S = (Word.uint imms) in
     (DecodeBitMasks (( 32 :: int)::ii) N imms immr False  :: (( 32 Word.word *  32 Word.word)) M) \<bind> (\<lambda> (w__0 ::
       ( 32 Word.word *  32 Word.word)) . 
     (let (tup__0, tup__1) = w__0 in
     (let wmask = tup__0 in
     (let tmask = tup__1 in
     aarch64_integer_bitfield R1 S d ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) extend1 inzero n tmask
       wmask)))))))))))))))))))
   else
     write_reg unconditional_ref True \<then>
     ((let (d :: ii) = (Word.uint Rd) in
     (let (n :: ii) = (Word.uint Rn) in
     undefined_bool ()  \<bind> (\<lambda> (inzero :: bool) . 
     undefined_bool ()  \<bind> (\<lambda> (extend1 :: bool) . 
     undefined_int ()  \<bind> (\<lambda> (R1 :: ii) . 
     undefined_int ()  \<bind> (\<lambda> (S :: ii) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (wmask :: 64 bits) . 
     (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (tmask :: 64 bits) . 
     (let b__6 = opc in
     (if (((b__6 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
        (let (inzero :: bool) = True in
        (let (extend1 :: bool) = True in
        return (extend1, inzero)))
      else if (((b__6 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
        (let (inzero :: bool) = False in
        (let (extend1 :: bool) = False in
        return (extend1, inzero)))
      else if (((b__6 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
        (let (inzero :: bool) = True in
        (let (extend1 :: bool) = False in
        return (extend1, inzero)))
      else UnallocatedEncoding ()  \<then> return (extend1, inzero)) \<bind> (\<lambda> varstup .  (let ((extend1 :: bool), (inzero ::
       bool)) = varstup in
     ((if (((True \<and> (((N \<noteq> (vec_of_bits [B1]  ::  1 Word.word))))))) then ReservedValue () 
      else return () ) \<then>
     (if (((False \<and> (((((((((N \<noteq> (vec_of_bits [B0]  ::  1 Word.word)))) \<or> ((((vec_of_bits [access_vec_dec immr (( 5 :: int)::ii)]  ::  1 Word.word) \<noteq> (vec_of_bits [B0]  ::  1 Word.word))))))) \<or> ((((vec_of_bits [access_vec_dec imms (( 5 :: int)::ii)]  ::  1 Word.word) \<noteq> (vec_of_bits [B0]  ::  1 Word.word)))))))))) then
        ReservedValue () 
      else return () )) \<then>
     ((let R1 = (Word.uint immr) in
     (let S = (Word.uint imms) in
     (DecodeBitMasks (( 64 :: int)::ii) N imms immr False  :: (( 64 Word.word *  64 Word.word)) M) \<bind> (\<lambda> (w__1 ::
       ( 64 Word.word *  64 Word.word)) . 
     (let (tup__0, tup__1) = w__1 in
     (let wmask = tup__0 in
     (let tmask = tup__1 in
     aarch64_integer_bitfield R1 S d ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) extend1 inzero n tmask
       wmask))))))))))))))))))))"


(*val decode : mword ty32 -> M unit*)

definition decode  :: "(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " decode op_code = (
   if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)) = (vec_of_bits [B1,B0,B0,B1,B1,B0,B1,B1]  ::  8 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 22 :: int)::ii) (( 21 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 15 :: int)::ii) (( 15 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))))))))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (op54 :: 2 bits) = ((subrange_vec_dec op_code (( 30 :: int)::ii) (( 29 :: int)::ii)  ::  2 Word.word)) in
     (let (U :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 23 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rm :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (o0 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 15 :: int)::ii)]  ::  1 Word.word)) in
     (let (Ra :: 5 bits) = ((subrange_vec_dec op_code (( 14 :: int)::ii) (( 10 :: int)::ii)  ::  5 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_arithmetic_mul_widening_64128hi_decode sf op54 U Rm o0 Ra Rn Rd))))))))
   else if (((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 23 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B0,B1,B0,B0,B0,B1]  ::  7 Word.word)))) then
     (let (opc :: 2 bits) = ((subrange_vec_dec op_code (( 31 :: int)::ii) (( 30 :: int)::ii)  ::  2 Word.word)) in
     (let (V1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 :: int)::ii)]  ::  1 Word.word)) in
     (let (L :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 :: int)::ii)]  ::  1 Word.word)) in
     (let (imm7 :: 7 bits) = ((subrange_vec_dec op_code (( 21 :: int)::ii) (( 15 :: int)::ii)  ::  7 Word.word)) in
     (let (Rt2 :: 5 bits) = ((subrange_vec_dec op_code (( 14 :: int)::ii) (( 10 :: int)::ii)  ::  5 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_pair_general_postidx_aarch64_memory_pair_general_postidx__decode opc V1 L imm7 Rt2 Rn Rt)))))))
   else if (((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 23 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B0,B1,B0,B0,B1,B1]  ::  7 Word.word)))) then
     (let (opc :: 2 bits) = ((subrange_vec_dec op_code (( 31 :: int)::ii) (( 30 :: int)::ii)  ::  2 Word.word)) in
     (let (V1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 :: int)::ii)]  ::  1 Word.word)) in
     (let (L :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 :: int)::ii)]  ::  1 Word.word)) in
     (let (imm7 :: 7 bits) = ((subrange_vec_dec op_code (( 21 :: int)::ii) (( 15 :: int)::ii)  ::  7 Word.word)) in
     (let (Rt2 :: 5 bits) = ((subrange_vec_dec op_code (( 14 :: int)::ii) (( 10 :: int)::ii)  ::  5 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_pair_general_preidx_aarch64_memory_pair_general_postidx__decode opc V1 L imm7 Rt2 Rn Rt)))))))
   else if (((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 23 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B0,B1,B0,B0,B1,B0]  ::  7 Word.word)))) then
     (let (opc :: 2 bits) = ((subrange_vec_dec op_code (( 31 :: int)::ii) (( 30 :: int)::ii)  ::  2 Word.word)) in
     (let (V1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 :: int)::ii)]  ::  1 Word.word)) in
     (let (L :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 :: int)::ii)]  ::  1 Word.word)) in
     (let (imm7 :: 7 bits) = ((subrange_vec_dec op_code (( 21 :: int)::ii) (( 15 :: int)::ii)  ::  7 Word.word)) in
     (let (Rt2 :: 5 bits) = ((subrange_vec_dec op_code (( 14 :: int)::ii) (( 10 :: int)::ii)  ::  5 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_pair_general_offset_aarch64_memory_pair_general_postidx__decode opc V1 L imm7 Rt2 Rn Rt)))))))
   else if ((((((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 24 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B1,B1,B0,B0]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     (let (size1 :: 2 bits) = ((subrange_vec_dec op_code (( 31 :: int)::ii) (( 30 :: int)::ii)  ::  2 Word.word)) in
     (let (V1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 :: int)::ii)]  ::  1 Word.word)) in
     (let (opc :: 2 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 22 :: int)::ii)  ::  2 Word.word)) in
     (let (Rm :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (option_name :: 3 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 12 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_single_simdfp_register_aarch64_memory_single_simdfp_register__decode size1 V1 opc Rm
       option_name S Rn Rt))))))))
   else if (((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B1,B1,B1,B1]  ::  8 Word.word)))) then
     (let (M :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (typ1 :: 2 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 22 :: int)::ii)  ::  2 Word.word)) in
     (let (o1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rm :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (o0 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 15 :: int)::ii)]  ::  1 Word.word)) in
     (let (Ra :: 5 bits) = ((subrange_vec_dec op_code (( 14 :: int)::ii) (( 10 :: int)::ii)  ::  5 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     float_arithmetic_mul_addsub_decode M S typ1 o1 Rm o0 Ra Rn Rd)))))))))
   else if ((((((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 24 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B0,B0]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 15 :: int)::ii) (( 15 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word))))))))))))) then
     (let (size1 :: 2 bits) = ((subrange_vec_dec op_code (( 31 :: int)::ii) (( 30 :: int)::ii)  ::  2 Word.word)) in
     (let (V1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 :: int)::ii)]  ::  1 Word.word)) in
     (let (A :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 23 :: int)::ii)]  ::  1 Word.word)) in
     (let (R1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rs :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (o3 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 15 :: int)::ii)]  ::  1 Word.word)) in
     (let (opc :: 3 bits) = ((subrange_vec_dec op_code (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_atomicops_ld_decode size1 V1 A R1 Rs o3 opc Rn Rt)))))))))
   else if (((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 11 :: int)::ii)  ::  21 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B1,B0,B1,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B1,B0,B0,B0]
                 ::  21 Word.word)))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (opcode2 :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (D :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 10 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_pac_strip_dp_1src_decode sf S opcode2 D Rn Rd))))))
   else if (((op_code = (vec_of_bits [B1,B1,B0,B1,B0,B1,B0,B1,B0,B0,B0,B0,B0,B0,B1,B1,B0,B0,B1,B0,B0,B0,B0,B0,
                             B1,B1,B1,B1,B1,B1,B1,B1]
                 ::  32 Word.word)))) then
     (let (L :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 :: int)::ii)]  ::  1 Word.word)) in
     (let (op0 :: 2 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 19 :: int)::ii)  ::  2 Word.word)) in
     (let (op1 :: 3 bits) = ((subrange_vec_dec op_code (( 18 :: int)::ii) (( 16 :: int)::ii)  ::  3 Word.word)) in
     (let (CRn :: 4 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) in
     (let (CRm :: 4 bits) = ((subrange_vec_dec op_code (( 11 :: int)::ii) (( 8 :: int)::ii)  ::  4 Word.word)) in
     (let (op2 :: 3 bits) = ((subrange_vec_dec op_code (( 7 :: int)::ii) (( 5 :: int)::ii)  ::  3 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_pac_strip_hint_decode L op0 op1 CRn CRm op2 Rt)))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 14 :: int)::ii)  ::  18 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B1,B0,B1,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B0]
                     ::  18 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 12 :: int)::ii) (( 10 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word))))))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (opcode2 :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (Z :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 13 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_pac_pacda_dp_1src_decode sf S opcode2 Z Rn Rd))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 12 :: int)::ii)  ::  20 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B0,B1,B0,B1,B0,B0,B0,B0,B0,B0,B1,B1,B0,B0,B1,B1]
                     ::  20 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1,B1,B1]  ::  8 Word.word))))))) then
     (let (L :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 :: int)::ii)]  ::  1 Word.word)) in
     (let (op0 :: 2 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 19 :: int)::ii)  ::  2 Word.word)) in
     (let (op1 :: 3 bits) = ((subrange_vec_dec op_code (( 18 :: int)::ii) (( 16 :: int)::ii)  ::  3 Word.word)) in
     (let (CRn :: 4 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) in
     (let (CRm :: 4 bits) = ((subrange_vec_dec op_code (( 11 :: int)::ii) (( 8 :: int)::ii)  ::  4 Word.word)) in
     (let (op2 :: 3 bits) = ((subrange_vec_dec op_code (( 7 :: int)::ii) (( 5 :: int)::ii)  ::  3 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     system_monitors_decode L op0 op1 CRn CRm op2 Rt)))))))
   else if ((((((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 24 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B0,B0]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     (let (size1 :: 2 bits) = ((subrange_vec_dec op_code (( 31 :: int)::ii) (( 30 :: int)::ii)  ::  2 Word.word)) in
     (let (V1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 :: int)::ii)]  ::  1 Word.word)) in
     (let (opc :: 2 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 22 :: int)::ii)  ::  2 Word.word)) in
     (let (imm9 :: 9 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 12 :: int)::ii)  ::  9 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_single_general_immediate_signed_offset_normal_aarch64_memory_single_general_immediate_signed_offset_normal__decode
       size1 V1 opc imm9 Rn Rt))))))
   else if (((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 23 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B0,B1,B0,B0,B0,B0]  ::  7 Word.word)))) then
     (let (opc :: 2 bits) = ((subrange_vec_dec op_code (( 31 :: int)::ii) (( 30 :: int)::ii)  ::  2 Word.word)) in
     (let (V1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 :: int)::ii)]  ::  1 Word.word)) in
     (let (L :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 :: int)::ii)]  ::  1 Word.word)) in
     (let (imm7 :: 7 bits) = ((subrange_vec_dec op_code (( 21 :: int)::ii) (( 15 :: int)::ii)  ::  7 Word.word)) in
     (let (Rt2 :: 5 bits) = ((subrange_vec_dec op_code (( 14 :: int)::ii) (( 10 :: int)::ii)  ::  5 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_pair_general_noalloc_aarch64_memory_pair_general_noalloc__decode opc V1 L imm7 Rt2 Rn Rt)))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B1,B1,B1,B0]  ::  8 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 14 :: int)::ii) (( 10 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B0]  ::  5 Word.word)))))))))) then
     (let (M :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (typ1 :: 2 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 22 :: int)::ii)  ::  2 Word.word)) in
     (let (Rm :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (op1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 15 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     float_arithmetic_mul_product_decode M S typ1 Rm op1 Rn Rd)))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B1,B0,B0,B1,B1,B0,B1,B0,B1,B1,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B0]  ::  6 Word.word))))))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (op1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rm :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (opcode2 :: 6 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_pac_pacga_dp_2src_decode sf op1 S Rm opcode2 Rn Rd)))))))
   else if ((((((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 23 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B0,B0,B1]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 14 :: int)::ii) (( 10 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B1,B1,B1,B1,B1]  ::  5 Word.word)))))))))) then
     (let (size1 :: 2 bits) = ((subrange_vec_dec op_code (( 31 :: int)::ii) (( 30 :: int)::ii)  ::  2 Word.word)) in
     (let (o2 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 23 :: int)::ii)]  ::  1 Word.word)) in
     (let (L :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 :: int)::ii)]  ::  1 Word.word)) in
     (let (o1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rs :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (o0 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 15 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rt2 :: 5 bits) = ((subrange_vec_dec op_code (( 14 :: int)::ii) (( 10 :: int)::ii)  ::  5 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_atomicops_cas_single_decode size1 o2 L o1 Rs o0 Rt2 Rn Rt)))))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 19 :: int)::ii)  ::  13 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B0,B1,B0,B1,B0,B0,B0,B0,B0]  ::  13 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) = (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B1,B1,B1,B1,B1]  ::  5 Word.word)))))))))) then
     (let (L :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 :: int)::ii)]  ::  1 Word.word)) in
     (let (op0 :: 2 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 19 :: int)::ii)  ::  2 Word.word)) in
     (let (op1 :: 3 bits) = ((subrange_vec_dec op_code (( 18 :: int)::ii) (( 16 :: int)::ii)  ::  3 Word.word)) in
     (let (CRn :: 4 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) in
     (let (CRm :: 4 bits) = ((subrange_vec_dec op_code (( 11 :: int)::ii) (( 8 :: int)::ii)  ::  4 Word.word)) in
     (let (op2 :: 3 bits) = ((subrange_vec_dec op_code (( 7 :: int)::ii) (( 5 :: int)::ii)  ::  3 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     system_register_cpsr_decode L op0 op1 CRn CRm op2 Rt)))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B0,B1,B0,B0]  ::  8 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word))))))) then
     (let (o1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 24 :: int)::ii)]  ::  1 Word.word)) in
     (let (imm19 :: 19 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 5 :: int)::ii)  ::  19 Word.word)) in
     (let (o0 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 4 :: int)::ii)]  ::  1 Word.word)) in
     (let (cond :: 4 bits) = ((subrange_vec_dec op_code (( 3 :: int)::ii) (( 0 :: int)::ii)  ::  4 Word.word)) in
     branch_conditional_cond_decode o1 imm19 o0 cond))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B0,B1,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B0]  ::  5 Word.word))))))) then
     (let (opc :: 3 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 21 :: int)::ii)  ::  3 Word.word)) in
     (let (imm16 :: 16 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 5 :: int)::ii)  ::  16 Word.word)) in
     (let (op2 :: 3 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     (let (LL :: 2 bits) = ((subrange_vec_dec op_code (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) in
     system_exceptions_runtime_hvc_decode opc imm16 op2 LL))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 31 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 23 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B1]  ::  1 Word.word)))))))))) then
     (let (sz :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 :: int)::ii)]  ::  1 Word.word)) in
     (let (o2 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 23 :: int)::ii)]  ::  1 Word.word)) in
     (let (L :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 :: int)::ii)]  ::  1 Word.word)) in
     (let (o1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rs :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (o0 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 15 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rt2 :: 5 bits) = ((subrange_vec_dec op_code (( 14 :: int)::ii) (( 10 :: int)::ii)  ::  5 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_exclusive_pair_decode sz o2 L o1 Rs o0 Rt2 Rn Rt)))))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 14 :: int)::ii)  ::  18 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B1,B0,B1,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B0]
                     ::  18 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 12 :: int)::ii) (( 10 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B1]  ::  3 Word.word))))))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (opcode2 :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (Z :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 13 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_pac_autdb_dp_1src_decode sf S opcode2 Z Rn Rd))))))
   else if (((((subrange_vec_dec op_code (( 30 :: int)::ii) (( 10 :: int)::ii)  ::  21 Word.word)) = (vec_of_bits [B1,B0,B1,B1,B0,B1,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
                 ::  21 Word.word)))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (opcode2 :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_arithmetic_rbit_decode sf S opcode2 Rn Rd)))))
   else if (((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 24 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B0,B1]  ::  6 Word.word)))) then
     (let (size1 :: 2 bits) = ((subrange_vec_dec op_code (( 31 :: int)::ii) (( 30 :: int)::ii)  ::  2 Word.word)) in
     (let (V1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 :: int)::ii)]  ::  1 Word.word)) in
     (let (opc :: 2 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 22 :: int)::ii)  ::  2 Word.word)) in
     (let (imm12 :: 12 bits) = ((subrange_vec_dec op_code (( 21 :: int)::ii) (( 10 :: int)::ii)  ::  12 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_single_general_immediate_unsigned_aarch64_memory_single_general_immediate_unsigned__decode
       size1 V1 opc imm12 Rn Rt))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 14 :: int)::ii)  ::  18 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B1,B0,B1,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B0]
                     ::  18 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 12 :: int)::ii) (( 10 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B0]  ::  3 Word.word))))))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (opcode2 :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (Z :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 13 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_pac_autia_dp_1src_decode sf S opcode2 Z Rn Rd))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 12 :: int)::ii)  ::  20 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B0,B1,B0,B1,B0,B0,B0,B0,B0,B0,B1,B1,B0,B0,B1,B0]
                     ::  20 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B1,B1,B1,B1,B1]  ::  5 Word.word))))))) then
     (let (L :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 :: int)::ii)]  ::  1 Word.word)) in
     (let (op0 :: 2 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 19 :: int)::ii)  ::  2 Word.word)) in
     (let (op1 :: 3 bits) = ((subrange_vec_dec op_code (( 18 :: int)::ii) (( 16 :: int)::ii)  ::  3 Word.word)) in
     (let (CRn :: 4 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) in
     (let (CRm :: 4 bits) = ((subrange_vec_dec op_code (( 11 :: int)::ii) (( 8 :: int)::ii)  ::  4 Word.word)) in
     (let (op2 :: 3 bits) = ((subrange_vec_dec op_code (( 7 :: int)::ii) (( 5 :: int)::ii)  ::  3 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_pac_autia_hint_decode L op0 op1 CRn CRm op2 Rt)))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B0,B1,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B1]  ::  5 Word.word))))))) then
     (let (opc :: 3 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 21 :: int)::ii)  ::  3 Word.word)) in
     (let (imm16 :: 16 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 5 :: int)::ii)  ::  16 Word.word)) in
     (let (op2 :: 3 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     (let (LL :: 2 bits) = ((subrange_vec_dec op_code (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) in
     system_exceptions_runtime_svc_decode opc imm16 op2 LL))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B0,B1,B1]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 23 :: int)::ii) (( 23 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 20 :: int)::ii) (( 12 :: int)::ii)  ::  9 Word.word)) = (vec_of_bits [B1,B1,B1,B1,B1,B0,B0,B0,B0]  ::  9 Word.word)))))))))) then
     (let (Z :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 24 :: int)::ii)]  ::  1 Word.word)) in
     (let (opc :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 23 :: int)::ii)]  ::  1 Word.word)) in
     (let (op1 :: 2 bits) = ((subrange_vec_dec op_code (( 22 :: int)::ii) (( 21 :: int)::ii)  ::  2 Word.word)) in
     (let (op2 :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (op3 :: 4 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) in
     (let (A :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 11 :: int)::ii)]  ::  1 Word.word)) in
     (let (M :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 10 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rm :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     branch_unconditional_register_decode Z opc op1 op2 op3 A M Rn Rm)))))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B1,B1,B1,B0]  ::  8 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 12 :: int)::ii) (( 5 :: int)::ii)  ::  8 Word.word)) = (vec_of_bits [B1,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word)))))))))) then
     (let (M :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (typ1 :: 2 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 22 :: int)::ii)  ::  2 Word.word)) in
     (let (imm8 :: 8 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 13 :: int)::ii)  ::  8 Word.word)) in
     (let (imm5 :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     float_move_fp_imm_decode M S typ1 imm8 imm5 Rd))))))
   else if (((((subrange_vec_dec op_code (( 30 :: int)::ii) (( 25 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B1,B1]  ::  6 Word.word)))) then
     (let (b5 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (op1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 24 :: int)::ii)]  ::  1 Word.word)) in
     (let (b40 :: 5 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 19 :: int)::ii)  ::  5 Word.word)) in
     (let (imm14 :: 14 bits) = ((subrange_vec_dec op_code (( 18 :: int)::ii) (( 5 :: int)::ii)  ::  14 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     branch_conditional_test_decode b5 op1 b40 imm14 Rt)))))
   else if ((((((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 24 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B0,B0]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     (let (size1 :: 2 bits) = ((subrange_vec_dec op_code (( 31 :: int)::ii) (( 30 :: int)::ii)  ::  2 Word.word)) in
     (let (V1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 :: int)::ii)]  ::  1 Word.word)) in
     (let (opc :: 2 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 22 :: int)::ii)  ::  2 Word.word)) in
     (let (imm9 :: 9 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 12 :: int)::ii)  ::  9 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_single_general_immediate_signed_postidx_aarch64_memory_single_general_immediate_signed_postidx__decode
       size1 V1 opc imm9 Rn Rt))))))
   else if ((((((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 24 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B0,B0]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     (let (size1 :: 2 bits) = ((subrange_vec_dec op_code (( 31 :: int)::ii) (( 30 :: int)::ii)  ::  2 Word.word)) in
     (let (V1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 :: int)::ii)]  ::  1 Word.word)) in
     (let (opc :: 2 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 22 :: int)::ii)  ::  2 Word.word)) in
     (let (imm9 :: 9 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 12 :: int)::ii)  ::  9 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_single_general_immediate_signed_preidx_aarch64_memory_single_general_immediate_signed_postidx__decode
       size1 V1 opc imm9 Rn Rt))))))
   else if (((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 24 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B0,B1]  ::  6 Word.word)))) then
     (let (size1 :: 2 bits) = ((subrange_vec_dec op_code (( 31 :: int)::ii) (( 30 :: int)::ii)  ::  2 Word.word)) in
     (let (V1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 :: int)::ii)]  ::  1 Word.word)) in
     (let (opc :: 2 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 22 :: int)::ii)  ::  2 Word.word)) in
     (let (imm12 :: 12 bits) = ((subrange_vec_dec op_code (( 21 :: int)::ii) (( 10 :: int)::ii)  ::  12 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_single_general_immediate_unsigned_aarch64_memory_single_general_immediate_signed_postidx__decode
       size1 V1 opc imm12 Rn Rt))))))
   else if (((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 24 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B0]  ::  6 Word.word)))) then
     (let (opc :: 2 bits) = ((subrange_vec_dec op_code (( 31 :: int)::ii) (( 30 :: int)::ii)  ::  2 Word.word)) in
     (let (V1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 :: int)::ii)]  ::  1 Word.word)) in
     (let (imm19 :: 19 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 5 :: int)::ii)  ::  19 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_literal_general_decode opc V1 imm19 Rt))))
   else if (((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 23 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B0,B1,B1,B0,B0,B1]  ::  7 Word.word)))) then
     (let (opc :: 2 bits) = ((subrange_vec_dec op_code (( 31 :: int)::ii) (( 30 :: int)::ii)  ::  2 Word.word)) in
     (let (V1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 :: int)::ii)]  ::  1 Word.word)) in
     (let (L :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 :: int)::ii)]  ::  1 Word.word)) in
     (let (imm7 :: 7 bits) = ((subrange_vec_dec op_code (( 21 :: int)::ii) (( 15 :: int)::ii)  ::  7 Word.word)) in
     (let (Rt2 :: 5 bits) = ((subrange_vec_dec op_code (( 14 :: int)::ii) (( 10 :: int)::ii)  ::  5 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_pair_simdfp_postidx_aarch64_memory_pair_simdfp_postidx__decode opc V1 L imm7 Rt2 Rn Rt)))))))
   else if (((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 23 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B0,B1,B1,B0,B1,B1]  ::  7 Word.word)))) then
     (let (opc :: 2 bits) = ((subrange_vec_dec op_code (( 31 :: int)::ii) (( 30 :: int)::ii)  ::  2 Word.word)) in
     (let (V1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 :: int)::ii)]  ::  1 Word.word)) in
     (let (L :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 :: int)::ii)]  ::  1 Word.word)) in
     (let (imm7 :: 7 bits) = ((subrange_vec_dec op_code (( 21 :: int)::ii) (( 15 :: int)::ii)  ::  7 Word.word)) in
     (let (Rt2 :: 5 bits) = ((subrange_vec_dec op_code (( 14 :: int)::ii) (( 10 :: int)::ii)  ::  5 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_pair_simdfp_preidx_aarch64_memory_pair_simdfp_postidx__decode opc V1 L imm7 Rt2 Rn Rt)))))))
   else if (((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 23 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B0,B1,B1,B0,B1,B0]  ::  7 Word.word)))) then
     (let (opc :: 2 bits) = ((subrange_vec_dec op_code (( 31 :: int)::ii) (( 30 :: int)::ii)  ::  2 Word.word)) in
     (let (V1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 :: int)::ii)]  ::  1 Word.word)) in
     (let (L :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 :: int)::ii)]  ::  1 Word.word)) in
     (let (imm7 :: 7 bits) = ((subrange_vec_dec op_code (( 21 :: int)::ii) (( 15 :: int)::ii)  ::  7 Word.word)) in
     (let (Rt2 :: 5 bits) = ((subrange_vec_dec op_code (( 14 :: int)::ii) (( 10 :: int)::ii)  ::  5 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_pair_simdfp_offset_aarch64_memory_pair_simdfp_postidx__decode opc V1 L imm7 Rt2 Rn Rt)))))))
   else if (((((subrange_vec_dec op_code (( 30 :: int)::ii) (( 25 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B1,B0]  ::  6 Word.word)))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (op1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 24 :: int)::ii)]  ::  1 Word.word)) in
     (let (imm19 :: 19 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 5 :: int)::ii)  ::  19 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     branch_conditional_compare_decode sf op1 imm19 Rt))))
   else if ((((((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 24 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B1,B1,B0,B0]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     (let (size1 :: 2 bits) = ((subrange_vec_dec op_code (( 31 :: int)::ii) (( 30 :: int)::ii)  ::  2 Word.word)) in
     (let (V1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 :: int)::ii)]  ::  1 Word.word)) in
     (let (opc :: 2 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 22 :: int)::ii)  ::  2 Word.word)) in
     (let (imm9 :: 9 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 12 :: int)::ii)  ::  9 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_single_simdfp_immediate_signed_offset_normal_aarch64_memory_single_simdfp_immediate_signed_offset_normal__decode
       size1 V1 opc imm9 Rn Rt))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 14 :: int)::ii)  ::  18 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B1,B0,B1,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B0]
                     ::  18 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 12 :: int)::ii) (( 10 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B1]  ::  3 Word.word))))))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (opcode2 :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (Z :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 13 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_pac_pacib_dp_1src_decode sf S opcode2 Z Rn Rd))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 12 :: int)::ii)  ::  20 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B0,B1,B0,B1,B0,B0,B0,B0,B0,B0,B1,B1,B0,B0,B1,B0]
                     ::  20 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B1,B1,B1,B1,B1]  ::  5 Word.word))))))) then
     (let (L :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 :: int)::ii)]  ::  1 Word.word)) in
     (let (op0 :: 2 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 19 :: int)::ii)  ::  2 Word.word)) in
     (let (op1 :: 3 bits) = ((subrange_vec_dec op_code (( 18 :: int)::ii) (( 16 :: int)::ii)  ::  3 Word.word)) in
     (let (CRn :: 4 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) in
     (let (CRm :: 4 bits) = ((subrange_vec_dec op_code (( 11 :: int)::ii) (( 8 :: int)::ii)  ::  4 Word.word)) in
     (let (op2 :: 3 bits) = ((subrange_vec_dec op_code (( 7 :: int)::ii) (( 5 :: int)::ii)  ::  3 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_pac_pacib_hint_decode L op0 op1 CRn CRm op2 Rt)))))))
   else if ((((((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 24 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B1,B1,B0,B0]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     (let (size1 :: 2 bits) = ((subrange_vec_dec op_code (( 31 :: int)::ii) (( 30 :: int)::ii)  ::  2 Word.word)) in
     (let (V1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 :: int)::ii)]  ::  1 Word.word)) in
     (let (opc :: 2 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 22 :: int)::ii)  ::  2 Word.word)) in
     (let (imm9 :: 9 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 12 :: int)::ii)  ::  9 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_single_simdfp_immediate_signed_postidx_aarch64_memory_single_simdfp_immediate_signed_postidx__decode
       size1 V1 opc imm9 Rn Rt))))))
   else if ((((((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 24 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B1,B1,B0,B0]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     (let (size1 :: 2 bits) = ((subrange_vec_dec op_code (( 31 :: int)::ii) (( 30 :: int)::ii)  ::  2 Word.word)) in
     (let (V1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 :: int)::ii)]  ::  1 Word.word)) in
     (let (opc :: 2 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 22 :: int)::ii)  ::  2 Word.word)) in
     (let (imm9 :: 9 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 12 :: int)::ii)  ::  9 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_single_simdfp_immediate_signed_preidx_aarch64_memory_single_simdfp_immediate_signed_postidx__decode
       size1 V1 opc imm9 Rn Rt))))))
   else if (((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 24 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B1,B1,B0,B1]  ::  6 Word.word)))) then
     (let (size1 :: 2 bits) = ((subrange_vec_dec op_code (( 31 :: int)::ii) (( 30 :: int)::ii)  ::  2 Word.word)) in
     (let (V1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 :: int)::ii)]  ::  1 Word.word)) in
     (let (opc :: 2 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 22 :: int)::ii)  ::  2 Word.word)) in
     (let (imm12 :: 12 bits) = ((subrange_vec_dec op_code (( 21 :: int)::ii) (( 10 :: int)::ii)  ::  12 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_single_simdfp_immediate_unsigned_aarch64_memory_single_simdfp_immediate_signed_postidx__decode
       size1 V1 opc imm12 Rn Rt))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 31 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 23 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0]  ::  7 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 16 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))))))))) then
     (let (Q :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 :: int)::ii)]  ::  1 Word.word)) in
     (let (L :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 :: int)::ii)]  ::  1 Word.word)) in
     (let (opcode :: 4 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) in
     (let (size1 :: 2 bits) = ((subrange_vec_dec op_code (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_vector_multiple_nowb_aarch64_memory_vector_multiple_nowb__decode Q L opcode size1 Rn Rt))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 31 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 23 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B0,B1]  ::  7 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))))))))) then
     (let (Q :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 :: int)::ii)]  ::  1 Word.word)) in
     (let (L :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rm :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (opcode :: 4 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) in
     (let (size1 :: 2 bits) = ((subrange_vec_dec op_code (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_vector_multiple_postinc_aarch64_memory_vector_multiple_nowb__decode Q L Rm opcode size1
       Rn Rt)))))))
   else if (((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 12 :: int)::ii)  ::  20 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B0,B1,B1,B0,B1,B0,B0,B1,B1,B1,B1,B1,B0,B0,B0,B0]
                 ::  20 Word.word)))) then
     (let (opc :: 4 bits) = ((subrange_vec_dec op_code (( 24 :: int)::ii) (( 21 :: int)::ii)  ::  4 Word.word)) in
     (let (op2 :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (op3 :: 4 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) in
     (let (A :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 11 :: int)::ii)]  ::  1 Word.word)) in
     (let (M :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 10 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (op4 :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     branch_unconditional_eret_decode opc op2 op3 A M Rn op4)))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B1,B1,B1,B0]  ::  8 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 15 :: int)::ii) (( 14 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word))))))))))))) then
     (let (M :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (typ1 :: 2 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 22 :: int)::ii)  ::  2 Word.word)) in
     (let (Rm :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (op1 :: 2 bits) = ((subrange_vec_dec op_code (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     float_arithmetic_maxmin_decode M S typ1 Rm op1 Rn Rd)))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B1,B1,B1,B0]  ::  8 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 17 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B1,B0,B0,B0,B0]  ::  5 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 14 :: int)::ii) (( 10 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B1,B0,B0,B0,B0]  ::  5 Word.word)))))))))) then
     (let (M :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (typ1 :: 2 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 22 :: int)::ii)  ::  2 Word.word)) in
     (let (opc :: 2 bits) = ((subrange_vec_dec op_code (( 16 :: int)::ii) (( 15 :: int)::ii)  ::  2 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     float_arithmetic_unary_decode M S typ1 opc Rn Rd))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B0,B1,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B1]  ::  5 Word.word))))))) then
     (let (opc :: 3 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 21 :: int)::ii)  ::  3 Word.word)) in
     (let (imm16 :: 16 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 5 :: int)::ii)  ::  16 Word.word)) in
     (let (op2 :: 3 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     (let (LL :: 2 bits) = ((subrange_vec_dec op_code (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) in
     system_exceptions_runtime_smc_decode opc imm16 op2 LL))))
   else if ((((((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 23 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B0,B0,B1]  ::  7 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word))))))) then
     (let (size1 :: 2 bits) = ((subrange_vec_dec op_code (( 31 :: int)::ii) (( 30 :: int)::ii)  ::  2 Word.word)) in
     (let (o2 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 23 :: int)::ii)]  ::  1 Word.word)) in
     (let (L :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 :: int)::ii)]  ::  1 Word.word)) in
     (let (o1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rs :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (o0 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 15 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rt2 :: 5 bits) = ((subrange_vec_dec op_code (( 14 :: int)::ii) (( 10 :: int)::ii)  ::  5 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_ordered_decode size1 o2 L o1 Rs o0 Rt2 Rn Rt)))))))))
   else if ((((((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 24 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B0,B0]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     (let (size1 :: 2 bits) = ((subrange_vec_dec op_code (( 31 :: int)::ii) (( 30 :: int)::ii)  ::  2 Word.word)) in
     (let (V1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 :: int)::ii)]  ::  1 Word.word)) in
     (let (opc :: 2 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 22 :: int)::ii)  ::  2 Word.word)) in
     (let (Rm :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (option_name :: 3 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 12 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_single_general_register_aarch64_memory_single_general_register__decode size1 V1 opc Rm
       option_name S Rn Rt))))))))
   else if (((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 23 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B0,B1,B1,B0,B0,B0]  ::  7 Word.word)))) then
     (let (opc :: 2 bits) = ((subrange_vec_dec op_code (( 31 :: int)::ii) (( 30 :: int)::ii)  ::  2 Word.word)) in
     (let (V1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 :: int)::ii)]  ::  1 Word.word)) in
     (let (L :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 :: int)::ii)]  ::  1 Word.word)) in
     (let (imm7 :: 7 bits) = ((subrange_vec_dec op_code (( 21 :: int)::ii) (( 15 :: int)::ii)  ::  7 Word.word)) in
     (let (Rt2 :: 5 bits) = ((subrange_vec_dec op_code (( 14 :: int)::ii) (( 10 :: int)::ii)  ::  5 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_pair_simdfp_noalloc_aarch64_memory_pair_simdfp_noalloc__decode opc V1 L imm7 Rt2 Rn Rt)))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B0,B1,B0,B0,B0,B0,B1]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word))))))) then
     (let (opc :: 3 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 21 :: int)::ii)  ::  3 Word.word)) in
     (let (imm16 :: 16 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 5 :: int)::ii)  ::  16 Word.word)) in
     (let (op2 :: 3 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     (let (LL :: 2 bits) = ((subrange_vec_dec op_code (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) in
     system_exceptions_debug_breakpoint_decode opc imm16 op2 LL))))
   else if (((((subrange_vec_dec op_code (( 30 :: int)::ii) (( 21 :: int)::ii)  ::  10 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B1,B1,B0,B0,B0]  ::  10 Word.word)))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (op54 :: 2 bits) = ((subrange_vec_dec op_code (( 30 :: int)::ii) (( 29 :: int)::ii)  ::  2 Word.word)) in
     (let (op31 :: 3 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 21 :: int)::ii)  ::  3 Word.word)) in
     (let (Rm :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (o0 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 15 :: int)::ii)]  ::  1 Word.word)) in
     (let (Ra :: 5 bits) = ((subrange_vec_dec op_code (( 14 :: int)::ii) (( 10 :: int)::ii)  ::  5 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_arithmetic_mul_uniform_addsub_decode sf op54 op31 Rm o0 Ra Rn Rd))))))))
   else if (((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 24 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B0]  ::  6 Word.word)))) then
     (let (opc :: 2 bits) = ((subrange_vec_dec op_code (( 31 :: int)::ii) (( 30 :: int)::ii)  ::  2 Word.word)) in
     (let (V1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 :: int)::ii)]  ::  1 Word.word)) in
     (let (imm19 :: 19 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 5 :: int)::ii)  ::  19 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_literal_simdfp_decode opc V1 imm19 Rt))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 22 :: int)::ii)  ::  10 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B0,B1,B0,B1,B0,B0]  ::  10 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 20 :: int)::ii) (( 19 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     (let (L :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 :: int)::ii)]  ::  1 Word.word)) in
     (let (op0 :: 2 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 19 :: int)::ii)  ::  2 Word.word)) in
     (let (op1 :: 3 bits) = ((subrange_vec_dec op_code (( 18 :: int)::ii) (( 16 :: int)::ii)  ::  3 Word.word)) in
     (let (CRn :: 4 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) in
     (let (CRm :: 4 bits) = ((subrange_vec_dec op_code (( 11 :: int)::ii) (( 8 :: int)::ii)  ::  4 Word.word)) in
     (let (op2 :: 3 bits) = ((subrange_vec_dec op_code (( 7 :: int)::ii) (( 5 :: int)::ii)  ::  3 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     system_sysops_decode L op0 op1 CRn CRm op2 Rt)))))))
   else if ((((((((subrange_vec_dec op_code (( 28 :: int)::ii) (( 24 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1]  ::  5 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word))))))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (op1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (shift :: 2 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 22 :: int)::ii)  ::  2 Word.word)) in
     (let (Rm :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (imm6 :: 6 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_arithmetic_addsub_shiftedreg_decode sf op1 S shift Rm imm6 Rn Rd))))))))
   else if (((((subrange_vec_dec op_code (( 28 :: int)::ii) (( 23 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B1,B0,B0]  ::  6 Word.word)))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (opc :: 2 bits) = ((subrange_vec_dec op_code (( 30 :: int)::ii) (( 29 :: int)::ii)  ::  2 Word.word)) in
     (let (N :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 :: int)::ii)]  ::  1 Word.word)) in
     (let (immr :: 6 bits) = ((subrange_vec_dec op_code (( 21 :: int)::ii) (( 16 :: int)::ii)  ::  6 Word.word)) in
     (let (imms :: 6 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_logical_immediate_decode sf opc N immr imms Rn Rd)))))))
   else if ((((((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 21 :: int)::ii)  ::  9 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B1,B0,B0,B1,B0]  ::  9 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))))))))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (op1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rm :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cond :: 4 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) in
     (let (o2 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 10 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (o3 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 4 :: int)::ii)]  ::  1 Word.word)) in
     (let (nzcv :: 4 bits) = ((subrange_vec_dec op_code (( 3 :: int)::ii) (( 0 :: int)::ii)  ::  4 Word.word)) in
     integer_conditional_compare_register_decode sf op1 S Rm cond o2 Rn o3 nzcv)))))))))
   else if (((((subrange_vec_dec op_code (( 28 :: int)::ii) (( 23 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B1,B1,B0]  ::  6 Word.word)))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (opc :: 2 bits) = ((subrange_vec_dec op_code (( 30 :: int)::ii) (( 29 :: int)::ii)  ::  2 Word.word)) in
     (let (N :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 :: int)::ii)]  ::  1 Word.word)) in
     (let (immr :: 6 bits) = ((subrange_vec_dec op_code (( 21 :: int)::ii) (( 16 :: int)::ii)  ::  6 Word.word)) in
     (let (imms :: 6 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_bitfield_decode sf opc N immr imms Rn Rd)))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 22 :: int)::ii)  ::  10 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B0,B1,B0,B1,B0,B0]  ::  10 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 20 :: int)::ii) (( 20 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B1]  ::  1 Word.word))))))) then
     (let (L :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 :: int)::ii)]  ::  1 Word.word)) in
     (let (o0 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 19 :: int)::ii)]  ::  1 Word.word)) in
     (let (op1 :: 3 bits) = ((subrange_vec_dec op_code (( 18 :: int)::ii) (( 16 :: int)::ii)  ::  3 Word.word)) in
     (let (CRn :: 4 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) in
     (let (CRm :: 4 bits) = ((subrange_vec_dec op_code (( 11 :: int)::ii) (( 8 :: int)::ii)  ::  4 Word.word)) in
     (let (op2 :: 3 bits) = ((subrange_vec_dec op_code (( 7 :: int)::ii) (( 5 :: int)::ii)  ::  3 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     system_register_system_decode L o0 op1 CRn CRm op2 Rt)))))))
   else if ((((((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 21 :: int)::ii)  ::  9 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B1,B0,B0,B1,B0]  ::  9 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))))))))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (op1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (imm5 :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cond :: 4 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) in
     (let (o2 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 10 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (o3 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 4 :: int)::ii)]  ::  1 Word.word)) in
     (let (nzcv :: 4 bits) = ((subrange_vec_dec op_code (( 3 :: int)::ii) (( 0 :: int)::ii)  ::  4 Word.word)) in
     integer_conditional_compare_immediate_decode sf op1 S imm5 cond o2 Rn o3 nzcv)))))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B1,B1,B1,B0]  ::  8 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B1,B0]  ::  6 Word.word)))))))))) then
     (let (M :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (typ1 :: 2 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 22 :: int)::ii)  ::  2 Word.word)) in
     (let (Rm :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     float_arithmetic_div_decode M S typ1 Rm Rn Rd))))))
   else if ((((((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 24 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B0,B0]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B0,B0,B0]  ::  6 Word.word)))))))))) then
     (let (size1 :: 2 bits) = ((subrange_vec_dec op_code (( 31 :: int)::ii) (( 30 :: int)::ii)  ::  2 Word.word)) in
     (let (V1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 :: int)::ii)]  ::  1 Word.word)) in
     (let (A :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 23 :: int)::ii)]  ::  1 Word.word)) in
     (let (R1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rs :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (o3 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 15 :: int)::ii)]  ::  1 Word.word)) in
     (let (opc :: 3 bits) = ((subrange_vec_dec op_code (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_atomicops_swp_decode size1 V1 A R1 Rs o3 opc Rn Rt)))))))))
   else if (((((subrange_vec_dec op_code (( 28 :: int)::ii) (( 24 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B1,B0,B0,B0,B1]  ::  5 Word.word)))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (op1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (shift :: 2 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 22 :: int)::ii)  ::  2 Word.word)) in
     (let (imm12 :: 12 bits) = ((subrange_vec_dec op_code (( 21 :: int)::ii) (( 10 :: int)::ii)  ::  12 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_arithmetic_addsub_immediate_decode sf op1 S shift imm12 Rn Rd)))))))
   else if (((((subrange_vec_dec op_code (( 30 :: int)::ii) (( 26 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B1]  ::  5 Word.word)))) then
     (let (op1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (imm26 :: 26 bits) = ((subrange_vec_dec op_code (( 25 :: int)::ii) (( 0 :: int)::ii)  ::  26 Word.word)) in
     branch_unconditional_immediate_decode op1 imm26))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 14 :: int)::ii)  ::  18 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B1,B0,B1,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B0]
                     ::  18 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 12 :: int)::ii) (( 10 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B0]  ::  3 Word.word))))))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (opcode2 :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (Z :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 13 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_pac_autda_dp_1src_decode sf S opcode2 Z Rn Rd))))))
   else if (((((subrange_vec_dec op_code (( 30 :: int)::ii) (( 11 :: int)::ii)  ::  20 Word.word)) = (vec_of_bits [B1,B0,B1,B1,B0,B1,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0]
                 ::  20 Word.word)))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (opcode2 :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (op1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 10 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_arithmetic_cnt_decode sf S opcode2 op1 Rn Rd))))))
   else if ((((((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 27 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 25 :: int)::ii) (( 24 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B1,B1,B1,B1,B1]  ::  5 Word.word)))))))))))))))) then
     (let (size1 :: 2 bits) = ((subrange_vec_dec op_code (( 31 :: int)::ii) (( 30 :: int)::ii)  ::  2 Word.word)) in
     (let (V1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 :: int)::ii)]  ::  1 Word.word)) in
     (let (A :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 23 :: int)::ii)]  ::  1 Word.word)) in
     (let (R1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rs :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (o3 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 15 :: int)::ii)]  ::  1 Word.word)) in
     (let (opc :: 3 bits) = ((subrange_vec_dec op_code (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_atomicops_st_decode size1 V1 A R1 Rs o3 opc Rn Rt)))))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 12 :: int)::ii)  ::  20 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B0,B1,B0,B1,B0,B0,B0,B0,B0,B0,B1,B1,B0,B0,B1,B1]
                     ::  20 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B1,B1,B1,B1,B1]  ::  5 Word.word)))))))))) then
     (let (L :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 :: int)::ii)]  ::  1 Word.word)) in
     (let (op0 :: 2 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 19 :: int)::ii)  ::  2 Word.word)) in
     (let (op1 :: 3 bits) = ((subrange_vec_dec op_code (( 18 :: int)::ii) (( 16 :: int)::ii)  ::  3 Word.word)) in
     (let (CRn :: 4 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) in
     (let (CRm :: 4 bits) = ((subrange_vec_dec op_code (( 11 :: int)::ii) (( 8 :: int)::ii)  ::  4 Word.word)) in
     (let (opc :: 2 bits) = ((subrange_vec_dec op_code (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     system_barriers_decode L op0 op1 CRn CRm opc Rt)))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 31 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 23 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B1]  ::  1 Word.word)))))))))) then
     (let (sz :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 :: int)::ii)]  ::  1 Word.word)) in
     (let (o2 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 23 :: int)::ii)]  ::  1 Word.word)) in
     (let (L :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 :: int)::ii)]  ::  1 Word.word)) in
     (let (o1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rs :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (o0 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 15 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rt2 :: 5 bits) = ((subrange_vec_dec op_code (( 14 :: int)::ii) (( 10 :: int)::ii)  ::  5 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_atomicops_cas_pair_decode sz o2 L o1 Rs o0 Rt2 Rn Rt)))))))))
   else if (((((subrange_vec_dec op_code (( 28 :: int)::ii) (( 23 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B1,B0,B1]  ::  6 Word.word)))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (opc :: 2 bits) = ((subrange_vec_dec op_code (( 30 :: int)::ii) (( 29 :: int)::ii)  ::  2 Word.word)) in
     (let (hw :: 2 bits) = ((subrange_vec_dec op_code (( 22 :: int)::ii) (( 21 :: int)::ii)  ::  2 Word.word)) in
     (let (imm16 :: 16 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 5 :: int)::ii)  ::  16 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_insext_insert_movewide_decode sf opc hw imm16 Rd)))))
   else if (((op_code = (vec_of_bits [B1,B1,B0,B1,B0,B1,B1,B0,B1,B0,B1,B1,B1,B1,B1,B1,B0,B0,B0,B0,B0,B0,B1,B1,
                             B1,B1,B1,B0,B0,B0,B0,B0]
                 ::  32 Word.word)))) then
     (let (opc :: 4 bits) = ((subrange_vec_dec op_code (( 24 :: int)::ii) (( 21 :: int)::ii)  ::  4 Word.word)) in
     (let (op2 :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (op3 :: 6 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (op4 :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     branch_unconditional_dret_decode opc op2 op3 Rt op4)))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B1,B1,B1,B0]  ::  8 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B1]  ::  2 Word.word)))))))))) then
     (let (M :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (typ1 :: 2 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 22 :: int)::ii)  ::  2 Word.word)) in
     (let (Rm :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cond :: 4 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     float_move_fp_select_decode M S typ1 Rm cond Rn Rd)))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B0,B1,B0,B0,B1,B0,B1]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
     (let (opc :: 3 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 21 :: int)::ii)  ::  3 Word.word)) in
     (let (imm16 :: 16 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 5 :: int)::ii)  ::  16 Word.word)) in
     (let (op2 :: 3 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     (let (LL :: 2 bits) = ((subrange_vec_dec op_code (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) in
     system_exceptions_debug_exception_decode opc imm16 op2 LL))))
   else if (((((subrange_vec_dec op_code (( 30 :: int)::ii) (( 12 :: int)::ii)  ::  19 Word.word)) = (vec_of_bits [B1,B0,B1,B1,B0,B1,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  19 Word.word))))
   then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (opcode2 :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (opc :: 2 bits) = ((subrange_vec_dec op_code (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_arithmetic_rev_decode sf S opcode2 opc Rn Rd))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B1,B1,B1,B0]  ::  8 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 17 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B1,B0,B0,B0,B1]  ::  5 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 14 :: int)::ii) (( 10 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B1,B0,B0,B0,B0]  ::  5 Word.word)))))))))) then
     (let (M :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (typ1 :: 2 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 22 :: int)::ii)  ::  2 Word.word)) in
     (let (opc :: 2 bits) = ((subrange_vec_dec op_code (( 16 :: int)::ii) (( 15 :: int)::ii)  ::  2 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     float_convert_fp_decode M S typ1 opc Rn Rd))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 14 :: int)::ii)  ::  18 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B1,B0,B1,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B0]
                     ::  18 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 12 :: int)::ii) (( 10 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (opcode2 :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (Z :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 13 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_pac_pacia_dp_1src_decode sf S opcode2 Z Rn Rd))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 12 :: int)::ii)  ::  20 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B0,B1,B0,B1,B0,B0,B0,B0,B0,B0,B1,B1,B0,B0,B1,B0]
                     ::  20 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B1,B1,B1,B1,B1]  ::  5 Word.word))))))) then
     (let (L :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 :: int)::ii)]  ::  1 Word.word)) in
     (let (op0 :: 2 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 19 :: int)::ii)  ::  2 Word.word)) in
     (let (op1 :: 3 bits) = ((subrange_vec_dec op_code (( 18 :: int)::ii) (( 16 :: int)::ii)  ::  3 Word.word)) in
     (let (CRn :: 4 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) in
     (let (CRm :: 4 bits) = ((subrange_vec_dec op_code (( 11 :: int)::ii) (( 8 :: int)::ii)  ::  4 Word.word)) in
     (let (op2 :: 3 bits) = ((subrange_vec_dec op_code (( 7 :: int)::ii) (( 5 :: int)::ii)  ::  3 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_pac_pacia_hint_decode L op0 op1 CRn CRm op2 Rt)))))))
   else if ((((((((subrange_vec_dec op_code (( 30 :: int)::ii) (( 24 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B1,B1,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))))))))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (typ1 :: 2 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 22 :: int)::ii)  ::  2 Word.word)) in
     (let (rmode :: 2 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 19 :: int)::ii)  ::  2 Word.word)) in
     (let (opcode :: 3 bits) = ((subrange_vec_dec op_code (( 18 :: int)::ii) (( 16 :: int)::ii)  ::  3 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     float_convert_int_decode sf S typ1 rmode opcode Rn Rd)))))))
   else if ((((((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 21 :: int)::ii)  ::  9 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B1,B0,B1,B0,B0]  ::  9 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 11 :: int)::ii) (( 11 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word))))))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (op1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rm :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cond :: 4 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) in
     (let (o2 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 10 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_conditional_select_decode sf op1 S Rm cond o2 Rn Rd))))))))
   else if ((((((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 21 :: int)::ii)  ::  9 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B0,B0,B1,B0,B1]  ::  9 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B0,B0,B0,B0]  ::  6 Word.word))))))) then
     (let (size1 :: 2 bits) = ((subrange_vec_dec op_code (( 31 :: int)::ii) (( 30 :: int)::ii)  ::  2 Word.word)) in
     (let (V1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 :: int)::ii)]  ::  1 Word.word)) in
     (let (A :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 23 :: int)::ii)]  ::  1 Word.word)) in
     (let (R1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rs :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (o3 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 15 :: int)::ii)]  ::  1 Word.word)) in
     (let (opc :: 3 bits) = ((subrange_vec_dec op_code (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_orderedrcpc_decode size1 V1 A R1 Rs o3 opc Rn Rt)))))))))
   else if (((((subrange_vec_dec op_code (( 28 :: int)::ii) (( 21 :: int)::ii)  ::  8 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B0,B0,B1]  ::  8 Word.word)))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (op1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (opt :: 2 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 22 :: int)::ii)  ::  2 Word.word)) in
     (let (Rm :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (option_name :: 3 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) in
     (let (imm3 :: 3 bits) = ((subrange_vec_dec op_code (( 12 :: int)::ii) (( 10 :: int)::ii)  ::  3 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_arithmetic_addsub_extendedreg_decode sf op1 S opt Rm option_name imm3 Rn Rd)))))))))
   else if (((((subrange_vec_dec op_code (( 28 :: int)::ii) (( 24 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B1,B0,B0,B0,B0]  ::  5 Word.word)))) then
     (let (op1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (immlo :: 2 bits) = ((subrange_vec_dec op_code (( 30 :: int)::ii) (( 29 :: int)::ii)  ::  2 Word.word)) in
     (let (immhi :: 19 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 5 :: int)::ii)  ::  19 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_arithmetic_address_pcrel_decode op1 immlo immhi Rd))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 31 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 23 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0]  ::  7 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)))))))))) then
     (let (Q :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 :: int)::ii)]  ::  1 Word.word)) in
     (let (L :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 :: int)::ii)]  ::  1 Word.word)) in
     (let (R1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 :: int)::ii)]  ::  1 Word.word)) in
     (let (opcode :: 3 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 12 :: int)::ii)]  ::  1 Word.word)) in
     (let (size1 :: 2 bits) = ((subrange_vec_dec op_code (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_vector_single_nowb_aarch64_memory_vector_single_nowb__decode Q L R1 opcode S size1 Rn Rt))))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 31 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 23 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B1,B1]  ::  7 Word.word))))))) then
     (let (Q :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 :: int)::ii)]  ::  1 Word.word)) in
     (let (L :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 :: int)::ii)]  ::  1 Word.word)) in
     (let (R1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rm :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (opcode :: 3 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 12 :: int)::ii)]  ::  1 Word.word)) in
     (let (size1 :: 2 bits) = ((subrange_vec_dec op_code (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_vector_single_postinc_aarch64_memory_vector_single_nowb__decode Q L R1 Rm opcode S size1
       Rn Rt)))))))))
   else if ((((((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 24 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B0,B0]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 10 :: int)::ii) (( 10 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B1]  ::  1 Word.word)))))))))) then
     (let (size1 :: 2 bits) = ((subrange_vec_dec op_code (( 31 :: int)::ii) (( 30 :: int)::ii)  ::  2 Word.word)) in
     (let (V1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 :: int)::ii)]  ::  1 Word.word)) in
     (let (M :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 23 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 :: int)::ii)]  ::  1 Word.word)) in
     (let (imm9 :: 9 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 12 :: int)::ii)  ::  9 Word.word)) in
     (let (W :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 11 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_single_general_immediate_signed_pac_decode size1 V1 M S imm9 W Rn Rt))))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 14 :: int)::ii)  ::  18 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B1,B0,B1,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B0]
                     ::  18 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 12 :: int)::ii) (( 10 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word))))))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (opcode2 :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (Z :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 13 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_pac_autib_dp_1src_decode sf S opcode2 Z Rn Rd))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 12 :: int)::ii)  ::  20 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B0,B1,B0,B1,B0,B0,B0,B0,B0,B0,B1,B1,B0,B0,B1,B0]
                     ::  20 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B1,B1,B1,B1,B1]  ::  5 Word.word))))))) then
     (let (L :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 :: int)::ii)]  ::  1 Word.word)) in
     (let (op0 :: 2 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 19 :: int)::ii)  ::  2 Word.word)) in
     (let (op1 :: 3 bits) = ((subrange_vec_dec op_code (( 18 :: int)::ii) (( 16 :: int)::ii)  ::  3 Word.word)) in
     (let (CRn :: 4 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) in
     (let (CRm :: 4 bits) = ((subrange_vec_dec op_code (( 11 :: int)::ii) (( 8 :: int)::ii)  ::  4 Word.word)) in
     (let (op2 :: 3 bits) = ((subrange_vec_dec op_code (( 7 :: int)::ii) (( 5 :: int)::ii)  ::  3 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_pac_autib_hint_decode L op0 op1 CRn CRm op2 Rt)))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B1,B1,B1,B0]  ::  8 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     (let (M :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (typ1 :: 2 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 22 :: int)::ii)  ::  2 Word.word)) in
     (let (Rm :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cond :: 4 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (op1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 4 :: int)::ii)]  ::  1 Word.word)) in
     (let (nzcv :: 4 bits) = ((subrange_vec_dec op_code (( 3 :: int)::ii) (( 0 :: int)::ii)  ::  4 Word.word)) in
     float_compare_cond_decode M S typ1 Rm cond Rn op1 nzcv))))))))
   else if ((((((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 23 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word))))))) then
     (let (size1 :: 2 bits) = ((subrange_vec_dec op_code (( 31 :: int)::ii) (( 30 :: int)::ii)  ::  2 Word.word)) in
     (let (o2 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 23 :: int)::ii)]  ::  1 Word.word)) in
     (let (L :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 :: int)::ii)]  ::  1 Word.word)) in
     (let (o1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rs :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (o0 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 15 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rt2 :: 5 bits) = ((subrange_vec_dec op_code (( 14 :: int)::ii) (( 10 :: int)::ii)  ::  5 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_exclusive_single_decode size1 o2 L o1 Rs o0 Rt2 Rn Rt)))))))))
   else if ((((((((subrange_vec_dec op_code (( 30 :: int)::ii) (( 24 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B1,B1,B0]  ::  7 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word))))))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (typ1 :: 2 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 22 :: int)::ii)  ::  2 Word.word)) in
     (let (rmode :: 2 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 19 :: int)::ii)  ::  2 Word.word)) in
     (let (opcode :: 3 bits) = ((subrange_vec_dec op_code (( 18 :: int)::ii) (( 16 :: int)::ii)  ::  3 Word.word)) in
     (let (scale :: 6 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     float_convert_fix_decode sf S typ1 rmode opcode scale Rn Rd))))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B1,B1,B1,B0]  ::  8 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 18 :: int)::ii)  ::  4 Word.word)) = (vec_of_bits [B1,B0,B0,B1]  ::  4 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 14 :: int)::ii) (( 10 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B1,B0,B0,B0,B0]  ::  5 Word.word)))))))))) then
     (let (M :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (typ1 :: 2 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 22 :: int)::ii)  ::  2 Word.word)) in
     (let (rmode :: 3 bits) = ((subrange_vec_dec op_code (( 17 :: int)::ii) (( 15 :: int)::ii)  ::  3 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     float_arithmetic_round_decode M S typ1 rmode Rn Rd))))))
   else if (((((subrange_vec_dec op_code (( 28 :: int)::ii) (( 24 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B0]  ::  5 Word.word)))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (opc :: 2 bits) = ((subrange_vec_dec op_code (( 30 :: int)::ii) (( 29 :: int)::ii)  ::  2 Word.word)) in
     (let (shift :: 2 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 22 :: int)::ii)  ::  2 Word.word)) in
     (let (N :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rm :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (imm6 :: 6 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_logical_shiftedreg_decode sf opc shift N Rm imm6 Rn Rd))))))))
   else if ((((((((subrange_vec_dec op_code (( 30 :: int)::ii) (( 21 :: int)::ii)  ::  10 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B1,B1,B0]  ::  10 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word))))))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (op1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rm :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (opcode2 :: 3 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) in
     (let (C :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 12 :: int)::ii)]  ::  1 Word.word)) in
     (let (sz :: 2 bits) = ((subrange_vec_dec op_code (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_crc_decode sf op1 S Rm opcode2 C sz Rn Rd)))))))))
   else if ((((((((subrange_vec_dec op_code (( 28 :: int)::ii) (( 21 :: int)::ii)  ::  8 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B0,B0,B0,B0]  ::  8 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word))))))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (op1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rm :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (opcode2 :: 6 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_arithmetic_addsub_carry_decode sf op1 S Rm opcode2 Rn Rd)))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B1,B1,B1,B0]  ::  8 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))))))))) then
     (let (M :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (typ1 :: 2 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 22 :: int)::ii)  ::  2 Word.word)) in
     (let (Rm :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (op1 :: 2 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 14 :: int)::ii)  ::  2 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (opc :: 2 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
     float_compare_uncond_decode M S typ1 Rm op1 Rn opc)))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 12 :: int)::ii)  ::  20 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B0,B1,B0,B1,B0,B0,B0,B0,B0,B0,B1,B1,B0,B0,B1,B0]
                     ::  20 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B1,B1,B1,B1,B1]  ::  5 Word.word))))))) then
     (let (L :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 :: int)::ii)]  ::  1 Word.word)) in
     (let (op0 :: 2 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 19 :: int)::ii)  ::  2 Word.word)) in
     (let (op1 :: 3 bits) = ((subrange_vec_dec op_code (( 18 :: int)::ii) (( 16 :: int)::ii)  ::  3 Word.word)) in
     (let (CRn :: 4 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) in
     (let (CRm :: 4 bits) = ((subrange_vec_dec op_code (( 11 :: int)::ii) (( 8 :: int)::ii)  ::  4 Word.word)) in
     (let (op2 :: 3 bits) = ((subrange_vec_dec op_code (( 7 :: int)::ii) (( 5 :: int)::ii)  ::  3 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     system_hints_decode L op0 op1 CRn CRm op2 Rt)))))))
   else if ((((((((subrange_vec_dec op_code (( 30 :: int)::ii) (( 21 :: int)::ii)  ::  10 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B1,B1,B0]  ::  10 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) = (vec_of_bits [B0,B0,B1,B0]  ::  4 Word.word))))))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (op1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rm :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (opcode2 :: 4 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) in
     (let (op2 :: 2 bits) = ((subrange_vec_dec op_code (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_shift_variable_decode sf op1 S Rm opcode2 op2 Rn Rd))))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 14 :: int)::ii)  ::  18 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B1,B0,B1,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B0]
                     ::  18 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 12 :: int)::ii) (( 10 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word))))))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (opcode2 :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (Z :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 13 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_pac_pacdb_dp_1src_decode sf S opcode2 Z Rn Rd))))))
   else if ((((((((subrange_vec_dec op_code (( 29 :: int)::ii) (( 24 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B0,B0]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     (let (size1 :: 2 bits) = ((subrange_vec_dec op_code (( 31 :: int)::ii) (( 30 :: int)::ii)  ::  2 Word.word)) in
     (let (V1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 26 :: int)::ii)]  ::  1 Word.word)) in
     (let (opc :: 2 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 22 :: int)::ii)  ::  2 Word.word)) in
     (let (imm9 :: 9 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 12 :: int)::ii)  ::  9 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rt :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     memory_single_general_immediate_signed_offset_unpriv_aarch64_memory_single_general_immediate_signed_offset_unpriv__decode
       size1 V1 opc imm9 Rn Rt))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B1,B1,B1,B0]  ::  8 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B1]  ::  1 Word.word)))) \<and> ((((((((subrange_vec_dec op_code (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word))))))))))))) then
     (let (M :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (typ1 :: 2 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 22 :: int)::ii)  ::  2 Word.word)) in
     (let (Rm :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (op1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 12 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     float_arithmetic_addsub_decode M S typ1 Rm op1 Rn Rd)))))))
   else if ((((((((subrange_vec_dec op_code (( 30 :: int)::ii) (( 23 :: int)::ii)  ::  8 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B0,B1,B1,B1]  ::  8 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word))))))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (op21 :: 2 bits) = ((subrange_vec_dec op_code (( 30 :: int)::ii) (( 29 :: int)::ii)  ::  2 Word.word)) in
     (let (N :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 22 :: int)::ii)]  ::  1 Word.word)) in
     (let (o0 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 21 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rm :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (imms :: 6 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_insext_extract_immediate_decode sf op21 N o0 Rm imms Rn Rd))))))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B0,B1,B0,B0,B0,B1,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word))))))) then
     (let (opc :: 3 bits) = ((subrange_vec_dec op_code (( 23 :: int)::ii) (( 21 :: int)::ii)  ::  3 Word.word)) in
     (let (imm16 :: 16 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 5 :: int)::ii)  ::  16 Word.word)) in
     (let (op2 :: 3 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     (let (LL :: 2 bits) = ((subrange_vec_dec op_code (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) in
     system_exceptions_debug_halt_decode opc imm16 op2 LL))))
   else if ((((((((subrange_vec_dec op_code (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word)) = (vec_of_bits [B1,B0,B0,B1,B1,B0,B1,B1]  ::  8 Word.word)))) \<and> (((((subrange_vec_dec op_code (( 22 :: int)::ii) (( 21 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (op54 :: 2 bits) = ((subrange_vec_dec op_code (( 30 :: int)::ii) (( 29 :: int)::ii)  ::  2 Word.word)) in
     (let (U :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 23 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rm :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (o0 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 15 :: int)::ii)]  ::  1 Word.word)) in
     (let (Ra :: 5 bits) = ((subrange_vec_dec op_code (( 14 :: int)::ii) (( 10 :: int)::ii)  ::  5 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_arithmetic_mul_widening_3264_decode sf op54 U Rm o0 Ra Rn Rd))))))))
   else
     (let (sf :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 31 :: int)::ii)]  ::  1 Word.word)) in
     (let (op1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 30 :: int)::ii)]  ::  1 Word.word)) in
     (let (S :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 29 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rm :: 5 bits) = ((subrange_vec_dec op_code (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (opcode2 :: 5 bits) = ((subrange_vec_dec op_code (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (o1 :: 1 bits) = ((vec_of_bits [access_vec_dec op_code (( 10 :: int)::ii)]  ::  1 Word.word)) in
     (let (Rn :: 5 bits) = ((subrange_vec_dec op_code (( 9 :: int)::ii) (( 5 :: int)::ii)  ::  5 Word.word)) in
     (let (Rd :: 5 bits) = ((subrange_vec_dec op_code (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
     integer_arithmetic_div_decode sf op1 S Rm opcode2 o1 Rn Rd)))))))))"


(*val fetch_and_execute : unit -> M unit*)

definition fetch_and_execute  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " fetch_and_execute _ = (
   (whileM () 
     (\<lambda> unit_var .  return True)
     (\<lambda> unit_var . 
       (try_catch ((read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 :: 64 bits) . 
                  (aget_Mem w__0 (( 4 :: int)::ii) AccType_IFETCH  :: ( 32 Word.word) M) \<bind> (\<lambda> instr . 
                  decode instr))) (\<lambda>x .  
  (case  x of
      Error_Undefined _ => exit0 () 
    | Error_See s =>
  if(s = (''HINT'')) then (return () ) else (exit0 () )
    | Error_Implementation_Defined _ => exit0 () 
    | Error_ReservedEncoding _ => exit0 () 
    | Error_ExceptionTaken _ => exit0 () 
  )) \<then>
       read_reg BranchTaken_ref) \<bind> (\<lambda> (w__1 :: bool) . 
       if w__1 then write_reg BranchTaken_ref False
       else
         (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 :: 64 bits) . 
         write_reg PC_ref ((add_vec_int w__2 (( 4 :: int)::ii)  ::  64 Word.word)))))))"


(*val main : unit -> M unit*)

definition main  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " main _ = (
   (write_reg
     PC_ref
     ((GetSlice_int ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) ((elf_entry () )) (( 0 :: int)::ii)
        ::  64 Word.word)) \<then>
   (ZeroExtend__0 (vec_of_bits [B0,B0,B1,B1,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  16 Word.word)
      ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
     :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (write_reg SP_EL0_ref w__0 \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__1 :: ProcState) . 
   (write_reg PSTATE_ref (w__1 (| ProcState_D := ((vec_of_bits [B1]  ::  1 Word.word))|)) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__2 :: ProcState) . 
   (write_reg PSTATE_ref (w__2 (| ProcState_A := ((vec_of_bits [B1]  ::  1 Word.word))|)) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__3 :: ProcState) . 
   (write_reg PSTATE_ref (w__3 (| ProcState_I := ((vec_of_bits [B1]  ::  1 Word.word))|)) \<then>
   read_reg PSTATE_ref) \<bind> (\<lambda> (w__4 :: ProcState) . 
   (write_reg PSTATE_ref (w__4 (| ProcState_F := ((vec_of_bits [B1]  ::  1 Word.word))|)) \<then>
   (ZeroExtend__0 (vec_of_bits [B1,B0]  ::  2 Word.word) ((make_the_value (( 32 :: int)::ii)  ::  32 itself))
     :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__5 ::  32 Word.word) . 
   (write_reg OSLSR_EL1_ref w__5 \<then> write_reg BranchTaken_ref False) \<then> fetch_and_execute () )))))))"


(*val initialize_registers : unit -> M unit*)

definition initialize_registers  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " initialize_registers _ = (
   undefined_bool ()  \<bind> (\<lambda> (w__0 :: bool) . 
   (write_reg unconditional_ref w__0 \<then>
   (undefined_bitvector (( 4 :: int)::ii)  :: ( 4 Word.word) M)) \<bind> (\<lambda> (w__1 ::  4 Word.word) . 
   (write_reg currentCond_ref w__1 \<then>
   undefined___InstrEnc () ) \<bind> (\<lambda> (w__2 :: InstrEnc) . 
   (write_reg ThisInstrEnc_ref w__2 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__3 ::  32 Word.word) . 
   (write_reg ThisInstr_ref w__3 \<then>
   undefined_bool () ) \<bind> (\<lambda> (w__4 :: bool) . 
   (write_reg Sleeping_ref w__4 \<then>
   undefined_bool () ) \<bind> (\<lambda> (w__5 :: bool) . 
   (write_reg PendingPhysicalSError_ref w__5 \<then>
   undefined_bool () ) \<bind> (\<lambda> (w__6 :: bool) . 
   (write_reg PendingInterrupt_ref w__6 \<then>
   (undefined_bitvector (( 52 :: int)::ii)  :: ( 52 Word.word) M)) \<bind> (\<lambda> (w__7 ::  52 Word.word) . 
   (write_reg Memory_ref w__7 \<then>
   undefined_bool () ) \<bind> (\<lambda> (w__8 :: bool) . 
   (write_reg ExclusiveLocal_ref w__8 \<then>
   undefined_bool () ) \<bind> (\<lambda> (w__9 :: bool) . 
   (write_reg BranchTaken_ref w__9 \<then>
   (undefined_bitvector (( 128 :: int)::ii)  :: ( 128 Word.word) M)) \<bind> (\<lambda> (w__10 ::  128 Word.word) . 
   (undefined_vector (( 32 :: int)::ii) w__10  :: ( ( 128 Word.word)list) M) \<bind> (\<lambda> (w__11 :: ( 128 Word.word) list) . 
   (write_reg V_ref w__11 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__12 ::  64 Word.word) . 
   (undefined_vector (( 31 :: int)::ii) w__12  :: ( ( 64 Word.word)list) M) \<bind> (\<lambda> (w__13 :: ( 64 Word.word) list) . 
   (write_reg R_ref w__13 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__14 ::  64 Word.word) . 
   (write_reg PC_ref w__14 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__15 ::  64 Word.word) . 
   (write_reg VTTBR_EL2_ref w__15 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__16 ::  32 Word.word) . 
   (write_reg VTCR_EL2_ref w__16 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__17 ::  32 Word.word) . 
   (write_reg VSESR_EL2_ref w__17 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__18 ::  32 Word.word) . 
   (write_reg VDFSR_ref w__18 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__19 ::  64 Word.word) . 
   (write_reg VBAR_EL3_ref w__19 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__20 ::  64 Word.word) . 
   (write_reg VBAR_EL2_ref w__20 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__21 ::  64 Word.word) . 
   (write_reg VBAR_EL1_ref w__21 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__22 ::  32 Word.word) . 
   (write_reg VBAR_ref w__22 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__23 ::  64 Word.word) . 
   (write_reg TTBR1_EL2_ref w__23 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__24 ::  64 Word.word) . 
   (write_reg TTBR1_EL1_ref w__24 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__25 ::  64 Word.word) . 
   (write_reg TTBR0_EL3_ref w__25 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__26 ::  64 Word.word) . 
   (write_reg TTBR0_EL2_ref w__26 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__27 ::  64 Word.word) . 
   (write_reg TTBR0_EL1_ref w__27 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__28 ::  32 Word.word) . 
   (write_reg TTBCR_ref w__28 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__29 ::  32 Word.word) . 
   (write_reg TCR_EL3_ref w__29 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__30 ::  64 Word.word) . 
   (write_reg TCR_EL2_ref w__30 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__31 ::  64 Word.word) . 
   (write_reg TCR_EL1_ref w__31 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__32 ::  32 Word.word) . 
   (write_reg SP_mon_ref w__32 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__33 ::  64 Word.word) . 
   (write_reg SP_EL3_ref w__33 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__34 ::  64 Word.word) . 
   (write_reg SP_EL2_ref w__34 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__35 ::  64 Word.word) . 
   (write_reg SP_EL1_ref w__35 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__36 ::  64 Word.word) . 
   (write_reg SP_EL0_ref w__36 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__37 ::  32 Word.word) . 
   (write_reg SPSR_und_ref w__37 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__38 ::  32 Word.word) . 
   (write_reg SPSR_svc_ref w__38 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__39 ::  32 Word.word) . 
   (write_reg SPSR_mon_ref w__39 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__40 ::  32 Word.word) . 
   (write_reg SPSR_irq_ref w__40 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__41 ::  32 Word.word) . 
   (write_reg SPSR_hyp_ref w__41 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__42 ::  32 Word.word) . 
   (write_reg SPSR_fiq_ref w__42 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__43 ::  32 Word.word) . 
   (write_reg SPSR_abt_ref w__43 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__44 ::  32 Word.word) . 
   (write_reg SPSR_EL3_ref w__44 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__45 ::  32 Word.word) . 
   (write_reg SPSR_EL2_ref w__45 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__46 ::  32 Word.word) . 
   (write_reg SPSR_EL1_ref w__46 \<then>
   undefined_signal () ) \<bind> (\<lambda> (w__47 :: signal) . 
   (write_reg SPIDEN_ref w__47 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__48 ::  32 Word.word) . 
   (write_reg SDER_ref w__48 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__49 ::  32 Word.word) . 
   (write_reg SDCR_ref w__49 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__50 ::  32 Word.word) . 
   (write_reg SCTLR_EL3_ref w__50 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__51 ::  32 Word.word) . 
   (write_reg SCTLR_EL2_ref w__51 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__52 ::  32 Word.word) . 
   (write_reg SCTLR_EL1_ref w__52 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__53 ::  32 Word.word) . 
   (write_reg SCTLR_ref w__53 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__54 ::  32 Word.word) . 
   (write_reg SCR_EL3_ref w__54 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__55 ::  32 Word.word) . 
   (write_reg SCR_ref w__55 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__56 ::  64 Word.word) . 
   (write_reg RVBAR_EL3_ref w__56 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__57 ::  64 Word.word) . 
   (write_reg RVBAR_EL2_ref w__57 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__58 ::  64 Word.word) . 
   (write_reg RVBAR_EL1_ref w__58 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__59 ::  64 Word.word) . 
   (undefined_vector (( 5 :: int)::ii) w__59  :: ( ( 64 Word.word)list) M) \<bind> (\<lambda> (w__60 :: ( 64 Word.word) list) . 
   (write_reg RC_ref w__60 \<then>
   undefined_ProcState () ) \<bind> (\<lambda> (w__61 :: ProcState) . 
   (write_reg PSTATE_ref w__61 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__62 ::  32 Word.word) . 
   (write_reg OSLSR_EL1_ref w__62 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__63 ::  32 Word.word) . 
   (write_reg OSDLR_EL1_ref w__63 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__64 ::  32 Word.word) . 
   (write_reg MDSCR_EL1_ref w__64 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__65 ::  32 Word.word) . 
   (write_reg MDCR_EL3_ref w__65 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__66 ::  32 Word.word) . 
   (write_reg MDCR_EL2_ref w__66 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__67 ::  64 Word.word) . 
   (write_reg MAIR_EL3_ref w__67 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__68 ::  64 Word.word) . 
   (write_reg MAIR_EL2_ref w__68 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__69 ::  64 Word.word) . 
   (write_reg MAIR_EL1_ref w__69 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__70 ::  32 Word.word) . 
   (write_reg LR_mon_ref w__70 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__71 ::  64 Word.word) . 
   (write_reg ID_AA64DFR0_EL1_ref w__71 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__72 ::  32 Word.word) . 
   (write_reg HVBAR_ref w__72 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__73 ::  32 Word.word) . 
   (write_reg HSR_ref w__73 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__74 ::  32 Word.word) . 
   (write_reg HSCTLR_ref w__74 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__75 ::  64 Word.word) . 
   (write_reg HPFAR_EL2_ref w__75 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__76 ::  32 Word.word) . 
   (write_reg HPFAR_ref w__76 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__77 ::  32 Word.word) . 
   (write_reg HIFAR_ref w__77 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__78 ::  32 Word.word) . 
   (write_reg HDFAR_ref w__78 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__79 ::  32 Word.word) . 
   (write_reg HDCR_ref w__79 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__80 ::  64 Word.word) . 
   (write_reg HCR_EL2_ref w__80 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__81 ::  32 Word.word) . 
   (write_reg HCR2_ref w__81 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__82 ::  32 Word.word) . 
   (write_reg HCR_ref w__82 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__83 ::  32 Word.word) . 
   (write_reg FPSR_ref w__83 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__84 ::  32 Word.word) . 
   (write_reg FPSCR_ref w__84 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__85 ::  32 Word.word) . 
   (write_reg FPEXC_ref w__85 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__86 ::  32 Word.word) . 
   (write_reg FPCR_ref w__86 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__87 ::  64 Word.word) . 
   (write_reg FAR_EL3_ref w__87 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__88 ::  64 Word.word) . 
   (write_reg FAR_EL2_ref w__88 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__89 ::  64 Word.word) . 
   (write_reg FAR_EL1_ref w__89 \<then>
   (undefined_bitvector (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> (\<lambda> (w__90 ::  1 Word.word) . 
   (write_reg EventRegister_ref w__90 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__91 ::  32 Word.word) . 
   (write_reg ESR_EL3_ref w__91 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__92 ::  32 Word.word) . 
   (write_reg ESR_EL2_ref w__92 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__93 ::  32 Word.word) . 
   (write_reg ESR_EL1_ref w__93 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__94 ::  32 Word.word) . 
   (write_reg ELR_hyp_ref w__94 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__95 ::  64 Word.word) . 
   (write_reg ELR_EL3_ref w__95 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__96 ::  64 Word.word) . 
   (write_reg ELR_EL2_ref w__96 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__97 ::  64 Word.word) . 
   (write_reg ELR_EL1_ref w__97 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__98 ::  32 Word.word) . 
   (write_reg EDSCR_ref w__98 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__99 ::  32 Word.word) . 
   (write_reg DSPSR_EL0_ref w__99 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__100 ::  32 Word.word) . 
   (write_reg DSPSR_ref w__100 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__101 ::  64 Word.word) . 
   (write_reg DLR_EL0_ref w__101 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__102 ::  32 Word.word) . 
   (write_reg DLR_ref w__102 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__103 ::  64 Word.word) . 
   (undefined_vector (( 16 :: int)::ii) w__103  :: ( ( 64 Word.word)list) M) \<bind> (\<lambda> (w__104 :: ( 64 Word.word) list) . 
   (write_reg DBGWVR_EL1_ref w__104 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__105 ::  32 Word.word) . 
   (undefined_vector (( 16 :: int)::ii) w__105  :: ( ( 32 Word.word)list) M) \<bind> (\<lambda> (w__106 :: ( 32 Word.word) list) . 
   (write_reg DBGWCR_EL1_ref w__106 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__107 ::  32 Word.word) . 
   (write_reg DBGPRCR_EL1_ref w__107 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__108 ::  32 Word.word) . 
   (write_reg DBGPRCR_ref w__108 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__109 ::  32 Word.word) . 
   (write_reg DBGOSLSR_ref w__109 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__110 ::  32 Word.word) . 
   (write_reg DBGOSDLR_ref w__110 \<then>
   undefined_signal () ) \<bind> (\<lambda> (w__111 :: signal) . 
   (write_reg DBGEN_ref w__111 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__112 ::  64 Word.word) . 
   (undefined_vector (( 16 :: int)::ii) w__112  :: ( ( 64 Word.word)list) M) \<bind> (\<lambda> (w__113 :: ( 64 Word.word) list) . 
   (write_reg DBGBVR_EL1_ref w__113 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__114 ::  32 Word.word) . 
   (undefined_vector (( 16 :: int)::ii) w__114  :: ( ( 32 Word.word)list) M) \<bind> (\<lambda> (w__115 :: ( 32 Word.word) list) . 
   (write_reg DBGBCR_EL1_ref w__115 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__116 ::  32 Word.word) . 
   (write_reg CPTR_EL3_ref w__116 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__117 ::  32 Word.word) . 
   (write_reg CPTR_EL2_ref w__117 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__118 ::  32 Word.word) . 
   (write_reg CPACR_EL1_ref w__118 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__119 ::  32 Word.word) . 
   (write_reg CONTEXTIDR_EL2_ref w__119 \<then>
   (undefined_bitvector (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__120 ::  32 Word.word) . 
   (write_reg CONTEXTIDR_EL1_ref w__120 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__121 ::  64 Word.word) . 
   (write_reg APIBKeyLo_EL1_ref w__121 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__122 ::  64 Word.word) . 
   (write_reg APIBKeyHi_EL1_ref w__122 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__123 ::  64 Word.word) . 
   (write_reg APIAKeyLo_EL1_ref w__123 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__124 ::  64 Word.word) . 
   (write_reg APIAKeyHi_EL1_ref w__124 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__125 ::  64 Word.word) . 
   (write_reg APGAKeyLo_EL1_ref w__125 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__126 ::  64 Word.word) . 
   (write_reg APGAKeyHi_EL1_ref w__126 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__127 ::  64 Word.word) . 
   (write_reg APDBKeyLo_EL1_ref w__127 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__128 ::  64 Word.word) . 
   (write_reg APDBKeyHi_EL1_ref w__128 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__129 ::  64 Word.word) . 
   (write_reg APDAKeyLo_EL1_ref w__129 \<then>
   (undefined_bitvector (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__130 ::  64 Word.word) . 
   write_reg APDAKeyHi_EL1_ref w__130))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))"


definition initial_regstate  :: " regstate "  where 
     " initial_regstate = (
  (| APDAKeyHi_EL1 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     APDAKeyLo_EL1 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     APDBKeyHi_EL1 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     APDBKeyLo_EL1 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     APGAKeyHi_EL1 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     APGAKeyLo_EL1 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     APIAKeyHi_EL1 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     APIAKeyLo_EL1 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     APIBKeyHi_EL1 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     APIBKeyLo_EL1 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     CONTEXTIDR_EL1 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     CONTEXTIDR_EL2 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     CPACR_EL1 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     CPTR_EL2 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     CPTR_EL3 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     DBGBCR_EL1 =
       ([(vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word)]), 
     DBGBVR_EL1 =
       ([(vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word)]), 
     DBGEN = LOW, 
     DBGOSDLR =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     DBGOSLSR =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     DBGPRCR =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     DBGPRCR_EL1 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     DBGWCR_EL1 =
       ([(vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0]
           ::  32 Word.word)]), 
     DBGWVR_EL1 =
       ([(vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word)]), 
     DLR =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     DLR_EL0 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     DSPSR =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     DSPSR_EL0 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     EDSCR =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     ELR_EL1 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     ELR_EL2 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     ELR_EL3 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     ELR_hyp =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     ESR_EL1 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     ESR_EL2 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     ESR_EL3 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     EventRegister = ((vec_of_bits [B0]  ::  1 Word.word)), 
     FAR_EL1 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     FAR_EL2 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     FAR_EL3 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     FPCR =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     FPEXC =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     FPSCR =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     FPSR =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     HCR =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     HCR2 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     HCR_EL2 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     HDCR =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     HDFAR =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     HIFAR =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     HPFAR =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     HPFAR_EL2 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     HSCTLR =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     HSR =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     HVBAR =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     ID_AA64DFR0_EL1 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     LR_mon =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     MAIR_EL1 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     MAIR_EL2 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     MAIR_EL3 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     MDCR_EL2 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     MDCR_EL3 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     MDSCR_EL1 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     OSDLR_EL1 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     OSLSR_EL1 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     PSTATE =
       ((| ProcState_N = ((vec_of_bits [B0]  ::  1 Word.word)), 
           ProcState_Z = ((vec_of_bits [B0]  ::  1 Word.word)), 
           ProcState_C = ((vec_of_bits [B0]  ::  1 Word.word)), 
           ProcState_V = ((vec_of_bits [B0]  ::  1 Word.word)), 
           ProcState_D = ((vec_of_bits [B0]  ::  1 Word.word)), 
           ProcState_A = ((vec_of_bits [B0]  ::  1 Word.word)), 
           ProcState_I = ((vec_of_bits [B0]  ::  1 Word.word)), 
           ProcState_F = ((vec_of_bits [B0]  ::  1 Word.word)), 
           ProcState_PAN = ((vec_of_bits [B0]  ::  1 Word.word)), 
           ProcState_UAO = ((vec_of_bits [B0]  ::  1 Word.word)), 
           ProcState_SS = ((vec_of_bits [B0]  ::  1 Word.word)), 
           ProcState_IL = ((vec_of_bits [B0]  ::  1 Word.word)), 
           ProcState_EL = ((vec_of_bits [B0,B0]  ::  2 Word.word)), 
           ProcState_nRW = ((vec_of_bits [B0]  ::  1 Word.word)), 
           ProcState_SP = ((vec_of_bits [B0]  ::  1 Word.word)), 
           ProcState_Q = ((vec_of_bits [B0]  ::  1 Word.word)), 
           ProcState_GE = ((vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)), 
           ProcState_IT = ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word)), 
           ProcState_J = ((vec_of_bits [B0]  ::  1 Word.word)), 
           ProcState_T = ((vec_of_bits [B0]  ::  1 Word.word)), 
           ProcState_E = ((vec_of_bits [B0]  ::  1 Word.word)), 
           ProcState_M = ((vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)) |)), 
     RC =
       ([(vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word)]), 
     RVBAR_EL1 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     RVBAR_EL2 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     RVBAR_EL3 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     SCR =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     SCR_EL3 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     SCTLR =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     SCTLR_EL1 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     SCTLR_EL2 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     SCTLR_EL3 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     SDCR =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     SDER =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     SPIDEN = LOW, 
     SPSR_EL1 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     SPSR_EL2 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     SPSR_EL3 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     SPSR_abt =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     SPSR_fiq =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     SPSR_hyp =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     SPSR_irq =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     SPSR_mon =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     SPSR_svc =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     SPSR_und =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     SP_EL0 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     SP_EL1 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     SP_EL2 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     SP_EL3 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     SP_mon =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     TCR_EL1 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     TCR_EL2 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     TCR_EL3 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     TTBCR =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     TTBR0_EL1 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     TTBR0_EL2 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     TTBR0_EL3 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     TTBR1_EL1 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     TTBR1_EL2 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     VBAR =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     VBAR_EL1 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     VBAR_EL2 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     VBAR_EL3 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     VDFSR =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     VSESR_EL2 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     VTCR_EL2 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     VTTBR_EL2 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     PC =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     R =
       ([(vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word)]), 
     V =
       ([(vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  128 Word.word)]), 
     BranchTaken = False, 
     ExclusiveLocal = False, 
     Memory =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  52 Word.word)), 
     PendingInterrupt = False, 
     PendingPhysicalSError = False, 
     Sleeping = False, 
     ThisInstr =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     ThisInstrEnc = A64, 
     currentCond = ((vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)), 
     unconditional = False |) )"



end

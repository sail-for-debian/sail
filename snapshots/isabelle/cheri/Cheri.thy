chapter \<open>Generated by Lem from \<open>cheri.lem\<close>.\<close>

theory "Cheri" 

imports
  Main
  "LEM.Lem_pervasives_extra"
  "Sail.Sail2_instr_kinds"
  "Sail.Sail2_values"
  "Sail.Sail2_string"
  "Sail.Sail2_operators_mwords"
  "Sail.Sail2_prompt_monad"
  "Sail.Sail2_prompt"
  "Cheri_types"
  "Mips_extras"

begin 

(*Generated by Sail from cheri.*)
(*open import Pervasives_extra*)
(*open import Sail2_instr_kinds*)
(*open import Sail2_values*)
(*open import Sail2_string*)
(*open import Sail2_operators_mwords*)
(*open import Sail2_prompt_monad*)
(*open import Sail2_prompt*)
(*open import Cheri_types*)
(*open import Mips_extras*)

definition cap_size  :: " int "  where 
     " cap_size = ( (( 32 :: int)::ii))"


(*val eq_unit : unit -> unit -> bool*)

definition eq_unit  :: " unit \<Rightarrow> unit \<Rightarrow> bool "  where 
     " eq_unit g__20 g__21 = ( True )"








(*val neq_bool : bool -> bool -> bool*)

definition neq_bool  :: " bool \<Rightarrow> bool \<Rightarrow> bool "  where 
     " neq_bool x y = ( \<not> (((x = y))))"


(*val undefined_option : forall 'a. 'a -> M (maybe 'a)*)

definition undefined_option  :: " 'a \<Rightarrow>((register_value),('a option),(exception))monad "  where 
     " undefined_option typ_a = (
   undefined_unit ()  \<bind> (\<lambda> (u_0 :: unit) . 
   (let u_1 = typ_a in
   internal_pick [Some u_1,None])))"


(*val is_none : forall 'a. maybe 'a -> bool*)

fun is_none  :: " 'a option \<Rightarrow> bool "  where 
     " is_none (Some (_)) = ( False )"
|" is_none None = ( True )"


(*val is_some : forall 'a. maybe 'a -> bool*)

fun is_some  :: " 'a option \<Rightarrow> bool "  where 
     " is_some (Some (_)) = ( True )"
|" is_some None = ( False )"


(*val sail_mask : forall 'len 'v . Size 'len, Size 'v => itself 'len -> mword 'v -> mword 'len*)

definition sail_mask  :: "('len::len)itself \<Rightarrow>('v::len)Word.word \<Rightarrow>('len::len)Word.word "  where 
     " sail_mask len v = (
   (let len = (size_itself_int len) in
   if ((len \<le> ((int (size v))))) then (vector_truncate v len  :: ( 'len::len)Word.word)
   else (zero_extend v len  :: ( 'len::len)Word.word)))"






(*val cast_unit_vec : bitU -> mword ty1*)

fun cast_unit_vec0  :: " bitU \<Rightarrow>(1)Word.word "  where 
     " cast_unit_vec0 B0 = ( (vec_of_bits [B0]  ::  1 Word.word))"
|" cast_unit_vec0 _ = ( (vec_of_bits [B1]  ::  1 Word.word))"


(*val __MIPS_write : forall  'p8_times_n_ . Size 'p8_times_n_ => mword ty64 -> integer -> mword 'p8_times_n_ -> M unit*)

definition MIPS_write  :: "(64)Word.word \<Rightarrow> int \<Rightarrow>('p8_times_n_::len)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " MIPS_write addr width data = (
   write_ram instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii) width
     (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                   B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                   B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
       ::  64 Word.word) addr data \<then>
   return ()  )"


(*val __MIPS_read : forall   'p8_times_n_ . Size 'p8_times_n_ => mword ty64 -> integer -> M (mword 'p8_times_n_)*)

definition MIPS_read  :: "(64)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(('p8_times_n_::len)Word.word),(exception))monad "  where 
     " MIPS_read addr width = (
   (read_ram instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii) width
      (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                    B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                    B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
        ::  64 Word.word) addr
     :: (( 'p8_times_n_::len)Word.word) M))"




(*val undefined_exception : unit -> M exception*)

definition undefined_exception  :: " unit \<Rightarrow>((register_value),(exception),(exception))monad "  where 
     " undefined_exception _ = (
   undefined_string ()  \<bind> (\<lambda> (u_0 :: string) . 
   undefined_unit ()  \<bind> (\<lambda> (u_1 :: unit) . 
   internal_pick
     [ISAException u_1,Error_not_implemented u_0,Error_misaligned_access u_1,Error_EBREAK u_1,Error_internal_error u_1])))"


(*val mips_sign_extend : forall 'n 'm . Size 'm, Size 'n => integer -> mword 'n -> mword 'm*)

(*val mips_zero_extend : forall 'n 'm . Size 'm, Size 'n => integer -> mword 'n -> mword 'm*)

definition mips_sign_extend  :: " int \<Rightarrow>('n::len)Word.word \<Rightarrow>('m::len)Word.word "  where 
     " mips_sign_extend (m__tv :: int) v = ( (sign_extend v m__tv  :: ( 'm::len)Word.word))"


definition mips_zero_extend  :: " int \<Rightarrow>('n::len)Word.word \<Rightarrow>('m::len)Word.word "  where 
     " mips_zero_extend (m__tv :: int) v = ( (zero_extend v m__tv  :: ( 'm::len)Word.word))"


(*val zeros : forall 'n . Size 'n => integer -> unit -> mword 'n*)

definition zeros0  :: " int \<Rightarrow> unit \<Rightarrow>('n::len)Word.word "  where 
     " zeros0 (n__tv :: int) _ = ( (replicate_bits (vec_of_bits [B0]  ::  1 Word.word) n__tv  :: ( 'n::len)Word.word))"


(*val ones : forall 'n . Size 'n => integer -> unit -> mword 'n*)

definition ones  :: " int \<Rightarrow> unit \<Rightarrow>('n::len)Word.word "  where 
     " ones (n__tv :: int) _ = ( (replicate_bits (vec_of_bits [B1]  ::  1 Word.word) n__tv  :: ( 'n::len)Word.word))"


(*val zopz0zI_s : forall 'n . Size 'n => mword 'n -> mword 'n -> bool*)

(*val zopz0zKzJ_s : forall 'n . Size 'n => mword 'n -> mword 'n -> bool*)

(*val zopz0zI_u : forall 'n . Size 'n => mword 'n -> mword 'n -> bool*)

(*val zopz0zKzJ_u : forall 'n . Size 'n => mword 'n -> mword 'n -> bool*)

definition zopz0zI_s  :: "('n::len)Word.word \<Rightarrow>('n::len)Word.word \<Rightarrow> bool "  where 
     " zopz0zI_s x y = ( ((Word.sint x)) < ((Word.sint y)))"


definition zopz0zKzJ_s  :: "('n::len)Word.word \<Rightarrow>('n::len)Word.word \<Rightarrow> bool "  where 
     " zopz0zKzJ_s x y = ( ((Word.sint x)) \<ge> ((Word.sint y)))"


definition zopz0zI_u  :: "('n::len)Word.word \<Rightarrow>('n::len)Word.word \<Rightarrow> bool "  where 
     " zopz0zI_u x y = ( ((Word.uint x)) < ((Word.uint y)))"


definition zopz0zKzJ_u  :: "('n::len)Word.word \<Rightarrow>('n::len)Word.word \<Rightarrow> bool "  where 
     " zopz0zKzJ_u x y = ( ((Word.uint x)) \<ge> ((Word.uint y)))"


(*val bool_to_bits : bool -> mword ty1*)

definition bool_to_bits  :: " bool \<Rightarrow>(1)Word.word "  where 
     " bool_to_bits x = ( if x then (vec_of_bits [B1]  ::  1 Word.word) else (vec_of_bits [B0]  ::  1 Word.word))"


(*val bit_to_bool : bitU -> bool*)

fun bit_to_bool  :: " bitU \<Rightarrow> bool "  where 
     " bit_to_bool B1 = ( True )"
|" bit_to_bool _ = ( False )"


(*val bits_to_bool : mword ty1 -> bool*)

definition bits_to_bool  :: "(1)Word.word \<Rightarrow> bool "  where 
     " bits_to_bool x = ( bit_to_bool ((access_vec_dec x (( 0 :: int)::ii))))"


(*
function{to_bits} converts an integer to a bit vector of given length. If the integer is negative a twos-complement representation is used. If the integer is too large (or too negative) to fit in the requested length then it is truncated to the least significant bits.
*)
(*val to_bits : forall 'l . Size 'l => itself 'l -> ii -> mword 'l*)

definition to_bits  :: "('l::len)itself \<Rightarrow> int \<Rightarrow>('l::len)Word.word "  where 
     " to_bits l n = (
   (let l = (size_itself_int l) in
   (get_slice_int0 instance_Sail2_values_Bitvector_Machine_word_mword_dict l n (( 0 :: int)::ii)  :: ( 'l::len)Word.word)))"


(*val mask : forall 'm 'n . Size 'm, Size 'n => integer -> mword 'm -> mword 'n*)

definition mask0  :: " int \<Rightarrow>('m::len)Word.word \<Rightarrow>('n::len)Word.word "  where 
     " mask0 (n__tv :: int) bs = (
   (subrange_vec_dec bs ((n__tv - (( 1 :: int)::ii))) (( 0 :: int)::ii)  :: ( 'n::len)Word.word))"


(*val undefined_CauseReg : unit -> M CauseReg*)

definition undefined_CauseReg  :: " unit \<Rightarrow>((register_value),(CauseReg),(exception))monad "  where 
     " undefined_CauseReg _ = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 ::  32 Word.word) . 
   return ((| CauseReg_CauseReg_chunk_0 = w__0 |))))"


(*val Mk_CauseReg : mword ty32 -> CauseReg*)

definition Mk_CauseReg  :: "(32)Word.word \<Rightarrow> CauseReg "  where 
     " Mk_CauseReg v = (
   (| CauseReg_CauseReg_chunk_0 = ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) |) )"


(*val _get_CauseReg_bits : CauseReg -> mword ty32*)

definition get_CauseReg_bits  :: " CauseReg \<Rightarrow>(32)Word.word "  where 
     " get_CauseReg_bits v = (
   (subrange_vec_dec(CauseReg_CauseReg_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))"


(*val _set_CauseReg_bits : register_ref regstate register_value CauseReg -> mword ty32 -> M unit*)

definition set_CauseReg_bits  :: "((regstate),(register_value),(CauseReg))register_ref \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_CauseReg_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       CauseReg_CauseReg_chunk_0 :=
         ((update_subrange_vec_dec(CauseReg_CauseReg_chunk_0   r) (( 31 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_CauseReg_bits : CauseReg -> mword ty32 -> CauseReg*)

definition update_CauseReg_bits  :: " CauseReg \<Rightarrow>(32)Word.word \<Rightarrow> CauseReg "  where 
     " update_CauseReg_bits v x = (
   (v (|
     CauseReg_CauseReg_chunk_0 :=
       ((update_subrange_vec_dec(CauseReg_CauseReg_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
          ::  32 Word.word))|)))"


(*val _update_CapCauseReg_bits : CapCauseReg -> mword ty16 -> CapCauseReg*)

(*val _get_CapCauseReg_bits : CapCauseReg -> mword ty16*)

(*val _set_CapCauseReg_bits : register_ref regstate register_value CapCauseReg -> mword ty16 -> M unit*)

(*val _get_CauseReg_BD : CauseReg -> mword ty1*)

definition get_CauseReg_BD  :: " CauseReg \<Rightarrow>(1)Word.word "  where 
     " get_CauseReg_BD v = ( (subrange_vec_dec(CauseReg_CauseReg_chunk_0   v) (( 31 :: int)::ii) (( 31 :: int)::ii)  ::  1 Word.word))"


(*val _set_CauseReg_BD : register_ref regstate register_value CauseReg -> mword ty1 -> M unit*)

definition set_CauseReg_BD  :: "((regstate),(register_value),(CauseReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_CauseReg_BD r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       CauseReg_CauseReg_chunk_0 :=
         ((update_subrange_vec_dec(CauseReg_CauseReg_chunk_0   r) (( 31 :: int)::ii) (( 31 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_CauseReg_BD : CauseReg -> mword ty1 -> CauseReg*)

definition update_CauseReg_BD  :: " CauseReg \<Rightarrow>(1)Word.word \<Rightarrow> CauseReg "  where 
     " update_CauseReg_BD v x = (
   (v (|
     CauseReg_CauseReg_chunk_0 :=
       ((update_subrange_vec_dec(CauseReg_CauseReg_chunk_0   v) (( 31 :: int)::ii) (( 31 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))"


(*val _get_CauseReg_CE : CauseReg -> mword ty2*)

definition get_CauseReg_CE  :: " CauseReg \<Rightarrow>(2)Word.word "  where 
     " get_CauseReg_CE v = ( (subrange_vec_dec(CauseReg_CauseReg_chunk_0   v) (( 29 :: int)::ii) (( 28 :: int)::ii)  ::  2 Word.word))"


(*val _set_CauseReg_CE : register_ref regstate register_value CauseReg -> mword ty2 -> M unit*)

definition set_CauseReg_CE  :: "((regstate),(register_value),(CauseReg))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_CauseReg_CE r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       CauseReg_CauseReg_chunk_0 :=
         ((update_subrange_vec_dec(CauseReg_CauseReg_chunk_0   r) (( 29 :: int)::ii) (( 28 :: int)::ii)
             ((subrange_vec_dec v (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_CauseReg_CE : CauseReg -> mword ty2 -> CauseReg*)

definition update_CauseReg_CE  :: " CauseReg \<Rightarrow>(2)Word.word \<Rightarrow> CauseReg "  where 
     " update_CauseReg_CE v x = (
   (v (|
     CauseReg_CauseReg_chunk_0 :=
       ((update_subrange_vec_dec(CauseReg_CauseReg_chunk_0   v) (( 29 :: int)::ii) (( 28 :: int)::ii)
           ((subrange_vec_dec x (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
          ::  32 Word.word))|)))"


(*val _get_CauseReg_IV : CauseReg -> mword ty1*)

definition get_CauseReg_IV  :: " CauseReg \<Rightarrow>(1)Word.word "  where 
     " get_CauseReg_IV v = ( (subrange_vec_dec(CauseReg_CauseReg_chunk_0   v) (( 23 :: int)::ii) (( 23 :: int)::ii)  ::  1 Word.word))"


(*val _set_CauseReg_IV : register_ref regstate register_value CauseReg -> mword ty1 -> M unit*)

definition set_CauseReg_IV  :: "((regstate),(register_value),(CauseReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_CauseReg_IV r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       CauseReg_CauseReg_chunk_0 :=
         ((update_subrange_vec_dec(CauseReg_CauseReg_chunk_0   r) (( 23 :: int)::ii) (( 23 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_CauseReg_IV : CauseReg -> mword ty1 -> CauseReg*)

definition update_CauseReg_IV  :: " CauseReg \<Rightarrow>(1)Word.word \<Rightarrow> CauseReg "  where 
     " update_CauseReg_IV v x = (
   (v (|
     CauseReg_CauseReg_chunk_0 :=
       ((update_subrange_vec_dec(CauseReg_CauseReg_chunk_0   v) (( 23 :: int)::ii) (( 23 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))"


(*val _get_CauseReg_WP : CauseReg -> mword ty1*)

definition get_CauseReg_WP  :: " CauseReg \<Rightarrow>(1)Word.word "  where 
     " get_CauseReg_WP v = ( (subrange_vec_dec(CauseReg_CauseReg_chunk_0   v) (( 22 :: int)::ii) (( 22 :: int)::ii)  ::  1 Word.word))"


(*val _set_CauseReg_WP : register_ref regstate register_value CauseReg -> mword ty1 -> M unit*)

definition set_CauseReg_WP  :: "((regstate),(register_value),(CauseReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_CauseReg_WP r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       CauseReg_CauseReg_chunk_0 :=
         ((update_subrange_vec_dec(CauseReg_CauseReg_chunk_0   r) (( 22 :: int)::ii) (( 22 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_CauseReg_WP : CauseReg -> mword ty1 -> CauseReg*)

definition update_CauseReg_WP  :: " CauseReg \<Rightarrow>(1)Word.word \<Rightarrow> CauseReg "  where 
     " update_CauseReg_WP v x = (
   (v (|
     CauseReg_CauseReg_chunk_0 :=
       ((update_subrange_vec_dec(CauseReg_CauseReg_chunk_0   v) (( 22 :: int)::ii) (( 22 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))"


(*val _get_CauseReg_IP : CauseReg -> mword ty8*)

definition get_CauseReg_IP  :: " CauseReg \<Rightarrow>(8)Word.word "  where 
     " get_CauseReg_IP v = ( (subrange_vec_dec(CauseReg_CauseReg_chunk_0   v) (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))"


(*val _set_CauseReg_IP : register_ref regstate register_value CauseReg -> mword ty8 -> M unit*)

definition set_CauseReg_IP  :: "((regstate),(register_value),(CauseReg))register_ref \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_CauseReg_IP r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       CauseReg_CauseReg_chunk_0 :=
         ((update_subrange_vec_dec(CauseReg_CauseReg_chunk_0   r) (( 15 :: int)::ii) (( 8 :: int)::ii)
             ((subrange_vec_dec v (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_CauseReg_IP : CauseReg -> mword ty8 -> CauseReg*)

definition update_CauseReg_IP  :: " CauseReg \<Rightarrow>(8)Word.word \<Rightarrow> CauseReg "  where 
     " update_CauseReg_IP v x = (
   (v (|
     CauseReg_CauseReg_chunk_0 :=
       ((update_subrange_vec_dec(CauseReg_CauseReg_chunk_0   v) (( 15 :: int)::ii) (( 8 :: int)::ii)
           ((subrange_vec_dec x (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
          ::  32 Word.word))|)))"


(*val _get_CauseReg_ExcCode : CauseReg -> mword ty5*)

definition get_CauseReg_ExcCode  :: " CauseReg \<Rightarrow>(5)Word.word "  where 
     " get_CauseReg_ExcCode v = (
   (subrange_vec_dec(CauseReg_CauseReg_chunk_0   v) (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word))"


(*val _set_CauseReg_ExcCode : register_ref regstate register_value CauseReg -> mword ty5 -> M unit*)

definition set_CauseReg_ExcCode  :: "((regstate),(register_value),(CauseReg))register_ref \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_CauseReg_ExcCode r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       CauseReg_CauseReg_chunk_0 :=
         ((update_subrange_vec_dec(CauseReg_CauseReg_chunk_0   r) (( 6 :: int)::ii) (( 2 :: int)::ii)
             ((subrange_vec_dec v (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_CauseReg_ExcCode : CauseReg -> mword ty5 -> CauseReg*)

definition update_CauseReg_ExcCode  :: " CauseReg \<Rightarrow>(5)Word.word \<Rightarrow> CauseReg "  where 
     " update_CauseReg_ExcCode v x = (
   (v (|
     CauseReg_CauseReg_chunk_0 :=
       ((update_subrange_vec_dec(CauseReg_CauseReg_chunk_0   v) (( 6 :: int)::ii) (( 2 :: int)::ii)
           ((subrange_vec_dec x (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word))
          ::  32 Word.word))|)))"


(*val _update_CapCauseReg_ExcCode : CapCauseReg -> mword ty8 -> CapCauseReg*)

(*val _get_CapCauseReg_ExcCode : CapCauseReg -> mword ty8*)

(*val _set_CapCauseReg_ExcCode : register_ref regstate register_value CapCauseReg -> mword ty8 -> M unit*)

(*val undefined_TLBEntryLoReg : unit -> M TLBEntryLoReg*)

definition undefined_TLBEntryLoReg  :: " unit \<Rightarrow>((register_value),(TLBEntryLoReg),(exception))monad "  where 
     " undefined_TLBEntryLoReg _ = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   return ((| TLBEntryLoReg_TLBEntryLoReg_chunk_0 = w__0 |))))"


(*val Mk_TLBEntryLoReg : mword ty64 -> TLBEntryLoReg*)

definition Mk_TLBEntryLoReg  :: "(64)Word.word \<Rightarrow> TLBEntryLoReg "  where 
     " Mk_TLBEntryLoReg v = (
   (| TLBEntryLoReg_TLBEntryLoReg_chunk_0 = ((subrange_vec_dec v (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word)) |) )"


(*val _get_TLBEntryLoReg_bits : TLBEntryLoReg -> mword ty64*)

definition get_TLBEntryLoReg_bits  :: " TLBEntryLoReg \<Rightarrow>(64)Word.word "  where 
     " get_TLBEntryLoReg_bits v = (
   (subrange_vec_dec(TLBEntryLoReg_TLBEntryLoReg_chunk_0   v) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))"


(*val _set_TLBEntryLoReg_bits : register_ref regstate register_value TLBEntryLoReg -> mword ty64 -> M unit*)

definition set_TLBEntryLoReg_bits  :: "((regstate),(register_value),(TLBEntryLoReg))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_TLBEntryLoReg_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
         ((update_subrange_vec_dec(TLBEntryLoReg_TLBEntryLoReg_chunk_0   r) (( 63 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_TLBEntryLoReg_bits : TLBEntryLoReg -> mword ty64 -> TLBEntryLoReg*)

definition update_TLBEntryLoReg_bits  :: " TLBEntryLoReg \<Rightarrow>(64)Word.word \<Rightarrow> TLBEntryLoReg "  where 
     " update_TLBEntryLoReg_bits v x = (
   (v (|
     TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
       ((update_subrange_vec_dec(TLBEntryLoReg_TLBEntryLoReg_chunk_0   v) (( 63 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
          ::  64 Word.word))|)))"


(*val _get_TLBEntryLoReg_CapS : TLBEntryLoReg -> mword ty1*)

definition get_TLBEntryLoReg_CapS  :: " TLBEntryLoReg \<Rightarrow>(1)Word.word "  where 
     " get_TLBEntryLoReg_CapS v = (
   (subrange_vec_dec(TLBEntryLoReg_TLBEntryLoReg_chunk_0   v) (( 63 :: int)::ii) (( 63 :: int)::ii)  ::  1 Word.word))"


(*val _set_TLBEntryLoReg_CapS : register_ref regstate register_value TLBEntryLoReg -> mword ty1 -> M unit*)

definition set_TLBEntryLoReg_CapS  :: "((regstate),(register_value),(TLBEntryLoReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_TLBEntryLoReg_CapS r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
         ((update_subrange_vec_dec(TLBEntryLoReg_TLBEntryLoReg_chunk_0   r) (( 63 :: int)::ii) (( 63 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_TLBEntryLoReg_CapS : TLBEntryLoReg -> mword ty1 -> TLBEntryLoReg*)

definition update_TLBEntryLoReg_CapS  :: " TLBEntryLoReg \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntryLoReg "  where 
     " update_TLBEntryLoReg_CapS v x = (
   (v (|
     TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
       ((update_subrange_vec_dec(TLBEntryLoReg_TLBEntryLoReg_chunk_0   v) (( 63 :: int)::ii) (( 63 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  64 Word.word))|)))"


(*val _get_TLBEntryLoReg_CapL : TLBEntryLoReg -> mword ty1*)

definition get_TLBEntryLoReg_CapL  :: " TLBEntryLoReg \<Rightarrow>(1)Word.word "  where 
     " get_TLBEntryLoReg_CapL v = (
   (subrange_vec_dec(TLBEntryLoReg_TLBEntryLoReg_chunk_0   v) (( 62 :: int)::ii) (( 62 :: int)::ii)  ::  1 Word.word))"


(*val _set_TLBEntryLoReg_CapL : register_ref regstate register_value TLBEntryLoReg -> mword ty1 -> M unit*)

definition set_TLBEntryLoReg_CapL  :: "((regstate),(register_value),(TLBEntryLoReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_TLBEntryLoReg_CapL r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
         ((update_subrange_vec_dec(TLBEntryLoReg_TLBEntryLoReg_chunk_0   r) (( 62 :: int)::ii) (( 62 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_TLBEntryLoReg_CapL : TLBEntryLoReg -> mword ty1 -> TLBEntryLoReg*)

definition update_TLBEntryLoReg_CapL  :: " TLBEntryLoReg \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntryLoReg "  where 
     " update_TLBEntryLoReg_CapL v x = (
   (v (|
     TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
       ((update_subrange_vec_dec(TLBEntryLoReg_TLBEntryLoReg_chunk_0   v) (( 62 :: int)::ii) (( 62 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  64 Word.word))|)))"


(*val _get_TLBEntryLoReg_PFN : TLBEntryLoReg -> mword ty24*)

definition get_TLBEntryLoReg_PFN  :: " TLBEntryLoReg \<Rightarrow>(24)Word.word "  where 
     " get_TLBEntryLoReg_PFN v = (
   (subrange_vec_dec(TLBEntryLoReg_TLBEntryLoReg_chunk_0   v) (( 29 :: int)::ii) (( 6 :: int)::ii)  ::  24 Word.word))"


(*val _set_TLBEntryLoReg_PFN : register_ref regstate register_value TLBEntryLoReg -> mword ty24 -> M unit*)

definition set_TLBEntryLoReg_PFN  :: "((regstate),(register_value),(TLBEntryLoReg))register_ref \<Rightarrow>(24)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_TLBEntryLoReg_PFN r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
         ((update_subrange_vec_dec(TLBEntryLoReg_TLBEntryLoReg_chunk_0   r) (( 29 :: int)::ii) (( 6 :: int)::ii)
             ((subrange_vec_dec v (( 23 :: int)::ii) (( 0 :: int)::ii)  ::  24 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_TLBEntryLoReg_PFN : TLBEntryLoReg -> mword ty24 -> TLBEntryLoReg*)

definition update_TLBEntryLoReg_PFN  :: " TLBEntryLoReg \<Rightarrow>(24)Word.word \<Rightarrow> TLBEntryLoReg "  where 
     " update_TLBEntryLoReg_PFN v x = (
   (v (|
     TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
       ((update_subrange_vec_dec(TLBEntryLoReg_TLBEntryLoReg_chunk_0   v) (( 29 :: int)::ii) (( 6 :: int)::ii)
           ((subrange_vec_dec x (( 23 :: int)::ii) (( 0 :: int)::ii)  ::  24 Word.word))
          ::  64 Word.word))|)))"


(*val _get_TLBEntryLoReg_C : TLBEntryLoReg -> mword ty3*)

definition get_TLBEntryLoReg_C  :: " TLBEntryLoReg \<Rightarrow>(3)Word.word "  where 
     " get_TLBEntryLoReg_C v = (
   (subrange_vec_dec(TLBEntryLoReg_TLBEntryLoReg_chunk_0   v) (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word))"


(*val _set_TLBEntryLoReg_C : register_ref regstate register_value TLBEntryLoReg -> mword ty3 -> M unit*)

definition set_TLBEntryLoReg_C  :: "((regstate),(register_value),(TLBEntryLoReg))register_ref \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_TLBEntryLoReg_C r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
         ((update_subrange_vec_dec(TLBEntryLoReg_TLBEntryLoReg_chunk_0   r) (( 5 :: int)::ii) (( 3 :: int)::ii)
             ((subrange_vec_dec v (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_TLBEntryLoReg_C : TLBEntryLoReg -> mword ty3 -> TLBEntryLoReg*)

definition update_TLBEntryLoReg_C  :: " TLBEntryLoReg \<Rightarrow>(3)Word.word \<Rightarrow> TLBEntryLoReg "  where 
     " update_TLBEntryLoReg_C v x = (
   (v (|
     TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
       ((update_subrange_vec_dec(TLBEntryLoReg_TLBEntryLoReg_chunk_0   v) (( 5 :: int)::ii) (( 3 :: int)::ii)
           ((subrange_vec_dec x (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))
          ::  64 Word.word))|)))"


(*val _get_TLBEntryLoReg_D : TLBEntryLoReg -> mword ty1*)

definition get_TLBEntryLoReg_D  :: " TLBEntryLoReg \<Rightarrow>(1)Word.word "  where 
     " get_TLBEntryLoReg_D v = (
   (subrange_vec_dec(TLBEntryLoReg_TLBEntryLoReg_chunk_0   v) (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word))"


(*val _set_TLBEntryLoReg_D : register_ref regstate register_value TLBEntryLoReg -> mword ty1 -> M unit*)

definition set_TLBEntryLoReg_D  :: "((regstate),(register_value),(TLBEntryLoReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_TLBEntryLoReg_D r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
         ((update_subrange_vec_dec(TLBEntryLoReg_TLBEntryLoReg_chunk_0   r) (( 2 :: int)::ii) (( 2 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_TLBEntryLoReg_D : TLBEntryLoReg -> mword ty1 -> TLBEntryLoReg*)

definition update_TLBEntryLoReg_D  :: " TLBEntryLoReg \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntryLoReg "  where 
     " update_TLBEntryLoReg_D v x = (
   (v (|
     TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
       ((update_subrange_vec_dec(TLBEntryLoReg_TLBEntryLoReg_chunk_0   v) (( 2 :: int)::ii) (( 2 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  64 Word.word))|)))"


(*val _get_TLBEntryLoReg_V : TLBEntryLoReg -> mword ty1*)

definition get_TLBEntryLoReg_V  :: " TLBEntryLoReg \<Rightarrow>(1)Word.word "  where 
     " get_TLBEntryLoReg_V v = (
   (subrange_vec_dec(TLBEntryLoReg_TLBEntryLoReg_chunk_0   v) (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))"


(*val _set_TLBEntryLoReg_V : register_ref regstate register_value TLBEntryLoReg -> mword ty1 -> M unit*)

definition set_TLBEntryLoReg_V  :: "((regstate),(register_value),(TLBEntryLoReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_TLBEntryLoReg_V r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
         ((update_subrange_vec_dec(TLBEntryLoReg_TLBEntryLoReg_chunk_0   r) (( 1 :: int)::ii) (( 1 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_TLBEntryLoReg_V : TLBEntryLoReg -> mword ty1 -> TLBEntryLoReg*)

definition update_TLBEntryLoReg_V  :: " TLBEntryLoReg \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntryLoReg "  where 
     " update_TLBEntryLoReg_V v x = (
   (v (|
     TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
       ((update_subrange_vec_dec(TLBEntryLoReg_TLBEntryLoReg_chunk_0   v) (( 1 :: int)::ii) (( 1 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  64 Word.word))|)))"


(*val _get_TLBEntryLoReg_G : TLBEntryLoReg -> mword ty1*)

definition get_TLBEntryLoReg_G  :: " TLBEntryLoReg \<Rightarrow>(1)Word.word "  where 
     " get_TLBEntryLoReg_G v = (
   (subrange_vec_dec(TLBEntryLoReg_TLBEntryLoReg_chunk_0   v) (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))"


(*val _set_TLBEntryLoReg_G : register_ref regstate register_value TLBEntryLoReg -> mword ty1 -> M unit*)

definition set_TLBEntryLoReg_G  :: "((regstate),(register_value),(TLBEntryLoReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_TLBEntryLoReg_G r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
         ((update_subrange_vec_dec(TLBEntryLoReg_TLBEntryLoReg_chunk_0   r) (( 0 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_TLBEntryLoReg_G : TLBEntryLoReg -> mword ty1 -> TLBEntryLoReg*)

definition update_TLBEntryLoReg_G  :: " TLBEntryLoReg \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntryLoReg "  where 
     " update_TLBEntryLoReg_G v x = (
   (v (|
     TLBEntryLoReg_TLBEntryLoReg_chunk_0 :=
       ((update_subrange_vec_dec(TLBEntryLoReg_TLBEntryLoReg_chunk_0   v) (( 0 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  64 Word.word))|)))"


(*val undefined_TLBEntryHiReg : unit -> M TLBEntryHiReg*)

definition undefined_TLBEntryHiReg  :: " unit \<Rightarrow>((register_value),(TLBEntryHiReg),(exception))monad "  where 
     " undefined_TLBEntryHiReg _ = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   return ((| TLBEntryHiReg_TLBEntryHiReg_chunk_0 = w__0 |))))"


(*val Mk_TLBEntryHiReg : mword ty64 -> TLBEntryHiReg*)

definition Mk_TLBEntryHiReg  :: "(64)Word.word \<Rightarrow> TLBEntryHiReg "  where 
     " Mk_TLBEntryHiReg v = (
   (| TLBEntryHiReg_TLBEntryHiReg_chunk_0 = ((subrange_vec_dec v (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word)) |) )"


(*val _get_TLBEntryHiReg_bits : TLBEntryHiReg -> mword ty64*)

definition get_TLBEntryHiReg_bits  :: " TLBEntryHiReg \<Rightarrow>(64)Word.word "  where 
     " get_TLBEntryHiReg_bits v = (
   (subrange_vec_dec(TLBEntryHiReg_TLBEntryHiReg_chunk_0   v) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))"


(*val _set_TLBEntryHiReg_bits : register_ref regstate register_value TLBEntryHiReg -> mword ty64 -> M unit*)

definition set_TLBEntryHiReg_bits  :: "((regstate),(register_value),(TLBEntryHiReg))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_TLBEntryHiReg_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       TLBEntryHiReg_TLBEntryHiReg_chunk_0 :=
         ((update_subrange_vec_dec(TLBEntryHiReg_TLBEntryHiReg_chunk_0   r) (( 63 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_TLBEntryHiReg_bits : TLBEntryHiReg -> mword ty64 -> TLBEntryHiReg*)

definition update_TLBEntryHiReg_bits  :: " TLBEntryHiReg \<Rightarrow>(64)Word.word \<Rightarrow> TLBEntryHiReg "  where 
     " update_TLBEntryHiReg_bits v x = (
   (v (|
     TLBEntryHiReg_TLBEntryHiReg_chunk_0 :=
       ((update_subrange_vec_dec(TLBEntryHiReg_TLBEntryHiReg_chunk_0   v) (( 63 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
          ::  64 Word.word))|)))"


(*val _get_TLBEntryHiReg_R : TLBEntryHiReg -> mword ty2*)

definition get_TLBEntryHiReg_R  :: " TLBEntryHiReg \<Rightarrow>(2)Word.word "  where 
     " get_TLBEntryHiReg_R v = (
   (subrange_vec_dec(TLBEntryHiReg_TLBEntryHiReg_chunk_0   v) (( 63 :: int)::ii) (( 62 :: int)::ii)  ::  2 Word.word))"


(*val _set_TLBEntryHiReg_R : register_ref regstate register_value TLBEntryHiReg -> mword ty2 -> M unit*)

definition set_TLBEntryHiReg_R  :: "((regstate),(register_value),(TLBEntryHiReg))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_TLBEntryHiReg_R r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       TLBEntryHiReg_TLBEntryHiReg_chunk_0 :=
         ((update_subrange_vec_dec(TLBEntryHiReg_TLBEntryHiReg_chunk_0   r) (( 63 :: int)::ii) (( 62 :: int)::ii)
             ((subrange_vec_dec v (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_TLBEntryHiReg_R : TLBEntryHiReg -> mword ty2 -> TLBEntryHiReg*)

definition update_TLBEntryHiReg_R  :: " TLBEntryHiReg \<Rightarrow>(2)Word.word \<Rightarrow> TLBEntryHiReg "  where 
     " update_TLBEntryHiReg_R v x = (
   (v (|
     TLBEntryHiReg_TLBEntryHiReg_chunk_0 :=
       ((update_subrange_vec_dec(TLBEntryHiReg_TLBEntryHiReg_chunk_0   v) (( 63 :: int)::ii) (( 62 :: int)::ii)
           ((subrange_vec_dec x (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
          ::  64 Word.word))|)))"


(*val _get_TLBEntryHiReg_VPN2 : TLBEntryHiReg -> mword ty27*)

definition get_TLBEntryHiReg_VPN2  :: " TLBEntryHiReg \<Rightarrow>(27)Word.word "  where 
     " get_TLBEntryHiReg_VPN2 v = (
   (subrange_vec_dec(TLBEntryHiReg_TLBEntryHiReg_chunk_0   v) (( 39 :: int)::ii) (( 13 :: int)::ii)  ::  27 Word.word))"


(*val _set_TLBEntryHiReg_VPN2 : register_ref regstate register_value TLBEntryHiReg -> mword ty27 -> M unit*)

definition set_TLBEntryHiReg_VPN2  :: "((regstate),(register_value),(TLBEntryHiReg))register_ref \<Rightarrow>(27)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_TLBEntryHiReg_VPN2 r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       TLBEntryHiReg_TLBEntryHiReg_chunk_0 :=
         ((update_subrange_vec_dec(TLBEntryHiReg_TLBEntryHiReg_chunk_0   r) (( 39 :: int)::ii) (( 13 :: int)::ii)
             ((subrange_vec_dec v (( 26 :: int)::ii) (( 0 :: int)::ii)  ::  27 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_TLBEntryHiReg_VPN2 : TLBEntryHiReg -> mword ty27 -> TLBEntryHiReg*)

definition update_TLBEntryHiReg_VPN2  :: " TLBEntryHiReg \<Rightarrow>(27)Word.word \<Rightarrow> TLBEntryHiReg "  where 
     " update_TLBEntryHiReg_VPN2 v x = (
   (v (|
     TLBEntryHiReg_TLBEntryHiReg_chunk_0 :=
       ((update_subrange_vec_dec(TLBEntryHiReg_TLBEntryHiReg_chunk_0   v) (( 39 :: int)::ii) (( 13 :: int)::ii)
           ((subrange_vec_dec x (( 26 :: int)::ii) (( 0 :: int)::ii)  ::  27 Word.word))
          ::  64 Word.word))|)))"


(*val _get_TLBEntryHiReg_ASID : TLBEntryHiReg -> mword ty8*)

definition get_TLBEntryHiReg_ASID  :: " TLBEntryHiReg \<Rightarrow>(8)Word.word "  where 
     " get_TLBEntryHiReg_ASID v = (
   (subrange_vec_dec(TLBEntryHiReg_TLBEntryHiReg_chunk_0   v) (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))"


(*val _set_TLBEntryHiReg_ASID : register_ref regstate register_value TLBEntryHiReg -> mword ty8 -> M unit*)

definition set_TLBEntryHiReg_ASID  :: "((regstate),(register_value),(TLBEntryHiReg))register_ref \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_TLBEntryHiReg_ASID r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       TLBEntryHiReg_TLBEntryHiReg_chunk_0 :=
         ((update_subrange_vec_dec(TLBEntryHiReg_TLBEntryHiReg_chunk_0   r) (( 7 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_TLBEntryHiReg_ASID : TLBEntryHiReg -> mword ty8 -> TLBEntryHiReg*)

definition update_TLBEntryHiReg_ASID  :: " TLBEntryHiReg \<Rightarrow>(8)Word.word \<Rightarrow> TLBEntryHiReg "  where 
     " update_TLBEntryHiReg_ASID v x = (
   (v (|
     TLBEntryHiReg_TLBEntryHiReg_chunk_0 :=
       ((update_subrange_vec_dec(TLBEntryHiReg_TLBEntryHiReg_chunk_0   v) (( 7 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
          ::  64 Word.word))|)))"


(*val undefined_ContextReg : unit -> M ContextReg*)

definition undefined_ContextReg  :: " unit \<Rightarrow>((register_value),(ContextReg),(exception))monad "  where 
     " undefined_ContextReg _ = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   return ((| ContextReg_ContextReg_chunk_0 = w__0 |))))"


(*val Mk_ContextReg : mword ty64 -> ContextReg*)

definition Mk_ContextReg  :: "(64)Word.word \<Rightarrow> ContextReg "  where 
     " Mk_ContextReg v = (
   (| ContextReg_ContextReg_chunk_0 = ((subrange_vec_dec v (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word)) |) )"


(*val _get_ContextReg_bits : ContextReg -> mword ty64*)

definition get_ContextReg_bits  :: " ContextReg \<Rightarrow>(64)Word.word "  where 
     " get_ContextReg_bits v = (
   (subrange_vec_dec(ContextReg_ContextReg_chunk_0   v) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))"


(*val _set_ContextReg_bits : register_ref regstate register_value ContextReg -> mword ty64 -> M unit*)

definition set_ContextReg_bits  :: "((regstate),(register_value),(ContextReg))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_ContextReg_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       ContextReg_ContextReg_chunk_0 :=
         ((update_subrange_vec_dec(ContextReg_ContextReg_chunk_0   r) (( 63 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_ContextReg_bits : ContextReg -> mword ty64 -> ContextReg*)

definition update_ContextReg_bits  :: " ContextReg \<Rightarrow>(64)Word.word \<Rightarrow> ContextReg "  where 
     " update_ContextReg_bits v x = (
   (v (|
     ContextReg_ContextReg_chunk_0 :=
       ((update_subrange_vec_dec(ContextReg_ContextReg_chunk_0   v) (( 63 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
          ::  64 Word.word))|)))"


(*val _get_ContextReg_PTEBase : ContextReg -> mword ty41*)

definition get_ContextReg_PTEBase  :: " ContextReg \<Rightarrow>(41)Word.word "  where 
     " get_ContextReg_PTEBase v = (
   (subrange_vec_dec(ContextReg_ContextReg_chunk_0   v) (( 63 :: int)::ii) (( 23 :: int)::ii)  ::  41 Word.word))"


(*val _set_ContextReg_PTEBase : register_ref regstate register_value ContextReg -> mword ty41 -> M unit*)

definition set_ContextReg_PTEBase  :: "((regstate),(register_value),(ContextReg))register_ref \<Rightarrow>(41)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_ContextReg_PTEBase r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       ContextReg_ContextReg_chunk_0 :=
         ((update_subrange_vec_dec(ContextReg_ContextReg_chunk_0   r) (( 63 :: int)::ii) (( 23 :: int)::ii)
             ((subrange_vec_dec v (( 40 :: int)::ii) (( 0 :: int)::ii)  ::  41 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_ContextReg_PTEBase : ContextReg -> mword ty41 -> ContextReg*)

definition update_ContextReg_PTEBase  :: " ContextReg \<Rightarrow>(41)Word.word \<Rightarrow> ContextReg "  where 
     " update_ContextReg_PTEBase v x = (
   (v (|
     ContextReg_ContextReg_chunk_0 :=
       ((update_subrange_vec_dec(ContextReg_ContextReg_chunk_0   v) (( 63 :: int)::ii) (( 23 :: int)::ii)
           ((subrange_vec_dec x (( 40 :: int)::ii) (( 0 :: int)::ii)  ::  41 Word.word))
          ::  64 Word.word))|)))"


(*val _get_ContextReg_BadVPN2 : ContextReg -> mword ty19*)

definition get_ContextReg_BadVPN2  :: " ContextReg \<Rightarrow>(19)Word.word "  where 
     " get_ContextReg_BadVPN2 v = (
   (subrange_vec_dec(ContextReg_ContextReg_chunk_0   v) (( 22 :: int)::ii) (( 4 :: int)::ii)  ::  19 Word.word))"


(*val _set_ContextReg_BadVPN2 : register_ref regstate register_value ContextReg -> mword ty19 -> M unit*)

definition set_ContextReg_BadVPN2  :: "((regstate),(register_value),(ContextReg))register_ref \<Rightarrow>(19)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_ContextReg_BadVPN2 r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       ContextReg_ContextReg_chunk_0 :=
         ((update_subrange_vec_dec(ContextReg_ContextReg_chunk_0   r) (( 22 :: int)::ii) (( 4 :: int)::ii)
             ((subrange_vec_dec v (( 18 :: int)::ii) (( 0 :: int)::ii)  ::  19 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_ContextReg_BadVPN2 : ContextReg -> mword ty19 -> ContextReg*)

definition update_ContextReg_BadVPN2  :: " ContextReg \<Rightarrow>(19)Word.word \<Rightarrow> ContextReg "  where 
     " update_ContextReg_BadVPN2 v x = (
   (v (|
     ContextReg_ContextReg_chunk_0 :=
       ((update_subrange_vec_dec(ContextReg_ContextReg_chunk_0   v) (( 22 :: int)::ii) (( 4 :: int)::ii)
           ((subrange_vec_dec x (( 18 :: int)::ii) (( 0 :: int)::ii)  ::  19 Word.word))
          ::  64 Word.word))|)))"


(*val undefined_XContextReg : unit -> M XContextReg*)

definition undefined_XContextReg  :: " unit \<Rightarrow>((register_value),(XContextReg),(exception))monad "  where 
     " undefined_XContextReg _ = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   return ((| XContextReg_XContextReg_chunk_0 = w__0 |))))"


(*val Mk_XContextReg : mword ty64 -> XContextReg*)

definition Mk_XContextReg  :: "(64)Word.word \<Rightarrow> XContextReg "  where 
     " Mk_XContextReg v = (
   (| XContextReg_XContextReg_chunk_0 = ((subrange_vec_dec v (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word)) |) )"


(*val _get_XContextReg_bits : XContextReg -> mword ty64*)

definition get_XContextReg_bits  :: " XContextReg \<Rightarrow>(64)Word.word "  where 
     " get_XContextReg_bits v = (
   (subrange_vec_dec(XContextReg_XContextReg_chunk_0   v) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))"


(*val _set_XContextReg_bits : register_ref regstate register_value XContextReg -> mword ty64 -> M unit*)

definition set_XContextReg_bits  :: "((regstate),(register_value),(XContextReg))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_XContextReg_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       XContextReg_XContextReg_chunk_0 :=
         ((update_subrange_vec_dec(XContextReg_XContextReg_chunk_0   r) (( 63 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_XContextReg_bits : XContextReg -> mword ty64 -> XContextReg*)

definition update_XContextReg_bits  :: " XContextReg \<Rightarrow>(64)Word.word \<Rightarrow> XContextReg "  where 
     " update_XContextReg_bits v x = (
   (v (|
     XContextReg_XContextReg_chunk_0 :=
       ((update_subrange_vec_dec(XContextReg_XContextReg_chunk_0   v) (( 63 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
          ::  64 Word.word))|)))"


(*val _get_XContextReg_XPTEBase : XContextReg -> mword ty31*)

definition get_XContextReg_XPTEBase  :: " XContextReg \<Rightarrow>(31)Word.word "  where 
     " get_XContextReg_XPTEBase v = (
   (subrange_vec_dec(XContextReg_XContextReg_chunk_0   v) (( 63 :: int)::ii) (( 33 :: int)::ii)  ::  31 Word.word))"


(*val _set_XContextReg_XPTEBase : register_ref regstate register_value XContextReg -> mword ty31 -> M unit*)

definition set_XContextReg_XPTEBase  :: "((regstate),(register_value),(XContextReg))register_ref \<Rightarrow>(31)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_XContextReg_XPTEBase r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       XContextReg_XContextReg_chunk_0 :=
         ((update_subrange_vec_dec(XContextReg_XContextReg_chunk_0   r) (( 63 :: int)::ii) (( 33 :: int)::ii)
             ((subrange_vec_dec v (( 30 :: int)::ii) (( 0 :: int)::ii)  ::  31 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_XContextReg_XPTEBase : XContextReg -> mword ty31 -> XContextReg*)

definition update_XContextReg_XPTEBase  :: " XContextReg \<Rightarrow>(31)Word.word \<Rightarrow> XContextReg "  where 
     " update_XContextReg_XPTEBase v x = (
   (v (|
     XContextReg_XContextReg_chunk_0 :=
       ((update_subrange_vec_dec(XContextReg_XContextReg_chunk_0   v) (( 63 :: int)::ii) (( 33 :: int)::ii)
           ((subrange_vec_dec x (( 30 :: int)::ii) (( 0 :: int)::ii)  ::  31 Word.word))
          ::  64 Word.word))|)))"


(*val _get_XContextReg_XR : XContextReg -> mword ty2*)

definition get_XContextReg_XR  :: " XContextReg \<Rightarrow>(2)Word.word "  where 
     " get_XContextReg_XR v = (
   (subrange_vec_dec(XContextReg_XContextReg_chunk_0   v) (( 32 :: int)::ii) (( 31 :: int)::ii)  ::  2 Word.word))"


(*val _set_XContextReg_XR : register_ref regstate register_value XContextReg -> mword ty2 -> M unit*)

definition set_XContextReg_XR  :: "((regstate),(register_value),(XContextReg))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_XContextReg_XR r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       XContextReg_XContextReg_chunk_0 :=
         ((update_subrange_vec_dec(XContextReg_XContextReg_chunk_0   r) (( 32 :: int)::ii) (( 31 :: int)::ii)
             ((subrange_vec_dec v (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_XContextReg_XR : XContextReg -> mword ty2 -> XContextReg*)

definition update_XContextReg_XR  :: " XContextReg \<Rightarrow>(2)Word.word \<Rightarrow> XContextReg "  where 
     " update_XContextReg_XR v x = (
   (v (|
     XContextReg_XContextReg_chunk_0 :=
       ((update_subrange_vec_dec(XContextReg_XContextReg_chunk_0   v) (( 32 :: int)::ii) (( 31 :: int)::ii)
           ((subrange_vec_dec x (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
          ::  64 Word.word))|)))"


(*val _get_XContextReg_XBadVPN2 : XContextReg -> mword ty27*)

definition get_XContextReg_XBadVPN2  :: " XContextReg \<Rightarrow>(27)Word.word "  where 
     " get_XContextReg_XBadVPN2 v = (
   (subrange_vec_dec(XContextReg_XContextReg_chunk_0   v) (( 30 :: int)::ii) (( 4 :: int)::ii)  ::  27 Word.word))"


(*val _set_XContextReg_XBadVPN2 : register_ref regstate register_value XContextReg -> mword ty27 -> M unit*)

definition set_XContextReg_XBadVPN2  :: "((regstate),(register_value),(XContextReg))register_ref \<Rightarrow>(27)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_XContextReg_XBadVPN2 r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       XContextReg_XContextReg_chunk_0 :=
         ((update_subrange_vec_dec(XContextReg_XContextReg_chunk_0   r) (( 30 :: int)::ii) (( 4 :: int)::ii)
             ((subrange_vec_dec v (( 26 :: int)::ii) (( 0 :: int)::ii)  ::  27 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_XContextReg_XBadVPN2 : XContextReg -> mword ty27 -> XContextReg*)

definition update_XContextReg_XBadVPN2  :: " XContextReg \<Rightarrow>(27)Word.word \<Rightarrow> XContextReg "  where 
     " update_XContextReg_XBadVPN2 v x = (
   (v (|
     XContextReg_XContextReg_chunk_0 :=
       ((update_subrange_vec_dec(XContextReg_XContextReg_chunk_0   v) (( 30 :: int)::ii) (( 4 :: int)::ii)
           ((subrange_vec_dec x (( 26 :: int)::ii) (( 0 :: int)::ii)  ::  27 Word.word))
          ::  64 Word.word))|)))"


definition TLBNumEntries  :: " int "  where 
     " TLBNumEntries = ( (( 64 :: int)::ii))"


definition TLBIndexMax  :: "(6)Word.word "  where 
     " TLBIndexMax = ( (vec_of_bits [B1,B1,B1,B1,B1,B1]  ::  6 Word.word))"


(*val MAX : integer -> integer*)

definition MAX0  :: " int \<Rightarrow> int "  where 
     " MAX0 n = ( ((pow2 n)) - (( 1 :: int)::ii))"


definition MAX_U64  :: " int "  where 
     " MAX_U64 = ( MAX0 (( 64 :: int)::ii))"


definition MAX_VA  :: " int "  where 
     " MAX_VA = ( MAX0 (( 40 :: int)::ii))"


definition MAX_PA  :: " int "  where 
     " MAX_PA = ( MAX0 (( 36 :: int)::ii))"


(*val undefined_TLBEntry : unit -> M TLBEntry*)

definition undefined_TLBEntry  :: " unit \<Rightarrow>((register_value),(TLBEntry),(exception))monad "  where 
     " undefined_TLBEntry _ = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 53 :: int)::ii)  :: ( 53 Word.word) M) \<bind> (\<lambda> (w__0 ::  53 Word.word) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   return ((| TLBEntry_TLBEntry_chunk_1 = w__0, 
              TLBEntry_TLBEntry_chunk_0 = w__1 |)))))"


(*val Mk_TLBEntry : mword ty117 -> TLBEntry*)

definition Mk_TLBEntry  :: "(117)Word.word \<Rightarrow> TLBEntry "  where 
     " Mk_TLBEntry v = (
   (| TLBEntry_TLBEntry_chunk_1 = ((subrange_vec_dec v (( 116 :: int)::ii) (( 64 :: int)::ii)  ::  53 Word.word)), 
      TLBEntry_TLBEntry_chunk_0 = ((subrange_vec_dec v (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word)) |) )"


(*val _get_TLBEntry_bits : TLBEntry -> mword ty117*)

definition get_TLBEntry_bits  :: " TLBEntry \<Rightarrow>(117)Word.word "  where 
     " get_TLBEntry_bits v = (
   (concat_vec ((subrange_vec_dec(TLBEntry_TLBEntry_chunk_1   v) (( 52 :: int)::ii) (( 0 :: int)::ii)  ::  53 Word.word))
      ((subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   v) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
     ::  117 Word.word))"


(*val _set_TLBEntry_bits : register_ref regstate register_value TLBEntry -> mword ty117 -> M unit*)

definition set_TLBEntry_bits  :: "((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(117)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_TLBEntry_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       TLBEntry_TLBEntry_chunk_1 :=
         ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_1   r) (( 52 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 116 :: int)::ii) (( 64 :: int)::ii)  ::  53 Word.word))
            ::  53 Word.word))|))) in
   (let r =
     ((r (|
       TLBEntry_TLBEntry_chunk_0 :=
         ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   r) (( 63 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r))))"


(*val _update_TLBEntry_bits : TLBEntry -> mword ty117 -> TLBEntry*)

definition update_TLBEntry_bits  :: " TLBEntry \<Rightarrow>(117)Word.word \<Rightarrow> TLBEntry "  where 
     " update_TLBEntry_bits v x = (
   (let v =
     ((v (|
       TLBEntry_TLBEntry_chunk_1 :=
         ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_1   v) (( 52 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec x (( 116 :: int)::ii) (( 64 :: int)::ii)  ::  53 Word.word))
            ::  53 Word.word))|))) in
   (v (|
     TLBEntry_TLBEntry_chunk_0 :=
       ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   v) (( 63 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
          ::  64 Word.word))|))))"


(*val _get_TLBEntry_pagemask : TLBEntry -> mword ty16*)

definition get_TLBEntry_pagemask  :: " TLBEntry \<Rightarrow>(16)Word.word "  where 
     " get_TLBEntry_pagemask v = (
   (subrange_vec_dec(TLBEntry_TLBEntry_chunk_1   v) (( 52 :: int)::ii) (( 37 :: int)::ii)  ::  16 Word.word))"


(*val _set_TLBEntry_pagemask : register_ref regstate register_value TLBEntry -> mword ty16 -> M unit*)

definition set_TLBEntry_pagemask  :: "((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_TLBEntry_pagemask r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       TLBEntry_TLBEntry_chunk_1 :=
         ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_1   r) (( 52 :: int)::ii) (( 37 :: int)::ii)
             ((subrange_vec_dec v (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
            ::  53 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_TLBEntry_pagemask : TLBEntry -> mword ty16 -> TLBEntry*)

definition update_TLBEntry_pagemask  :: " TLBEntry \<Rightarrow>(16)Word.word \<Rightarrow> TLBEntry "  where 
     " update_TLBEntry_pagemask v x = (
   (v (|
     TLBEntry_TLBEntry_chunk_1 :=
       ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_1   v) (( 52 :: int)::ii) (( 37 :: int)::ii)
           ((subrange_vec_dec x (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
          ::  53 Word.word))|)))"


(*val _get_TLBEntry_r : TLBEntry -> mword ty2*)

definition get_TLBEntry_r  :: " TLBEntry \<Rightarrow>(2)Word.word "  where 
     " get_TLBEntry_r v = ( (subrange_vec_dec(TLBEntry_TLBEntry_chunk_1   v) (( 36 :: int)::ii) (( 35 :: int)::ii)  ::  2 Word.word))"


(*val _set_TLBEntry_r : register_ref regstate register_value TLBEntry -> mword ty2 -> M unit*)

definition set_TLBEntry_r  :: "((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_TLBEntry_r r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       TLBEntry_TLBEntry_chunk_1 :=
         ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_1   r) (( 36 :: int)::ii) (( 35 :: int)::ii)
             ((subrange_vec_dec v (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
            ::  53 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_TLBEntry_r : TLBEntry -> mword ty2 -> TLBEntry*)

definition update_TLBEntry_r  :: " TLBEntry \<Rightarrow>(2)Word.word \<Rightarrow> TLBEntry "  where 
     " update_TLBEntry_r v x = (
   (v (|
     TLBEntry_TLBEntry_chunk_1 :=
       ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_1   v) (( 36 :: int)::ii) (( 35 :: int)::ii)
           ((subrange_vec_dec x (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
          ::  53 Word.word))|)))"


(*val _get_TLBEntry_vpn2 : TLBEntry -> mword ty27*)

definition get_TLBEntry_vpn2  :: " TLBEntry \<Rightarrow>(27)Word.word "  where 
     " get_TLBEntry_vpn2 v = (
   (subrange_vec_dec(TLBEntry_TLBEntry_chunk_1   v) (( 34 :: int)::ii) (( 8 :: int)::ii)  ::  27 Word.word))"


(*val _set_TLBEntry_vpn2 : register_ref regstate register_value TLBEntry -> mword ty27 -> M unit*)

definition set_TLBEntry_vpn2  :: "((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(27)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_TLBEntry_vpn2 r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       TLBEntry_TLBEntry_chunk_1 :=
         ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_1   r) (( 34 :: int)::ii) (( 8 :: int)::ii)
             ((subrange_vec_dec v (( 26 :: int)::ii) (( 0 :: int)::ii)  ::  27 Word.word))
            ::  53 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_TLBEntry_vpn2 : TLBEntry -> mword ty27 -> TLBEntry*)

definition update_TLBEntry_vpn2  :: " TLBEntry \<Rightarrow>(27)Word.word \<Rightarrow> TLBEntry "  where 
     " update_TLBEntry_vpn2 v x = (
   (v (|
     TLBEntry_TLBEntry_chunk_1 :=
       ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_1   v) (( 34 :: int)::ii) (( 8 :: int)::ii)
           ((subrange_vec_dec x (( 26 :: int)::ii) (( 0 :: int)::ii)  ::  27 Word.word))
          ::  53 Word.word))|)))"


(*val _get_TLBEntry_asid : TLBEntry -> mword ty8*)

definition get_TLBEntry_asid  :: " TLBEntry \<Rightarrow>(8)Word.word "  where 
     " get_TLBEntry_asid v = ( (subrange_vec_dec(TLBEntry_TLBEntry_chunk_1   v) (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))"


(*val _set_TLBEntry_asid : register_ref regstate register_value TLBEntry -> mword ty8 -> M unit*)

definition set_TLBEntry_asid  :: "((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_TLBEntry_asid r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       TLBEntry_TLBEntry_chunk_1 :=
         ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_1   r) (( 7 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
            ::  53 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_TLBEntry_asid : TLBEntry -> mword ty8 -> TLBEntry*)

definition update_TLBEntry_asid  :: " TLBEntry \<Rightarrow>(8)Word.word \<Rightarrow> TLBEntry "  where 
     " update_TLBEntry_asid v x = (
   (v (|
     TLBEntry_TLBEntry_chunk_1 :=
       ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_1   v) (( 7 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
          ::  53 Word.word))|)))"


(*val _get_TLBEntry_g : TLBEntry -> mword ty1*)

definition get_TLBEntry_g  :: " TLBEntry \<Rightarrow>(1)Word.word "  where 
     " get_TLBEntry_g v = ( (subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   v) (( 63 :: int)::ii) (( 63 :: int)::ii)  ::  1 Word.word))"


(*val _set_TLBEntry_g : register_ref regstate register_value TLBEntry -> mword ty1 -> M unit*)

definition set_TLBEntry_g  :: "((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_TLBEntry_g r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       TLBEntry_TLBEntry_chunk_0 :=
         ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   r) (( 63 :: int)::ii) (( 63 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_TLBEntry_g : TLBEntry -> mword ty1 -> TLBEntry*)

definition update_TLBEntry_g  :: " TLBEntry \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntry "  where 
     " update_TLBEntry_g v x = (
   (v (|
     TLBEntry_TLBEntry_chunk_0 :=
       ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   v) (( 63 :: int)::ii) (( 63 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  64 Word.word))|)))"


(*val _get_TLBEntry_valid : TLBEntry -> mword ty1*)

definition get_TLBEntry_valid  :: " TLBEntry \<Rightarrow>(1)Word.word "  where 
     " get_TLBEntry_valid v = (
   (subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   v) (( 62 :: int)::ii) (( 62 :: int)::ii)  ::  1 Word.word))"


(*val _set_TLBEntry_valid : register_ref regstate register_value TLBEntry -> mword ty1 -> M unit*)

definition set_TLBEntry_valid  :: "((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_TLBEntry_valid r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       TLBEntry_TLBEntry_chunk_0 :=
         ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   r) (( 62 :: int)::ii) (( 62 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_TLBEntry_valid : TLBEntry -> mword ty1 -> TLBEntry*)

definition update_TLBEntry_valid  :: " TLBEntry \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntry "  where 
     " update_TLBEntry_valid v x = (
   (v (|
     TLBEntry_TLBEntry_chunk_0 :=
       ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   v) (( 62 :: int)::ii) (( 62 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  64 Word.word))|)))"


(*val _get_TLBEntry_caps1 : TLBEntry -> mword ty1*)

definition get_TLBEntry_caps1  :: " TLBEntry \<Rightarrow>(1)Word.word "  where 
     " get_TLBEntry_caps1 v = (
   (subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   v) (( 61 :: int)::ii) (( 61 :: int)::ii)  ::  1 Word.word))"


(*val _set_TLBEntry_caps1 : register_ref regstate register_value TLBEntry -> mword ty1 -> M unit*)

definition set_TLBEntry_caps1  :: "((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_TLBEntry_caps1 r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       TLBEntry_TLBEntry_chunk_0 :=
         ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   r) (( 61 :: int)::ii) (( 61 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_TLBEntry_caps1 : TLBEntry -> mword ty1 -> TLBEntry*)

definition update_TLBEntry_caps1  :: " TLBEntry \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntry "  where 
     " update_TLBEntry_caps1 v x = (
   (v (|
     TLBEntry_TLBEntry_chunk_0 :=
       ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   v) (( 61 :: int)::ii) (( 61 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  64 Word.word))|)))"


(*val _get_TLBEntry_capl1 : TLBEntry -> mword ty1*)

definition get_TLBEntry_capl1  :: " TLBEntry \<Rightarrow>(1)Word.word "  where 
     " get_TLBEntry_capl1 v = (
   (subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   v) (( 60 :: int)::ii) (( 60 :: int)::ii)  ::  1 Word.word))"


(*val _set_TLBEntry_capl1 : register_ref regstate register_value TLBEntry -> mword ty1 -> M unit*)

definition set_TLBEntry_capl1  :: "((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_TLBEntry_capl1 r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       TLBEntry_TLBEntry_chunk_0 :=
         ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   r) (( 60 :: int)::ii) (( 60 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_TLBEntry_capl1 : TLBEntry -> mword ty1 -> TLBEntry*)

definition update_TLBEntry_capl1  :: " TLBEntry \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntry "  where 
     " update_TLBEntry_capl1 v x = (
   (v (|
     TLBEntry_TLBEntry_chunk_0 :=
       ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   v) (( 60 :: int)::ii) (( 60 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  64 Word.word))|)))"


(*val _get_TLBEntry_pfn1 : TLBEntry -> mword ty24*)

definition get_TLBEntry_pfn1  :: " TLBEntry \<Rightarrow>(24)Word.word "  where 
     " get_TLBEntry_pfn1 v = (
   (subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   v) (( 59 :: int)::ii) (( 36 :: int)::ii)  ::  24 Word.word))"


(*val _set_TLBEntry_pfn1 : register_ref regstate register_value TLBEntry -> mword ty24 -> M unit*)

definition set_TLBEntry_pfn1  :: "((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(24)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_TLBEntry_pfn1 r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       TLBEntry_TLBEntry_chunk_0 :=
         ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   r) (( 59 :: int)::ii) (( 36 :: int)::ii)
             ((subrange_vec_dec v (( 23 :: int)::ii) (( 0 :: int)::ii)  ::  24 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_TLBEntry_pfn1 : TLBEntry -> mword ty24 -> TLBEntry*)

definition update_TLBEntry_pfn1  :: " TLBEntry \<Rightarrow>(24)Word.word \<Rightarrow> TLBEntry "  where 
     " update_TLBEntry_pfn1 v x = (
   (v (|
     TLBEntry_TLBEntry_chunk_0 :=
       ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   v) (( 59 :: int)::ii) (( 36 :: int)::ii)
           ((subrange_vec_dec x (( 23 :: int)::ii) (( 0 :: int)::ii)  ::  24 Word.word))
          ::  64 Word.word))|)))"


(*val _get_TLBEntry_c1 : TLBEntry -> mword ty3*)

definition get_TLBEntry_c1  :: " TLBEntry \<Rightarrow>(3)Word.word "  where 
     " get_TLBEntry_c1 v = ( (subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   v) (( 35 :: int)::ii) (( 33 :: int)::ii)  ::  3 Word.word))"


(*val _set_TLBEntry_c1 : register_ref regstate register_value TLBEntry -> mword ty3 -> M unit*)

definition set_TLBEntry_c1  :: "((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_TLBEntry_c1 r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       TLBEntry_TLBEntry_chunk_0 :=
         ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   r) (( 35 :: int)::ii) (( 33 :: int)::ii)
             ((subrange_vec_dec v (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_TLBEntry_c1 : TLBEntry -> mword ty3 -> TLBEntry*)

definition update_TLBEntry_c1  :: " TLBEntry \<Rightarrow>(3)Word.word \<Rightarrow> TLBEntry "  where 
     " update_TLBEntry_c1 v x = (
   (v (|
     TLBEntry_TLBEntry_chunk_0 :=
       ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   v) (( 35 :: int)::ii) (( 33 :: int)::ii)
           ((subrange_vec_dec x (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))
          ::  64 Word.word))|)))"


(*val _get_TLBEntry_d1 : TLBEntry -> mword ty1*)

definition get_TLBEntry_d1  :: " TLBEntry \<Rightarrow>(1)Word.word "  where 
     " get_TLBEntry_d1 v = ( (subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   v) (( 32 :: int)::ii) (( 32 :: int)::ii)  ::  1 Word.word))"


(*val _set_TLBEntry_d1 : register_ref regstate register_value TLBEntry -> mword ty1 -> M unit*)

definition set_TLBEntry_d1  :: "((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_TLBEntry_d1 r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       TLBEntry_TLBEntry_chunk_0 :=
         ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   r) (( 32 :: int)::ii) (( 32 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_TLBEntry_d1 : TLBEntry -> mword ty1 -> TLBEntry*)

definition update_TLBEntry_d1  :: " TLBEntry \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntry "  where 
     " update_TLBEntry_d1 v x = (
   (v (|
     TLBEntry_TLBEntry_chunk_0 :=
       ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   v) (( 32 :: int)::ii) (( 32 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  64 Word.word))|)))"


(*val _get_TLBEntry_v1 : TLBEntry -> mword ty1*)

definition get_TLBEntry_v1  :: " TLBEntry \<Rightarrow>(1)Word.word "  where 
     " get_TLBEntry_v1 v = ( (subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   v) (( 31 :: int)::ii) (( 31 :: int)::ii)  ::  1 Word.word))"


(*val _set_TLBEntry_v1 : register_ref regstate register_value TLBEntry -> mword ty1 -> M unit*)

definition set_TLBEntry_v1  :: "((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_TLBEntry_v1 r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       TLBEntry_TLBEntry_chunk_0 :=
         ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   r) (( 31 :: int)::ii) (( 31 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_TLBEntry_v1 : TLBEntry -> mword ty1 -> TLBEntry*)

definition update_TLBEntry_v1  :: " TLBEntry \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntry "  where 
     " update_TLBEntry_v1 v x = (
   (v (|
     TLBEntry_TLBEntry_chunk_0 :=
       ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   v) (( 31 :: int)::ii) (( 31 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  64 Word.word))|)))"


(*val _get_TLBEntry_caps0 : TLBEntry -> mword ty1*)

definition get_TLBEntry_caps0  :: " TLBEntry \<Rightarrow>(1)Word.word "  where 
     " get_TLBEntry_caps0 v = (
   (subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   v) (( 30 :: int)::ii) (( 30 :: int)::ii)  ::  1 Word.word))"


(*val _set_TLBEntry_caps0 : register_ref regstate register_value TLBEntry -> mword ty1 -> M unit*)

definition set_TLBEntry_caps0  :: "((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_TLBEntry_caps0 r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       TLBEntry_TLBEntry_chunk_0 :=
         ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   r) (( 30 :: int)::ii) (( 30 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_TLBEntry_caps0 : TLBEntry -> mword ty1 -> TLBEntry*)

definition update_TLBEntry_caps0  :: " TLBEntry \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntry "  where 
     " update_TLBEntry_caps0 v x = (
   (v (|
     TLBEntry_TLBEntry_chunk_0 :=
       ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   v) (( 30 :: int)::ii) (( 30 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  64 Word.word))|)))"


(*val _get_TLBEntry_capl0 : TLBEntry -> mword ty1*)

definition get_TLBEntry_capl0  :: " TLBEntry \<Rightarrow>(1)Word.word "  where 
     " get_TLBEntry_capl0 v = (
   (subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   v) (( 29 :: int)::ii) (( 29 :: int)::ii)  ::  1 Word.word))"


(*val _set_TLBEntry_capl0 : register_ref regstate register_value TLBEntry -> mword ty1 -> M unit*)

definition set_TLBEntry_capl0  :: "((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_TLBEntry_capl0 r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       TLBEntry_TLBEntry_chunk_0 :=
         ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   r) (( 29 :: int)::ii) (( 29 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_TLBEntry_capl0 : TLBEntry -> mword ty1 -> TLBEntry*)

definition update_TLBEntry_capl0  :: " TLBEntry \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntry "  where 
     " update_TLBEntry_capl0 v x = (
   (v (|
     TLBEntry_TLBEntry_chunk_0 :=
       ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   v) (( 29 :: int)::ii) (( 29 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  64 Word.word))|)))"


(*val _get_TLBEntry_pfn0 : TLBEntry -> mword ty24*)

definition get_TLBEntry_pfn0  :: " TLBEntry \<Rightarrow>(24)Word.word "  where 
     " get_TLBEntry_pfn0 v = (
   (subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   v) (( 28 :: int)::ii) (( 5 :: int)::ii)  ::  24 Word.word))"


(*val _set_TLBEntry_pfn0 : register_ref regstate register_value TLBEntry -> mword ty24 -> M unit*)

definition set_TLBEntry_pfn0  :: "((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(24)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_TLBEntry_pfn0 r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       TLBEntry_TLBEntry_chunk_0 :=
         ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   r) (( 28 :: int)::ii) (( 5 :: int)::ii)
             ((subrange_vec_dec v (( 23 :: int)::ii) (( 0 :: int)::ii)  ::  24 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_TLBEntry_pfn0 : TLBEntry -> mword ty24 -> TLBEntry*)

definition update_TLBEntry_pfn0  :: " TLBEntry \<Rightarrow>(24)Word.word \<Rightarrow> TLBEntry "  where 
     " update_TLBEntry_pfn0 v x = (
   (v (|
     TLBEntry_TLBEntry_chunk_0 :=
       ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   v) (( 28 :: int)::ii) (( 5 :: int)::ii)
           ((subrange_vec_dec x (( 23 :: int)::ii) (( 0 :: int)::ii)  ::  24 Word.word))
          ::  64 Word.word))|)))"


(*val _get_TLBEntry_c0 : TLBEntry -> mword ty3*)

definition get_TLBEntry_c0  :: " TLBEntry \<Rightarrow>(3)Word.word "  where 
     " get_TLBEntry_c0 v = ( (subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   v) (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word))"


(*val _set_TLBEntry_c0 : register_ref regstate register_value TLBEntry -> mword ty3 -> M unit*)

definition set_TLBEntry_c0  :: "((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(3)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_TLBEntry_c0 r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       TLBEntry_TLBEntry_chunk_0 :=
         ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   r) (( 4 :: int)::ii) (( 2 :: int)::ii)
             ((subrange_vec_dec v (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_TLBEntry_c0 : TLBEntry -> mword ty3 -> TLBEntry*)

definition update_TLBEntry_c0  :: " TLBEntry \<Rightarrow>(3)Word.word \<Rightarrow> TLBEntry "  where 
     " update_TLBEntry_c0 v x = (
   (v (|
     TLBEntry_TLBEntry_chunk_0 :=
       ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   v) (( 4 :: int)::ii) (( 2 :: int)::ii)
           ((subrange_vec_dec x (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))
          ::  64 Word.word))|)))"


(*val _get_TLBEntry_d0 : TLBEntry -> mword ty1*)

definition get_TLBEntry_d0  :: " TLBEntry \<Rightarrow>(1)Word.word "  where 
     " get_TLBEntry_d0 v = ( (subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   v) (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))"


(*val _set_TLBEntry_d0 : register_ref regstate register_value TLBEntry -> mword ty1 -> M unit*)

definition set_TLBEntry_d0  :: "((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_TLBEntry_d0 r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       TLBEntry_TLBEntry_chunk_0 :=
         ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   r) (( 1 :: int)::ii) (( 1 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_TLBEntry_d0 : TLBEntry -> mword ty1 -> TLBEntry*)

definition update_TLBEntry_d0  :: " TLBEntry \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntry "  where 
     " update_TLBEntry_d0 v x = (
   (v (|
     TLBEntry_TLBEntry_chunk_0 :=
       ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   v) (( 1 :: int)::ii) (( 1 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  64 Word.word))|)))"


(*val _get_TLBEntry_v0 : TLBEntry -> mword ty1*)

definition get_TLBEntry_v0  :: " TLBEntry \<Rightarrow>(1)Word.word "  where 
     " get_TLBEntry_v0 v = ( (subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   v) (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))"


(*val _set_TLBEntry_v0 : register_ref regstate register_value TLBEntry -> mword ty1 -> M unit*)

definition set_TLBEntry_v0  :: "((regstate),(register_value),(TLBEntry))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_TLBEntry_v0 r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       TLBEntry_TLBEntry_chunk_0 :=
         ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   r) (( 0 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_TLBEntry_v0 : TLBEntry -> mword ty1 -> TLBEntry*)

definition update_TLBEntry_v0  :: " TLBEntry \<Rightarrow>(1)Word.word \<Rightarrow> TLBEntry "  where 
     " update_TLBEntry_v0 v x = (
   (v (|
     TLBEntry_TLBEntry_chunk_0 :=
       ((update_subrange_vec_dec(TLBEntry_TLBEntry_chunk_0   v) (( 0 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  64 Word.word))|)))"


definition TLBEntries  :: "(((regstate),(register_value),(TLBEntry))register_ref)list "  where 
     " TLBEntries = (
  [TLBEntry63_ref,TLBEntry62_ref,TLBEntry61_ref,TLBEntry60_ref,TLBEntry59_ref,TLBEntry58_ref,
   TLBEntry57_ref,TLBEntry56_ref,TLBEntry55_ref,TLBEntry54_ref,TLBEntry53_ref,TLBEntry52_ref,
   TLBEntry51_ref,TLBEntry50_ref,TLBEntry49_ref,TLBEntry48_ref,TLBEntry47_ref,TLBEntry46_ref,
   TLBEntry45_ref,TLBEntry44_ref,TLBEntry43_ref,TLBEntry42_ref,TLBEntry41_ref,TLBEntry40_ref,
   TLBEntry39_ref,TLBEntry38_ref,TLBEntry37_ref,TLBEntry36_ref,TLBEntry35_ref,TLBEntry34_ref,
   TLBEntry33_ref,TLBEntry32_ref,TLBEntry31_ref,TLBEntry30_ref,TLBEntry29_ref,TLBEntry28_ref,
   TLBEntry27_ref,TLBEntry26_ref,TLBEntry25_ref,TLBEntry24_ref,TLBEntry23_ref,TLBEntry22_ref,
   TLBEntry21_ref,TLBEntry20_ref,TLBEntry19_ref,TLBEntry18_ref,TLBEntry17_ref,TLBEntry16_ref,
   TLBEntry15_ref,TLBEntry14_ref,TLBEntry13_ref,TLBEntry12_ref,TLBEntry11_ref,TLBEntry10_ref,
   TLBEntry09_ref,TLBEntry08_ref,TLBEntry07_ref,TLBEntry06_ref,TLBEntry05_ref,TLBEntry04_ref,
   TLBEntry03_ref,TLBEntry02_ref,TLBEntry01_ref,TLBEntry00_ref])"


(*val undefined_StatusReg : unit -> M StatusReg*)

definition undefined_StatusReg  :: " unit \<Rightarrow>((register_value),(StatusReg),(exception))monad "  where 
     " undefined_StatusReg _ = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 ::  32 Word.word) . 
   return ((| StatusReg_StatusReg_chunk_0 = w__0 |))))"


(*val Mk_StatusReg : mword ty32 -> StatusReg*)

definition Mk_StatusReg  :: "(32)Word.word \<Rightarrow> StatusReg "  where 
     " Mk_StatusReg v = (
   (| StatusReg_StatusReg_chunk_0 = ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) |) )"


(*val _get_StatusReg_bits : StatusReg -> mword ty32*)

definition get_StatusReg_bits  :: " StatusReg \<Rightarrow>(32)Word.word "  where 
     " get_StatusReg_bits v = (
   (subrange_vec_dec(StatusReg_StatusReg_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))"


(*val _set_StatusReg_bits : register_ref regstate register_value StatusReg -> mword ty32 -> M unit*)

definition set_StatusReg_bits  :: "((regstate),(register_value),(StatusReg))register_ref \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_StatusReg_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       StatusReg_StatusReg_chunk_0 :=
         ((update_subrange_vec_dec(StatusReg_StatusReg_chunk_0   r) (( 31 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_StatusReg_bits : StatusReg -> mword ty32 -> StatusReg*)

definition update_StatusReg_bits  :: " StatusReg \<Rightarrow>(32)Word.word \<Rightarrow> StatusReg "  where 
     " update_StatusReg_bits v x = (
   (v (|
     StatusReg_StatusReg_chunk_0 :=
       ((update_subrange_vec_dec(StatusReg_StatusReg_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
          ::  32 Word.word))|)))"


(*val _get_StatusReg_CU : StatusReg -> mword ty4*)

definition get_StatusReg_CU  :: " StatusReg \<Rightarrow>(4)Word.word "  where 
     " get_StatusReg_CU v = (
   (subrange_vec_dec(StatusReg_StatusReg_chunk_0   v) (( 31 :: int)::ii) (( 28 :: int)::ii)  ::  4 Word.word))"


(*val _set_StatusReg_CU : register_ref regstate register_value StatusReg -> mword ty4 -> M unit*)

definition set_StatusReg_CU  :: "((regstate),(register_value),(StatusReg))register_ref \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_StatusReg_CU r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       StatusReg_StatusReg_chunk_0 :=
         ((update_subrange_vec_dec(StatusReg_StatusReg_chunk_0   r) (( 31 :: int)::ii) (( 28 :: int)::ii)
             ((subrange_vec_dec v (( 3 :: int)::ii) (( 0 :: int)::ii)  ::  4 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_StatusReg_CU : StatusReg -> mword ty4 -> StatusReg*)

definition update_StatusReg_CU  :: " StatusReg \<Rightarrow>(4)Word.word \<Rightarrow> StatusReg "  where 
     " update_StatusReg_CU v x = (
   (v (|
     StatusReg_StatusReg_chunk_0 :=
       ((update_subrange_vec_dec(StatusReg_StatusReg_chunk_0   v) (( 31 :: int)::ii) (( 28 :: int)::ii)
           ((subrange_vec_dec x (( 3 :: int)::ii) (( 0 :: int)::ii)  ::  4 Word.word))
          ::  32 Word.word))|)))"


(*val _get_StatusReg_BEV : StatusReg -> mword ty1*)

definition get_StatusReg_BEV  :: " StatusReg \<Rightarrow>(1)Word.word "  where 
     " get_StatusReg_BEV v = (
   (subrange_vec_dec(StatusReg_StatusReg_chunk_0   v) (( 22 :: int)::ii) (( 22 :: int)::ii)  ::  1 Word.word))"


(*val _set_StatusReg_BEV : register_ref regstate register_value StatusReg -> mword ty1 -> M unit*)

definition set_StatusReg_BEV  :: "((regstate),(register_value),(StatusReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_StatusReg_BEV r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       StatusReg_StatusReg_chunk_0 :=
         ((update_subrange_vec_dec(StatusReg_StatusReg_chunk_0   r) (( 22 :: int)::ii) (( 22 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_StatusReg_BEV : StatusReg -> mword ty1 -> StatusReg*)

definition update_StatusReg_BEV  :: " StatusReg \<Rightarrow>(1)Word.word \<Rightarrow> StatusReg "  where 
     " update_StatusReg_BEV v x = (
   (v (|
     StatusReg_StatusReg_chunk_0 :=
       ((update_subrange_vec_dec(StatusReg_StatusReg_chunk_0   v) (( 22 :: int)::ii) (( 22 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))"


(*val _get_StatusReg_IM : StatusReg -> mword ty8*)

definition get_StatusReg_IM  :: " StatusReg \<Rightarrow>(8)Word.word "  where 
     " get_StatusReg_IM v = (
   (subrange_vec_dec(StatusReg_StatusReg_chunk_0   v) (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))"


(*val _set_StatusReg_IM : register_ref regstate register_value StatusReg -> mword ty8 -> M unit*)

definition set_StatusReg_IM  :: "((regstate),(register_value),(StatusReg))register_ref \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_StatusReg_IM r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       StatusReg_StatusReg_chunk_0 :=
         ((update_subrange_vec_dec(StatusReg_StatusReg_chunk_0   r) (( 15 :: int)::ii) (( 8 :: int)::ii)
             ((subrange_vec_dec v (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_StatusReg_IM : StatusReg -> mword ty8 -> StatusReg*)

definition update_StatusReg_IM  :: " StatusReg \<Rightarrow>(8)Word.word \<Rightarrow> StatusReg "  where 
     " update_StatusReg_IM v x = (
   (v (|
     StatusReg_StatusReg_chunk_0 :=
       ((update_subrange_vec_dec(StatusReg_StatusReg_chunk_0   v) (( 15 :: int)::ii) (( 8 :: int)::ii)
           ((subrange_vec_dec x (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
          ::  32 Word.word))|)))"


(*val _get_StatusReg_KX : StatusReg -> mword ty1*)

definition get_StatusReg_KX  :: " StatusReg \<Rightarrow>(1)Word.word "  where 
     " get_StatusReg_KX v = (
   (subrange_vec_dec(StatusReg_StatusReg_chunk_0   v) (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word))"


(*val _set_StatusReg_KX : register_ref regstate register_value StatusReg -> mword ty1 -> M unit*)

definition set_StatusReg_KX  :: "((regstate),(register_value),(StatusReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_StatusReg_KX r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       StatusReg_StatusReg_chunk_0 :=
         ((update_subrange_vec_dec(StatusReg_StatusReg_chunk_0   r) (( 7 :: int)::ii) (( 7 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_StatusReg_KX : StatusReg -> mword ty1 -> StatusReg*)

definition update_StatusReg_KX  :: " StatusReg \<Rightarrow>(1)Word.word \<Rightarrow> StatusReg "  where 
     " update_StatusReg_KX v x = (
   (v (|
     StatusReg_StatusReg_chunk_0 :=
       ((update_subrange_vec_dec(StatusReg_StatusReg_chunk_0   v) (( 7 :: int)::ii) (( 7 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))"


(*val _get_StatusReg_SX : StatusReg -> mword ty1*)

definition get_StatusReg_SX  :: " StatusReg \<Rightarrow>(1)Word.word "  where 
     " get_StatusReg_SX v = (
   (subrange_vec_dec(StatusReg_StatusReg_chunk_0   v) (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word))"


(*val _set_StatusReg_SX : register_ref regstate register_value StatusReg -> mword ty1 -> M unit*)

definition set_StatusReg_SX  :: "((regstate),(register_value),(StatusReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_StatusReg_SX r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       StatusReg_StatusReg_chunk_0 :=
         ((update_subrange_vec_dec(StatusReg_StatusReg_chunk_0   r) (( 6 :: int)::ii) (( 6 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_StatusReg_SX : StatusReg -> mword ty1 -> StatusReg*)

definition update_StatusReg_SX  :: " StatusReg \<Rightarrow>(1)Word.word \<Rightarrow> StatusReg "  where 
     " update_StatusReg_SX v x = (
   (v (|
     StatusReg_StatusReg_chunk_0 :=
       ((update_subrange_vec_dec(StatusReg_StatusReg_chunk_0   v) (( 6 :: int)::ii) (( 6 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))"


(*val _get_StatusReg_UX : StatusReg -> mword ty1*)

definition get_StatusReg_UX  :: " StatusReg \<Rightarrow>(1)Word.word "  where 
     " get_StatusReg_UX v = (
   (subrange_vec_dec(StatusReg_StatusReg_chunk_0   v) (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word))"


(*val _set_StatusReg_UX : register_ref regstate register_value StatusReg -> mword ty1 -> M unit*)

definition set_StatusReg_UX  :: "((regstate),(register_value),(StatusReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_StatusReg_UX r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       StatusReg_StatusReg_chunk_0 :=
         ((update_subrange_vec_dec(StatusReg_StatusReg_chunk_0   r) (( 5 :: int)::ii) (( 5 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_StatusReg_UX : StatusReg -> mword ty1 -> StatusReg*)

definition update_StatusReg_UX  :: " StatusReg \<Rightarrow>(1)Word.word \<Rightarrow> StatusReg "  where 
     " update_StatusReg_UX v x = (
   (v (|
     StatusReg_StatusReg_chunk_0 :=
       ((update_subrange_vec_dec(StatusReg_StatusReg_chunk_0   v) (( 5 :: int)::ii) (( 5 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))"


(*val _get_StatusReg_KSU : StatusReg -> mword ty2*)

definition get_StatusReg_KSU  :: " StatusReg \<Rightarrow>(2)Word.word "  where 
     " get_StatusReg_KSU v = (
   (subrange_vec_dec(StatusReg_StatusReg_chunk_0   v) (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word))"


(*val _set_StatusReg_KSU : register_ref regstate register_value StatusReg -> mword ty2 -> M unit*)

definition set_StatusReg_KSU  :: "((regstate),(register_value),(StatusReg))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_StatusReg_KSU r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       StatusReg_StatusReg_chunk_0 :=
         ((update_subrange_vec_dec(StatusReg_StatusReg_chunk_0   r) (( 4 :: int)::ii) (( 3 :: int)::ii)
             ((subrange_vec_dec v (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_StatusReg_KSU : StatusReg -> mword ty2 -> StatusReg*)

definition update_StatusReg_KSU  :: " StatusReg \<Rightarrow>(2)Word.word \<Rightarrow> StatusReg "  where 
     " update_StatusReg_KSU v x = (
   (v (|
     StatusReg_StatusReg_chunk_0 :=
       ((update_subrange_vec_dec(StatusReg_StatusReg_chunk_0   v) (( 4 :: int)::ii) (( 3 :: int)::ii)
           ((subrange_vec_dec x (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
          ::  32 Word.word))|)))"


(*val _get_StatusReg_ERL : StatusReg -> mword ty1*)

definition get_StatusReg_ERL  :: " StatusReg \<Rightarrow>(1)Word.word "  where 
     " get_StatusReg_ERL v = (
   (subrange_vec_dec(StatusReg_StatusReg_chunk_0   v) (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word))"


(*val _set_StatusReg_ERL : register_ref regstate register_value StatusReg -> mword ty1 -> M unit*)

definition set_StatusReg_ERL  :: "((regstate),(register_value),(StatusReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_StatusReg_ERL r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       StatusReg_StatusReg_chunk_0 :=
         ((update_subrange_vec_dec(StatusReg_StatusReg_chunk_0   r) (( 2 :: int)::ii) (( 2 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_StatusReg_ERL : StatusReg -> mword ty1 -> StatusReg*)

definition update_StatusReg_ERL  :: " StatusReg \<Rightarrow>(1)Word.word \<Rightarrow> StatusReg "  where 
     " update_StatusReg_ERL v x = (
   (v (|
     StatusReg_StatusReg_chunk_0 :=
       ((update_subrange_vec_dec(StatusReg_StatusReg_chunk_0   v) (( 2 :: int)::ii) (( 2 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))"


(*val _get_StatusReg_EXL : StatusReg -> mword ty1*)

definition get_StatusReg_EXL  :: " StatusReg \<Rightarrow>(1)Word.word "  where 
     " get_StatusReg_EXL v = (
   (subrange_vec_dec(StatusReg_StatusReg_chunk_0   v) (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))"


(*val _set_StatusReg_EXL : register_ref regstate register_value StatusReg -> mword ty1 -> M unit*)

definition set_StatusReg_EXL  :: "((regstate),(register_value),(StatusReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_StatusReg_EXL r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       StatusReg_StatusReg_chunk_0 :=
         ((update_subrange_vec_dec(StatusReg_StatusReg_chunk_0   r) (( 1 :: int)::ii) (( 1 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_StatusReg_EXL : StatusReg -> mword ty1 -> StatusReg*)

definition update_StatusReg_EXL  :: " StatusReg \<Rightarrow>(1)Word.word \<Rightarrow> StatusReg "  where 
     " update_StatusReg_EXL v x = (
   (v (|
     StatusReg_StatusReg_chunk_0 :=
       ((update_subrange_vec_dec(StatusReg_StatusReg_chunk_0   v) (( 1 :: int)::ii) (( 1 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))"


(*val _get_StatusReg_IE : StatusReg -> mword ty1*)

definition get_StatusReg_IE  :: " StatusReg \<Rightarrow>(1)Word.word "  where 
     " get_StatusReg_IE v = (
   (subrange_vec_dec(StatusReg_StatusReg_chunk_0   v) (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))"


(*val _set_StatusReg_IE : register_ref regstate register_value StatusReg -> mword ty1 -> M unit*)

definition set_StatusReg_IE  :: "((regstate),(register_value),(StatusReg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_StatusReg_IE r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       StatusReg_StatusReg_chunk_0 :=
         ((update_subrange_vec_dec(StatusReg_StatusReg_chunk_0   r) (( 0 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_StatusReg_IE : StatusReg -> mword ty1 -> StatusReg*)

definition update_StatusReg_IE  :: " StatusReg \<Rightarrow>(1)Word.word \<Rightarrow> StatusReg "  where 
     " update_StatusReg_IE v x = (
   (v (|
     StatusReg_StatusReg_chunk_0 :=
       ((update_subrange_vec_dec(StatusReg_StatusReg_chunk_0   v) (( 0 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))"


(*val execute_branch : mword ty64 -> M unit*)

definition execute_branch  :: "(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_branch pc = (
   write_reg delayedPC_ref pc \<then> write_reg branchPending_ref (vec_of_bits [B1]  ::  1 Word.word))"


(*val NotWordVal : mword ty64 -> bool*)

definition NotWordVal  :: "(64)Word.word \<Rightarrow> bool "  where 
     " NotWordVal word1 = (
   (((replicate_bits ((cast_unit_vec0 ((access_vec_dec word1 (( 31 :: int)::ii)))  ::  1 Word.word)) (( 32 :: int)::ii)
        ::  32 Word.word)) \<noteq> ((subrange_vec_dec word1 (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))))"


(*val rGPR : mword ty5 -> M (mword ty64)*)

definition rGPR  :: "(5)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " rGPR idx = (
   (let i = (Word.uint idx) in
   if (((i = (( 0 :: int)::ii)))) then
     return (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                          B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                          B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
              ::  64 Word.word)
   else
     read_reg GPR_ref \<bind> (\<lambda> (w__0 :: ( 64 bits) list) . 
     return ((access_list_dec w__0 i  ::  64 Word.word)))))"


(*val wGPR : mword ty5 -> mword ty64 -> M unit*)

definition wGPR  :: "(5)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " wGPR idx v = (
   (let i = (Word.uint idx) in
   if (((i \<noteq> (( 0 :: int)::ii)))) then
     read_reg GPR_ref \<bind> (\<lambda> (w__0 :: ( 64 bits) list) . 
     write_reg GPR_ref ((update_list_dec w__0 i v  :: ( 64 Word.word) list)))
   else return () ))"
















(*val Exception_of_num : integer -> Exception*)

definition Exception_of_num  :: " int \<Rightarrow> Exception "  where 
     " Exception_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then Interrupt
   else if (((p00 = (( 1 :: int)::ii)))) then TLBMod
   else if (((p00 = (( 2 :: int)::ii)))) then TLBL
   else if (((p00 = (( 3 :: int)::ii)))) then TLBS
   else if (((p00 = (( 4 :: int)::ii)))) then AdEL
   else if (((p00 = (( 5 :: int)::ii)))) then AdES
   else if (((p00 = (( 6 :: int)::ii)))) then Sys
   else if (((p00 = (( 7 :: int)::ii)))) then Bp
   else if (((p00 = (( 8 :: int)::ii)))) then ResI
   else if (((p00 = (( 9 :: int)::ii)))) then CpU
   else if (((p00 = (( 10 :: int)::ii)))) then Ov
   else if (((p00 = (( 11 :: int)::ii)))) then Tr
   else if (((p00 = (( 12 :: int)::ii)))) then C2E
   else if (((p00 = (( 13 :: int)::ii)))) then C2Trap
   else if (((p00 = (( 14 :: int)::ii)))) then XTLBRefillL
   else if (((p00 = (( 15 :: int)::ii)))) then XTLBRefillS
   else if (((p00 = (( 16 :: int)::ii)))) then XTLBInvL
   else if (((p00 = (( 17 :: int)::ii)))) then XTLBInvS
   else MCheck))"


(*val num_of_Exception : Exception -> integer*)

fun num_of_Exception  :: " Exception \<Rightarrow> int "  where 
     " num_of_Exception Interrupt = ( (( 0 :: int)::ii))"
|" num_of_Exception TLBMod = ( (( 1 :: int)::ii))"
|" num_of_Exception TLBL = ( (( 2 :: int)::ii))"
|" num_of_Exception TLBS = ( (( 3 :: int)::ii))"
|" num_of_Exception AdEL = ( (( 4 :: int)::ii))"
|" num_of_Exception AdES = ( (( 5 :: int)::ii))"
|" num_of_Exception Sys = ( (( 6 :: int)::ii))"
|" num_of_Exception Bp = ( (( 7 :: int)::ii))"
|" num_of_Exception ResI = ( (( 8 :: int)::ii))"
|" num_of_Exception CpU = ( (( 9 :: int)::ii))"
|" num_of_Exception Ov = ( (( 10 :: int)::ii))"
|" num_of_Exception Tr = ( (( 11 :: int)::ii))"
|" num_of_Exception C2E = ( (( 12 :: int)::ii))"
|" num_of_Exception C2Trap = ( (( 13 :: int)::ii))"
|" num_of_Exception XTLBRefillL = ( (( 14 :: int)::ii))"
|" num_of_Exception XTLBRefillS = ( (( 15 :: int)::ii))"
|" num_of_Exception XTLBInvL = ( (( 16 :: int)::ii))"
|" num_of_Exception XTLBInvS = ( (( 17 :: int)::ii))"
|" num_of_Exception MCheck = ( (( 18 :: int)::ii))"


(*val undefined_Exception : unit -> M Exception*)

definition undefined_Exception  :: " unit \<Rightarrow>((register_value),(Exception),(exception))monad "  where 
     " undefined_Exception _ = (
   internal_pick
     [Interrupt,TLBMod,TLBL,TLBS,AdEL,AdES,Sys,Bp,ResI,CpU,Ov,Tr,C2E,C2Trap,XTLBRefillL,XTLBRefillS,XTLBInvL,XTLBInvS,MCheck])"


(*val ExceptionCode : Exception -> mword ty5*)

definition ExceptionCode  :: " Exception \<Rightarrow>(5)Word.word "  where 
     " ExceptionCode ex = (
   (let (x :: 8 bits) =
     ((case  ex of
       Interrupt => (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word)
     | TLBMod => (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B1]  ::  8 Word.word)
     | TLBL => (vec_of_bits [B0,B0,B0,B0,B0,B0,B1,B0]  ::  8 Word.word)
     | TLBS => (vec_of_bits [B0,B0,B0,B0,B0,B0,B1,B1]  ::  8 Word.word)
     | AdEL => (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0]  ::  8 Word.word)
     | AdES => (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B1]  ::  8 Word.word)
     | Sys => (vec_of_bits [B0,B0,B0,B0,B1,B0,B0,B0]  ::  8 Word.word)
     | Bp => (vec_of_bits [B0,B0,B0,B0,B1,B0,B0,B1]  ::  8 Word.word)
     | ResI => (vec_of_bits [B0,B0,B0,B0,B1,B0,B1,B0]  ::  8 Word.word)
     | CpU => (vec_of_bits [B0,B0,B0,B0,B1,B0,B1,B1]  ::  8 Word.word)
     | Ov => (vec_of_bits [B0,B0,B0,B0,B1,B1,B0,B0]  ::  8 Word.word)
     | Tr => (vec_of_bits [B0,B0,B0,B0,B1,B1,B0,B1]  ::  8 Word.word)
     | C2E => (vec_of_bits [B0,B0,B0,B1,B0,B0,B1,B0]  ::  8 Word.word)
     | C2Trap => (vec_of_bits [B0,B0,B0,B1,B0,B0,B1,B0]  ::  8 Word.word)
     | XTLBRefillL => (vec_of_bits [B0,B0,B0,B0,B0,B0,B1,B0]  ::  8 Word.word)
     | XTLBRefillS => (vec_of_bits [B0,B0,B0,B0,B0,B0,B1,B1]  ::  8 Word.word)
     | XTLBInvL => (vec_of_bits [B0,B0,B0,B0,B0,B0,B1,B0]  ::  8 Word.word)
     | XTLBInvS => (vec_of_bits [B0,B0,B0,B0,B0,B0,B1,B1]  ::  8 Word.word)
     | MCheck => (vec_of_bits [B0,B0,B0,B1,B1,B0,B0,B0]  ::  8 Word.word)
     )) in
   (subrange_vec_dec x (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)))"


(*val SignalExceptionMIPS : forall 'o. Exception -> mword ty64 -> M 'o*)

definition SignalExceptionMIPS  :: " Exception \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),'o,(exception))monad "  where 
     " SignalExceptionMIPS ex kccBase = (
   read_reg CP0Status_ref \<bind> (\<lambda> (w__0 :: StatusReg) . 
   ((if ((\<not> ((bits_to_bool ((get_StatusReg_EXL w__0  ::  1 Word.word)))))) then
      (read_reg inBranchDelay_ref  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__1 :: 1 bits) . 
      if ((bit_to_bool ((access_vec_dec w__1 (( 0 :: int)::ii))))) then
        (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 :: 64 bits) . 
        write_reg CP0EPC_ref ((sub_vec_int w__2 (( 4 :: int)::ii)  ::  64 Word.word)) \<then>
        set_CauseReg_BD CP0Cause_ref (vec_of_bits [B1]  ::  1 Word.word))
      else
        (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 :: 64 bits) . 
        write_reg CP0EPC_ref w__3 \<then> set_CauseReg_BD CP0Cause_ref (vec_of_bits [B0]  ::  1 Word.word)))
    else return () ) \<then>
   read_reg CP0Status_ref) \<bind> (\<lambda> (w__4 :: StatusReg) . 
   (let vectorOffset =
     (if ((bits_to_bool ((get_StatusReg_EXL w__4  ::  1 Word.word)))) then
       (vec_of_bits [B0,B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)
     else if ((((((ex = XTLBRefillL))) \<or> (((ex = XTLBRefillS)))))) then
       (vec_of_bits [B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)
     else if (((ex = C2Trap))) then (vec_of_bits [B0,B0,B1,B0,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)
     else (vec_of_bits [B0,B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)) in
   read_reg CP0Status_ref \<bind> (\<lambda> (w__5 :: StatusReg) . 
   (let (vectorBase :: 64 bits) =
     (if ((bits_to_bool ((get_StatusReg_BEV w__5  ::  1 Word.word)))) then
       (vec_of_bits [B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,
                     B1,B1,B1,B1,B1,B1,B1,B0,B1,B1,B1,B1,B1,B1,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)
     else
       (vec_of_bits [B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,
                     B1,B1,B1,B1,B1,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)) in
   ((write_reg
     nextPC_ref
     ((sub_vec
         ((add_vec vectorBase ((mips_sign_extend (( 64 :: int)::ii) vectorOffset  ::  64 Word.word))  ::  64 Word.word))
         kccBase
        ::  64 Word.word)) \<then>
   set_CauseReg_ExcCode CP0Cause_ref ((ExceptionCode ex  ::  5 Word.word))) \<then>
   set_StatusReg_EXL CP0Status_ref (vec_of_bits [B1]  ::  1 Word.word)) \<then> throw (ISAException () )))))))"


(*val SignalException : forall 'o. Exception -> M 'o*)

(*val SignalExceptionBadAddr : forall 'o. Exception -> mword ty64 -> M 'o*)

(*val capRegToCapStruct : mword ty257 -> CapStruct*)

definition capRegToCapStruct  :: "(257)Word.word \<Rightarrow> CapStruct "  where 
     " capRegToCapStruct capReg = (
   (| CapStruct_tag = ((bit_to_bool ((access_vec_dec capReg (( 256 :: int)::ii))))), 
      CapStruct_padding = ((subrange_vec_dec capReg (( 255 :: int)::ii) (( 248 :: int)::ii)  ::  8 Word.word)), 
      CapStruct_otype = ((subrange_vec_dec capReg (( 247 :: int)::ii) (( 224 :: int)::ii)  ::  24 Word.word)), 
      CapStruct_uperms = ((subrange_vec_dec capReg (( 223 :: int)::ii) (( 208 :: int)::ii)  ::  16 Word.word)), 
      CapStruct_perm_reserved11_14 = ((subrange_vec_dec capReg (( 207 :: int)::ii) (( 204 :: int)::ii)  ::  4 Word.word)), 
      CapStruct_access_system_regs = ((bit_to_bool ((access_vec_dec capReg (( 203 :: int)::ii))))), 
      CapStruct_permit_unseal = ((bit_to_bool ((access_vec_dec capReg (( 202 :: int)::ii))))), 
      CapStruct_permit_ccall = ((bit_to_bool ((access_vec_dec capReg (( 201 :: int)::ii))))), 
      CapStruct_permit_seal = ((bit_to_bool ((access_vec_dec capReg (( 200 :: int)::ii))))), 
      CapStruct_permit_store_local_cap = ((bit_to_bool ((access_vec_dec capReg (( 199 :: int)::ii))))), 
      CapStruct_permit_store_cap = ((bit_to_bool ((access_vec_dec capReg (( 198 :: int)::ii))))), 
      CapStruct_permit_load_cap = ((bit_to_bool ((access_vec_dec capReg (( 197 :: int)::ii))))), 
      CapStruct_permit_store = ((bit_to_bool ((access_vec_dec capReg (( 196 :: int)::ii))))), 
      CapStruct_permit_load = ((bit_to_bool ((access_vec_dec capReg (( 195 :: int)::ii))))), 
      CapStruct_permit_execute = ((bit_to_bool ((access_vec_dec capReg (( 194 :: int)::ii))))), 
      CapStruct_global = ((bit_to_bool ((access_vec_dec capReg (( 193 :: int)::ii))))), 
      CapStruct_sealed = ((bit_to_bool ((access_vec_dec capReg (( 192 :: int)::ii))))), 
      CapStruct_address = ((subrange_vec_dec capReg (( 191 :: int)::ii) (( 128 :: int)::ii)  ::  64 Word.word)), 
      CapStruct_base = ((subrange_vec_dec capReg (( 127 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word)), 
      CapStruct_length = ((subrange_vec_dec capReg (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word)) |) )"


(*val getCapPerms : CapStruct -> mword ty31*)

definition getCapPerms  :: " CapStruct \<Rightarrow>(31)Word.word "  where 
     " getCapPerms cap = (
   (concat_vec(CapStruct_uperms   cap)
      ((concat_vec(CapStruct_perm_reserved11_14   cap)
          ((concat_vec ((bool_to_bits(CapStruct_access_system_regs   cap)  ::  1 Word.word))
              ((concat_vec ((bool_to_bits(CapStruct_permit_unseal   cap)  ::  1 Word.word))
                  ((concat_vec ((bool_to_bits(CapStruct_permit_ccall   cap)  ::  1 Word.word))
                      ((concat_vec ((bool_to_bits(CapStruct_permit_seal   cap)  ::  1 Word.word))
                          ((concat_vec
                              ((bool_to_bits(CapStruct_permit_store_local_cap   cap)  ::  1 Word.word))
                              ((concat_vec
                                  ((bool_to_bits(CapStruct_permit_store_cap   cap)  ::  1 Word.word))
                                  ((concat_vec
                                      ((bool_to_bits(CapStruct_permit_load_cap   cap)  ::  1 Word.word))
                                      ((concat_vec
                                          ((bool_to_bits(CapStruct_permit_store   cap)  ::  1 Word.word))
                                          ((concat_vec
                                              ((bool_to_bits(CapStruct_permit_load   cap)  ::  1 Word.word))
                                              ((concat_vec
                                                  ((bool_to_bits(CapStruct_permit_execute   cap)
                                                     ::  1 Word.word))
                                                  ((bool_to_bits(CapStruct_global   cap)  ::  1 Word.word))
                                                 ::  2 Word.word))
                                             ::  3 Word.word))
                                         ::  4 Word.word))
                                     ::  5 Word.word))
                                 ::  6 Word.word))
                             ::  7 Word.word))
                         ::  8 Word.word))
                     ::  9 Word.word))
                 ::  10 Word.word))
             ::  11 Word.word))
         ::  15 Word.word))
     ::  31 Word.word))"


(*val capStructToMemBits256 : CapStruct -> mword ty256*)

definition capStructToMemBits256  :: " CapStruct \<Rightarrow>(256)Word.word "  where 
     " capStructToMemBits256 cap = (
   (concat_vec(CapStruct_padding   cap)
      ((concat_vec(CapStruct_otype   cap)
          ((concat_vec ((getCapPerms cap  ::  31 Word.word))
              ((concat_vec ((bool_to_bits(CapStruct_sealed   cap)  ::  1 Word.word))
                  ((concat_vec(CapStruct_address   cap)
                      ((concat_vec(CapStruct_base   cap)(CapStruct_length   cap)  ::  128 Word.word))
                     ::  192 Word.word))
                 ::  193 Word.word))
             ::  224 Word.word))
         ::  248 Word.word))
     ::  256 Word.word))"


(*val capStructToCapReg : CapStruct -> mword ty257*)

definition capStructToCapReg  :: " CapStruct \<Rightarrow>(257)Word.word "  where 
     " capStructToCapReg cap = (
   (concat_vec ((bool_to_bits(CapStruct_tag   cap)  ::  1 Word.word))
      ((capStructToMemBits256 cap  ::  256 Word.word))
     ::  257 Word.word))"


(*val getCapBase : CapStruct -> integer*)

definition getCapBase  :: " CapStruct \<Rightarrow> int "  where 
     " getCapBase c = ( Word.uint(CapStruct_base   c))"


definition null_cap  :: " CapStruct "  where 
     " null_cap = (
  (| CapStruct_tag = False, 
     CapStruct_padding = ((zeros0 (( 8 :: int)::ii) ()   ::  8 Word.word)), 
     CapStruct_otype = ((zeros0 (( 24 :: int)::ii) ()   ::  24 Word.word)), 
     CapStruct_uperms = ((zeros0 (( 16 :: int)::ii) ()   ::  16 Word.word)), 
     CapStruct_perm_reserved11_14 = ((zeros0 (( 4 :: int)::ii) ()   ::  4 Word.word)), 
     CapStruct_access_system_regs = False, 
     CapStruct_permit_unseal = False, 
     CapStruct_permit_ccall = False, 
     CapStruct_permit_seal = False, 
     CapStruct_permit_store_local_cap = False, 
     CapStruct_permit_store_cap = False, 
     CapStruct_permit_load_cap = False, 
     CapStruct_permit_store = False, 
     CapStruct_permit_load = False, 
     CapStruct_permit_execute = False, 
     CapStruct_global = False, 
     CapStruct_sealed = False, 
     CapStruct_address = ((zeros0 (( 64 :: int)::ii) ()   ::  64 Word.word)), 
     CapStruct_base = ((zeros0 (( 64 :: int)::ii) ()   ::  64 Word.word)), 
     CapStruct_length =
       ((vec_of_bits [B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,
                     B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,
                     B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1]
         ::  64 Word.word)) |) )"


(*val int_to_cap : mword ty64 -> CapStruct*)

definition int_to_cap  :: "(64)Word.word \<Rightarrow> CapStruct "  where 
     " int_to_cap address = ( (null_cap (| CapStruct_address := address |)))"


(*
Set the offset capability of the a capability to given value and return the result, along with a boolean indicating true if the operation preserved the existing bounds of the capability.  When using compressed capabilities, setting the offset far outside the capability bounds can cause the result to become unrepresentable (XXX mention guarantees). Additionally in some implementations a fast representablity check may be used that could cause the operation to return failure even though the capability would be representable (XXX provide details). 
 *)
(*val setCapOffset : CapStruct -> mword ty64 -> (bool * CapStruct)*)

definition setCapOffset  :: " CapStruct \<Rightarrow>(64)Word.word \<Rightarrow> bool*CapStruct "  where 
     " setCapOffset c offset = (
   (True, (c (| CapStruct_address := ((add_vec(CapStruct_base   c) offset  ::  64 Word.word))|))))"


definition SignalException  :: " Exception \<Rightarrow>((register_value),'o,(exception))monad "  where 
     " SignalException ex = (
   read_reg CP0Status_ref \<bind> (\<lambda> (w__0 :: StatusReg) . 
   ((if ((\<not> ((bits_to_bool ((get_StatusReg_EXL w__0  ::  1 Word.word)))))) then
      (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> pc . 
      (read_reg PCC_ref  :: ( 257 Word.word) M) \<bind> (\<lambda> (w__1 :: CapReg) . 
      (let pcc = (capRegToCapStruct w__1) in
      (let (success, epcc) = (setCapOffset pcc pc) in
      if success then write_reg EPCC_ref ((capStructToCapReg epcc  ::  257 Word.word))
      else
        write_reg
          EPCC_ref
          ((capStructToCapReg
              ((int_to_cap
                  ((add_vec_int
                      ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) ((getCapBase pcc))
                         ::  64 Word.word)) ((Word.uint pc))
                     ::  64 Word.word))))
             ::  257 Word.word))))))
    else return () ) \<then>
   (read_reg KCC_ref  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__2 :: CapReg) . 
   (write_reg nextPCC_ref w__2 \<then>
   (read_reg KCC_ref  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__3 :: CapReg) . 
   (write_reg delayedPCC_ref w__3 \<then>
   (read_reg KCC_ref  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__4 :: CapReg) . 
   (let base = (getCapBase ((capRegToCapStruct w__4))) in
   SignalExceptionMIPS ex ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) base  ::  64 Word.word))))))))"


definition SignalExceptionBadAddr  :: " Exception \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),'o,(exception))monad "  where 
     " SignalExceptionBadAddr ex badAddr = ( write_reg CP0BadVAddr_ref badAddr \<then> SignalException ex )"


(*val SignalExceptionTLB : forall 'o. Exception -> mword ty64 -> M 'o*)

definition SignalExceptionTLB  :: " Exception \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),'o,(exception))monad "  where 
     " SignalExceptionTLB ex badAddr = (
   (((((write_reg CP0BadVAddr_ref badAddr \<then>
   set_ContextReg_BadVPN2 TLBContext_ref ((subrange_vec_dec badAddr (( 31 :: int)::ii) (( 13 :: int)::ii)  ::  19 Word.word))) \<then>
   set_XContextReg_XBadVPN2 TLBXContext_ref
     ((subrange_vec_dec badAddr (( 39 :: int)::ii) (( 13 :: int)::ii)  ::  27 Word.word))) \<then>
   set_XContextReg_XR TLBXContext_ref ((subrange_vec_dec badAddr (( 63 :: int)::ii) (( 62 :: int)::ii)  ::  2 Word.word))) \<then>
   set_TLBEntryHiReg_R TLBEntryHi_ref ((subrange_vec_dec badAddr (( 63 :: int)::ii) (( 62 :: int)::ii)  ::  2 Word.word))) \<then>
   set_TLBEntryHiReg_VPN2 TLBEntryHi_ref ((subrange_vec_dec badAddr (( 39 :: int)::ii) (( 13 :: int)::ii)  ::  27 Word.word))) \<then>
   SignalException ex )"


(*val MemAccessType_of_num : integer -> MemAccessType*)

definition MemAccessType_of_num  :: " int \<Rightarrow> MemAccessType "  where 
     " MemAccessType_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then Instruction
   else if (((p00 = (( 1 :: int)::ii)))) then LoadData
   else StoreData))"


(*val num_of_MemAccessType : MemAccessType -> integer*)

fun num_of_MemAccessType  :: " MemAccessType \<Rightarrow> int "  where 
     " num_of_MemAccessType Instruction = ( (( 0 :: int)::ii))"
|" num_of_MemAccessType LoadData = ( (( 1 :: int)::ii))"
|" num_of_MemAccessType StoreData = ( (( 2 :: int)::ii))"


(*val undefined_MemAccessType : unit -> M MemAccessType*)

definition undefined_MemAccessType  :: " unit \<Rightarrow>((register_value),(MemAccessType),(exception))monad "  where 
     " undefined_MemAccessType _ = ( internal_pick [Instruction,LoadData,StoreData])"


(*val AccessLevel_of_num : integer -> AccessLevel*)

definition AccessLevel_of_num  :: " int \<Rightarrow> AccessLevel "  where 
     " AccessLevel_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then User
   else if (((p00 = (( 1 :: int)::ii)))) then Supervisor
   else Kernel))"


(*val num_of_AccessLevel : AccessLevel -> integer*)

fun num_of_AccessLevel  :: " AccessLevel \<Rightarrow> int "  where 
     " num_of_AccessLevel User = ( (( 0 :: int)::ii))"
|" num_of_AccessLevel Supervisor = ( (( 1 :: int)::ii))"
|" num_of_AccessLevel Kernel = ( (( 2 :: int)::ii))"


(*val undefined_AccessLevel : unit -> M AccessLevel*)

definition undefined_AccessLevel  :: " unit \<Rightarrow>((register_value),(AccessLevel),(exception))monad "  where 
     " undefined_AccessLevel _ = ( internal_pick [User,Supervisor,Kernel])"


(*val int_of_AccessLevel : AccessLevel -> integer*)

fun int_of_AccessLevel  :: " AccessLevel \<Rightarrow> int "  where 
     " int_of_AccessLevel User = ( (( 0 :: int)::ii))"
|" int_of_AccessLevel Supervisor = ( (( 1 :: int)::ii))"
|" int_of_AccessLevel Kernel = ( (( 2 :: int)::ii))"


(*
Returns whether the first AccessLevel is sufficient to grant access at the second, required, access level.
 *)
(*val grantsAccess : AccessLevel -> AccessLevel -> bool*)

definition grantsAccess  :: " AccessLevel \<Rightarrow> AccessLevel \<Rightarrow> bool "  where 
     " grantsAccess currentLevel requiredLevel = (
   ((int_of_AccessLevel currentLevel)) \<ge> ((int_of_AccessLevel requiredLevel)))"


(*
Returns the current effective access level determined by accessing the relevant parts of the MIPS status register.
 *)
(*val getAccessLevel : unit -> M AccessLevel*)

definition getAccessLevel  :: " unit \<Rightarrow>((register_value),(AccessLevel),(exception))monad "  where 
     " getAccessLevel _ = (
   or_boolM
     (read_reg CP0Status_ref \<bind> (\<lambda> (w__0 :: StatusReg) . 
      return ((bits_to_bool ((get_StatusReg_EXL w__0  ::  1 Word.word))))))
     (read_reg CP0Status_ref \<bind> (\<lambda> (w__1 :: StatusReg) . 
      return ((bits_to_bool ((get_StatusReg_ERL w__1  ::  1 Word.word)))))) \<bind> (\<lambda> (w__2 :: bool) . 
   if w__2 then return Kernel
   else
     read_reg CP0Status_ref \<bind> (\<lambda> (w__3 :: StatusReg) . 
     (let p__19 = ((get_StatusReg_KSU w__3  ::  2 Word.word)) in
     (let b__0 = p__19 in
     return (if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then Kernel
             else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then Supervisor
             else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then User
             else User))))))"


(*val checkCP0Access : unit -> M unit*)

definition checkCP0Access  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " checkCP0Access _ = (
   getAccessLevel ()  \<bind> (\<lambda> accessLevel . 
   and_boolM (return (((accessLevel \<noteq> Kernel))))
     (read_reg CP0Status_ref \<bind> (\<lambda> (w__0 :: StatusReg) . 
      return ((\<not> ((bit_to_bool ((access_vec_dec ((get_StatusReg_CU w__0  ::  4 Word.word)) (( 0 :: int)::ii))))))))) \<bind> (\<lambda> (w__1 ::
     bool) . 
   if w__1 then
     set_CauseReg_CE CP0Cause_ref (vec_of_bits [B0,B0]  ::  2 Word.word) \<then> SignalException CpU
   else return () )))"


(*val incrementCP0Count : unit -> M unit*)

definition incrementCP0Count  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " incrementCP0Count _ = (
   (read_reg TLBRandom_ref  :: ( 6 Word.word) M) \<bind> (\<lambda> (w__0 :: TLBIndexT) . 
   (read_reg TLBWired_ref  :: ( 6 Word.word) M) \<bind> (\<lambda> (w__1 :: TLBIndexT) . 
   (if (((w__0 = w__1))) then return TLBIndexMax
    else
      (read_reg TLBRandom_ref  :: ( 6 Word.word) M) \<bind> (\<lambda> (w__2 :: TLBIndexT) . 
      return ((sub_vec_int w__2 (( 1 :: int)::ii)  ::  6 Word.word)))) \<bind> (\<lambda> (w__3 ::  6 Word.word) . 
   (write_reg TLBRandom_ref w__3 \<then>
   (read_reg CP0Count_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__4 :: 32 bits) . 
   (write_reg CP0Count_ref ((add_vec_int w__4 (( 1 :: int)::ii)  ::  32 Word.word)) \<then>
   (read_reg CP0Count_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__5 :: 32 bits) . 
   (read_reg CP0Compare_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__6 :: 32 bits) . 
   ((if (((w__5 = w__6))) then
      read_reg CP0Cause_ref \<bind> (\<lambda> (w__7 :: CauseReg) . 
      set_CauseReg_IP CP0Cause_ref
        ((or_vec ((get_CauseReg_IP w__7  ::  8 Word.word))
            (vec_of_bits [B1,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word)
           ::  8 Word.word)))
    else return () ) \<then>
   read_reg CP0Status_ref) \<bind> (\<lambda> (w__8 :: StatusReg) . 
   (let ims = ((get_StatusReg_IM w__8  ::  8 Word.word)) in
   read_reg CP0Cause_ref \<bind> (\<lambda> (w__9 :: CauseReg) . 
   (let ips = ((get_CauseReg_IP w__9  ::  8 Word.word)) in
   read_reg CP0Status_ref \<bind> (\<lambda> (w__10 :: StatusReg) . 
   (let ie = ((get_StatusReg_IE w__10  ::  1 Word.word)) in
   read_reg CP0Status_ref \<bind> (\<lambda> (w__11 :: StatusReg) . 
   (let exl = ((get_StatusReg_EXL w__11  ::  1 Word.word)) in
   read_reg CP0Status_ref \<bind> (\<lambda> (w__12 :: StatusReg) . 
   (let erl = ((get_StatusReg_ERL w__12  ::  1 Word.word)) in
   if (((((\<not> ((bits_to_bool exl)))) \<and> (((((\<not> ((bits_to_bool erl)))) \<and> (((((bits_to_bool ie)) \<and> (((((and_vec ips ims  ::  8 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word))))))))))))) then
     SignalException Interrupt
   else return () )))))))))))))))))"


(*val decode_failure_of_num : integer -> decode_failure*)

definition decode_failure_of_num  :: " int \<Rightarrow> decode_failure "  where 
     " decode_failure_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then No_matching_pattern
   else if (((p00 = (( 1 :: int)::ii)))) then Unsupported_instruction
   else if (((p00 = (( 2 :: int)::ii)))) then Illegal_instruction
   else Internal_error))"


(*val num_of_decode_failure : decode_failure -> integer*)

definition num_of_decode_failure  :: " decode_failure \<Rightarrow> int "  where 
     " num_of_decode_failure no_matching_pattern = ( (( 0 :: int)::ii))"


(*val undefined_decode_failure : unit -> M decode_failure*)

definition undefined_decode_failure  :: " unit \<Rightarrow>((register_value),(decode_failure),(exception))monad "  where 
     " undefined_decode_failure _ = (
   internal_pick [No_matching_pattern,Unsupported_instruction,Illegal_instruction,Internal_error])"


(*val Comparison_of_num : integer -> Comparison*)

definition Comparison_of_num  :: " int \<Rightarrow> Comparison "  where 
     " Comparison_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then EQ'
   else if (((p00 = (( 1 :: int)::ii)))) then NE
   else if (((p00 = (( 2 :: int)::ii)))) then GE
   else if (((p00 = (( 3 :: int)::ii)))) then GEU
   else if (((p00 = (( 4 :: int)::ii)))) then GT'
   else if (((p00 = (( 5 :: int)::ii)))) then LE
   else if (((p00 = (( 6 :: int)::ii)))) then LT'
   else LTU))"


(*val num_of_Comparison : Comparison -> integer*)

fun num_of_Comparison  :: " Comparison \<Rightarrow> int "  where 
     " num_of_Comparison EQ' = ( (( 0 :: int)::ii))"
|" num_of_Comparison NE = ( (( 1 :: int)::ii))"
|" num_of_Comparison GE = ( (( 2 :: int)::ii))"
|" num_of_Comparison GEU = ( (( 3 :: int)::ii))"
|" num_of_Comparison GT' = ( (( 4 :: int)::ii))"
|" num_of_Comparison LE = ( (( 5 :: int)::ii))"
|" num_of_Comparison LT' = ( (( 6 :: int)::ii))"
|" num_of_Comparison LTU = ( (( 7 :: int)::ii))"


(*val undefined_Comparison : unit -> M Comparison*)

definition undefined_Comparison  :: " unit \<Rightarrow>((register_value),(Comparison),(exception))monad "  where 
     " undefined_Comparison _ = ( internal_pick [EQ',NE,GE,GEU,GT',LE,LT',LTU])"


(*val compare : Comparison -> mword ty64 -> mword ty64 -> bool*)

fun compare  :: " Comparison \<Rightarrow>(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow> bool "  where 
     " compare EQ' valA valB = ( (valA = valB))"
|" compare NE valA valB = ( (valA \<noteq> valB))"
|" compare GE valA valB = ( zopz0zKzJ_s valA valB )"
|" compare GEU valA valB = ( zopz0zKzJ_u valA valB )"
|" compare GT' valA valB = ( zopz0zI_s valB valA )"
|" compare LE valA valB = ( zopz0zKzJ_s valB valA )"
|" compare LT' valA valB = ( zopz0zI_s valA valB )"
|" compare LTU valA valB = ( zopz0zI_u valA valB )"


(*val WordType_of_num : integer -> WordType*)

definition WordType_of_num  :: " int \<Rightarrow> WordType "  where 
     " WordType_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then B
   else if (((p00 = (( 1 :: int)::ii)))) then H
   else if (((p00 = (( 2 :: int)::ii)))) then W
   else D))"


(*val num_of_WordType : WordType -> integer*)

fun num_of_WordType  :: " WordType \<Rightarrow> int "  where 
     " num_of_WordType B = ( (( 0 :: int)::ii))"
|" num_of_WordType H = ( (( 1 :: int)::ii))"
|" num_of_WordType W = ( (( 2 :: int)::ii))"
|" num_of_WordType D = ( (( 3 :: int)::ii))"


(*val undefined_WordType : unit -> M WordType*)

definition undefined_WordType  :: " unit \<Rightarrow>((register_value),(WordType),(exception))monad "  where 
     " undefined_WordType _ = ( internal_pick [B,H,W,D])"


(*val WordTypeUnaligned_of_num : integer -> WordTypeUnaligned*)

definition WordTypeUnaligned_of_num  :: " int \<Rightarrow> WordTypeUnaligned "  where 
     " WordTypeUnaligned_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then WL
   else if (((p00 = (( 1 :: int)::ii)))) then WR
   else if (((p00 = (( 2 :: int)::ii)))) then DL
   else DR))"


(*val num_of_WordTypeUnaligned : WordTypeUnaligned -> integer*)

fun num_of_WordTypeUnaligned  :: " WordTypeUnaligned \<Rightarrow> int "  where 
     " num_of_WordTypeUnaligned WL = ( (( 0 :: int)::ii))"
|" num_of_WordTypeUnaligned WR = ( (( 1 :: int)::ii))"
|" num_of_WordTypeUnaligned DL = ( (( 2 :: int)::ii))"
|" num_of_WordTypeUnaligned DR = ( (( 3 :: int)::ii))"


(*val undefined_WordTypeUnaligned : unit -> M WordTypeUnaligned*)

definition undefined_WordTypeUnaligned  :: " unit \<Rightarrow>((register_value),(WordTypeUnaligned),(exception))monad "  where 
     " undefined_WordTypeUnaligned _ = ( internal_pick [WL,WR,DL,DR])"


(*val wordWidthBytes : WordType -> integer*)

fun wordWidthBytes  :: " WordType \<Rightarrow> int "  where 
     " wordWidthBytes B = ( (( 1 :: int)::ii))"
|" wordWidthBytes H = ( (( 2 :: int)::ii))"
|" wordWidthBytes W = ( (( 4 :: int)::ii))"
|" wordWidthBytes D = ( (( 8 :: int)::ii))"


definition alignment_width  :: " int "  where 
     " alignment_width = ( (( 16 :: int)::ii))"


(*val isAddressAligned : mword ty64 -> WordType -> bool*)

definition isAddressAligned  :: "(64)Word.word \<Rightarrow> WordType \<Rightarrow> bool "  where 
     " isAddressAligned addr wordType = (
   (let a = (Word.uint addr) in
   (((a div alignment_width)) = ((((((a + ((wordWidthBytes wordType)))) - (( 1 :: int)::ii))) div
         alignment_width)))))"


(*val MEMr_wrapper : forall   'p8_times_n_ . Size 'p8_times_n_ => integer -> mword ty64 -> integer -> M (mword 'p8_times_n_)*)

definition MEMr_wrapper  :: " int \<Rightarrow>(64)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(('p8_times_n_::len)Word.word),(exception))monad "  where 
     " MEMr_wrapper (p8_times_n___tv :: int) addr size1 = (
   if (((addr = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                        B0,B0,B0,B0,B0,B0,B0,B0,B1,B1,B1,B1,B1,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                        B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
            ::  64 Word.word)))) then
     (read_reg UART_RVALID_ref  :: ( 1 Word.word) M) \<bind> (\<lambda> rvalid . 
     (write_reg UART_RVALID_ref (vec_of_bits [B0]  ::  1 Word.word) \<then>
     (read_reg UART_RDATA_ref  :: ( 8 Word.word) M)) \<bind> (\<lambda> (w__0 :: 8 bits) . 
     return ((mask0 p8_times_n___tv
                ((concat_vec
                    (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                  B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
                      ::  32 Word.word)
                    ((concat_vec w__0
                        ((concat_vec rvalid
                            ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)
                                (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
                                  ::  16 Word.word)
                               ::  23 Word.word))
                           ::  24 Word.word))
                       ::  32 Word.word))
                   ::  64 Word.word))
               :: ( 'p8_times_n_::len)Word.word))))
   else if (((addr = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                             B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1,B1,B1,B1,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,
                             B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B0]
                 ::  64 Word.word)))) then
     return ((mask0 p8_times_n___tv
                (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                              B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,
                              B0,B0,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1]
                  ::  64 Word.word)
               :: ( 'p8_times_n_::len)Word.word))
   else
     (MEMr instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict addr size1  :: (( 'p8_times_n_::len)Word.word) M) \<bind> (\<lambda> w__1 . 
     return ((reverse_endianness w__1  :: ( 'p8_times_n_::len)Word.word))))"


(*val MEMr_reserve_wrapper : forall   'p8_times_n_ . Size 'p8_times_n_ => mword ty64 -> integer -> M (mword 'p8_times_n_)*)

definition MEMr_reserve_wrapper  :: "(64)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(('p8_times_n_::len)Word.word),(exception))monad "  where 
     " MEMr_reserve_wrapper addr size1 = (
   (MEMr_reserve instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict addr size1  :: (( 'p8_times_n_::len)Word.word) M) \<bind> (\<lambda> w__0 . 
   return ((reverse_endianness w__0  :: ( 'p8_times_n_::len)Word.word))))"


(*val init_cp0_state : unit -> M unit*)

definition init_cp0_state  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " init_cp0_state _ = ( set_StatusReg_BEV CP0Status_ref ((cast_unit_vec0 B1  ::  1 Word.word)))"


(*val init_cp2_state : unit -> M unit*)

(*val cp2_next_pc : unit -> M unit*)

(*val dump_cp2_state : unit -> M unit*)

(*val extzv : forall 'n 'm. Size 'm, Size 'n => integer -> mword 'n -> mword 'm*)

definition extzv  :: " int \<Rightarrow>('n::len)Word.word \<Rightarrow>('m::len)Word.word "  where 
     " extzv (m__tv :: int) v = ( (extz_vec m__tv v  :: ( 'm::len)Word.word))"


(*val extsv : forall 'n 'm. Size 'm, Size 'n => integer -> mword 'n -> mword 'm*)

definition extsv  :: " int \<Rightarrow>('n::len)Word.word \<Rightarrow>('m::len)Word.word "  where 
     " extsv (m__tv :: int) v = ( (exts_vec m__tv v  :: ( 'm::len)Word.word))"


(*val slice_mask : forall 'n . Size 'n => integer -> ii -> ii -> mword 'n*)

definition slice_mask  :: " int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('n::len)Word.word "  where 
     " slice_mask (n__tv :: int) i l = (
   (let one = ((extzv n__tv (vec_of_bits [B1]  ::  1 Word.word)  :: ( 'n::len)Word.word)) in
   (shiftl ((sub_vec ((shiftl one l  :: ( 'n::len)Word.word)) one  :: ( 'n::len)Word.word)) i  :: ( 'n::len)Word.word)))"


(*val is_zero_subrange : forall 'n . Size 'n => mword 'n -> ii -> ii -> bool*)

definition is_zero_subrange  :: "('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool "  where 
     " is_zero_subrange xs i j = (
   (((and_vec xs
         ((slice_mask ((int (size xs))) j ((((i - j)) + (( 1 :: int)::ii)))  :: ( 'n::len)Word.word))
        :: ( 'n::len)Word.word)) = ((extzv ((int (size xs))) (vec_of_bits [B0]  ::  1 Word.word)  :: ( 'n::len)Word.word))))"


(*val is_ones_subrange : forall 'n . Size 'n => mword 'n -> ii -> ii -> bool*)

definition is_ones_subrange  :: "('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool "  where 
     " is_ones_subrange xs i j = (
   (let m = ((slice_mask ((int (size xs))) j ((((j - i)) + (( 1 :: int)::ii)))  :: ( 'n::len)Word.word)) in
   (((and_vec xs m  :: ( 'n::len)Word.word)) = m)))"


(*val slice_slice_concat : forall 'n 'm 'r . Size 'm, Size 'n, Size 'r => integer -> mword 'n -> ii -> ii -> mword 'm -> ii -> ii -> mword 'r*)

definition slice_slice_concat  :: " int \<Rightarrow>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('m::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('r::len)Word.word "  where 
     " slice_slice_concat (r__tv :: int) xs i l ys i' l' = (
   (let xs =
     ((shiftr ((and_vec xs ((slice_mask ((int (size xs))) i l  :: ( 'n::len)Word.word))  :: ( 'n::len)Word.word)) i  :: ( 'n::len)Word.word)) in
   (let ys =
     ((shiftr ((and_vec ys ((slice_mask ((int (size ys))) i' l'  :: ( 'm::len)Word.word))  :: ( 'm::len)Word.word)) i'
       :: ( 'm::len)Word.word)) in
   (or_vec ((shiftl ((extzv r__tv xs  :: ( 'r::len)Word.word)) l'  :: ( 'r::len)Word.word)) ((extzv r__tv ys  :: ( 'r::len)Word.word))
     :: ( 'r::len)Word.word))))"


(*val slice_zeros_concat : forall 'n   'r . Size 'n, Size 'r => integer -> mword 'n -> ii -> integer -> integer -> mword 'r*)

definition slice_zeros_concat  :: " int \<Rightarrow>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('r::len)Word.word "  where 
     " slice_zeros_concat (r__tv :: int) xs i l l' = (
   (let xs =
     ((shiftr ((and_vec xs ((slice_mask ((int (size xs))) i l  :: ( 'n::len)Word.word))  :: ( 'n::len)Word.word)) i  :: ( 'n::len)Word.word)) in
   (shiftl ((extzv r__tv xs  :: ( 'r::len)Word.word)) l'  :: ( 'r::len)Word.word)))"


(*val subrange_subrange_eq : forall 'n . Size 'n => mword 'n -> ii -> ii -> mword 'n -> ii -> ii -> bool*)

definition subrange_subrange_eq  :: "('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> bool "  where 
     " subrange_subrange_eq xs i j ys i' j' = (
   (let xs =
     ((shiftr
        ((and_vec xs
            ((slice_mask ((int (size xs))) j ((((i - j)) + (( 1 :: int)::ii)))  :: ( 'n::len)Word.word))
           :: ( 'n::len)Word.word)) j
       :: ( 'n::len)Word.word)) in
   (let ys =
     ((shiftr
        ((and_vec ys
            ((slice_mask ((int (size xs))) j' ((((i' - j')) + (( 1 :: int)::ii)))  :: ( 'n::len)Word.word))
           :: ( 'n::len)Word.word)) j'
       :: ( 'n::len)Word.word)) in
   (xs = ys))))"


(*val subrange_subrange_concat : forall 'n   'm   's . Size 'm, Size 'n, Size 's => integer -> mword 'n -> integer -> integer -> mword 'm -> integer -> integer -> mword 's*)

definition subrange_subrange_concat  :: " int \<Rightarrow>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('m::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('s::len)Word.word "  where 
     " subrange_subrange_concat (s__tv :: int) xs i j ys i' j' = (
   (let xs =
     ((shiftr
        ((and_vec xs
            ((slice_mask ((int (size xs))) j ((((i - j)) + (( 1 :: int)::ii)))  :: ( 'n::len)Word.word))
           :: ( 'n::len)Word.word)) j
       :: ( 'n::len)Word.word)) in
   (let ys =
     ((shiftr
        ((and_vec ys
            ((slice_mask ((int (size ys))) j' ((((i' - j')) + (( 1 :: int)::ii)))  :: ( 'm::len)Word.word))
           :: ( 'm::len)Word.word)) j'
       :: ( 'm::len)Word.word)) in
   (or_vec
      ((shiftl ((extzv s__tv xs  :: ( 's::len)Word.word)) ((((i' - j')) + (( 1 :: int)::ii)))
         :: ( 's::len)Word.word)) ((extzv s__tv ys  :: ( 's::len)Word.word))
     :: ( 's::len)Word.word))))"


(*val place_subrange : forall 'n 'm . Size 'm, Size 'n => integer -> mword 'n -> ii -> ii -> ii -> mword 'm*)

definition place_subrange  :: " int \<Rightarrow>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('m::len)Word.word "  where 
     " place_subrange (m__tv :: int) xs i j shift = (
   (let xs =
     ((shiftr
        ((and_vec xs
            ((slice_mask ((int (size xs))) j ((((i - j)) + (( 1 :: int)::ii)))  :: ( 'n::len)Word.word))
           :: ( 'n::len)Word.word)) j
       :: ( 'n::len)Word.word)) in
   (shiftl ((extzv m__tv xs  :: ( 'm::len)Word.word)) shift  :: ( 'm::len)Word.word)))"


(*val place_slice : forall 'n 'm . Size 'm, Size 'n => integer -> mword 'n -> ii -> ii -> ii -> mword 'm*)

definition place_slice  :: " int \<Rightarrow>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('m::len)Word.word "  where 
     " place_slice (m__tv :: int) xs i l shift = (
   (let xs =
     ((shiftr ((and_vec xs ((slice_mask ((int (size xs))) i l  :: ( 'n::len)Word.word))  :: ( 'n::len)Word.word)) i  :: ( 'n::len)Word.word)) in
   (shiftl ((extzv m__tv xs  :: ( 'm::len)Word.word)) shift  :: ( 'm::len)Word.word)))"


(*val zext_slice : forall 'n 'm . Size 'm, Size 'n => integer -> mword 'n -> ii -> ii -> mword 'm*)

definition zext_slice  :: " int \<Rightarrow>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('m::len)Word.word "  where 
     " zext_slice (m__tv :: int) xs i l = (
   (let xs =
     ((shiftr ((and_vec xs ((slice_mask ((int (size xs))) i l  :: ( 'n::len)Word.word))  :: ( 'n::len)Word.word)) i  :: ( 'n::len)Word.word)) in
   (extzv m__tv xs  :: ( 'm::len)Word.word)))"


(*val sext_slice : forall 'n 'm . Size 'm, Size 'n => integer -> mword 'n -> ii -> ii -> mword 'm*)

definition sext_slice  :: " int \<Rightarrow>('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('m::len)Word.word "  where 
     " sext_slice (m__tv :: int) xs i l = (
   (let xs =
     ((arith_shiftr
        ((shiftl ((and_vec xs ((slice_mask ((int (size xs))) i l  :: ( 'n::len)Word.word))  :: ( 'n::len)Word.word))
            ((((((int (size xs))) - i)) - l))
           :: ( 'n::len)Word.word)) ((((int (size xs))) - l))
       :: ( 'n::len)Word.word)) in
   (extsv m__tv xs  :: ( 'm::len)Word.word)))"


(*val unsigned_slice : forall 'n . Size 'n => mword 'n -> ii -> ii -> ii*)

definition unsigned_slice  :: "('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int "  where 
     " unsigned_slice xs i l = (
   (let xs =
     ((shiftr ((and_vec xs ((slice_mask ((int (size xs))) i l  :: ( 'n::len)Word.word))  :: ( 'n::len)Word.word)) i  :: ( 'n::len)Word.word)) in
   Word.uint xs))"


(*val unsigned_subrange : forall 'n . Size 'n => mword 'n -> ii -> ii -> ii*)

definition unsigned_subrange  :: "('n::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow> int "  where 
     " unsigned_subrange xs i j = (
   (let xs =
     ((shiftr
        ((and_vec xs
            ((slice_mask ((int (size xs))) j ((((i - j)) + (( 1 :: int)::ii)))  :: ( 'n::len)Word.word))
           :: ( 'n::len)Word.word)) i
       :: ( 'n::len)Word.word)) in
   Word.uint xs))"


(*val zext_ones : forall 'n . Size 'n => integer -> ii -> mword 'n*)

definition zext_ones  :: " int \<Rightarrow> int \<Rightarrow>('n::len)Word.word "  where 
     " zext_ones (n__tv :: int) m = (
   (let v = ((extsv n__tv (vec_of_bits [B1]  ::  1 Word.word)  :: ( 'n::len)Word.word)) in
   (shiftr v ((((int (size v))) - m))  :: ( 'n::len)Word.word)))"


(*val tlbEntryMatch : mword ty2 -> mword ty27 -> mword ty8 -> TLBEntry -> bool*)

definition tlbEntryMatch  :: "(2)Word.word \<Rightarrow>(27)Word.word \<Rightarrow>(8)Word.word \<Rightarrow> TLBEntry \<Rightarrow> bool "  where 
     " tlbEntryMatch r vpn2 asid entry = (
   (let entryValid = ((get_TLBEntry_valid entry  ::  1 Word.word)) in
   (let entryR = ((get_TLBEntry_r entry  ::  2 Word.word)) in
   (let entryMask = ((get_TLBEntry_pagemask entry  ::  16 Word.word)) in
   (let entryVPN = ((get_TLBEntry_vpn2 entry  ::  27 Word.word)) in
   (let entryASID = ((get_TLBEntry_asid entry  ::  8 Word.word)) in
   (let entryG = ((get_TLBEntry_g entry  ::  1 Word.word)) in
   (let (vpnMask :: 27 bits) =
     ((not_vec ((mips_zero_extend (( 27 :: int)::ii) entryMask  ::  27 Word.word))  ::  27 Word.word)) in
   (((bits_to_bool entryValid)) \<and> ((((((r = entryR))) \<and> ((((((((and_vec vpn2 vpnMask  ::  27 Word.word)) = ((and_vec entryVPN vpnMask  ::  27 Word.word))))) \<and> ((((((asid = entryASID))) \<or> ((bits_to_bool entryG))))))))))))))))))))"


(*val tlbSearch : mword ty64 -> M (maybe (mword ty6))*)

definition tlbSearch  :: "(64)Word.word \<Rightarrow>((register_value),(((6)Word.word)option),(exception))monad "  where 
     " tlbSearch VAddr = (
   catch_early_return
     ((let r = ((subrange_vec_dec VAddr (( 63 :: int)::ii) (( 62 :: int)::ii)  ::  2 Word.word)) in
     (let vpn2 = ((subrange_vec_dec VAddr (( 39 :: int)::ii) (( 13 :: int)::ii)  ::  27 Word.word)) in
     liftR (read_reg TLBEntryHi_ref) \<bind> (\<lambda> (w__0 :: TLBEntryHiReg) . 
     (let asid = ((get_TLBEntryHiReg_ASID w__0  ::  8 Word.word)) in
     (foreachM (index_list (( 0 :: int)::ii) (( 63 :: int)::ii) (( 1 :: int)::ii)) () 
       (\<lambda> idx unit_var . 
         liftR (reg_deref ((access_list_dec TLBEntries idx))) \<bind> (\<lambda> (w__1 :: TLBEntry) . 
         if ((tlbEntryMatch r vpn2 asid w__1)) then
           (early_return (Some ((to_bits ((make_the_value (( 6 :: int)::ii)  ::  6 itself)) idx  ::  6 Word.word))) :: (unit, ( ( 6 Word.word)option))
             MR)
         else return () ))) \<then>
     return None))))))"


(*val TLBTranslate2 : mword ty64 -> MemAccessType -> M (mword ty64 * bool)*)

definition TLBTranslate2  :: "(64)Word.word \<Rightarrow> MemAccessType \<Rightarrow>((register_value),((64)Word.word*bool),(exception))monad "  where 
     " TLBTranslate2 vAddr accessType = (
   (tlbSearch vAddr  :: ( ( 6 Word.word)option) M) \<bind> (\<lambda> idx . 
   (case  idx of
     Some (idx) =>
      (let i = (Word.uint idx) in
      reg_deref ((access_list_dec TLBEntries i)) \<bind> (\<lambda> entry . 
      (let entryMask = ((get_TLBEntry_pagemask entry  ::  16 Word.word)) in
      (let b__0 = entryMask in
      (if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  16 Word.word)))) then
         return (( 12 :: int)::ii)
       else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1]  ::  16 Word.word))))
       then
         return (( 14 :: int)::ii)
       else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1,B1,B1]  ::  16 Word.word))))
       then
         return (( 16 :: int)::ii)
       else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1,B1,B1,B1,B1]  ::  16 Word.word))))
       then
         return (( 18 :: int)::ii)
       else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B1,B1,B1,B1,B1,B1,B1,B1]  ::  16 Word.word))))
       then
         return (( 20 :: int)::ii)
       else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1]  ::  16 Word.word))))
       then
         return (( 22 :: int)::ii)
       else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1]  ::  16 Word.word))))
       then
         return (( 24 :: int)::ii)
       else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1]  ::  16 Word.word))))
       then
         return (( 26 :: int)::ii)
       else if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1]  ::  16 Word.word))))
       then
         return (( 28 :: int)::ii)
       else undefined_range (( 12 :: int)::ii) (( 28 :: int)::ii)) \<bind> (\<lambda> (evenOddBit :: int) . 
      (let isOdd = (access_vec_dec vAddr evenOddBit) in
      (let ((caps :: 1 bits), (capl :: 1 bits), (pfn :: 24 bits), (d :: 1 bits), (v :: 1 bits)) =
        (if ((bit_to_bool isOdd)) then
          ((get_TLBEntry_caps1 entry  ::  1 Word.word),
           (get_TLBEntry_capl1 entry  ::  1 Word.word),
           (get_TLBEntry_pfn1 entry  ::  24 Word.word),
           (get_TLBEntry_d1 entry  ::  1 Word.word),
           (get_TLBEntry_v1 entry  ::  1 Word.word))
        else
          ((get_TLBEntry_caps0 entry  ::  1 Word.word),
           (get_TLBEntry_capl0 entry  ::  1 Word.word),
           (get_TLBEntry_pfn0 entry  ::  24 Word.word),
           (get_TLBEntry_d0 entry  ::  1 Word.word),
           (get_TLBEntry_v0 entry  ::  1 Word.word))) in
      if ((\<not> ((bits_to_bool v)))) then
        (SignalExceptionTLB (if (((accessType = StoreData))) then XTLBInvS else XTLBInvL) vAddr
          :: (( 64 Word.word * bool)) M)
      else if ((((((accessType = StoreData))) \<and> ((\<not> ((bits_to_bool d))))))) then
        (SignalExceptionTLB TLBMod vAddr  :: (( 64 Word.word * bool)) M)
      else
        (let (res :: 64 bits) =
          ((mips_zero_extend (( 64 :: int)::ii)
             ((subrange_subrange_concat
                 (((((((( 23 :: int)::ii) -
                             ((((evenOddBit - (( 12 :: int)::ii))) - (( 1 :: int)::ii)))))
                         +
                         ((evenOddBit - (( 1 :: int)::ii)))))
                     - (((( 0 :: int)::ii) - (( 1 :: int)::ii))))) pfn
                 (( 23 :: int)::ii) ((evenOddBit - (( 12 :: int)::ii))) vAddr
                 ((evenOddBit - (( 1 :: int)::ii))) (( 0 :: int)::ii)
                ::  36 Word.word))
            ::  64 Word.word)) in
        return (res, bits_to_bool (if (((accessType = StoreData))) then caps else capl))))))))))
   | None =>
      (SignalExceptionTLB (if (((accessType = StoreData))) then XTLBRefillS else XTLBRefillL) vAddr
        :: (( 64 Word.word * bool)) M)
   )))"


(*val TLBTranslateC : mword ty64 -> MemAccessType -> M (mword ty64 * bool)*)

definition TLBTranslateC  :: "(64)Word.word \<Rightarrow> MemAccessType \<Rightarrow>((register_value),((64)Word.word*bool),(exception))monad "  where 
     " TLBTranslateC vAddr accessType = (
   getAccessLevel ()  \<bind> (\<lambda> currentAccessLevel . 
   (let compat32 =
     (((subrange_vec_dec vAddr (( 61 :: int)::ii) (( 31 :: int)::ii)  ::  31 Word.word)) = (vec_of_bits [B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,
                     B1,B1,B1,B1,B1]
         ::  31 Word.word)) in
   (let b__0 = ((subrange_vec_dec vAddr (( 63 :: int)::ii) (( 62 :: int)::ii)  ::  2 Word.word)) in
   (let ((requiredLevel :: AccessLevel), (addr ::  ( 64 bits)option)) =
     (if (((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) then
       (case  (compat32, (subrange_vec_dec vAddr (( 30 :: int)::ii) (( 29 :: int)::ii)  ::  2 Word.word)) of
         (True, b__1) =>
          if (((b__1 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) then (Kernel, None)
          else if (((b__1 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then (Supervisor, None)
          else if (((b__1 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
            (Kernel,
             Some ((concat_vec
                      (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                    B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
                        ::  32 Word.word)
                      ((concat_vec (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                          ((subrange_vec_dec vAddr (( 28 :: int)::ii) (( 0 :: int)::ii)  ::  29 Word.word))
                         ::  32 Word.word))
                     ::  64 Word.word)))
          else if (((b__1 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
            (Kernel,
             Some ((concat_vec
                      (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                    B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
                        ::  32 Word.word)
                      ((concat_vec (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                          ((subrange_vec_dec vAddr (( 28 :: int)::ii) (( 0 :: int)::ii)  ::  29 Word.word))
                         ::  32 Word.word))
                     ::  64 Word.word)))
          else (case  (True, b__1) of   (g__17, g__18) => (Kernel, None) )
       | (g__17, g__18) => (Kernel, None)
       )
     else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
       (Kernel,
        Some ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
                 ((subrange_vec_dec vAddr (( 58 :: int)::ii) (( 0 :: int)::ii)  ::  59 Word.word))
                ::  64 Word.word)))
     else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then (Supervisor, None)
     else (User, None)) in
   if ((\<not> ((grantsAccess currentAccessLevel requiredLevel)))) then
     (SignalExceptionBadAddr (if (((accessType = StoreData))) then AdES else AdEL) vAddr
       :: (( 64 Word.word * bool)) M)
   else
     (case  addr of
       Some (a) => return (a, False)
     | None =>
        if (((((\<not> compat32)) \<and> ((((Word.uint ((subrange_vec_dec vAddr (( 61 :: int)::ii) (( 0 :: int)::ii)  ::  62 Word.word)))) > MAX_VA))))) then
          (SignalExceptionBadAddr (if (((accessType = StoreData))) then AdES else AdEL) vAddr
            :: (( 64 Word.word * bool)) M)
        else (TLBTranslate2 vAddr accessType  :: (( 64 Word.word * bool)) M)
     ) \<bind> (\<lambda> varstup .  (let ((pa :: 64 bits), (c :: bool)) = varstup in
     if ((((Word.uint pa)) > MAX_PA)) then
       (SignalExceptionBadAddr (if (((accessType = StoreData))) then AdES else AdEL) vAddr
         :: (( 64 Word.word * bool)) M)
     else return (pa, c))))))))"


(*val TLBTranslate : mword ty64 -> MemAccessType -> M (mword ty64)*)

definition TLBTranslate  :: "(64)Word.word \<Rightarrow> MemAccessType \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " TLBTranslate vAddr accessType = (
   (TLBTranslateC vAddr accessType  :: (( 64 Word.word * bool)) M) \<bind> (\<lambda> varstup .  (let (addr, c) = varstup in
   return addr)))"


(*val CPtrCmpOp_of_num : integer -> CPtrCmpOp*)

definition CPtrCmpOp_of_num  :: " int \<Rightarrow> CPtrCmpOp "  where 
     " CPtrCmpOp_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then CEQ
   else if (((p00 = (( 1 :: int)::ii)))) then CNE
   else if (((p00 = (( 2 :: int)::ii)))) then CLT
   else if (((p00 = (( 3 :: int)::ii)))) then CLE
   else if (((p00 = (( 4 :: int)::ii)))) then CLTU
   else if (((p00 = (( 5 :: int)::ii)))) then CLEU
   else if (((p00 = (( 6 :: int)::ii)))) then CEXEQ
   else CNEXEQ))"


(*val num_of_CPtrCmpOp : CPtrCmpOp -> integer*)

fun num_of_CPtrCmpOp  :: " CPtrCmpOp \<Rightarrow> int "  where 
     " num_of_CPtrCmpOp CEQ = ( (( 0 :: int)::ii))"
|" num_of_CPtrCmpOp CNE = ( (( 1 :: int)::ii))"
|" num_of_CPtrCmpOp CLT = ( (( 2 :: int)::ii))"
|" num_of_CPtrCmpOp CLE = ( (( 3 :: int)::ii))"
|" num_of_CPtrCmpOp CLTU = ( (( 4 :: int)::ii))"
|" num_of_CPtrCmpOp CLEU = ( (( 5 :: int)::ii))"
|" num_of_CPtrCmpOp CEXEQ = ( (( 6 :: int)::ii))"
|" num_of_CPtrCmpOp CNEXEQ = ( (( 7 :: int)::ii))"


(*val undefined_CPtrCmpOp : unit -> M CPtrCmpOp*)

definition undefined_CPtrCmpOp  :: " unit \<Rightarrow>((register_value),(CPtrCmpOp),(exception))monad "  where 
     " undefined_CPtrCmpOp _ = ( internal_pick [CEQ,CNE,CLT,CLE,CLTU,CLEU,CEXEQ,CNEXEQ])"


(*val ClearRegSet_of_num : integer -> ClearRegSet*)

definition ClearRegSet_of_num  :: " int \<Rightarrow> ClearRegSet "  where 
     " ClearRegSet_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then GPLo
   else if (((p00 = (( 1 :: int)::ii)))) then GPHi
   else if (((p00 = (( 2 :: int)::ii)))) then CLo
   else CHi))"


(*val num_of_ClearRegSet : ClearRegSet -> integer*)

fun num_of_ClearRegSet  :: " ClearRegSet \<Rightarrow> int "  where 
     " num_of_ClearRegSet GPLo = ( (( 0 :: int)::ii))"
|" num_of_ClearRegSet GPHi = ( (( 1 :: int)::ii))"
|" num_of_ClearRegSet CLo = ( (( 2 :: int)::ii))"
|" num_of_ClearRegSet CHi = ( (( 3 :: int)::ii))"


(*val undefined_ClearRegSet : unit -> M ClearRegSet*)

definition undefined_ClearRegSet  :: " unit \<Rightarrow>((register_value),(ClearRegSet),(exception))monad "  where 
     " undefined_ClearRegSet _ = ( internal_pick [GPLo,GPHi,CLo,CHi])"


(*val undefined_CapStruct : unit -> M CapStruct*)

definition undefined_CapStruct  :: " unit \<Rightarrow>((register_value),(CapStruct),(exception))monad "  where 
     " undefined_CapStruct _ = (
   undefined_bool ()  \<bind> (\<lambda> (w__0 :: bool) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__1 ::  8 Word.word) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 24 :: int)::ii)  :: ( 24 Word.word) M) \<bind> (\<lambda> (w__2 ::  24 Word.word) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__3 ::  16 Word.word) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 4 :: int)::ii)  :: ( 4 Word.word) M) \<bind> (\<lambda> (w__4 ::  4 Word.word) . 
   undefined_bool ()  \<bind> (\<lambda> (w__5 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (w__6 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (w__7 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (w__8 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (w__9 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (w__10 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (w__11 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (w__12 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (w__13 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (w__14 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (w__15 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (w__16 :: bool) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__17 ::  64 Word.word) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__18 ::  64 Word.word) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__19 ::  64 Word.word) . 
   return ((| CapStruct_tag = w__0, 
              CapStruct_padding = w__1, 
              CapStruct_otype = w__2, 
              CapStruct_uperms = w__3, 
              CapStruct_perm_reserved11_14 = w__4, 
              CapStruct_access_system_regs = w__5, 
              CapStruct_permit_unseal = w__6, 
              CapStruct_permit_ccall = w__7, 
              CapStruct_permit_seal = w__8, 
              CapStruct_permit_store_local_cap = w__9, 
              CapStruct_permit_store_cap = w__10, 
              CapStruct_permit_load_cap = w__11, 
              CapStruct_permit_store = w__12, 
              CapStruct_permit_load = w__13, 
              CapStruct_permit_execute = w__14, 
              CapStruct_global = w__15, 
              CapStruct_sealed = w__16, 
              CapStruct_address = w__17, 
              CapStruct_base = w__18, 
              CapStruct_length = w__19 |)))))))))))))))))))))))"


definition default_cap  :: " CapStruct "  where 
     " default_cap = (
  (| CapStruct_tag = True, 
     CapStruct_padding = ((zeros0 (( 8 :: int)::ii) ()   ::  8 Word.word)), 
     CapStruct_otype = ((zeros0 (( 24 :: int)::ii) ()   ::  24 Word.word)), 
     CapStruct_uperms = ((ones (( 16 :: int)::ii) ()   ::  16 Word.word)), 
     CapStruct_perm_reserved11_14 = ((zeros0 (( 4 :: int)::ii) ()   ::  4 Word.word)), 
     CapStruct_access_system_regs = True, 
     CapStruct_permit_unseal = True, 
     CapStruct_permit_ccall = True, 
     CapStruct_permit_seal = True, 
     CapStruct_permit_store_local_cap = True, 
     CapStruct_permit_store_cap = True, 
     CapStruct_permit_load_cap = True, 
     CapStruct_permit_store = True, 
     CapStruct_permit_load = True, 
     CapStruct_permit_execute = True, 
     CapStruct_global = True, 
     CapStruct_sealed = False, 
     CapStruct_address = ((zeros0 (( 64 :: int)::ii) ()   ::  64 Word.word)), 
     CapStruct_base = ((zeros0 (( 64 :: int)::ii) ()   ::  64 Word.word)), 
     CapStruct_length =
       ((vec_of_bits [B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,
                     B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,
                     B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1]
         ::  64 Word.word)) |) )"


definition null_cap_bits  :: "(256)Word.word "  where 
     " null_cap_bits = ( (capStructToMemBits256 null_cap  ::  256 Word.word))"


(*val capStructToMemBits : CapStruct -> mword ty256*)

definition capStructToMemBits  :: " CapStruct \<Rightarrow>(256)Word.word "  where 
     " capStructToMemBits cap = (
   (xor_vec ((capStructToMemBits256 cap  ::  256 Word.word)) null_cap_bits  ::  256 Word.word))"


(*val memBitsToCapBits : bool -> mword ty256 -> mword ty257*)

definition memBitsToCapBits  :: " bool \<Rightarrow>(256)Word.word \<Rightarrow>(257)Word.word "  where 
     " memBitsToCapBits tag b = (
   (concat_vec ((bool_to_bits tag  ::  1 Word.word)) ((xor_vec b null_cap_bits  ::  256 Word.word))
     ::  257 Word.word))"


(*val setCapPerms : CapStruct -> mword ty31 -> CapStruct*)

definition setCapPerms  :: " CapStruct \<Rightarrow>(31)Word.word \<Rightarrow> CapStruct "  where 
     " setCapPerms cap perms = (
   (cap (|
     CapStruct_uperms := ((subrange_vec_dec perms (( 30 :: int)::ii) (( 15 :: int)::ii)  ::  16 Word.word)), CapStruct_access_system_regs :=
       ((bit_to_bool ((access_vec_dec perms (( 10 :: int)::ii))))), CapStruct_permit_unseal :=
       ((bit_to_bool ((access_vec_dec perms (( 9 :: int)::ii))))), CapStruct_permit_ccall :=
       ((bit_to_bool ((access_vec_dec perms (( 8 :: int)::ii))))), CapStruct_permit_seal :=
       ((bit_to_bool ((access_vec_dec perms (( 7 :: int)::ii))))), CapStruct_permit_store_local_cap :=
       ((bit_to_bool ((access_vec_dec perms (( 6 :: int)::ii))))), CapStruct_permit_store_cap :=
       ((bit_to_bool ((access_vec_dec perms (( 5 :: int)::ii))))), CapStruct_permit_load_cap :=
       ((bit_to_bool ((access_vec_dec perms (( 4 :: int)::ii))))), CapStruct_permit_store :=
       ((bit_to_bool ((access_vec_dec perms (( 3 :: int)::ii))))), CapStruct_permit_load :=
       ((bit_to_bool ((access_vec_dec perms (( 2 :: int)::ii))))), CapStruct_permit_execute :=
       ((bit_to_bool ((access_vec_dec perms (( 1 :: int)::ii))))), CapStruct_global :=
       ((bit_to_bool ((access_vec_dec perms (( 0 :: int)::ii)))))|)))"


(*val sealCap : CapStruct -> mword ty24 -> (bool * CapStruct)*)

definition sealCap  :: " CapStruct \<Rightarrow>(24)Word.word \<Rightarrow> bool*CapStruct "  where 
     " sealCap cap otype = ( (True, (cap (| CapStruct_sealed := True, CapStruct_otype := otype |))))"


(*val getCapTop : CapStruct -> integer*)

definition getCapTop  :: " CapStruct \<Rightarrow> int "  where 
     " getCapTop c = ( ((Word.uint(CapStruct_base   c))) + ((Word.uint(CapStruct_length   c))))"


(*val getCapOffset : CapStruct -> integer*)

definition getCapOffset  :: " CapStruct \<Rightarrow> int "  where 
     " getCapOffset c = (
   hardware_mod ((((Word.uint(CapStruct_address   c))) - ((Word.uint(CapStruct_base   c)))))
     ((pow2 (( 64 :: int)::ii))))"


(*val getCapLength : CapStruct -> integer*)

definition getCapLength  :: " CapStruct \<Rightarrow> int "  where 
     " getCapLength c = ( Word.uint(CapStruct_length   c))"


(*val getCapCursor : CapStruct -> integer*)

definition getCapCursor  :: " CapStruct \<Rightarrow> int "  where 
     " getCapCursor c = ( Word.uint(CapStruct_address   c))"


(*
function{incCapOffset} is the same as function{setCapOffset} except that the 64-bit value is added to the current capability offset modulo $2^{64}$ (i.e. signed twos-complement arithemtic).
 *)
(*val incCapOffset : CapStruct -> mword ty64 -> (bool * CapStruct)*)

definition incCapOffset  :: " CapStruct \<Rightarrow>(64)Word.word \<Rightarrow> bool*CapStruct "  where 
     " incCapOffset c delta = (
   (let (newAddr :: 64 bits) = ((add_vec(CapStruct_address   c) delta  ::  64 Word.word)) in
   (True, (c (| CapStruct_address := newAddr |)))))"


(*
Returns a capability derived from the given capability by setting the base and top to values provided.  The offset of the resulting capability is zero.  In case the requested bounds are not exactly representable the returned boolean is false and the returned capability has bounds at least including the region bounded by base and top but rounded to representable values.
 *)
(*val setCapBounds : CapStruct -> mword ty64 -> mword ty65 -> (bool * CapStruct)*)

definition setCapBounds  :: " CapStruct \<Rightarrow>(64)Word.word \<Rightarrow>(65)Word.word \<Rightarrow> bool*CapStruct "  where 
     " setCapBounds cap base top1 = (
   (let (length1 :: 65 bits) =
     ((sub_vec top1 ((concat_vec (vec_of_bits [B0]  ::  1 Word.word) base  ::  65 Word.word))  ::  65 Word.word)) in
   (True,
    (cap (|
      CapStruct_base := base, CapStruct_length :=
        ((subrange_vec_dec length1 (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word)), CapStruct_address := base |)))))"


(*val undefined_ast : unit -> M ast*)

definition undefined_ast  :: " unit \<Rightarrow>((register_value),(ast),(exception))monad "  where 
     " undefined_ast _ = (
   undefined_CPtrCmpOp ()  \<bind> (\<lambda> (u_0 :: CPtrCmpOp) . 
   undefined_ClearRegSet ()  \<bind> (\<lambda> (u_1 :: ClearRegSet) . 
   undefined_Comparison ()  \<bind> (\<lambda> (u_2 :: Comparison) . 
   undefined_WordType ()  \<bind> (\<lambda> (u_3 :: WordType) . 
   undefined_bool ()  \<bind> (\<lambda> (u_5 :: bool) . 
   undefined_bool ()  \<bind> (\<lambda> (u_4 :: bool) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (u_6 :: imm16) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 5 :: int)::ii)  :: ( 5 Word.word) M) \<bind> (\<lambda> (u_10 :: regno) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 5 :: int)::ii)  :: ( 5 Word.word) M) \<bind> (\<lambda> (u_9 :: regno) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 5 :: int)::ii)  :: ( 5 Word.word) M) \<bind> (\<lambda> (u_8 :: regno) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 5 :: int)::ii)  :: ( 5 Word.word) M) \<bind> (\<lambda> (u_7 :: regno) . 
   undefined_unit ()  \<bind> (\<lambda> (u_11 :: unit) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 3 :: int)::ii)  :: ( 3 Word.word) M) \<bind> (\<lambda> (u_12 :: 3 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 8 :: int)::ii)  :: ( 8 Word.word) M) \<bind> (\<lambda> (u_13 :: 8 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 11 :: int)::ii)  :: ( 11 Word.word) M) \<bind> (\<lambda> (u_14 :: 11 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (u_15 :: 16 bits) . 
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 26 :: int)::ii)  :: ( 26 Word.word) M) \<bind> (\<lambda> (u_16 :: 26 bits) . 
   internal_pick
     [DADDIU (u_8,u_7,u_6),DADDU (u_9,u_8,u_7),DADDI (u_8,u_7,u_15),DADD (u_9,u_8,u_7),ADD (u_9,u_8,u_7),ADDI (u_8,u_7,u_15),ADDU (u_9,u_8,u_7),ADDIU (u_8,u_7,u_15),DSUBU (u_9,u_8,u_7),DSUB (u_9,u_8,u_7),SUB (u_9,u_8,u_7),SUBU (u_9,u_8,u_7),AND0 (u_9,u_8,u_7),ANDI (u_8,u_7,u_15),OR0 (u_9,u_8,u_7),ORI (u_8,u_7,u_15),NOR (u_9,u_8,u_7),XOR0 (u_9,u_8,u_7),XORI (u_8,u_7,u_15),LUI (u_7,u_6),DSLL (u_9,u_8,u_7),DSLL32 (u_9,u_8,u_7),DSLLV (u_9,u_8,u_7),DSRA (u_9,u_8,u_7),DSRA32 (u_9,u_8,u_7),DSRAV (u_9,u_8,u_7),DSRL (u_9,u_8,u_7),DSRL32 (u_9,u_8,u_7),DSRLV (u_9,u_8,u_7),SLL (u_9,u_8,u_7),SLLV (u_9,u_8,u_7),SRA (u_9,u_8,u_7),SRAV (u_9,u_8,u_7),SRL (u_9,u_8,u_7),SRLV (u_9,u_8,u_7),SLT (u_9,u_8,u_7),SLTI (u_8,u_7,u_15),SLTU (u_9,u_8,u_7),SLTIU (u_8,u_7,u_15),MOVN (u_9,u_8,u_7),MOVZ (u_9,u_8,u_7),MFHI u_7,MFLO u_7,MTHI u_7,MTLO u_7,MUL (u_9,u_8,u_7),MULT (u_8,u_7),MULTU (u_8,u_7),DMULT (u_8,u_7),DMULTU (u_8,u_7),MADD (u_8,u_7),MADDU (u_8,u_7),MSUB (u_8,u_7),MSUBU (u_8,u_7),DIV (u_8,u_7),DIVU (u_8,u_7),DDIV (u_8,u_7),DDIVU (u_8,u_7),J u_16,JAL u_16,JR u_7,JALR (u_8,u_7),BEQ (u_8,u_7,u_6,u_5,u_4),BCMPZ (u_7,u_6,u_2,u_5,u_4),SYSCALL u_11,BREAK u_11,WAIT u_11,TRAPREG (u_8,u_7,u_2),TRAPIMM (u_7,u_6,u_2),Load (u_3,u_5,u_4,u_8,u_7,u_6),Store (u_3,u_4,u_8,u_7,u_6),LWL (u_8,u_7,u_15),LWR (u_8,u_7,u_15),SWL (u_8,u_7,u_15),SWR (u_8,u_7,u_15),LDL (u_8,u_7,u_15),LDR (u_8,u_7,u_15),SDL (u_8,u_7,u_15),SDR (u_8,u_7,u_15),CACHE (u_8,u_7,u_15),SYNC u_11,MFC0 (u_8,u_7,u_12,u_4),HCF u_11,MTC0 (u_8,u_7,u_12,u_4),TLBWI u_11,TLBWR u_11,TLBR u_11,TLBP u_11,RDHWR (u_8,u_7),ERET u_11,CGetPerm (u_8,u_7),CGetType (u_8,u_7),CGetBase (u_8,u_7),CGetLen (u_8,u_7),CGetTag (u_8,u_7),CGetSealed (u_8,u_7),CGetOffset (u_8,u_7),CGetAddr (u_8,u_7),CGetPCC u_7,CGetPCCSetOffset (u_8,u_7),CGetCause u_7,CSetCause u_7,CReadHwr (u_8,u_7),CWriteHwr (u_8,u_7),CAndPerm (u_9,u_8,u_7),CToPtr (u_9,u_8,u_7),CSub (u_9,u_8,u_7),CPtrCmp (u_9,u_8,u_7,u_0),CIncOffset (u_9,u_8,u_7),CIncOffsetImmediate (u_8,u_7,u_14),CSetOffset (u_9,u_8,u_7),CSetBounds (u_9,u_8,u_7),CSetBoundsImmediate (u_8,u_7,u_14),CSetBoundsExact (u_9,u_8,u_7),CClearTag (u_8,u_7),CMOVX (u_9,u_8,u_7,u_4),ClearRegs (u_1,u_15),CFromPtr (u_9,u_8,u_7),CBuildCap (u_9,u_8,u_7),CCopyType (u_9,u_8,u_7),CCheckPerm (u_8,u_7),CCheckType (u_8,u_7),CTestSubset (u_9,u_8,u_7),CSeal (u_9,u_8,u_7),CCSeal (u_9,u_8,u_7),CUnseal (u_9,u_8,u_7),CCall (u_8,u_7,u_14),CReturn u_11,CBX (u_7,u_15,u_4),CBZ (u_7,u_15,u_4),CJALR (u_8,u_7,u_4),CLoad (u_9,u_8,u_7,u_13,u_5,u_3,u_4),CStore (u_10,u_9,u_8,u_7,u_13,u_3,u_4),CSC (u_10,u_9,u_8,u_7,u_14,u_4),CLC (u_9,u_8,u_7,u_15,u_4),C2Dump u_7,RI u_11]))))))))))))))))))"


(*val execute : ast -> M unit*)

(*val decode : mword ty32 -> maybe ast*)

definition IDCNO  :: "(5)Word.word "  where 
     " IDCNO = ( (vec_of_bits [B1,B1,B0,B1,B0]  ::  5 Word.word))"


definition KR1CNO  :: "(5)Word.word "  where 
     " KR1CNO = ( (vec_of_bits [B1,B1,B0,B1,B1]  ::  5 Word.word))"


definition KR2CNO  :: "(5)Word.word "  where 
     " KR2CNO = ( (vec_of_bits [B1,B1,B1,B0,B0]  ::  5 Word.word))"


definition KCCNO  :: "(5)Word.word "  where 
     " KCCNO = ( (vec_of_bits [B1,B1,B1,B0,B1]  ::  5 Word.word))"


definition KDCNO  :: "(5)Word.word "  where 
     " KDCNO = ( (vec_of_bits [B1,B1,B1,B1,B0]  ::  5 Word.word))"


definition EPCCNO  :: "(5)Word.word "  where 
     " EPCCNO = ( (vec_of_bits [B1,B1,B1,B1,B1]  ::  5 Word.word))"


definition CapRegs  :: "(((regstate),(register_value),((257)Word.word))register_ref)list "  where 
     " CapRegs = (
  [C31_ref,C30_ref,C29_ref,C28_ref,C27_ref,C26_ref,C25_ref,C24_ref,C23_ref,C22_ref,C21_ref,C20_ref,
   C19_ref,C18_ref,C17_ref,C16_ref,C15_ref,C14_ref,C13_ref,C12_ref,C11_ref,C10_ref,C09_ref,C08_ref,
   C07_ref,C06_ref,C05_ref,C04_ref,C03_ref,C02_ref,C01_ref,DDC_ref])"


definition max_otype  :: " int "  where 
     " max_otype = ( MAX0 (( 24 :: int)::ii))"


definition have_cp2  :: " bool "  where 
     " have_cp2 = ( True )"


(*
This function reads a given capability register and returns its contents converted to a CapStruct.
If the argument is zero then the null capability is returned.
*)
(*val readCapReg : mword ty5 -> M CapStruct*)

definition readCapReg  :: "(5)Word.word \<Rightarrow>((register_value),(CapStruct),(exception))monad "  where 
     " readCapReg n = (
   if (((n = (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)))) then return null_cap
   else
     (let i = (Word.uint n) in
     (reg_deref ((access_list_dec CapRegs i  :: (regstate, register_value, ( 257 Word.word)) register_ref))
       :: ( 257 Word.word) M) \<bind> (\<lambda> (w__0 ::  257 Word.word) . 
     return ((capRegToCapStruct w__0)))))"


(*
This is the same as readCapReg except that when the argument is zero the value of DDC is returned 
instead of the null capability. This is used for instructions that expect an address, where using
null would always generate an exception.
*)
(*val readCapRegDDC : mword ty5 -> M CapStruct*)

definition readCapRegDDC  :: "(5)Word.word \<Rightarrow>((register_value),(CapStruct),(exception))monad "  where 
     " readCapRegDDC n = (
   (let i = (Word.uint n) in
   (reg_deref ((access_list_dec CapRegs i  :: (regstate, register_value, ( 257 Word.word)) register_ref))
     :: ( 257 Word.word) M) \<bind> (\<lambda> (w__0 ::  257 Word.word) . 
   return ((capRegToCapStruct w__0)))))"


(*val writeCapReg : mword ty5 -> CapStruct -> M unit*)

definition writeCapReg  :: "(5)Word.word \<Rightarrow> CapStruct \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " writeCapReg n cap = (
   if (((n = (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)))) then return () 
   else
     (let i = (Word.uint n) in
     write_reg
       ((access_list_dec CapRegs i  :: (regstate, register_value, ( 257 Word.word)) register_ref))
       ((capStructToCapReg cap  ::  257 Word.word))))"


(*val CapEx_of_num : integer -> CapEx*)

definition CapEx_of_num  :: " int \<Rightarrow> CapEx "  where 
     " CapEx_of_num arg0 = (
   (let p00 = arg0 in
   if (((p00 = (( 0 :: int)::ii)))) then CapEx_None
   else if (((p00 = (( 1 :: int)::ii)))) then CapEx_LengthViolation
   else if (((p00 = (( 2 :: int)::ii)))) then CapEx_TagViolation
   else if (((p00 = (( 3 :: int)::ii)))) then CapEx_SealViolation
   else if (((p00 = (( 4 :: int)::ii)))) then CapEx_TypeViolation
   else if (((p00 = (( 5 :: int)::ii)))) then CapEx_CallTrap
   else if (((p00 = (( 6 :: int)::ii)))) then CapEx_ReturnTrap
   else if (((p00 = (( 7 :: int)::ii)))) then CapEx_TSSUnderFlow
   else if (((p00 = (( 8 :: int)::ii)))) then CapEx_UserDefViolation
   else if (((p00 = (( 9 :: int)::ii)))) then CapEx_TLBNoStoreCap
   else if (((p00 = (( 10 :: int)::ii)))) then CapEx_InexactBounds
   else if (((p00 = (( 11 :: int)::ii)))) then CapEx_GlobalViolation
   else if (((p00 = (( 12 :: int)::ii)))) then CapEx_PermitExecuteViolation
   else if (((p00 = (( 13 :: int)::ii)))) then CapEx_PermitLoadViolation
   else if (((p00 = (( 14 :: int)::ii)))) then CapEx_PermitStoreViolation
   else if (((p00 = (( 15 :: int)::ii)))) then CapEx_PermitLoadCapViolation
   else if (((p00 = (( 16 :: int)::ii)))) then CapEx_PermitStoreCapViolation
   else if (((p00 = (( 17 :: int)::ii)))) then CapEx_PermitStoreLocalCapViolation
   else if (((p00 = (( 18 :: int)::ii)))) then CapEx_PermitSealViolation
   else if (((p00 = (( 19 :: int)::ii)))) then CapEx_AccessSystemRegsViolation
   else if (((p00 = (( 20 :: int)::ii)))) then CapEx_PermitCCallViolation
   else if (((p00 = (( 21 :: int)::ii)))) then CapEx_AccessCCallIDCViolation
   else CapEx_PermitUnsealViolation))"


(*val num_of_CapEx : CapEx -> integer*)

fun num_of_CapEx  :: " CapEx \<Rightarrow> int "  where 
     " num_of_CapEx CapEx_None = ( (( 0 :: int)::ii))"
|" num_of_CapEx CapEx_LengthViolation = ( (( 1 :: int)::ii))"
|" num_of_CapEx CapEx_TagViolation = ( (( 2 :: int)::ii))"
|" num_of_CapEx CapEx_SealViolation = ( (( 3 :: int)::ii))"
|" num_of_CapEx CapEx_TypeViolation = ( (( 4 :: int)::ii))"
|" num_of_CapEx CapEx_CallTrap = ( (( 5 :: int)::ii))"
|" num_of_CapEx CapEx_ReturnTrap = ( (( 6 :: int)::ii))"
|" num_of_CapEx CapEx_TSSUnderFlow = ( (( 7 :: int)::ii))"
|" num_of_CapEx CapEx_UserDefViolation = ( (( 8 :: int)::ii))"
|" num_of_CapEx CapEx_TLBNoStoreCap = ( (( 9 :: int)::ii))"
|" num_of_CapEx CapEx_InexactBounds = ( (( 10 :: int)::ii))"
|" num_of_CapEx CapEx_GlobalViolation = ( (( 11 :: int)::ii))"
|" num_of_CapEx CapEx_PermitExecuteViolation = ( (( 12 :: int)::ii))"
|" num_of_CapEx CapEx_PermitLoadViolation = ( (( 13 :: int)::ii))"
|" num_of_CapEx CapEx_PermitStoreViolation = ( (( 14 :: int)::ii))"
|" num_of_CapEx CapEx_PermitLoadCapViolation = ( (( 15 :: int)::ii))"
|" num_of_CapEx CapEx_PermitStoreCapViolation = ( (( 16 :: int)::ii))"
|" num_of_CapEx CapEx_PermitStoreLocalCapViolation = ( (( 17 :: int)::ii))"
|" num_of_CapEx CapEx_PermitSealViolation = ( (( 18 :: int)::ii))"
|" num_of_CapEx CapEx_AccessSystemRegsViolation = ( (( 19 :: int)::ii))"
|" num_of_CapEx CapEx_PermitCCallViolation = ( (( 20 :: int)::ii))"
|" num_of_CapEx CapEx_AccessCCallIDCViolation = ( (( 21 :: int)::ii))"
|" num_of_CapEx CapEx_PermitUnsealViolation = ( (( 22 :: int)::ii))"


(*val undefined_CapEx : unit -> M CapEx*)

definition undefined_CapEx  :: " unit \<Rightarrow>((register_value),(CapEx),(exception))monad "  where 
     " undefined_CapEx _ = (
   internal_pick
     [CapEx_None,CapEx_LengthViolation,CapEx_TagViolation,CapEx_SealViolation,CapEx_TypeViolation,CapEx_CallTrap,CapEx_ReturnTrap,CapEx_TSSUnderFlow,CapEx_UserDefViolation,CapEx_TLBNoStoreCap,CapEx_InexactBounds,CapEx_GlobalViolation,CapEx_PermitExecuteViolation,CapEx_PermitLoadViolation,CapEx_PermitStoreViolation,CapEx_PermitLoadCapViolation,CapEx_PermitStoreCapViolation,CapEx_PermitStoreLocalCapViolation,CapEx_PermitSealViolation,CapEx_AccessSystemRegsViolation,CapEx_PermitCCallViolation,CapEx_AccessCCallIDCViolation,CapEx_PermitUnsealViolation])"


(*val CapExCode : CapEx -> mword ty8*)

fun CapExCode  :: " CapEx \<Rightarrow>(8)Word.word "  where 
     " CapExCode CapEx_None = ( (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word))"
|" CapExCode CapEx_LengthViolation = ( (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B1]  ::  8 Word.word))"
|" CapExCode CapEx_TagViolation = ( (vec_of_bits [B0,B0,B0,B0,B0,B0,B1,B0]  ::  8 Word.word))"
|" CapExCode CapEx_SealViolation = ( (vec_of_bits [B0,B0,B0,B0,B0,B0,B1,B1]  ::  8 Word.word))"
|" CapExCode CapEx_TypeViolation = ( (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0]  ::  8 Word.word))"
|" CapExCode CapEx_CallTrap = ( (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B1]  ::  8 Word.word))"
|" CapExCode CapEx_ReturnTrap = ( (vec_of_bits [B0,B0,B0,B0,B0,B1,B1,B0]  ::  8 Word.word))"
|" CapExCode CapEx_TSSUnderFlow = ( (vec_of_bits [B0,B0,B0,B0,B0,B1,B1,B1]  ::  8 Word.word))"
|" CapExCode CapEx_UserDefViolation = ( (vec_of_bits [B0,B0,B0,B0,B1,B0,B0,B0]  ::  8 Word.word))"
|" CapExCode CapEx_TLBNoStoreCap = ( (vec_of_bits [B0,B0,B0,B0,B1,B0,B0,B1]  ::  8 Word.word))"
|" CapExCode CapEx_InexactBounds = ( (vec_of_bits [B0,B0,B0,B0,B1,B0,B1,B0]  ::  8 Word.word))"
|" CapExCode CapEx_GlobalViolation = ( (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0]  ::  8 Word.word))"
|" CapExCode CapEx_PermitExecuteViolation = ( (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B1]  ::  8 Word.word))"
|" CapExCode CapEx_PermitLoadViolation = ( (vec_of_bits [B0,B0,B0,B1,B0,B0,B1,B0]  ::  8 Word.word))"
|" CapExCode CapEx_PermitStoreViolation = ( (vec_of_bits [B0,B0,B0,B1,B0,B0,B1,B1]  ::  8 Word.word))"
|" CapExCode CapEx_PermitLoadCapViolation = ( (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0]  ::  8 Word.word))"
|" CapExCode CapEx_PermitStoreCapViolation = ( (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B1]  ::  8 Word.word))"
|" CapExCode CapEx_PermitStoreLocalCapViolation = ( (vec_of_bits [B0,B0,B0,B1,B0,B1,B1,B0]  ::  8 Word.word))"
|" CapExCode CapEx_PermitSealViolation = ( (vec_of_bits [B0,B0,B0,B1,B0,B1,B1,B1]  ::  8 Word.word))"
|" CapExCode CapEx_AccessSystemRegsViolation = ( (vec_of_bits [B0,B0,B0,B1,B1,B0,B0,B0]  ::  8 Word.word))"
|" CapExCode CapEx_PermitCCallViolation = ( (vec_of_bits [B0,B0,B0,B1,B1,B0,B0,B1]  ::  8 Word.word))"
|" CapExCode CapEx_AccessCCallIDCViolation = ( (vec_of_bits [B0,B0,B0,B1,B1,B0,B1,B0]  ::  8 Word.word))"
|" CapExCode CapEx_PermitUnsealViolation = ( (vec_of_bits [B0,B0,B0,B1,B1,B0,B1,B1]  ::  8 Word.word))"


(*val undefined_CapCauseReg : unit -> M CapCauseReg*)

definition undefined_CapCauseReg  :: " unit \<Rightarrow>((register_value),(CapCauseReg),(exception))monad "  where 
     " undefined_CapCauseReg _ = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__0 ::  16 Word.word) . 
   return ((| CapCauseReg_CapCauseReg_chunk_0 = w__0 |))))"


(*val Mk_CapCauseReg : mword ty16 -> CapCauseReg*)

definition Mk_CapCauseReg  :: "(16)Word.word \<Rightarrow> CapCauseReg "  where 
     " Mk_CapCauseReg v = (
   (| CapCauseReg_CapCauseReg_chunk_0 = ((subrange_vec_dec v (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) |) )"


definition get_CapCauseReg_bits  :: " CapCauseReg \<Rightarrow>(16)Word.word "  where 
     " get_CapCauseReg_bits v = (
   (subrange_vec_dec(CapCauseReg_CapCauseReg_chunk_0   v) (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))"


definition set_CapCauseReg_bits  :: "((regstate),(register_value),(CapCauseReg))register_ref \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_CapCauseReg_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       CapCauseReg_CapCauseReg_chunk_0 :=
         ((update_subrange_vec_dec(CapCauseReg_CapCauseReg_chunk_0   r) (( 15 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
            ::  16 Word.word))|))) in
   write_reg r_ref r)))"


definition update_CapCauseReg_bits  :: " CapCauseReg \<Rightarrow>(16)Word.word \<Rightarrow> CapCauseReg "  where 
     " update_CapCauseReg_bits v x = (
   (v (|
     CapCauseReg_CapCauseReg_chunk_0 :=
       ((update_subrange_vec_dec(CapCauseReg_CapCauseReg_chunk_0   v) (( 15 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
          ::  16 Word.word))|)))"


definition get_CapCauseReg_ExcCode  :: " CapCauseReg \<Rightarrow>(8)Word.word "  where 
     " get_CapCauseReg_ExcCode v = (
   (subrange_vec_dec(CapCauseReg_CapCauseReg_chunk_0   v) (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))"


definition set_CapCauseReg_ExcCode  :: "((regstate),(register_value),(CapCauseReg))register_ref \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_CapCauseReg_ExcCode r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       CapCauseReg_CapCauseReg_chunk_0 :=
         ((update_subrange_vec_dec(CapCauseReg_CapCauseReg_chunk_0   r) (( 15 :: int)::ii) (( 8 :: int)::ii)
             ((subrange_vec_dec v (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
            ::  16 Word.word))|))) in
   write_reg r_ref r)))"


definition update_CapCauseReg_ExcCode  :: " CapCauseReg \<Rightarrow>(8)Word.word \<Rightarrow> CapCauseReg "  where 
     " update_CapCauseReg_ExcCode v x = (
   (v (|
     CapCauseReg_CapCauseReg_chunk_0 :=
       ((update_subrange_vec_dec(CapCauseReg_CapCauseReg_chunk_0   v) (( 15 :: int)::ii) (( 8 :: int)::ii)
           ((subrange_vec_dec x (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
          ::  16 Word.word))|)))"


(*val _get_CapCauseReg_RegNum : CapCauseReg -> mword ty8*)

definition get_CapCauseReg_RegNum  :: " CapCauseReg \<Rightarrow>(8)Word.word "  where 
     " get_CapCauseReg_RegNum v = (
   (subrange_vec_dec(CapCauseReg_CapCauseReg_chunk_0   v) (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))"


(*val _set_CapCauseReg_RegNum : register_ref regstate register_value CapCauseReg -> mword ty8 -> M unit*)

definition set_CapCauseReg_RegNum  :: "((regstate),(register_value),(CapCauseReg))register_ref \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_CapCauseReg_RegNum r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       CapCauseReg_CapCauseReg_chunk_0 :=
         ((update_subrange_vec_dec(CapCauseReg_CapCauseReg_chunk_0   r) (( 7 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
            ::  16 Word.word))|))) in
   write_reg r_ref r)))"


(*val _update_CapCauseReg_RegNum : CapCauseReg -> mword ty8 -> CapCauseReg*)

definition update_CapCauseReg_RegNum  :: " CapCauseReg \<Rightarrow>(8)Word.word \<Rightarrow> CapCauseReg "  where 
     " update_CapCauseReg_RegNum v x = (
   (v (|
     CapCauseReg_CapCauseReg_chunk_0 :=
       ((update_subrange_vec_dec(CapCauseReg_CapCauseReg_chunk_0   v) (( 7 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
          ::  16 Word.word))|)))"


(*val execute_branch_pcc : CapStruct -> M unit*)

definition execute_branch_pcc  :: " CapStruct \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_branch_pcc newPCC = (
   (write_reg
     delayedPC_ref
     ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) ((getCapOffset newPCC))  ::  64 Word.word)) \<then>
   write_reg delayedPCC_ref ((capStructToCapReg newPCC  ::  257 Word.word))) \<then>
   write_reg branchPending_ref (vec_of_bits [B1]  ::  1 Word.word))"


(*val ERETHook : unit -> M unit*)

definition ERETHook  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " ERETHook _ = (
   (read_reg EPCC_ref  :: ( 257 Word.word) M) \<bind> (\<lambda> (w__0 :: CapReg) . 
   (write_reg nextPCC_ref w__0 \<then>
   (read_reg EPCC_ref  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__1 :: CapReg) .  write_reg delayedPCC_ref w__1)))"


(*val raise_c2_exception8 : forall 'o. CapEx -> mword ty8 -> M 'o*)

definition raise_c2_exception8  :: " CapEx \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),'o,(exception))monad "  where 
     " raise_c2_exception8 capEx regnum = (
   (set_CapCauseReg_ExcCode CapCause_ref ((CapExCode capEx  ::  8 Word.word)) \<then>
   set_CapCauseReg_RegNum CapCause_ref regnum) \<then>
   ((let mipsEx =
     (if ((((((capEx = CapEx_CallTrap))) \<or> (((capEx = CapEx_ReturnTrap)))))) then C2Trap
     else C2E) in
   SignalException mipsEx)))"


(*val raise_c2_exception : forall 'o. CapEx -> mword ty5 -> M 'o*)

definition raise_c2_exception  :: " CapEx \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),'o,(exception))monad "  where 
     " raise_c2_exception capEx regnum = (
   (let reg8 = ((concat_vec (vec_of_bits [B0,B0,B0]  ::  3 Word.word) regnum  ::  8 Word.word)) in
   if ((((((capEx = CapEx_AccessSystemRegsViolation))) \<and> (((regnum = IDCNO)))))) then
     raise_c2_exception8 CapEx_AccessCCallIDCViolation reg8
   else raise_c2_exception8 capEx reg8))"


(*val raise_c2_exception_noreg : forall 'o. CapEx -> M 'o*)

definition raise_c2_exception_noreg  :: " CapEx \<Rightarrow>((register_value),'o,(exception))monad "  where 
     " raise_c2_exception_noreg capEx = (
   raise_c2_exception8 capEx (vec_of_bits [B1,B1,B1,B1,B1,B1,B1,B1]  ::  8 Word.word))"


(*val pcc_access_system_regs : unit -> M bool*)

definition pcc_access_system_regs  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " pcc_access_system_regs _ = (
   (read_reg PCC_ref  :: ( 257 Word.word) M) \<bind> (\<lambda> (w__0 :: CapReg) . 
   (let pcc = (capRegToCapStruct w__0) in
   return(CapStruct_access_system_regs   pcc))))"


(*
The following function should be called before reading or writing any capability register to check whether it is one of the protected system capabilities. Although it is usually a general purpose capabilty the invoked data capabiltiy (IDC) is restricted in the branch delay slot of the CCall (selector one) instruction to protect the confidentiality and integrity of the invoked sandbox.
 *)
(*val register_inaccessible : mword ty5 -> M bool*)

definition register_inaccessible  :: "(5)Word.word \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " register_inaccessible r = (
   or_boolM
     (and_boolM (return (((r = IDCNO))))
        ((read_reg inCCallDelay_ref  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__0 :: 1 bits) . 
         return ((bits_to_bool w__0)))))
     (and_boolM
        (return ((((((r = KR1CNO))) \<or> ((((((r = KR2CNO))) \<or> ((((((r = KDCNO))) \<or> ((((((r = KCCNO))) \<or> (((r = EPCCNO))))))))))))))))
        (pcc_access_system_regs ()  \<bind> (\<lambda> (w__2 :: bool) .  return ((\<not> w__2))))))"


(*val MEMr_tagged : mword ty64 -> M (bool * mword ty256)*)

definition MEMr_tagged  :: "(64)Word.word \<Rightarrow>((register_value),(bool*(256)Word.word),(exception))monad "  where 
     " MEMr_tagged addr = (
   (assert_exp (((((((Word.uint addr)) mod cap_size)) = (( 0 :: int)::ii)))) ('''') \<then>
   read_tag_bool instance_Sail2_values_Bitvector_Machine_word_mword_dict addr) \<bind> (\<lambda> tag . 
   (MEMr instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict addr cap_size  :: ( 256 Word.word) M) \<bind> (\<lambda> data . 
   return (tag, (reverse_endianness data  ::  256 Word.word)))))"


(*val MEMr_tagged_reserve : mword ty64 -> M (bool * mword ty256)*)

definition MEMr_tagged_reserve  :: "(64)Word.word \<Rightarrow>((register_value),(bool*(256)Word.word),(exception))monad "  where 
     " MEMr_tagged_reserve addr = (
   (assert_exp (((((((Word.uint addr)) mod cap_size)) = (( 0 :: int)::ii)))) ('''') \<then>
   read_tag_bool instance_Sail2_values_Bitvector_Machine_word_mword_dict addr) \<bind> (\<lambda> tag . 
   (MEMr_reserve instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict addr cap_size  :: ( 256 Word.word) M) \<bind> (\<lambda> data . 
   return (tag, (reverse_endianness data  ::  256 Word.word)))))"


(*val MEMw_tagged : mword ty64 -> bool -> mword ty256 -> M unit*)

definition MEMw_tagged  :: "(64)Word.word \<Rightarrow> bool \<Rightarrow>(256)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " MEMw_tagged addr tag data = (
   ((assert_exp (((((((Word.uint addr)) mod cap_size)) = (( 0 :: int)::ii)))) ('''') \<then>
   MEMea instance_Sail2_values_Bitvector_Machine_word_mword_dict addr cap_size) \<then>
   MEMval instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict addr cap_size ((reverse_endianness data  ::  256 Word.word))) \<then> write_tag_bool 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict addr tag )"


(*val MEMw_tagged_conditional : mword ty64 -> bool -> mword ty256 -> M bool*)

definition MEMw_tagged_conditional  :: "(64)Word.word \<Rightarrow> bool \<Rightarrow>(256)Word.word \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " MEMw_tagged_conditional addr tag data = (
   ((assert_exp (((((((Word.uint addr)) mod cap_size)) = (( 0 :: int)::ii)))) ('''') \<then>
   MEMea_conditional instance_Sail2_values_Bitvector_Machine_word_mword_dict addr cap_size) \<then>
   MEMval_conditional 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict addr cap_size ((reverse_endianness data  ::  256 Word.word))) \<bind> (\<lambda> success . 
   (if success then write_tag_bool 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict addr tag else return () ) \<then> return success))"


definition cap_addr_mask  :: "(64)Word.word "  where 
     " cap_addr_mask = (
  (to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) ((((pow2 (( 64 :: int)::ii))) - cap_size))
    ::  64 Word.word))"


(*val MEMw_wrapper : forall   'p8_times_n_ . Size 'p8_times_n_ => mword ty64 -> integer -> mword 'p8_times_n_ -> M unit*)

definition MEMw_wrapper  :: "(64)Word.word \<Rightarrow> int \<Rightarrow>('p8_times_n_::len)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " MEMw_wrapper addr size1 data = (
   (let ledata = ((reverse_endianness data  :: ( 'p8_times_n_::len)Word.word)) in
   if (((addr = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                        B0,B0,B0,B0,B0,B0,B0,B0,B1,B1,B1,B1,B1,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                        B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
            ::  64 Word.word)))) then
     write_reg UART_WDATA_ref ((subrange_vec_dec ledata (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)) \<then>
     write_reg UART_WRITTEN_ref (vec_of_bits [B1]  ::  1 Word.word)
   else
     ((assert_exp (((((and_vec addr cap_addr_mask  ::  64 Word.word)) = ((and_vec
                        ((add_vec addr
                            ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
                                ((size1 - (( 1 :: int)::ii)))
                               ::  64 Word.word))
                           ::  64 Word.word)) cap_addr_mask
                       ::  64 Word.word))))) ('''') \<then>
     MEMea instance_Sail2_values_Bitvector_Machine_word_mword_dict addr size1) \<then>
     MEMval instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict addr size1 ledata) \<then> write_tag_bool 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict ((and_vec addr cap_addr_mask  ::  64 Word.word)) False))"


(*val MEMw_conditional_wrapper : forall   'p8_times_n_ . Size 'p8_times_n_ => mword ty64 -> integer -> mword 'p8_times_n_ -> M bool*)

definition MEMw_conditional_wrapper  :: "(64)Word.word \<Rightarrow> int \<Rightarrow>('p8_times_n_::len)Word.word \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " MEMw_conditional_wrapper addr size1 data = (
   ((assert_exp (((((and_vec addr cap_addr_mask  ::  64 Word.word)) = ((and_vec
                      ((add_vec addr
                          ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
                              ((size1 - (( 1 :: int)::ii)))
                             ::  64 Word.word))
                         ::  64 Word.word)) cap_addr_mask
                     ::  64 Word.word))))) ('''') \<then>
   MEMea_conditional instance_Sail2_values_Bitvector_Machine_word_mword_dict addr size1) \<then>
   MEMval_conditional 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict addr size1 ((reverse_endianness data  :: ( 'p8_times_n_::len)Word.word))) \<bind> (\<lambda> success . 
   (if success then write_tag_bool 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict ((and_vec addr cap_addr_mask  ::  64 Word.word)) False
    else return () ) \<then>
   return success))"


(*val checkDDCPerms : CapStruct -> MemAccessType -> M unit*)

definition checkDDCPerms  :: " CapStruct \<Rightarrow> MemAccessType \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " checkDDCPerms (ddc :: CapStruct) (accessType :: MemAccessType) = (
   (if ((\<not>(CapStruct_tag   ddc))) then
      raise_c2_exception CapEx_TagViolation (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
    else if(CapStruct_sealed   ddc) then
      raise_c2_exception CapEx_SealViolation (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
    else return () ) \<then>
   (case  accessType of
     Instruction => assert_exp False ('''')
   | LoadData =>
      if ((\<not>(CapStruct_permit_load   ddc))) then
        raise_c2_exception CapEx_PermitLoadViolation (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
      else return () 
   | StoreData =>
      if ((\<not>(CapStruct_permit_store   ddc))) then
        raise_c2_exception CapEx_PermitStoreViolation (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
      else return () 
   ))"


(*val addrWrapper : mword ty64 -> MemAccessType -> WordType -> M (mword ty64)*)

definition addrWrapper  :: "(64)Word.word \<Rightarrow> MemAccessType \<Rightarrow> WordType \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " addrWrapper addr accessType width = (
   (read_reg DDC_ref  :: ( 257 Word.word) M) \<bind> (\<lambda> (w__0 :: CapReg) . 
   (let ddc = (capRegToCapStruct w__0) in
   checkDDCPerms ddc accessType \<then>
   ((let cursor = (getCapCursor ddc) in
   (let vAddr = (((cursor + ((Word.uint addr)))) mod ((pow2 (( 64 :: int)::ii)))) in
   (let size1 = (wordWidthBytes width) in
   (let base = (getCapBase ddc) in
   (let top1 = (getCapTop ddc) in
   if ((((vAddr + size1)) > top1)) then
     (raise_c2_exception CapEx_LengthViolation (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
       :: ( 64 Word.word) M)
   else if ((vAddr < base)) then
     (raise_c2_exception CapEx_LengthViolation (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
       :: ( 64 Word.word) M)
   else return ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) vAddr  ::  64 Word.word)))))))))))"


(*val addrWrapperUnaligned : mword ty64 -> MemAccessType -> WordTypeUnaligned -> M (mword ty64)*)

definition addrWrapperUnaligned  :: "(64)Word.word \<Rightarrow> MemAccessType \<Rightarrow> WordTypeUnaligned \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " addrWrapperUnaligned addr accessType width = (
   (read_reg DDC_ref  :: ( 257 Word.word) M) \<bind> (\<lambda> (w__0 :: CapReg) . 
   (let ddc = (capRegToCapStruct w__0) in
   checkDDCPerms ddc accessType \<then>
   ((let cursor = (getCapCursor ddc) in
   (let vAddr = (((cursor + ((Word.uint addr)))) mod ((pow2 (( 64 :: int)::ii)))) in
   (let woffset = (vAddr mod (( 4 :: int)::ii)) in
   (let doffset = (vAddr mod (( 8 :: int)::ii)) in
   (let ((waddr :: ii), (size1 :: ii)) =
     ((case  width of
       WL => (vAddr, (( 4 :: int)::ii) - woffset)
     | WR => (vAddr - woffset, woffset + (( 1 :: int)::ii))
     | DL => (vAddr, (( 8 :: int)::ii) - doffset)
     | DR => (vAddr - doffset, doffset + (( 1 :: int)::ii))
     )) in
   (let base = (getCapBase ddc) in
   (let top1 = (getCapTop ddc) in
   if ((((waddr + size1)) > top1)) then
     (raise_c2_exception CapEx_LengthViolation (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
       :: ( 64 Word.word) M)
   else if ((waddr < base)) then
     (raise_c2_exception CapEx_LengthViolation (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
       :: ( 64 Word.word) M)
   else return ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) vAddr  ::  64 Word.word)))))))))))))"


(*val TranslatePC : mword ty64 -> M (mword ty64)*)

definition TranslatePC  :: "(64)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " TranslatePC vAddr = (
   (incrementCP0Count ()  \<then>
   (read_reg PCC_ref  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__0 :: CapReg) . 
   (let pcc = (capRegToCapStruct w__0) in
   (let base = (getCapBase pcc) in
   (let top1 = (getCapTop pcc) in
   (let absPC = (base + ((Word.uint vAddr))) in
   if (((((absPC mod (( 4 :: int)::ii))) \<noteq> (( 0 :: int)::ii)))) then
     (SignalExceptionBadAddr AdEL
        ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) absPC  ::  64 Word.word))
       :: ( 64 Word.word) M)
   else if ((\<not>(CapStruct_tag   pcc))) then
     (raise_c2_exception_noreg CapEx_TagViolation  :: ( 64 Word.word) M)
   else if ((((absPC + (( 4 :: int)::ii))) > top1)) then
     (raise_c2_exception_noreg CapEx_LengthViolation  :: ( 64 Word.word) M)
   else
     (TLBTranslate ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) absPC  ::  64 Word.word))
        Instruction
       :: ( 64 Word.word) M)))))))"


(*  
All capability instrucitons must first check that the capability
co-processor is enabled using the following function that raises a
co-processor unusable exception if a CP0Status.CU2 is not set. This
allows the operating system to only save and restore the full
capability context for processes that use capabilities.
*)
(*val checkCP2usable : unit -> M unit*)

definition checkCP2usable  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " checkCP2usable _ = (
   read_reg CP0Status_ref \<bind> (\<lambda> (w__0 :: StatusReg) . 
   if ((\<not> ((bit_to_bool ((access_vec_dec ((get_StatusReg_CU w__0  ::  4 Word.word)) (( 2 :: int)::ii))))))) then
     set_CauseReg_CE CP0Cause_ref (vec_of_bits [B1,B0]  ::  2 Word.word) \<then> SignalException CpU
   else return () ))"


definition init_cp2_state  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " init_cp2_state _ = (
   (let defaultBits = ((capStructToCapReg default_cap  ::  257 Word.word)) in
   (let nullBits = ((capStructToCapReg null_cap  ::  257 Word.word)) in
   ((((((((((write_reg PCC_ref defaultBits \<then>
   write_reg nextPCC_ref defaultBits) \<then>
   write_reg delayedPCC_ref defaultBits) \<then>
   write_reg DDC_ref defaultBits) \<then>
   write_reg KCC_ref defaultBits) \<then>
   write_reg EPCC_ref defaultBits) \<then>
   write_reg KDC_ref nullBits) \<then>
   write_reg KR1C_ref nullBits) \<then>
   write_reg KR2C_ref nullBits) \<then>
   write_reg CTLSP_ref nullBits) \<then>
   write_reg CTLSU_ref nullBits) \<then>
   (foreachM (index_list (( 1 :: int)::ii) (( 31 :: int)::ii) (( 1 :: int)::ii)) () 
     (\<lambda> i unit_var . 
       (let idx = ((to_bits ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) i  ::  5 Word.word)) in
       writeCapReg idx null_cap))))))"


definition cp2_next_pc  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " cp2_next_pc _ = (
   (read_reg nextPCC_ref  :: ( 257 Word.word) M) \<bind> (\<lambda> (w__0 :: CapReg) . 
   (write_reg PCC_ref w__0 \<then>
   (read_reg inBranchDelay_ref  :: ( 1 Word.word) M)) \<bind> (\<lambda> (w__1 :: 1 bits) . 
   if ((bits_to_bool w__1)) then
     (read_reg delayedPCC_ref  :: ( 257 Word.word) M) \<bind> (\<lambda> (w__2 :: CapReg) . 
     write_reg nextPCC_ref w__2)
   else write_reg inCCallDelay_ref (vec_of_bits [B0]  ::  1 Word.word))))"


(*val capToString : CapStruct -> M string*)

definition capToString  :: " CapStruct \<Rightarrow>((register_value),(string),(exception))monad "  where 
     " capToString cap = (
   skip ()  \<then>
   return (((@) ('' t:'')
              (((@) (if(CapStruct_tag   cap) then (''1'') else (''0''))
                  (((@) ('' s:'')
                      (((@) (if(CapStruct_sealed   cap) then (''1'') else (''0''))
                          (((@) ('' perms:'')
                              (((@)
                                  ((string_of_bits
                                      ((concat_vec (vec_of_bits [B0]  ::  1 Word.word)
                                          ((getCapPerms cap  ::  31 Word.word))
                                         ::  32 Word.word))))
                                  (((@) ('' type:'')
                                      (((@) ((string_of_bits(CapStruct_otype   cap)))
                                          (((@) ('' offset:'')
                                              (((@)
                                                  ((string_of_bits
                                                      ((to_bits
                                                          ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
                                                          ((getCapOffset cap))
                                                         ::  64 Word.word))))
                                                  (((@) ('' base:'')
                                                      (((@)
                                                          ((string_of_bits
                                                              ((to_bits
                                                                  ((make_the_value (( 64 :: int)::ii)
                                                                     ::  64 itself))
                                                                  ((getCapBase cap))
                                                                 ::  64 Word.word))))
                                                          (((@) ('' length:'')
                                                              ((string_of_bits
                                                                  ((to_bits
                                                                      ((make_the_value (( 64 :: int)::ii)
                                                                         ::  64 itself))
                                                                      ((min ((getCapLength cap))
                                                                          ((MAX0 (( 64 :: int)::ii)))))
                                                                     ::  64 Word.word)))))))))))))))))))))))))))))))"


definition dump_cp2_state  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " dump_cp2_state _ = (
   (read_reg PCC_ref  :: ( 257 Word.word) M) \<bind> (\<lambda> (w__0 :: CapReg) . 
   capToString ((capRegToCapStruct w__0)) \<bind> (\<lambda> (w__1 :: string) . 
   (let (_ :: unit) = (print_endline (((@) (''DEBUG CAP PCC'') w__1))) in
   ((foreachM (index_list (( 0 :: int)::ii) (( 31 :: int)::ii) (( 1 :: int)::ii)) () 
     (\<lambda> i unit_var . 
       readCapReg ((to_bits ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) i  ::  5 Word.word)) \<bind> (\<lambda> (w__2 ::
         CapStruct) . 
       capToString w__2 \<bind> (\<lambda> (w__3 :: string) . 
       return ((let _ =
         (print_endline (((@) (''DEBUG CAP REG '') (((@) ((string_of_int 
  instance_Show_Show_Num_integer_dict i)) w__3))))) in
       () )))))) \<then>
   (read_reg DDC_ref  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__4 :: CapReg) . 
   capToString ((capRegToCapStruct w__4)) \<bind> (\<lambda> (w__5 :: string) . 
   (let (_ :: unit) = (print_endline (((@) (''DEBUG CAP HWREG 00'') w__5))) in
   (read_reg CTLSU_ref  :: ( 257 Word.word) M) \<bind> (\<lambda> (w__6 :: CapReg) . 
   capToString ((capRegToCapStruct w__6)) \<bind> (\<lambda> (w__7 :: string) . 
   (let (_ :: unit) = (print_endline (((@) (''DEBUG CAP HWREG 01'') w__7))) in
   (read_reg CTLSP_ref  :: ( 257 Word.word) M) \<bind> (\<lambda> (w__8 :: CapReg) . 
   capToString ((capRegToCapStruct w__8)) \<bind> (\<lambda> (w__9 :: string) . 
   (let (_ :: unit) = (print_endline (((@) (''DEBUG CAP HWREG 08'') w__9))) in
   (read_reg KR1C_ref  :: ( 257 Word.word) M) \<bind> (\<lambda> (w__10 :: CapReg) . 
   capToString ((capRegToCapStruct w__10)) \<bind> (\<lambda> (w__11 :: string) . 
   (let (_ :: unit) = (print_endline (((@) (''DEBUG CAP HWREG 22'') w__11))) in
   (read_reg KR2C_ref  :: ( 257 Word.word) M) \<bind> (\<lambda> (w__12 :: CapReg) . 
   capToString ((capRegToCapStruct w__12)) \<bind> (\<lambda> (w__13 :: string) . 
   (let (_ :: unit) = (print_endline (((@) (''DEBUG CAP HWREG 23'') w__13))) in
   (read_reg KCC_ref  :: ( 257 Word.word) M) \<bind> (\<lambda> (w__14 :: CapReg) . 
   capToString ((capRegToCapStruct w__14)) \<bind> (\<lambda> (w__15 :: string) . 
   (let (_ :: unit) = (print_endline (((@) (''DEBUG CAP HWREG 29'') w__15))) in
   (read_reg KDC_ref  :: ( 257 Word.word) M) \<bind> (\<lambda> (w__16 :: CapReg) . 
   capToString ((capRegToCapStruct w__16)) \<bind> (\<lambda> (w__17 :: string) . 
   (let (_ :: unit) = (print_endline (((@) (''DEBUG CAP HWREG 30'') w__17))) in
   (read_reg EPCC_ref  :: ( 257 Word.word) M) \<bind> (\<lambda> (w__18 :: CapReg) . 
   capToString ((capRegToCapStruct w__18)) \<bind> (\<lambda> (w__19 :: string) . 
   return ((print_endline (((@) (''DEBUG CAP HWREG 31'') w__19)))))))))))))))))))))))))))))))"


(*val extendLoad : forall 'sz . Size 'sz => mword 'sz -> bool -> mword ty64*)

definition extendLoad  :: "('sz::len)Word.word \<Rightarrow> bool \<Rightarrow>(64)Word.word "  where 
     " extendLoad memResult sign = (
   if sign then (mips_sign_extend (( 64 :: int)::ii) memResult  ::  64 Word.word)
   else (mips_zero_extend (( 64 :: int)::ii) memResult  ::  64 Word.word))"


(*val TLBWriteEntry : mword ty6 -> M unit*)

definition TLBWriteEntry  :: "(6)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " TLBWriteEntry idx = (
   (read_reg TLBPageMask_ref  :: ( 16 Word.word) M) \<bind> (\<lambda> pagemask . 
   (let b__0 = pagemask in
   (if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  16 Word.word))))
    then
      return () 
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1]  ::  16 Word.word)))) then
      return () 
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1,B1,B1]  ::  16 Word.word)))) then
      return () 
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1,B1,B1,B1,B1]  ::  16 Word.word)))) then
      return () 
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B1,B1,B1,B1,B1,B1,B1,B1]  ::  16 Word.word)))) then
      return () 
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1]  ::  16 Word.word)))) then
      return () 
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1]  ::  16 Word.word)))) then
      return () 
    else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1]  ::  16 Word.word)))) then
      return () 
    else if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1]  ::  16 Word.word)))) then
      return () 
    else SignalException MCheck) \<then>
   ((let i = (Word.uint idx) in
   (let entry = (access_list_dec TLBEntries i) in
   (set_TLBEntry_pagemask entry pagemask \<then>
   read_reg TLBEntryHi_ref) \<bind> (\<lambda> (w__0 :: TLBEntryHiReg) . 
   (set_TLBEntry_r entry ((get_TLBEntryHiReg_R w__0  ::  2 Word.word)) \<then>
   read_reg TLBEntryHi_ref) \<bind> (\<lambda> (w__1 :: TLBEntryHiReg) . 
   (set_TLBEntry_vpn2 entry ((get_TLBEntryHiReg_VPN2 w__1  ::  27 Word.word)) \<then>
   read_reg TLBEntryHi_ref) \<bind> (\<lambda> (w__2 :: TLBEntryHiReg) . 
   (set_TLBEntry_asid entry ((get_TLBEntryHiReg_ASID w__2  ::  8 Word.word)) \<then>
   and_boolM
     (read_reg TLBEntryLo0_ref \<bind> (\<lambda> (w__3 :: TLBEntryLoReg) . 
      return ((bits_to_bool ((get_TLBEntryLoReg_G w__3  ::  1 Word.word))))))
     (read_reg TLBEntryLo1_ref \<bind> (\<lambda> (w__4 :: TLBEntryLoReg) . 
      return ((bits_to_bool ((get_TLBEntryLoReg_G w__4  ::  1 Word.word))))))) \<bind> (\<lambda> (w__5 :: bool) . 
   ((set_TLBEntry_g entry ((bool_to_bits w__5  ::  1 Word.word)) \<then>
   set_TLBEntry_valid entry ((cast_unit_vec0 B1  ::  1 Word.word))) \<then>
   read_reg TLBEntryLo0_ref) \<bind> (\<lambda> (w__6 :: TLBEntryLoReg) . 
   (set_TLBEntry_caps0 entry ((get_TLBEntryLoReg_CapS w__6  ::  1 Word.word)) \<then>
   read_reg TLBEntryLo0_ref) \<bind> (\<lambda> (w__7 :: TLBEntryLoReg) . 
   (set_TLBEntry_capl0 entry ((get_TLBEntryLoReg_CapL w__7  ::  1 Word.word)) \<then>
   read_reg TLBEntryLo0_ref) \<bind> (\<lambda> (w__8 :: TLBEntryLoReg) . 
   (set_TLBEntry_pfn0 entry ((get_TLBEntryLoReg_PFN w__8  ::  24 Word.word)) \<then>
   read_reg TLBEntryLo0_ref) \<bind> (\<lambda> (w__9 :: TLBEntryLoReg) . 
   (set_TLBEntry_c0 entry ((get_TLBEntryLoReg_C w__9  ::  3 Word.word)) \<then>
   read_reg TLBEntryLo0_ref) \<bind> (\<lambda> (w__10 :: TLBEntryLoReg) . 
   (set_TLBEntry_d0 entry ((get_TLBEntryLoReg_D w__10  ::  1 Word.word)) \<then>
   read_reg TLBEntryLo0_ref) \<bind> (\<lambda> (w__11 :: TLBEntryLoReg) . 
   (set_TLBEntry_v0 entry ((get_TLBEntryLoReg_V w__11  ::  1 Word.word)) \<then>
   read_reg TLBEntryLo1_ref) \<bind> (\<lambda> (w__12 :: TLBEntryLoReg) . 
   (set_TLBEntry_caps1 entry ((get_TLBEntryLoReg_CapS w__12  ::  1 Word.word)) \<then>
   read_reg TLBEntryLo1_ref) \<bind> (\<lambda> (w__13 :: TLBEntryLoReg) . 
   (set_TLBEntry_capl1 entry ((get_TLBEntryLoReg_CapL w__13  ::  1 Word.word)) \<then>
   read_reg TLBEntryLo1_ref) \<bind> (\<lambda> (w__14 :: TLBEntryLoReg) . 
   (set_TLBEntry_pfn1 entry ((get_TLBEntryLoReg_PFN w__14  ::  24 Word.word)) \<then>
   read_reg TLBEntryLo1_ref) \<bind> (\<lambda> (w__15 :: TLBEntryLoReg) . 
   (set_TLBEntry_c1 entry ((get_TLBEntryLoReg_C w__15  ::  3 Word.word)) \<then>
   read_reg TLBEntryLo1_ref) \<bind> (\<lambda> (w__16 :: TLBEntryLoReg) . 
   (set_TLBEntry_d1 entry ((get_TLBEntryLoReg_D w__16  ::  1 Word.word)) \<then>
   read_reg TLBEntryLo1_ref) \<bind> (\<lambda> (w__17 :: TLBEntryLoReg) . 
   set_TLBEntry_v1 entry ((get_TLBEntryLoReg_V w__17  ::  1 Word.word))))))))))))))))))))))))"


definition decode  :: "(32)Word.word \<Rightarrow>(ast)option "  where 
     " decode v__0 = (
   if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (DADDIU (rs,rt,imm)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B1,B1,B0,B1]  ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (DADDU (rs,rt,rd)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B0]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (DADDI (rs,rt,imm)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B1,B1,B0,B0]  ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (DADD (rs,rt,rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0]  ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (ADD (rs,rt,rd)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B0,B0]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (ADDI (rs,rt,imm)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B1]  ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (ADDU (rs,rt,rd)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B0,B1]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (ADDIU (rs,rt,imm)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B1,B1,B1,B1]  ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (DSUBU (rs,rt,rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B1,B1,B1,B0]  ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (DSUB (rs,rt,rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B1,B0]  ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (SUB (rs,rt,rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B1,B1]  ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (SUBU (rs,rt,rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B1,B0,B0]  ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (AND0 (rs,rt,rd)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B0]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (ANDI (rs,rt,imm)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B1,B0,B1]  ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (OR0 (rs,rt,rd)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B1]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (ORI (rs,rt,imm)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B1,B1,B1]  ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (NOR (rs,rt,rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B1,B1,B0]  ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (XOR0 (rs,rt,rd)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B1,B0]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (XORI (rs,rt,imm)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B1,B1,B0,B0,B0,B0,B0]  ::  11 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (LUI (rt,imm))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B0,B0]  ::  6 Word.word))))))) then
     (let (sa :: 5 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (DSLL (rt,rd,sa)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B1,B1,B0,B0]  ::  6 Word.word))))))) then
     (let (sa :: 5 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (DSLL32 (rt,rd,sa)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1,B0,B1,B0,B0]  ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (DSLLV (rs,rt,rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B1,B1]  ::  6 Word.word))))))) then
     (let (sa :: 5 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (DSRA (rt,rd,sa)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B1,B1,B1,B1]  ::  6 Word.word))))))) then
     (let (sa :: 5 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (DSRA32 (rt,rd,sa)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1,B0,B1,B1,B1]  ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (DSRAV (rs,rt,rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B1,B0]  ::  6 Word.word))))))) then
     (let (sa :: 5 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (DSRL (rt,rd,sa)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B1,B1,B1,B0]  ::  6 Word.word))))))) then
     (let (sa :: 5 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (DSRL32 (rt,rd,sa)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1,B0,B1,B1,B0]  ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (DSRLV (rs,rt,rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word))))))) then
     (let (sa :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (SLL (rt,rd,sa)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B0]  ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (SLLV (rs,rt,rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B1,B1]  ::  6 Word.word))))))) then
     (let (sa :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (SRA (rt,rd,sa)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B1,B1,B1]  ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (SRAV (rs,rt,rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B1,B0]  ::  6 Word.word))))))) then
     (let (sa :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (SRL (rt,rd,sa)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B1,B1,B0]  ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (SRLV (rs,rt,rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B1,B0,B1,B0]  ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (SLT (rs,rt,rd)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B1,B0]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (SLTI (rs,rt,imm)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B1,B0,B1,B1]  ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (SLTU (rs,rt,rd)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B1,B1]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (SLTIU (rs,rt,imm)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B1,B0,B1,B1]  ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (MOVN (rs,rt,rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B1,B0,B1,B0]  ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (MOVZ (rs,rt,rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  16 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1,B0,B0,B0,B0]  ::  11 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (MFHI rd))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  16 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1,B0,B0,B1,B0]  ::  11 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (MFLO rd))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 0 :: int)::ii)  ::  21 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B0,B0,B1]
                     ::  21 Word.word))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (MTHI rs))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 0 :: int)::ii)  ::  21 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B0,B1,B1]
                     ::  21 Word.word))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (MTLO rs))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0]  ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (MUL (rs,rt,rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1,B0,B0,B0]  ::  16 Word.word)))))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (MULT (rs,rt))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1,B0,B0,B1]  ::  16 Word.word)))))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (MULTU (rs,rt))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1,B1,B0,B0]  ::  16 Word.word)))))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (DMULT (rs,rt))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1,B1,B0,B1]  ::  16 Word.word)))))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (DMULTU (rs,rt))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  16 Word.word)))))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (MADD (rs,rt))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1]  ::  16 Word.word)))))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (MADDU (rs,rt))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B0]  ::  16 Word.word)))))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (MSUB (rs,rt))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B1]  ::  16 Word.word)))))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (MSUBU (rs,rt))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1,B0,B1,B0]  ::  16 Word.word)))))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (DIV (rs,rt))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1,B0,B1,B1]  ::  16 Word.word)))))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (DIVU (rs,rt))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1,B1,B1,B0]  ::  16 Word.word)))))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (DDIV (rs,rt))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1,B1,B1,B1]  ::  16 Word.word)))))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (DDIVU (rs,rt))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B1,B0]  ::  6 Word.word)))) then
     (let (offset :: 26 bits) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 0 :: int)::ii)  ::  26 Word.word)) in
     Some (J offset))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B1,B1]  ::  6 Word.word)))) then
     (let (offset :: 26 bits) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 0 :: int)::ii)  ::  26 Word.word)) in
     Some (JAL offset))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 11 :: int)::ii)  ::  10 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  10 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B0,B0]  ::  6 Word.word)))))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (JR rs))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B0,B1]  ::  6 Word.word)))))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (JALR (rs,rd))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B0,B0]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BEQ (rs,rt,imm,False,False)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B0,B0]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BEQ (rs,rt,imm,False,True)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B0,B1]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BEQ (rs,rt,imm,True,False)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B0,B1]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BEQ (rs,rt,imm,True,True)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BCMPZ (rs,imm,LT',False,False))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B1,B0,B0,B0,B0]  ::  5 Word.word))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BCMPZ (rs,imm,LT',True,False))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B0]  ::  5 Word.word))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BCMPZ (rs,imm,LT',False,True))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B1,B0,B0,B1,B0]  ::  5 Word.word))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BCMPZ (rs,imm,LT',True,True))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B1]  ::  5 Word.word))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BCMPZ (rs,imm,GE,False,False))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B1,B0,B0,B0,B1]  ::  5 Word.word))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BCMPZ (rs,imm,GE,True,False))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B1]  ::  5 Word.word))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BCMPZ (rs,imm,GE,False,True))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B1,B0,B0,B1,B1]  ::  5 Word.word))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BCMPZ (rs,imm,GE,True,True))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B1,B1]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BCMPZ (rs,imm,GT',False,False))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BCMPZ (rs,imm,GT',False,True))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B1,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BCMPZ (rs,imm,LE,False,False))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (BCMPZ (rs,imm,LE,False,True))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B0]  ::  6 Word.word))))))) then
     Some (SYSCALL () )
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B1]  ::  6 Word.word))))))) then
     Some (BREAK () )
   else if (((v__0 = (vec_of_bits [B0,B1,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                             B0,B0,B1,B0,B0,B0,B0,B0]
                 ::  32 Word.word)))) then
     Some (WAIT () )
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B0,B0,B0,B0]  ::  6 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (TRAPREG (rs,rt,GE))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B0,B0,B0,B1]  ::  6 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (TRAPREG (rs,rt,GEU))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B0,B0,B1,B0]  ::  6 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (TRAPREG (rs,rt,LT'))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B0,B0,B1,B1]  ::  6 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (TRAPREG (rs,rt,LTU))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B0,B0]  ::  6 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (TRAPREG (rs,rt,EQ'))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B1,B0]  ::  6 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (TRAPREG (rs,rt,NE))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0]  ::  5 Word.word))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (TRAPIMM (rs,imm,EQ'))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0]  ::  5 Word.word))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (TRAPIMM (rs,imm,NE))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0]  ::  5 Word.word))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (TRAPIMM (rs,imm,GE))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1]  ::  5 Word.word))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (TRAPIMM (rs,imm,GEU))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B0]  ::  5 Word.word))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (TRAPIMM (rs,imm,LT'))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1]  ::  5 Word.word))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (TRAPIMM (rs,imm,LTU))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B0,B0,B0]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (Load (B,True,False,base,rt,offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B1,B0,B0]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (Load (B,False,False,base,rt,offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B0,B0,B1]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (Load (H,True,False,base,rt,offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B1,B0,B1]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (Load (H,False,False,base,rt,offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B0,B1,B1]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (Load (W,True,False,base,rt,offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B1,B1,B1]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (Load (W,False,False,base,rt,offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B1,B1]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (Load (D,False,False,base,rt,offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B0,B0,B0,B0]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (Load (W,True,True,base,rt,offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B0,B0]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (Load (D,False,True,base,rt,offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B1,B0,B0,B0]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (Store (B,False,base,rt,offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B1,B0,B0,B1]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (Store (H,False,base,rt,offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B1,B0,B1,B1]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (Store (W,False,base,rt,offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B1,B1,B1,B1]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (Store (D,False,base,rt,offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B0,B0]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (Store (W,True,base,rt,offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B1,B1,B0,B0]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (Store (D,True,base,rt,offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B0,B1,B0]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (LWL (base,rt,offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B1,B1,B0]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (LWR (base,rt,offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B1,B0,B1,B0]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (SWL (base,rt,offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B1,B1,B1,B0]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (SWR (base,rt,offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B1,B0]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (LDL (base,rt,offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B1,B1]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (LDR (base,rt,offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B1,B1,B0,B0]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (SDL (base,rt,offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B1,B1,B0,B1]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (SDR (base,rt,offset)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B1,B1,B1,B1]  ::  6 Word.word)))) then
     (let (op1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (imm :: imm16) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (base :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     Some (CACHE (base,op1,imm)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 11 :: int)::ii)  ::  21 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
                     ::  21 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B1,B1]  ::  6 Word.word))))))) then
     Some (SYNC () )
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 3 :: int)::ii)  ::  8 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word))))))) then
     (let (sel :: 3 bits) = ((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) in
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (MFC0 (rt,rd,sel,False)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B0,B0,B0,B0,B0,B1]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 3 :: int)::ii)  ::  8 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word))))))) then
     (let (sel :: 3 bits) = ((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) in
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (MFC0 (rt,rd,sel,True)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B0,B0,B0,B1,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = (vec_of_bits [B1,B0,B1,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  16 Word.word)))))))
   then
     Some (HCF () )
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B0,B0,B0,B1,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  16 Word.word)))))))
   then
     Some (HCF () )
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B0,B0,B0,B1,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 3 :: int)::ii)  ::  8 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word))))))) then
     (let (sel :: 3 bits) = ((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) in
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (MTC0 (rt,rd,sel,False)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B0,B0,B0,B1,B0,B1]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 3 :: int)::ii)  ::  8 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word))))))) then
     (let (sel :: 3 bits) = ((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) in
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (MTC0 (rt,rd,sel,True)))))
   else if (((v__0 = (vec_of_bits [B0,B1,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                             B0,B0,B0,B0,B0,B0,B1,B0]
                 ::  32 Word.word)))) then
     Some (TLBWI () )
   else if (((v__0 = (vec_of_bits [B0,B1,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                             B0,B0,B0,B0,B0,B1,B1,B0]
                 ::  32 Word.word)))) then
     Some (TLBWR () )
   else if (((v__0 = (vec_of_bits [B0,B1,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                             B0,B0,B0,B0,B0,B0,B0,B1]
                 ::  32 Word.word)))) then
     Some (TLBR () )
   else if (((v__0 = (vec_of_bits [B0,B1,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                             B0,B0,B0,B0,B1,B0,B0,B0]
                 ::  32 Word.word)))) then
     Some (TLBP () )
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B1,B1,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B1,B1,B0,B1,B1]  ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (RDHWR (rt,rd))))
   else if (((v__0 = (vec_of_bits [B0,B1,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                             B0,B0,B0,B1,B1,B0,B0,B0]
                 ::  32 Word.word)))) then
     Some (ERET () )
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  11 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetPerm (rd,cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1]  ::  11 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetType (rd,cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0]  ::  11 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetBase (rd,cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1]  ::  11 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetLen (rd,cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B1]  ::  11 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetTag (rd,cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B1,B1,B0]  ::  11 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetSealed (rd,cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B0]  ::  16 Word.word)))))))
   then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetCause rd))
   else if (((v__0 = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                             B0,B0,B0,B0,B0,B0,B0,B0]
                 ::  32 Word.word)))) then
     Some (CReturn () )
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B1,B1,B0,B1]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0]  ::  11 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetOffset (rd,cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 11 :: int)::ii)  ::  21 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
                     ::  21 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B0,B0]  ::  6 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     Some (CSetCause rt))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B1,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CAndPerm (cd1,cb,rt)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B1,B1,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (ct :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CToPtr (rd,cb,ct)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B1,B1,B1,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (ct :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd,cb,ct,CEQ)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B1,B1,B1,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1]  ::  6 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (ct :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd,cb,ct,CNE)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B1,B1,B1,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B1,B0]  ::  6 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (ct :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd,cb,ct,CLT)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B1,B1,B1,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B1,B1]  ::  6 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (ct :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd,cb,ct,CLE)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B1,B1,B1,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B0,B0]  ::  6 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (ct :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd,cb,ct,CLTU)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B1,B1,B1,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B0,B1]  ::  6 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (ct :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd,cb,ct,CLEU)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B1,B1,B1,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B1,B0]  ::  6 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (ct :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd,cb,ct,CEXEQ)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B1,B1,B1,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B1,B1]  ::  6 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (ct :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd,cb,ct,CNEXEQ)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B1,B1,B0,B1]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CIncOffset (cd1,cb,rt)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B1,B1,B0,B1]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1]  ::  6 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CSetOffset (cd1,cb,rt)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B1]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CSetBounds (cd1,cb,rt)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B1,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B1]  ::  11 Word.word))))))) then
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CClearTag (cd1,cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B1,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B1,B1]  ::  6 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CFromPtr (cd1,cb,rt)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B1,B0,B1,B1]  ::  11 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CCheckPerm (cs,rt))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B1,B0,B1,B1]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1]  ::  11 Word.word))))))) then
     (let (cs :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CCheckType (cs,cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B1,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word))))))) then
     (let (ct :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CSeal (cd1,cs,ct)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B1,B1]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word))))))) then
     (let (ct :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CUnseal (cd1,cs,ct)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B1,B1,B1]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  11 Word.word))))))) then
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CJALR (cd1,cb,True))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0]  ::  16 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  11 Word.word))))))) then
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CJALR ((vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word),cb,False)))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1]  ::  16 Word.word)))))))
   then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetCause rd))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B0,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1]  ::  16 Word.word)))))))
   then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CSetCause rs))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1]  ::  16 Word.word)))))))
   then
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetPCC cd1))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1]  ::  16 Word.word)))))))
   then
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CJALR ((vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word),cb,False)))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B1,B1,B1,B1,B1,B1]  ::  11 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CCheckPerm (cs,rt))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B1,B1,B1,B1,B1,B1]  ::  11 Word.word))))))) then
     (let (cs :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CCheckType (cs,cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1,B1,B1,B1,B1,B1]  ::  11 Word.word))))))) then
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CClearTag (cd1,cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B0,B1,B1,B1,B1,B1,B1]  ::  11 Word.word))))))) then
     (let (cs :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CMOVX (cd1,cs,(vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word),False))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1,B1,B1,B1,B1]  ::  11 Word.word))))))) then
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CJALR (cd1,cb,True))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B1,B1,B1,B1,B1]  ::  11 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetPerm (rd,cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B1,B1,B1,B1,B1,B1,B1]  ::  11 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetType (rd,cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B0,B1,B1,B1,B1,B1,B1]  ::  11 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetBase (rd,cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B1,B1,B1,B1,B1,B1,B1]  ::  11 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetLen (rd,cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B0,B1,B1,B1,B1,B1,B1]  ::  11 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetTag (rd,cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B1,B1,B1,B1,B1,B1,B1]  ::  11 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetSealed (rd,cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B1,B1,B1,B1,B1,B1]  ::  11 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetOffset (rd,cb))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B1,B1,B1,B1,B1,B1,B1]  ::  11 Word.word))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetPCCSetOffset (cd1,rs))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B1,B1,B1,B1,B1,B1,B1]  ::  11 Word.word))))))) then
     (let (sel :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CReadHwr (cd1,sel))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B1,B1,B1,B1,B1,B1]  ::  11 Word.word))))))) then
     (let (sel :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CWriteHwr (cb,sel))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1]  ::  11 Word.word))))))) then
     (let (sel :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CGetAddr (cb,sel))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B1,B1]  ::  6 Word.word))))))) then
     (let (ct :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CSeal (cd1,cs,ct)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B0]  ::  6 Word.word))))))) then
     (let (ct :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CUnseal (cd1,cs,ct)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B1]  ::  6 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CAndPerm (cd1,cs,rt)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B1,B1]  ::  6 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CSetOffset (cd1,cs,rt)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B0,B0]  ::  6 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CSetBounds (cd1,cs,rt)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B0,B1]  ::  6 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CSetBoundsExact (cd1,cs,rt)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B1]  ::  6 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CIncOffset (cd1,cb,rt)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B1]  ::  6 Word.word))))))) then
     (let (ct :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CBuildCap (cd1,cb,ct)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B1,B0]  ::  6 Word.word))))))) then
     (let (ct :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CCopyType (cd1,cb,ct)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B1,B1]  ::  6 Word.word))))))) then
     (let (ct :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CCSeal (cd1,cs,ct)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0]  ::  6 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (ct :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CToPtr (rd,cb,ct)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B1]  ::  6 Word.word))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CFromPtr (cd1,cb,rs)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B1,B0]  ::  6 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CSub (rt,cb,cs)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B1,B1]  ::  6 Word.word))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CMOVX (cd1,cs,rs,False)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B0]  ::  6 Word.word))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CMOVX (cd1,cs,rs,True)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B0,B0]  ::  6 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd,cb,cs,CEQ)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B0,B1]  ::  6 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd,cb,cs,CNE)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B0]  ::  6 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd,cb,cs,CLT)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1]  ::  6 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd,cb,cs,CLE)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B0]  ::  6 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd,cb,cs,CLTU)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1]  ::  6 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd,cb,cs,CLEU)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B1,B0]  ::  6 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd,cb,cs,CEXEQ)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B0,B0,B1]  ::  6 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CPtrCmp (rd,cb,cs,CNEXEQ)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B0,B0,B0]  ::  6 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (ct :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CTestSubset (rd,cb,ct)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B1,B0,B0,B1]  ::  11 Word.word)))) then
     (let (imm :: 16 bits) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CBX (cd1,imm,True))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B1,B0,B1,B0]  ::  11 Word.word)))) then
     (let (imm :: 16 bits) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CBX (cd1,imm,False))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B1,B0,B0,B0,B1]  ::  11 Word.word)))) then
     (let (imm :: 16 bits) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CBZ (cd1,imm,False))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B1,B0,B0,B1,B0]  ::  11 Word.word)))) then
     (let (imm :: 16 bits) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CBZ (cd1,imm,True))))
   else if (((v__0 = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1,B1,
                             B1,B1,B1,B1,B1,B1,B1,B1]
                 ::  32 Word.word)))) then
     Some (CReturn () )
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B1,B0,B1]  ::  11 Word.word)))) then
     (let (selector :: 11 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) in
     (let (cs :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CCall (cs,cb,selector)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B1,B1,B1,B1,B0,B0,B0,B0,B0]  ::  16 Word.word)))) then
     (let (imm :: 16 bits) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (ClearRegs (GPLo,imm)))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B1,B1,B1,B1,B0,B0,B0,B0,B1]  ::  16 Word.word)))) then
     (let (imm :: 16 bits) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (ClearRegs (GPHi,imm)))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B1,B1,B1,B1,B0,B0,B0,B1,B0]  ::  16 Word.word)))) then
     (let (imm :: 16 bits) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (ClearRegs (CLo,imm)))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B1,B1,B1,B1,B0,B0,B0,B1,B1]  ::  16 Word.word)))) then
     (let (imm :: 16 bits) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     Some (ClearRegs (CHi,imm)))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B1,B0,B0,B1,B1]  ::  11 Word.word)))) then
     (let (imm :: 11 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) in
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CIncOffsetImmediate (cd1,cb,imm)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B1,B0,B1,B0,B0]  ::  11 Word.word)))) then
     (let (imm :: 11 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) in
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CSetBoundsImmediate (cd1,cb,imm)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B0,B0,B1,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: 8 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 3 :: int)::ii)  ::  8 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CLoad (rd,cb,rt,offset,False,B,False))))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B0,B0,B1,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B0]  ::  3 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: 8 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 3 :: int)::ii)  ::  8 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CLoad (rd,cb,rt,offset,True,B,False))))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B0,B0,B1,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B1]  ::  3 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: 8 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 3 :: int)::ii)  ::  8 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CLoad (rd,cb,rt,offset,False,H,False))))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B0,B0,B1,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: 8 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 3 :: int)::ii)  ::  8 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CLoad (rd,cb,rt,offset,True,H,False))))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B0,B0,B1,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: 8 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 3 :: int)::ii)  ::  8 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CLoad (rd,cb,rt,offset,False,W,False))))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B0,B0,B1,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B0]  ::  3 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: 8 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 3 :: int)::ii)  ::  8 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CLoad (rd,cb,rt,offset,True,W,False))))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B0,B0,B1,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: 8 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 3 :: int)::ii)  ::  8 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CLoad (rd,cb,rt,offset,False,D,False))))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B1,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B1,B0,B0,B0]  ::  11 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CLoad (rd,cb,(vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word),(vec_of_bits [B0,B0,B0,B0,B0,B0,
                                                                                  B0,B0]
                                                                      ::  8 Word.word),False,B,True))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B1,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B1,B1,B0,B0]  ::  11 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CLoad (rd,cb,(vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word),(vec_of_bits [B0,B0,B0,B0,B0,B0,
                                                                                  B0,B0]
                                                                      ::  8 Word.word),True,B,True))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B1,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B1,B0,B0,B1]  ::  11 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CLoad (rd,cb,(vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word),(vec_of_bits [B0,B0,B0,B0,B0,B0,
                                                                                  B0,B0]
                                                                      ::  8 Word.word),False,H,True))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B1,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B1,B1,B0,B1]  ::  11 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CLoad (rd,cb,(vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word),(vec_of_bits [B0,B0,B0,B0,B0,B0,
                                                                                  B0,B0]
                                                                      ::  8 Word.word),True,H,True))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B1,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B1,B0,B1,B0]  ::  11 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CLoad (rd,cb,(vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word),(vec_of_bits [B0,B0,B0,B0,B0,B0,
                                                                                  B0,B0]
                                                                      ::  8 Word.word),False,W,True))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B1,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B1,B1,B1,B0]  ::  11 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CLoad (rd,cb,(vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word),(vec_of_bits [B0,B0,B0,B0,B0,B0,
                                                                                  B0,B0]
                                                                      ::  8 Word.word),True,W,True))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B1,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B1,B0,B1,B1]  ::  11 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CLoad (rd,cb,(vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word),(vec_of_bits [B0,B0,B0,B0,B0,B0,
                                                                                  B0,B0]
                                                                      ::  8 Word.word),False,D,True))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B1,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: 8 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 3 :: int)::ii)  ::  8 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CStore (rs,cb,rt,(vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word),offset,B,False))))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B1,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B1]  ::  3 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: 8 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 3 :: int)::ii)  ::  8 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CStore (rs,cb,rt,(vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word),offset,H,False))))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B1,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: 8 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 3 :: int)::ii)  ::  8 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CStore (rs,cb,rt,(vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word),offset,W,False))))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B1,B0]  ::  6 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word))))))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: 8 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 3 :: int)::ii)  ::  8 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CStore (rs,cb,rt,(vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word),offset,D,False))))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B1,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CStore (rs,cb,(vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word),rd,(vec_of_bits [B0,B0,B0,B0,B0,
                                                                                      B0,B0,B0]
                                                                          ::  8 Word.word),B,True)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B1,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1]  ::  6 Word.word))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CStore (rs,cb,(vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word),rd,(vec_of_bits [B0,B0,B0,B0,B0,
                                                                                      B0,B0,B0]
                                                                          ::  8 Word.word),H,True)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B1,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B1,B0]  ::  6 Word.word))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CStore (rs,cb,(vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word),rd,(vec_of_bits [B0,B0,B0,B0,B0,
                                                                                      B0,B0,B0]
                                                                          ::  8 Word.word),W,True)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B1,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B1,B1]  ::  6 Word.word))))))) then
     (let (rs :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CStore (rs,cb,(vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word),rd,(vec_of_bits [B0,B0,B0,B0,B0,
                                                                                      B0,B0,B0]
                                                                          ::  8 Word.word),D,True)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B1,B1,B1,B0]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: 11 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) in
     (let (cs :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CSC (cs,cb,rt,(vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word),offset,False))))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B1,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B1,B1]  ::  6 Word.word))))))) then
     (let (rd :: regno) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 6 :: int)::ii)  ::  5 Word.word)) in
     (let (cs :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CSC (cs,cb,(vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word),rd,(vec_of_bits [B0,B0,B0,B0,B0,B0,
                                                                                   B0,B0,B0,B0,B0]
                                                                       ::  11 Word.word),True)))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B1,B0]  ::  6 Word.word)))) then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     (let (offset :: 11 bits) = ((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) in
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CLC (cd1,cb,rt,(mips_sign_extend (( 16 :: int)::ii) offset  ::  16 Word.word),False))))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B1,B0,B0,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 10 :: int)::ii) (( 0 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B1,B1,B1,B1]  ::  11 Word.word))))))) then
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 11 :: int)::ii)  ::  5 Word.word)) in
     Some (CLC (cd1,cb,(vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word),(vec_of_bits [B0,B0,B0,B0,B0,B0,B0,
                                                                                B0,B0,B0,B0,B0,B0,B0,
                                                                                B0,B0]
                                                                    ::  16 Word.word),True))))
   else if (((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B1]  ::  6 Word.word)))) then
     (let (offset :: 16 bits) = ((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) in
     (let (cd1 :: regno) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 21 :: int)::ii)  ::  5 Word.word)) in
     (let (cb :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (CLC (cd1,cb,(vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word),offset,False)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 21 :: int)::ii)  ::  11 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B1,B0,B0,B0,B1,B0,B0]  ::  11 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1,B0]  ::  16 Word.word)))))))
   then
     (let (rt :: regno) = ((subrange_vec_dec v__0 (( 20 :: int)::ii) (( 16 :: int)::ii)  ::  5 Word.word)) in
     Some (C2Dump rt))
   else Some (RI () ))"


(*val execute_XORI : mword ty5 -> mword ty5 -> mword ty16 -> M unit*)

definition execute_XORI  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_XORI rs rt imm = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   wGPR rt ((xor_vec w__0 ((mips_zero_extend (( 64 :: int)::ii) imm  ::  64 Word.word))  ::  64 Word.word))))"


(*val execute_XOR : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_XOR  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_XOR rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   wGPR rd ((xor_vec w__0 w__1  ::  64 Word.word)))))"


(*val execute_WAIT : unit -> M unit*)

definition execute_WAIT  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_WAIT _ = (
   (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 :: 64 bits) .  write_reg nextPC_ref w__0))"


(*val execute_TRAPREG : mword ty5 -> mword ty5 -> Comparison -> M unit*)

definition execute_TRAPREG  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> Comparison \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_TRAPREG rs rt cmp = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> rs_val . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> rt_val . 
   (let condition = (compare cmp rs_val rt_val) in
   if condition then SignalException Tr
   else return () ))))"


(*val execute_TRAPIMM : mword ty5 -> mword ty16 -> Comparison -> M unit*)

definition execute_TRAPIMM  :: "(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow> Comparison \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_TRAPIMM rs imm cmp = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> rs_val . 
   (let (imm_val :: 64 bits) = ((mips_sign_extend (( 64 :: int)::ii) imm  ::  64 Word.word)) in
   (let condition = (compare cmp rs_val imm_val) in
   if condition then SignalException Tr
   else return () ))))"


(*val execute_TLBWR : unit -> M unit*)

definition execute_TLBWR  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_TLBWR _ = (
   (checkCP0Access ()  \<then>
   (read_reg TLBRandom_ref  :: ( 6 Word.word) M)) \<bind> (\<lambda> (w__0 :: TLBIndexT) .  TLBWriteEntry w__0))"


(*val execute_TLBWI : unit -> M unit*)

definition execute_TLBWI  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_TLBWI _ = (
   (checkCP0Access ()  \<then>
   (read_reg TLBIndex_ref  :: ( 6 Word.word) M)) \<bind> (\<lambda> (w__0 :: TLBIndexT) .  TLBWriteEntry w__0))"


(*val execute_TLBR : unit -> M unit*)

definition execute_TLBR  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_TLBR _ = (
   (checkCP0Access ()  \<then>
   (read_reg TLBIndex_ref  :: ( 6 Word.word) M)) \<bind> (\<lambda> (w__0 :: TLBIndexT) . 
   (let i = (Word.uint w__0) in
   reg_deref ((access_list_dec TLBEntries i)) \<bind> (\<lambda> entry . 
   ((((((((((((((((write_reg TLBPageMask_ref ((get_TLBEntry_pagemask entry  ::  16 Word.word)) \<then>
   set_TLBEntryHiReg_R TLBEntryHi_ref ((get_TLBEntry_r entry  ::  2 Word.word))) \<then>
   set_TLBEntryHiReg_VPN2 TLBEntryHi_ref ((get_TLBEntry_vpn2 entry  ::  27 Word.word))) \<then>
   set_TLBEntryHiReg_ASID TLBEntryHi_ref ((get_TLBEntry_asid entry  ::  8 Word.word))) \<then>
   set_TLBEntryLoReg_CapS TLBEntryLo0_ref ((get_TLBEntry_caps0 entry  ::  1 Word.word))) \<then>
   set_TLBEntryLoReg_CapL TLBEntryLo0_ref ((get_TLBEntry_capl0 entry  ::  1 Word.word))) \<then>
   set_TLBEntryLoReg_PFN TLBEntryLo0_ref ((get_TLBEntry_pfn0 entry  ::  24 Word.word))) \<then>
   set_TLBEntryLoReg_C TLBEntryLo0_ref ((get_TLBEntry_c0 entry  ::  3 Word.word))) \<then>
   set_TLBEntryLoReg_D TLBEntryLo0_ref ((get_TLBEntry_d0 entry  ::  1 Word.word))) \<then>
   set_TLBEntryLoReg_V TLBEntryLo0_ref ((get_TLBEntry_v0 entry  ::  1 Word.word))) \<then>
   set_TLBEntryLoReg_G TLBEntryLo0_ref ((get_TLBEntry_g entry  ::  1 Word.word))) \<then>
   set_TLBEntryLoReg_CapS TLBEntryLo1_ref ((get_TLBEntry_caps1 entry  ::  1 Word.word))) \<then>
   set_TLBEntryLoReg_CapL TLBEntryLo1_ref ((get_TLBEntry_capl1 entry  ::  1 Word.word))) \<then>
   set_TLBEntryLoReg_PFN TLBEntryLo1_ref ((get_TLBEntry_pfn1 entry  ::  24 Word.word))) \<then>
   set_TLBEntryLoReg_C TLBEntryLo1_ref ((get_TLBEntry_c1 entry  ::  3 Word.word))) \<then>
   set_TLBEntryLoReg_D TLBEntryLo1_ref ((get_TLBEntry_d1 entry  ::  1 Word.word))) \<then>
   set_TLBEntryLoReg_V TLBEntryLo1_ref ((get_TLBEntry_v1 entry  ::  1 Word.word))) \<then>
   set_TLBEntryLoReg_G TLBEntryLo1_ref ((get_TLBEntry_g entry  ::  1 Word.word))))))"


(*val execute_TLBP : unit -> M unit*)

definition execute_TLBP  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_TLBP _ = (
   (checkCP0Access ()  \<then>
   read_reg TLBEntryHi_ref) \<bind> (\<lambda> (w__0 :: TLBEntryHiReg) . 
   (tlbSearch ((get_TLBEntryHiReg_bits w__0  ::  64 Word.word))  :: ( ( 6 Word.word)option) M) \<bind> (\<lambda> result . 
   (case  result of
     Some (idx) =>
      write_reg TLBProbe_ref (vec_of_bits [B0]  ::  1 Word.word) \<then> write_reg TLBIndex_ref idx
   | None =>
      write_reg TLBProbe_ref (vec_of_bits [B1]  ::  1 Word.word) \<then>
      write_reg TLBIndex_ref (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)
   ))))"


(*val execute_Store : WordType -> bool -> mword ty5 -> mword ty5 -> mword ty16 -> M unit*)

definition execute_Store  :: " WordType \<Rightarrow> bool \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_Store width conditional base rt offset = (
   (rGPR base  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (addrWrapper ((add_vec ((mips_sign_extend (( 64 :: int)::ii) offset  ::  64 Word.word)) w__0  ::  64 Word.word))
      StoreData width
     :: ( 64 Word.word) M) \<bind> (\<lambda> (vAddr :: 64 bits) . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> rt_val . 
   if ((\<not> ((isAddressAligned vAddr width)))) then SignalExceptionBadAddr AdES vAddr
   else
     (TLBTranslate vAddr StoreData  :: ( 64 Word.word) M) \<bind> (\<lambda> pAddr . 
     if conditional then
       (read_reg CP0LLBit_ref  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__1 :: 1 bits) . 
       (if ((bit_to_bool ((access_vec_dec w__1 (( 0 :: int)::ii))))) then
          (case  width of
            W =>
             MEMw_conditional_wrapper pAddr (( 4 :: int)::ii)
               ((subrange_vec_dec rt_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
          | D => MEMw_conditional_wrapper pAddr (( 8 :: int)::ii) rt_val
          | _ => throw (Error_internal_error () )
          )
        else return False) \<bind> (\<lambda> (success :: bool) . 
       wGPR rt ((mips_zero_extend (( 64 :: int)::ii) ((bool_to_bits success  ::  1 Word.word))  ::  64 Word.word))))
     else
       (case  width of
         B => MEMw_wrapper pAddr (( 1 :: int)::ii) ((subrange_vec_dec rt_val (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
       | H => MEMw_wrapper pAddr (( 2 :: int)::ii) ((subrange_vec_dec rt_val (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
       | W => MEMw_wrapper pAddr (( 4 :: int)::ii) ((subrange_vec_dec rt_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
       | D => MEMw_wrapper pAddr (( 8 :: int)::ii) rt_val
       ))))))"


(*val execute_SYSCALL : unit -> M unit*)

definition execute_SYSCALL  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_SYSCALL _ = ( SignalException Sys )"


(*val execute_SYNC : unit -> M unit*)

definition execute_SYNC  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_SYNC _ = ( MEM_sync ()  )"


(*val execute_SWR : mword ty5 -> mword ty5 -> mword ty16 -> M unit*)

definition execute_SWR  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_SWR base rt offset = (
   (rGPR base  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (addrWrapperUnaligned
      ((add_vec ((mips_sign_extend (( 64 :: int)::ii) offset  ::  64 Word.word)) w__0  ::  64 Word.word)) StoreData WR
     :: ( 64 Word.word) M) \<bind> (\<lambda> vAddr . 
   (TLBTranslate vAddr StoreData  :: ( 64 Word.word) M) \<bind> (\<lambda> pAddr . 
   (let wordAddr =
     ((concat_vec ((subrange_vec_dec pAddr (( 63 :: int)::ii) (( 2 :: int)::ii)  ::  62 Word.word))
        (vec_of_bits [B0,B0]  ::  2 Word.word)
       ::  64 Word.word)) in
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> reg_val . 
   (let b__12 = ((subrange_vec_dec vAddr (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) in
   if (((b__12 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
     MEMw_wrapper wordAddr (( 1 :: int)::ii) ((subrange_vec_dec reg_val (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
   else if (((b__12 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
     MEMw_wrapper wordAddr (( 2 :: int)::ii) ((subrange_vec_dec reg_val (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
   else if (((b__12 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
     MEMw_wrapper wordAddr (( 3 :: int)::ii) ((subrange_vec_dec reg_val (( 23 :: int)::ii) (( 0 :: int)::ii)  ::  24 Word.word))
   else MEMw_wrapper wordAddr (( 4 :: int)::ii) ((subrange_vec_dec reg_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)))))))))"


(*val execute_SWL : mword ty5 -> mword ty5 -> mword ty16 -> M unit*)

definition execute_SWL  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_SWL base rt offset = (
   (rGPR base  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (addrWrapperUnaligned
      ((add_vec ((mips_sign_extend (( 64 :: int)::ii) offset  ::  64 Word.word)) w__0  ::  64 Word.word)) StoreData WL
     :: ( 64 Word.word) M) \<bind> (\<lambda> vAddr . 
   (TLBTranslate vAddr StoreData  :: ( 64 Word.word) M) \<bind> (\<lambda> pAddr . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> reg_val . 
   (let b__8 = ((subrange_vec_dec vAddr (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) in
   if (((b__8 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
     MEMw_wrapper pAddr (( 4 :: int)::ii) ((subrange_vec_dec reg_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
   else if (((b__8 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
     MEMw_wrapper pAddr (( 3 :: int)::ii) ((subrange_vec_dec reg_val (( 31 :: int)::ii) (( 8 :: int)::ii)  ::  24 Word.word))
   else if (((b__8 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
     MEMw_wrapper pAddr (( 2 :: int)::ii) ((subrange_vec_dec reg_val (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))
   else MEMw_wrapper pAddr (( 1 :: int)::ii) ((subrange_vec_dec reg_val (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word))))))))"


(*val execute_SUBU : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_SUBU  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_SUBU rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> opA . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> opB . 
   if (((((NotWordVal opA)) \<or> ((NotWordVal opB))))) then
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) .  wGPR rd w__0)
   else
     wGPR rd
       ((mips_sign_extend (( 64 :: int)::ii)
           ((sub_vec ((subrange_vec_dec opA (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
               ((subrange_vec_dec opB (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
              ::  32 Word.word))
          ::  64 Word.word)))))"


(*val execute_SUB : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_SUB  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_SUB rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> opA . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> opB . 
   if (((((NotWordVal opA)) \<or> ((NotWordVal opB))))) then
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) .  wGPR rd w__0)
   else
     (let (temp33 :: 33 bits) =
       ((sub_vec
          ((mips_sign_extend (( 33 :: int)::ii) ((subrange_vec_dec opA (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
             ::  33 Word.word))
          ((mips_sign_extend (( 33 :: int)::ii) ((subrange_vec_dec opB (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
             ::  33 Word.word))
         ::  33 Word.word)) in
     if ((neq_bool ((bit_to_bool ((access_vec_dec temp33 (( 32 :: int)::ii)))))
            ((bit_to_bool ((access_vec_dec temp33 (( 31 :: int)::ii))))))) then
       SignalException Ov
     else
       wGPR rd
         ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec temp33 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ::  64 Word.word))))))"


(*val execute_SRLV : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_SRLV  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_SRLV rs rt rd = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> temp . 
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (let sa = ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
   if ((NotWordVal temp)) then
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) .  wGPR rd w__1)
   else
     (let rt32 = ((subrange_vec_dec temp (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
     (shift_bits_right 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict rt32 sa  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__2 ::  32 Word.word) . 
     wGPR rd ((mips_sign_extend (( 64 :: int)::ii) w__2  ::  64 Word.word))))))))"


(*val execute_SRL : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_SRL  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_SRL rt rd sa = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> temp . 
   if ((NotWordVal temp)) then
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) .  wGPR rd w__0)
   else
     (let rt32 = ((subrange_vec_dec temp (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
     (shift_bits_right 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict rt32 sa  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 ::  32 Word.word) . 
     wGPR rd ((mips_sign_extend (( 64 :: int)::ii) w__1  ::  64 Word.word))))))"


(*val execute_SRAV : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_SRAV  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_SRAV rs rt rd = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> temp . 
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (let sa = ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
   if ((NotWordVal temp)) then
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) .  wGPR rd w__1)
   else
     (let rt32 = ((subrange_vec_dec temp (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
     (shift_bits_right_arith 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict rt32 sa  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__2 ::  32 Word.word) . 
     wGPR rd ((mips_sign_extend (( 64 :: int)::ii) w__2  ::  64 Word.word))))))))"


(*val execute_SRA : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_SRA  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_SRA rt rd sa = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> temp . 
   if ((NotWordVal temp)) then
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) .  wGPR rd w__0)
   else
     (let rt32 = ((subrange_vec_dec temp (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
     (shift_bits_right_arith 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict rt32 sa  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 ::  32 Word.word) . 
     wGPR rd ((mips_sign_extend (( 64 :: int)::ii) w__1  ::  64 Word.word))))))"


(*val execute_SLTU : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_SLTU  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_SLTU rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> rs_val . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> rt_val . 
   wGPR rd
     ((mips_zero_extend (( 64 :: int)::ii)
         (if ((zopz0zI_u rs_val rt_val)) then (vec_of_bits [B1]  ::  1 Word.word)
          else (vec_of_bits [B0]  ::  1 Word.word))
        ::  64 Word.word)))))"


(*val execute_SLTIU : mword ty5 -> mword ty5 -> mword ty16 -> M unit*)

definition execute_SLTIU  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_SLTIU rs rt imm = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> rs_val . 
   (let (immext :: 64 bits) = ((mips_sign_extend (( 64 :: int)::ii) imm  ::  64 Word.word)) in
   wGPR rt
     ((mips_zero_extend (( 64 :: int)::ii)
         (if ((zopz0zI_u rs_val immext)) then (vec_of_bits [B1]  ::  1 Word.word)
          else (vec_of_bits [B0]  ::  1 Word.word))
        ::  64 Word.word)))))"


(*val execute_SLTI : mword ty5 -> mword ty5 -> mword ty16 -> M unit*)

definition execute_SLTI  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_SLTI rs rt imm = (
   (let imm_val = (Word.sint imm) in
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (let rs_val = (Word.sint w__0) in
   wGPR rt
     ((mips_zero_extend (( 64 :: int)::ii)
         (if ((rs_val < imm_val)) then (vec_of_bits [B1]  ::  1 Word.word)
          else (vec_of_bits [B0]  ::  1 Word.word))
        ::  64 Word.word))))))"


(*val execute_SLT : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_SLT  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_SLT rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   wGPR rd
     ((mips_zero_extend (( 64 :: int)::ii)
         (if ((zopz0zI_s w__0 w__1)) then (vec_of_bits [B1]  ::  1 Word.word)
          else (vec_of_bits [B0]  ::  1 Word.word))
        ::  64 Word.word)))))"


(*val execute_SLLV : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_SLLV  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_SLLV rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (let sa = ((subrange_vec_dec w__0 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   (let rt32 = ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
   (shift_bits_left instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict rt32 sa  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__2 ::  32 Word.word) . 
   wGPR rd ((mips_sign_extend (( 64 :: int)::ii) w__2  ::  64 Word.word))))))))"


(*val execute_SLL : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_SLL  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_SLL rt rd sa = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (let rt32 = ((subrange_vec_dec w__0 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
   (shift_bits_left instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict rt32 sa  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 ::  32 Word.word) . 
   wGPR rd ((mips_sign_extend (( 64 :: int)::ii) w__1  ::  64 Word.word))))))"


(*val execute_SDR : mword ty5 -> mword ty5 -> mword ty16 -> M unit*)

definition execute_SDR  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_SDR base rt offset = (
   (rGPR base  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (addrWrapperUnaligned
      ((add_vec ((mips_sign_extend (( 64 :: int)::ii) offset  ::  64 Word.word)) w__0  ::  64 Word.word)) StoreData DR
     :: ( 64 Word.word) M) \<bind> (\<lambda> vAddr . 
   (TLBTranslate vAddr StoreData  :: ( 64 Word.word) M) \<bind> (\<lambda> pAddr . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> reg_val . 
   (let wordAddr =
     ((concat_vec ((subrange_vec_dec pAddr (( 63 :: int)::ii) (( 3 :: int)::ii)  ::  61 Word.word))
        (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
       ::  64 Word.word)) in
   (let b__40 = ((subrange_vec_dec vAddr (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) in
   if (((b__40 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) then
     MEMw_wrapper wordAddr (( 1 :: int)::ii) ((subrange_vec_dec reg_val (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
   else if (((b__40 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) then
     MEMw_wrapper wordAddr (( 2 :: int)::ii) ((subrange_vec_dec reg_val (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
   else if (((b__40 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) then
     MEMw_wrapper wordAddr (( 3 :: int)::ii) ((subrange_vec_dec reg_val (( 23 :: int)::ii) (( 0 :: int)::ii)  ::  24 Word.word))
   else if (((b__40 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) then
     MEMw_wrapper wordAddr (( 4 :: int)::ii) ((subrange_vec_dec reg_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
   else if (((b__40 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) then
     MEMw_wrapper wordAddr (( 5 :: int)::ii) ((subrange_vec_dec reg_val (( 39 :: int)::ii) (( 0 :: int)::ii)  ::  40 Word.word))
   else if (((b__40 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) then
     MEMw_wrapper wordAddr (( 6 :: int)::ii) ((subrange_vec_dec reg_val (( 47 :: int)::ii) (( 0 :: int)::ii)  ::  48 Word.word))
   else if (((b__40 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) then
     MEMw_wrapper wordAddr (( 7 :: int)::ii) ((subrange_vec_dec reg_val (( 55 :: int)::ii) (( 0 :: int)::ii)  ::  56 Word.word))
   else MEMw_wrapper wordAddr (( 8 :: int)::ii) ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word)))))))))"


(*val execute_SDL : mword ty5 -> mword ty5 -> mword ty16 -> M unit*)

definition execute_SDL  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_SDL base rt offset = (
   (rGPR base  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (addrWrapperUnaligned
      ((add_vec ((mips_sign_extend (( 64 :: int)::ii) offset  ::  64 Word.word)) w__0  ::  64 Word.word)) StoreData DL
     :: ( 64 Word.word) M) \<bind> (\<lambda> vAddr . 
   (TLBTranslate vAddr StoreData  :: ( 64 Word.word) M) \<bind> (\<lambda> pAddr . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> reg_val . 
   (let b__32 = ((subrange_vec_dec vAddr (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) in
   if (((b__32 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) then
     MEMw_wrapper pAddr (( 8 :: int)::ii) ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
   else if (((b__32 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) then
     MEMw_wrapper pAddr (( 7 :: int)::ii) ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 8 :: int)::ii)  ::  56 Word.word))
   else if (((b__32 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) then
     MEMw_wrapper pAddr (( 6 :: int)::ii) ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 16 :: int)::ii)  ::  48 Word.word))
   else if (((b__32 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) then
     MEMw_wrapper pAddr (( 5 :: int)::ii) ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 24 :: int)::ii)  ::  40 Word.word))
   else if (((b__32 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) then
     MEMw_wrapper pAddr (( 4 :: int)::ii) ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
   else if (((b__32 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) then
     MEMw_wrapper pAddr (( 3 :: int)::ii) ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 40 :: int)::ii)  ::  24 Word.word))
   else if (((b__32 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) then
     MEMw_wrapper pAddr (( 2 :: int)::ii) ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 48 :: int)::ii)  ::  16 Word.word))
   else MEMw_wrapper pAddr (( 1 :: int)::ii) ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 56 :: int)::ii)  ::  8 Word.word))))))))"


(*val execute_RI : unit -> M unit*)

definition execute_RI  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_RI _ = ( SignalException ResI )"


(*val execute_RDHWR : mword ty5 -> mword ty5 -> M unit*)

definition execute_RDHWR  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_RDHWR rt rd = (
   getAccessLevel ()  \<bind> (\<lambda> accessLevel . 
   (let (haveAccessLevel :: bool) = (accessLevel = Kernel) in
   read_reg CP0Status_ref \<bind> (\<lambda> (w__0 :: StatusReg) . 
   (let (haveCU0 :: bool) =
     (B1 = ((access_vec_dec ((get_StatusReg_CU w__0  ::  4 Word.word)) (( 0 :: int)::ii)))) in
   (let rdi = (Word.uint rd) in
   (read_reg CP0HWREna_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 :: 32 bits) . 
   (let (haveHWREna :: bool) = (B1 = ((access_vec_dec w__1 rdi))) in
   (if ((\<not> (((haveAccessLevel \<or> (((haveCU0 \<or> haveHWREna)))))))) then SignalException ResI
    else return () ) \<then>
   ((let b__146 = rd in
   (if (((b__146 = (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)))) then
      return ((mips_zero_extend (( 64 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  64 Word.word))
    else if (((b__146 = (vec_of_bits [B0,B0,B0,B0,B1]  ::  5 Word.word)))) then
      return ((mips_zero_extend (( 64 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  64 Word.word))
    else if (((b__146 = (vec_of_bits [B0,B0,B0,B1,B0]  ::  5 Word.word)))) then
      (read_reg CP0Count_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__2 :: 32 bits) . 
      return ((mips_zero_extend (( 64 :: int)::ii) w__2  ::  64 Word.word)))
    else if (((b__146 = (vec_of_bits [B0,B0,B0,B1,B1]  ::  5 Word.word)))) then
      return ((mips_zero_extend (( 64 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)  ::  64 Word.word))
    else if (((b__146 = (vec_of_bits [B1,B1,B1,B0,B1]  ::  5 Word.word)))) then
      (read_reg CP0UserLocal_ref  :: ( 64 Word.word) M)
    else (SignalException ResI  :: ( 64 Word.word) M)) \<bind> (\<lambda> (temp :: 64 bits) . 
   wGPR rt temp)))))))))))"


(*val execute_ORI : mword ty5 -> mword ty5 -> mword ty16 -> M unit*)

definition execute_ORI  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_ORI rs rt imm = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   wGPR rt ((or_vec w__0 ((mips_zero_extend (( 64 :: int)::ii) imm  ::  64 Word.word))  ::  64 Word.word))))"


(*val execute_OR : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_OR  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_OR rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   wGPR rd ((or_vec w__0 w__1  ::  64 Word.word)))))"


(*val execute_NOR : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_NOR  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_NOR rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   wGPR rd ((not_vec ((or_vec w__0 w__1  ::  64 Word.word))  ::  64 Word.word)))))"


(*val execute_MULTU : mword ty5 -> mword ty5 -> M unit*)

definition execute_MULTU  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_MULTU rs rt = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> rsVal . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> rtVal . 
   (if (((((NotWordVal rsVal)) \<or> ((NotWordVal rtVal))))) then
      (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M)
    else
      return ((mult_vec ((subrange_vec_dec rsVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                 ((subrange_vec_dec rtVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                ::  64 Word.word))) \<bind> (\<lambda> (result :: 64 bits) . 
   write_reg
     HI_ref
     ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec result (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
        ::  64 Word.word)) \<then>
   write_reg
     LO_ref
     ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
        ::  64 Word.word))))))"


(*val execute_MULT : mword ty5 -> mword ty5 -> M unit*)

definition execute_MULT  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_MULT rs rt = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> rsVal . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> rtVal . 
   (if (((((NotWordVal rsVal)) \<or> ((NotWordVal rtVal))))) then
      (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M)
    else
      return ((mults_vec ((subrange_vec_dec rsVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                 ((subrange_vec_dec rtVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                ::  64 Word.word))) \<bind> (\<lambda> (result :: 64 bits) . 
   write_reg
     HI_ref
     ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec result (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
        ::  64 Word.word)) \<then>
   write_reg
     LO_ref
     ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
        ::  64 Word.word))))))"


(*val execute_MUL : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_MUL  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_MUL rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> rsVal . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> rtVal . 
   (let (result :: 64 bits) =
     ((mips_sign_extend (( 64 :: int)::ii)
        ((mults_vec ((subrange_vec_dec rsVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ((subrange_vec_dec rtVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
           ::  64 Word.word))
       ::  64 Word.word)) in
   (if (((((NotWordVal rsVal)) \<or> ((NotWordVal rtVal))))) then
      (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M)
    else
      return ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                ::  64 Word.word))) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   wGPR rd w__1)))))"


(*val execute_MTLO : mword ty5 -> M unit*)

definition execute_MTLO  :: "(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_MTLO rs = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) .  write_reg LO_ref w__0))"


(*val execute_MTHI : mword ty5 -> M unit*)

definition execute_MTHI  :: "(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_MTHI rs = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) .  write_reg HI_ref w__0))"


(*val execute_MTC0 : mword ty5 -> mword ty5 -> mword ty3 -> bool -> M unit*)

definition execute_MTC0  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(3)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_MTC0 rt rd sel double = (
   (checkCP0Access ()  \<then>
   (rGPR rt  :: ( 64 Word.word) M)) \<bind> (\<lambda> reg_val . 
   (case  (rd, sel) of
     (b__108, b__109) =>
      if ((((((b__108 = (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)))) \<and> (((b__109 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        write_reg TLBIndex_ref ((mask0 (( 6 :: int)::ii) reg_val  ::  6 Word.word))
      else if ((((((b__108 = (vec_of_bits [B0,B0,B0,B0,B1]  ::  5 Word.word)))) \<and> (((b__109 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        return () 
      else if ((((((b__108 = (vec_of_bits [B0,B0,B0,B1,B0]  ::  5 Word.word)))) \<and> (((b__109 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        set_TLBEntryLoReg_bits TLBEntryLo0_ref reg_val
      else if ((((((b__108 = (vec_of_bits [B0,B0,B0,B1,B1]  ::  5 Word.word)))) \<and> (((b__109 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        set_TLBEntryLoReg_bits TLBEntryLo1_ref reg_val
      else if ((((((b__108 = (vec_of_bits [B0,B0,B1,B0,B0]  ::  5 Word.word)))) \<and> (((b__109 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        set_ContextReg_PTEBase TLBContext_ref
          ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 23 :: int)::ii)  ::  41 Word.word))
      else if ((((((b__108 = (vec_of_bits [B0,B0,B1,B0,B0]  ::  5 Word.word)))) \<and> (((b__109 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word))))))) then
        write_reg CP0UserLocal_ref reg_val
      else if ((((((b__108 = (vec_of_bits [B0,B0,B1,B0,B1]  ::  5 Word.word)))) \<and> (((b__109 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        write_reg TLBPageMask_ref ((subrange_vec_dec reg_val (( 28 :: int)::ii) (( 13 :: int)::ii)  ::  16 Word.word))
      else if ((((((b__108 = (vec_of_bits [B0,B0,B1,B1,B0]  ::  5 Word.word)))) \<and> (((b__109 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        write_reg TLBWired_ref ((mask0 (( 6 :: int)::ii) reg_val  ::  6 Word.word)) \<then>
        write_reg TLBRandom_ref TLBIndexMax
      else if ((((((b__108 = (vec_of_bits [B0,B0,B1,B1,B1]  ::  5 Word.word)))) \<and> (((b__109 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        write_reg
          CP0HWREna_ref
          ((concat_vec ((subrange_vec_dec reg_val (( 31 :: int)::ii) (( 29 :: int)::ii)  ::  3 Word.word))
              ((concat_vec
                  (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                B0,B0]
                    ::  25 Word.word) ((subrange_vec_dec reg_val (( 3 :: int)::ii) (( 0 :: int)::ii)  ::  4 Word.word))
                 ::  29 Word.word))
             ::  32 Word.word))
      else if ((((((b__108 = (vec_of_bits [B0,B1,B0,B0,B0]  ::  5 Word.word)))) \<and> (((b__109 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        return () 
      else if ((((((b__108 = (vec_of_bits [B0,B1,B0,B0,B1]  ::  5 Word.word)))) \<and> (((b__109 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        write_reg CP0Count_ref ((subrange_vec_dec reg_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
      else if ((((((b__108 = (vec_of_bits [B0,B1,B0,B1,B0]  ::  5 Word.word)))) \<and> (((b__109 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        (set_TLBEntryHiReg_R TLBEntryHi_ref
          ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 62 :: int)::ii)  ::  2 Word.word)) \<then>
        set_TLBEntryHiReg_VPN2 TLBEntryHi_ref
          ((subrange_vec_dec reg_val (( 39 :: int)::ii) (( 13 :: int)::ii)  ::  27 Word.word))) \<then>
        set_TLBEntryHiReg_ASID TLBEntryHi_ref
          ((subrange_vec_dec reg_val (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
      else if ((((((b__108 = (vec_of_bits [B0,B1,B0,B1,B1]  ::  5 Word.word)))) \<and> (((b__109 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        (write_reg CP0Compare_ref ((subrange_vec_dec reg_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) \<then>
        read_reg CP0Cause_ref) \<bind> (\<lambda> (w__0 :: CauseReg) . 
        set_CauseReg_IP CP0Cause_ref
          ((and_vec ((get_CauseReg_IP w__0  ::  8 Word.word))
              (vec_of_bits [B0,B1,B1,B1,B1,B1,B1,B1]  ::  8 Word.word)
             ::  8 Word.word)))
      else if ((((((b__108 = (vec_of_bits [B0,B1,B1,B0,B0]  ::  5 Word.word)))) \<and> (((b__109 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        ((((((((set_StatusReg_CU CP0Status_ref ((subrange_vec_dec reg_val (( 31 :: int)::ii) (( 28 :: int)::ii)  ::  4 Word.word)) \<then>
        set_StatusReg_BEV CP0Status_ref
          ((cast_unit_vec0 ((access_vec_dec reg_val (( 22 :: int)::ii)))  ::  1 Word.word))) \<then>
        set_StatusReg_IM CP0Status_ref ((subrange_vec_dec reg_val (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))) \<then>
        set_StatusReg_KX CP0Status_ref
          ((cast_unit_vec0 ((access_vec_dec reg_val (( 7 :: int)::ii)))  ::  1 Word.word))) \<then>
        set_StatusReg_SX CP0Status_ref
          ((cast_unit_vec0 ((access_vec_dec reg_val (( 6 :: int)::ii)))  ::  1 Word.word))) \<then>
        set_StatusReg_UX CP0Status_ref
          ((cast_unit_vec0 ((access_vec_dec reg_val (( 5 :: int)::ii)))  ::  1 Word.word))) \<then>
        set_StatusReg_KSU CP0Status_ref ((subrange_vec_dec reg_val (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word))) \<then>
        set_StatusReg_ERL CP0Status_ref
          ((cast_unit_vec0 ((access_vec_dec reg_val (( 2 :: int)::ii)))  ::  1 Word.word))) \<then>
        set_StatusReg_EXL CP0Status_ref
          ((cast_unit_vec0 ((access_vec_dec reg_val (( 1 :: int)::ii)))  ::  1 Word.word))) \<then>
        set_StatusReg_IE CP0Status_ref
          ((cast_unit_vec0 ((access_vec_dec reg_val (( 0 :: int)::ii)))  ::  1 Word.word))
      else if ((((((b__108 = (vec_of_bits [B0,B1,B1,B0,B1]  ::  5 Word.word)))) \<and> (((b__109 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        (set_CauseReg_IV CP0Cause_ref
          ((cast_unit_vec0 ((access_vec_dec reg_val (( 23 :: int)::ii)))  ::  1 Word.word)) \<then>
        read_reg CP0Cause_ref) \<bind> (\<lambda> (w__1 :: CauseReg) . 
        (let ip = ((get_CauseReg_IP w__1  ::  8 Word.word)) in
        set_CauseReg_IP CP0Cause_ref
          ((concat_vec ((subrange_vec_dec ip (( 7 :: int)::ii) (( 2 :: int)::ii)  ::  6 Word.word))
              ((subrange_vec_dec reg_val (( 9 :: int)::ii) (( 8 :: int)::ii)  ::  2 Word.word))
             ::  8 Word.word))))
      else if ((((((b__108 = (vec_of_bits [B0,B1,B1,B1,B0]  ::  5 Word.word)))) \<and> (((b__109 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        write_reg CP0EPC_ref reg_val
      else if ((((((b__108 = (vec_of_bits [B1,B0,B0,B0,B0]  ::  5 Word.word)))) \<and> (((b__109 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        write_reg CP0ConfigK0_ref ((subrange_vec_dec reg_val (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word))
      else if ((((((b__108 = (vec_of_bits [B1,B0,B1,B0,B0]  ::  5 Word.word)))) \<and> (((b__109 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        set_XContextReg_XPTEBase TLBXContext_ref
          ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 33 :: int)::ii)  ::  31 Word.word))
      else if ((((((b__108 = (vec_of_bits [B1,B1,B1,B1,B0]  ::  5 Word.word)))) \<and> (((b__109 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        write_reg CP0ErrorEPC_ref reg_val
      else SignalException ResI
   )))"


(*val execute_MSUBU : mword ty5 -> mword ty5 -> M unit*)

definition execute_MSUBU  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_MSUBU rs rt = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> rsVal . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> rtVal . 
   (if (((((NotWordVal rsVal)) \<or> ((NotWordVal rtVal))))) then
      (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M)
    else
      return ((mult_vec ((subrange_vec_dec rsVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                 ((subrange_vec_dec rtVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                ::  64 Word.word))) \<bind> (\<lambda> (mul_result :: 64 bits) . 
   (read_reg HI_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 :: 64 bits) . 
   (read_reg LO_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 :: 64 bits) . 
   (let result =
     ((sub_vec
        ((concat_vec ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
           ::  64 Word.word)) mul_result
       ::  64 Word.word)) in
   write_reg
     HI_ref
     ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec result (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
        ::  64 Word.word)) \<then>
   write_reg
     LO_ref
     ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
        ::  64 Word.word)))))))))"


(*val execute_MSUB : mword ty5 -> mword ty5 -> M unit*)

definition execute_MSUB  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_MSUB rs rt = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> rsVal . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> rtVal . 
   (if (((((NotWordVal rsVal)) \<or> ((NotWordVal rtVal))))) then
      (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M)
    else
      return ((mults_vec ((subrange_vec_dec rsVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                 ((subrange_vec_dec rtVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                ::  64 Word.word))) \<bind> (\<lambda> (mul_result :: 64 bits) . 
   (read_reg HI_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 :: 64 bits) . 
   (read_reg LO_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 :: 64 bits) . 
   (let result =
     ((sub_vec
        ((concat_vec ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
           ::  64 Word.word)) mul_result
       ::  64 Word.word)) in
   write_reg
     HI_ref
     ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec result (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
        ::  64 Word.word)) \<then>
   write_reg
     LO_ref
     ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
        ::  64 Word.word)))))))))"


(*val execute_MOVZ : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_MOVZ  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_MOVZ rs rt rd = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   if (((w__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                        B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                        B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
            ::  64 Word.word)))) then
     (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) .  wGPR rd w__1)
   else return () ))"


(*val execute_MOVN : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_MOVN  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_MOVN rs rt rd = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   if (((w__0 \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                        B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                        B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
            ::  64 Word.word)))) then
     (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) .  wGPR rd w__1)
   else return () ))"


(*val execute_MFLO : mword ty5 -> M unit*)

definition execute_MFLO  :: "(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_MFLO rd = ( (read_reg LO_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 :: 64 bits) .  wGPR rd w__0))"


(*val execute_MFHI : mword ty5 -> M unit*)

definition execute_MFHI  :: "(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_MFHI rd = ( (read_reg HI_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 :: 64 bits) .  wGPR rd w__0))"


(*val execute_MFC0 : mword ty5 -> mword ty5 -> mword ty3 -> bool -> M unit*)

definition execute_MFC0  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(3)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_MFC0 rt rd sel double = (
   (checkCP0Access ()  \<then>
   (case  (rd, sel) of
     (b__48, b__49) =>
      if ((((((b__48 = (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)))) \<and> (((b__49 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        (read_reg TLBIndex_ref  :: ( 6 Word.word) M) \<bind> (\<lambda> (w__0 :: TLBIndexT) . 
        (let (idx :: 31 bits) = ((mips_zero_extend (( 31 :: int)::ii) w__0  ::  31 Word.word)) in
        (read_reg TLBProbe_ref  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__1 :: 1 bits) . 
        return ((concat_vec
                   (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                 B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
                     ::  32 Word.word) ((concat_vec w__1 idx  ::  32 Word.word))
                  ::  64 Word.word)))))
      else if ((((((b__48 = (vec_of_bits [B0,B0,B0,B0,B1]  ::  5 Word.word)))) \<and> (((b__49 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        (read_reg TLBRandom_ref  :: ( 6 Word.word) M) \<bind> (\<lambda> (w__2 :: TLBIndexT) . 
        return ((mips_zero_extend (( 64 :: int)::ii) w__2  ::  64 Word.word)))
      else if ((((((b__48 = (vec_of_bits [B0,B0,B0,B1,B0]  ::  5 Word.word)))) \<and> (((b__49 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        read_reg TLBEntryLo0_ref \<bind> (\<lambda> (w__3 :: TLBEntryLoReg) . 
        return ((get_TLBEntryLoReg_bits w__3  ::  64 Word.word)))
      else if ((((((b__48 = (vec_of_bits [B0,B0,B0,B1,B1]  ::  5 Word.word)))) \<and> (((b__49 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        read_reg TLBEntryLo1_ref \<bind> (\<lambda> (w__4 :: TLBEntryLoReg) . 
        return ((get_TLBEntryLoReg_bits w__4  ::  64 Word.word)))
      else if ((((((b__48 = (vec_of_bits [B0,B0,B1,B0,B0]  ::  5 Word.word)))) \<and> (((b__49 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        read_reg TLBContext_ref \<bind> (\<lambda> (w__5 :: ContextReg) . 
        return ((get_ContextReg_bits w__5  ::  64 Word.word)))
      else if ((((((b__48 = (vec_of_bits [B0,B0,B1,B0,B0]  ::  5 Word.word)))) \<and> (((b__49 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word))))))) then
        (read_reg CP0UserLocal_ref  :: ( 64 Word.word) M)
      else if ((((((b__48 = (vec_of_bits [B0,B0,B1,B0,B1]  ::  5 Word.word)))) \<and> (((b__49 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        (read_reg TLBPageMask_ref  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__7 :: 16 bits) . 
        return ((mips_zero_extend (( 64 :: int)::ii)
                   ((concat_vec w__7
                       (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)
                      ::  28 Word.word))
                  ::  64 Word.word)))
      else if ((((((b__48 = (vec_of_bits [B0,B0,B1,B1,B0]  ::  5 Word.word)))) \<and> (((b__49 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        (read_reg TLBWired_ref  :: ( 6 Word.word) M) \<bind> (\<lambda> (w__8 :: TLBIndexT) . 
        return ((mips_zero_extend (( 64 :: int)::ii) w__8  ::  64 Word.word)))
      else if ((((((b__48 = (vec_of_bits [B0,B0,B1,B1,B1]  ::  5 Word.word)))) \<and> (((b__49 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        (read_reg CP0HWREna_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__9 :: 32 bits) . 
        return ((mips_zero_extend (( 64 :: int)::ii) w__9  ::  64 Word.word)))
      else if ((((((b__48 = (vec_of_bits [B0,B1,B0,B0,B0]  ::  5 Word.word)))) \<and> (((b__49 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        (read_reg CP0BadVAddr_ref  :: ( 64 Word.word) M)
      else if ((((((b__48 = (vec_of_bits [B0,B1,B0,B0,B0]  ::  5 Word.word)))) \<and> (((b__49 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word))))))) then
        return ((mips_zero_extend (( 64 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  64 Word.word))
      else if ((((((b__48 = (vec_of_bits [B0,B1,B0,B0,B1]  ::  5 Word.word)))) \<and> (((b__49 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        (read_reg CP0Count_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__11 :: 32 bits) . 
        return ((mips_zero_extend (( 64 :: int)::ii) w__11  ::  64 Word.word)))
      else if ((((((b__48 = (vec_of_bits [B0,B1,B0,B1,B0]  ::  5 Word.word)))) \<and> (((b__49 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        read_reg TLBEntryHi_ref \<bind> (\<lambda> (w__12 :: TLBEntryHiReg) . 
        return ((get_TLBEntryHiReg_bits w__12  ::  64 Word.word)))
      else if ((((((b__48 = (vec_of_bits [B0,B1,B0,B1,B1]  ::  5 Word.word)))) \<and> (((b__49 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        (read_reg CP0Compare_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__13 :: 32 bits) . 
        return ((mips_zero_extend (( 64 :: int)::ii) w__13  ::  64 Word.word)))
      else if ((((((b__48 = (vec_of_bits [B0,B1,B1,B0,B0]  ::  5 Word.word)))) \<and> (((b__49 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        read_reg CP0Status_ref \<bind> (\<lambda> (w__14 :: StatusReg) . 
        return ((mips_zero_extend (( 64 :: int)::ii) ((get_StatusReg_bits w__14  ::  32 Word.word))  ::  64 Word.word)))
      else if ((((((b__48 = (vec_of_bits [B0,B1,B1,B0,B1]  ::  5 Word.word)))) \<and> (((b__49 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        read_reg CP0Cause_ref \<bind> (\<lambda> (w__15 :: CauseReg) . 
        return ((mips_zero_extend (( 64 :: int)::ii) ((get_CauseReg_bits w__15  ::  32 Word.word))  ::  64 Word.word)))
      else if ((((((b__48 = (vec_of_bits [B0,B1,B1,B1,B0]  ::  5 Word.word)))) \<and> (((b__49 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        (read_reg CP0EPC_ref  :: ( 64 Word.word) M)
      else if ((((((b__48 = (vec_of_bits [B0,B1,B1,B1,B1]  ::  5 Word.word)))) \<and> (((b__49 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        return ((mips_zero_extend (( 64 :: int)::ii)
                   (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,
                                 B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
                     ::  32 Word.word)
                  ::  64 Word.word))
      else if ((((((b__48 = (vec_of_bits [B0,B1,B1,B1,B1]  ::  5 Word.word)))) \<and> (((b__49 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word))))))) then
        return ((mips_zero_extend (( 64 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  64 Word.word))
      else if ((((((b__48 = (vec_of_bits [B0,B1,B1,B1,B1]  ::  5 Word.word)))) \<and> (((b__49 = (vec_of_bits [B1,B1,B1]  ::  3 Word.word))))))) then
        return ((mips_zero_extend (( 64 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  64 Word.word))
      else if ((((((b__48 = (vec_of_bits [B1,B0,B0,B0,B0]  ::  5 Word.word)))) \<and> (((b__49 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        (read_reg CP0ConfigK0_ref  :: ( 3 Word.word) M) \<bind> (\<lambda> (w__17 :: 3 bits) . 
        return ((mips_zero_extend (( 64 :: int)::ii)
                   ((concat_vec (vec_of_bits [B1]  ::  1 Word.word)
                       ((concat_vec
                           (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  15 Word.word)
                           ((concat_vec (vec_of_bits [B1]  ::  1 Word.word)
                               ((concat_vec (vec_of_bits [B1,B0]  ::  2 Word.word)
                                   ((concat_vec (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                                       ((concat_vec (vec_of_bits [B0,B0,B1]  ::  3 Word.word)
                                           ((concat_vec (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)
                                               w__17
                                              ::  7 Word.word))
                                          ::  10 Word.word))
                                      ::  13 Word.word))
                                  ::  15 Word.word))
                              ::  16 Word.word))
                          ::  31 Word.word))
                      ::  32 Word.word))
                  ::  64 Word.word)))
      else if ((((((b__48 = (vec_of_bits [B1,B0,B0,B0,B0]  ::  5 Word.word)))) \<and> (((b__49 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word))))))) then
        return ((mips_zero_extend (( 64 :: int)::ii)
                   ((concat_vec (vec_of_bits [B1]  ::  1 Word.word)
                       ((concat_vec TLBIndexMax
                           ((concat_vec (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                               ((concat_vec (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                                   ((concat_vec (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                                       ((concat_vec (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                                           ((concat_vec (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                                               ((concat_vec (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                                                   ((concat_vec
                                                       ((bool_to_bits have_cp2  ::  1 Word.word))
                                                       ((concat_vec (vec_of_bits [B0]  ::  1 Word.word)
                                                           ((concat_vec
                                                               (vec_of_bits [B0]  ::  1 Word.word)
                                                               ((concat_vec
                                                                   (vec_of_bits [B0]  ::  1 Word.word)
                                                                   ((concat_vec
                                                                       (vec_of_bits [B0]
                                                                         ::  1 Word.word)
                                                                       ((concat_vec
                                                                           (vec_of_bits [B0]
                                                                             ::  1 Word.word)
                                                                           (vec_of_bits [B0]
                                                                             ::  1 Word.word)
                                                                          ::  2 Word.word))
                                                                      ::  3 Word.word))
                                                                  ::  4 Word.word))
                                                              ::  5 Word.word))
                                                          ::  6 Word.word))
                                                      ::  7 Word.word))
                                                  ::  10 Word.word))
                                              ::  13 Word.word))
                                          ::  16 Word.word))
                                      ::  19 Word.word))
                                  ::  22 Word.word))
                              ::  25 Word.word))
                          ::  31 Word.word))
                      ::  32 Word.word))
                  ::  64 Word.word))
      else if ((((((b__48 = (vec_of_bits [B1,B0,B0,B0,B0]  ::  5 Word.word)))) \<and> (((b__49 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word))))))) then
        return ((mips_zero_extend (( 64 :: int)::ii)
                   ((concat_vec (vec_of_bits [B1]  ::  1 Word.word)
                       ((concat_vec (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                           ((concat_vec (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)
                               ((concat_vec (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)
                                   ((concat_vec (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)
                                       ((concat_vec (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)
                                           ((concat_vec (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)
                                               ((concat_vec (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)
                                                   (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)
                                                  ::  8 Word.word))
                                              ::  12 Word.word))
                                          ::  16 Word.word))
                                      ::  20 Word.word))
                                  ::  24 Word.word))
                              ::  28 Word.word))
                          ::  31 Word.word))
                      ::  32 Word.word))
                  ::  64 Word.word))
      else if ((((((b__48 = (vec_of_bits [B1,B0,B0,B0,B0]  ::  5 Word.word)))) \<and> (((b__49 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word))))))) then
        return (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                             B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                             B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
                 ::  64 Word.word)
      else if ((((((b__48 = (vec_of_bits [B1,B0,B0,B0,B0]  ::  5 Word.word)))) \<and> (((b__49 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word))))))) then
        return (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                             B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                             B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
                 ::  64 Word.word)
      else if ((((((b__48 = (vec_of_bits [B1,B0,B0,B0,B1]  ::  5 Word.word)))) \<and> (((b__49 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        (read_reg CP0LLAddr_ref  :: ( 64 Word.word) M)
      else if ((((((b__48 = (vec_of_bits [B1,B0,B0,B1,B0]  ::  5 Word.word)))) \<and> (((b__49 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        return ((mips_zero_extend (( 64 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  64 Word.word))
      else if ((((((b__48 = (vec_of_bits [B1,B0,B0,B1,B1]  ::  5 Word.word)))) \<and> (((b__49 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        return ((mips_zero_extend (( 64 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  64 Word.word))
      else if ((((((b__48 = (vec_of_bits [B1,B0,B1,B0,B0]  ::  5 Word.word)))) \<and> (((b__49 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        read_reg TLBXContext_ref \<bind> (\<lambda> (w__19 :: XContextReg) . 
        return ((get_XContextReg_bits w__19  ::  64 Word.word)))
      else if ((((((b__48 = (vec_of_bits [B1,B1,B1,B1,B0]  ::  5 Word.word)))) \<and> (((b__49 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))))))) then
        (read_reg CP0ErrorEPC_ref  :: ( 64 Word.word) M)
      else (SignalException ResI  :: ( 64 Word.word) M)
   )) \<bind> (\<lambda> (result :: 64 bits) . 
   wGPR rt
     (if double then result
      else
        (mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
          ::  64 Word.word))))"


(*val execute_MADDU : mword ty5 -> mword ty5 -> M unit*)

definition execute_MADDU  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_MADDU rs rt = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> rsVal . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> rtVal . 
   (if (((((NotWordVal rsVal)) \<or> ((NotWordVal rtVal))))) then
      (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M)
    else
      return ((mult_vec ((subrange_vec_dec rsVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                 ((subrange_vec_dec rtVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                ::  64 Word.word))) \<bind> (\<lambda> (mul_result :: 64 bits) . 
   (read_reg HI_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 :: 64 bits) . 
   (read_reg LO_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 :: 64 bits) . 
   (let result =
     ((add_vec mul_result
        ((concat_vec ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
           ::  64 Word.word))
       ::  64 Word.word)) in
   write_reg
     HI_ref
     ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec result (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
        ::  64 Word.word)) \<then>
   write_reg
     LO_ref
     ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
        ::  64 Word.word)))))))))"


(*val execute_MADD : mword ty5 -> mword ty5 -> M unit*)

definition execute_MADD  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_MADD rs rt = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> rsVal . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> rtVal . 
   (if (((((NotWordVal rsVal)) \<or> ((NotWordVal rtVal))))) then
      (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M)
    else
      return ((mults_vec ((subrange_vec_dec rsVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                 ((subrange_vec_dec rtVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                ::  64 Word.word))) \<bind> (\<lambda> (mul_result :: 64 bits) . 
   (read_reg HI_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 :: 64 bits) . 
   (read_reg LO_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 :: 64 bits) . 
   (let result =
     ((add_vec mul_result
        ((concat_vec ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
           ::  64 Word.word))
       ::  64 Word.word)) in
   write_reg
     HI_ref
     ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec result (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
        ::  64 Word.word)) \<then>
   write_reg
     LO_ref
     ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
        ::  64 Word.word)))))))))"


(*val execute_Load : WordType -> bool -> bool -> mword ty5 -> mword ty5 -> mword ty16 -> M unit*)

definition execute_Load  :: " WordType \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_Load width sign linked base rt offset = (
   (rGPR base  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (addrWrapper ((add_vec ((mips_sign_extend (( 64 :: int)::ii) offset  ::  64 Word.word)) w__0  ::  64 Word.word))
      LoadData width
     :: ( 64 Word.word) M) \<bind> (\<lambda> (vAddr :: 64 bits) . 
   if ((\<not> ((isAddressAligned vAddr width)))) then SignalExceptionBadAddr AdEL vAddr
   else
     (TLBTranslate vAddr LoadData  :: ( 64 Word.word) M) \<bind> (\<lambda> pAddr . 
     (if linked then
        (write_reg CP0LLBit_ref (vec_of_bits [B1]  ::  1 Word.word) \<then>
        write_reg CP0LLAddr_ref pAddr) \<then>
        (case  width of
          W =>
           (MEMr_reserve_wrapper pAddr (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 ::  32 Word.word) . 
           return ((extendLoad w__1 sign  ::  64 Word.word)))
        | D =>
           (MEMr_reserve_wrapper pAddr (( 8 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::  64 Word.word) . 
           return ((extendLoad w__2 sign  ::  64 Word.word)))
        | _ => throw (Error_internal_error () )
        )
      else
        (case  width of
          B =>
           (MEMr_wrapper (( 8 :: int)::ii) pAddr (( 1 :: int)::ii)  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__5 ::  8 Word.word) . 
           return ((extendLoad w__5 sign  ::  64 Word.word)))
        | H =>
           (MEMr_wrapper (( 16 :: int)::ii) pAddr (( 2 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__6 ::  16 Word.word) . 
           return ((extendLoad w__6 sign  ::  64 Word.word)))
        | W =>
           (MEMr_wrapper (( 32 :: int)::ii) pAddr (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__7 ::  32 Word.word) . 
           return ((extendLoad w__7 sign  ::  64 Word.word)))
        | D =>
           (MEMr_wrapper (( 64 :: int)::ii) pAddr (( 8 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__8 ::  64 Word.word) . 
           return ((extendLoad w__8 sign  ::  64 Word.word)))
        )) \<bind> (\<lambda> (memResult :: 64 bits) . 
     wGPR rt memResult)))))"


(*val execute_LWR : mword ty5 -> mword ty5 -> mword ty16 -> M unit*)

definition execute_LWR  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_LWR base rt offset = (
   (rGPR base  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (addrWrapperUnaligned
      ((add_vec ((mips_sign_extend (( 64 :: int)::ii) offset  ::  64 Word.word)) w__0  ::  64 Word.word)) LoadData WR
     :: ( 64 Word.word) M) \<bind> (\<lambda> vAddr . 
   (TLBTranslate vAddr LoadData  :: ( 64 Word.word) M) \<bind> (\<lambda> pAddr . 
   (MEMr_wrapper (( 32 :: int)::ii)
      ((concat_vec ((subrange_vec_dec pAddr (( 63 :: int)::ii) (( 2 :: int)::ii)  ::  62 Word.word))
          (vec_of_bits [B0,B0]  ::  2 Word.word)
         ::  64 Word.word)) (( 4 :: int)::ii)
     :: ( 32 Word.word) M) \<bind> (\<lambda> mem_val . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> reg_val . 
   (let b__4 = ((subrange_vec_dec vAddr (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) in
   (let (result :: 32 bits) =
     (if (((b__4 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then
       (concat_vec ((subrange_vec_dec reg_val (( 31 :: int)::ii) (( 8 :: int)::ii)  ::  24 Word.word))
          ((subrange_vec_dec mem_val (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word))
         ::  32 Word.word)
     else if (((b__4 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
       (concat_vec ((subrange_vec_dec reg_val (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))
          ((subrange_vec_dec mem_val (( 31 :: int)::ii) (( 16 :: int)::ii)  ::  16 Word.word))
         ::  32 Word.word)
     else if (((b__4 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
       (concat_vec ((subrange_vec_dec reg_val (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word))
          ((subrange_vec_dec mem_val (( 31 :: int)::ii) (( 8 :: int)::ii)  ::  24 Word.word))
         ::  32 Word.word)
     else mem_val) in
   wGPR rt ((mips_sign_extend (( 64 :: int)::ii) result  ::  64 Word.word))))))))))"


(*val execute_LWL : mword ty5 -> mword ty5 -> mword ty16 -> M unit*)

definition execute_LWL  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_LWL base rt offset = (
   (rGPR base  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (addrWrapperUnaligned
      ((add_vec ((mips_sign_extend (( 64 :: int)::ii) offset  ::  64 Word.word)) w__0  ::  64 Word.word)) LoadData WL
     :: ( 64 Word.word) M) \<bind> (\<lambda> vAddr . 
   (TLBTranslate vAddr LoadData  :: ( 64 Word.word) M) \<bind> (\<lambda> pAddr . 
   (MEMr_wrapper (( 32 :: int)::ii)
      ((concat_vec ((subrange_vec_dec pAddr (( 63 :: int)::ii) (( 2 :: int)::ii)  ::  62 Word.word))
          (vec_of_bits [B0,B0]  ::  2 Word.word)
         ::  64 Word.word)) (( 4 :: int)::ii)
     :: ( 32 Word.word) M) \<bind> (\<lambda> mem_val . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> reg_val . 
   (let b__0 = ((subrange_vec_dec vAddr (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) in
   (let (result :: 32 bits) =
     (if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then mem_val
     else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then
       (concat_vec ((subrange_vec_dec mem_val (( 23 :: int)::ii) (( 0 :: int)::ii)  ::  24 Word.word))
          ((subrange_vec_dec reg_val (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
         ::  32 Word.word)
     else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then
       (concat_vec ((subrange_vec_dec mem_val (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
          ((subrange_vec_dec reg_val (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
         ::  32 Word.word)
     else
       (concat_vec ((subrange_vec_dec mem_val (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
          ((subrange_vec_dec reg_val (( 23 :: int)::ii) (( 0 :: int)::ii)  ::  24 Word.word))
         ::  32 Word.word)) in
   wGPR rt ((mips_sign_extend (( 64 :: int)::ii) result  ::  64 Word.word))))))))))"


(*val execute_LUI : mword ty5 -> mword ty16 -> M unit*)

definition execute_LUI  :: "(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_LUI rt imm = (
   wGPR rt
     ((mips_sign_extend (( 64 :: int)::ii)
         ((concat_vec imm
             (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  16 Word.word)
            ::  32 Word.word))
        ::  64 Word.word)))"


(*val execute_LDR : mword ty5 -> mword ty5 -> mword ty16 -> M unit*)

definition execute_LDR  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_LDR base rt offset = (
   (rGPR base  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (addrWrapperUnaligned
      ((add_vec ((mips_sign_extend (( 64 :: int)::ii) offset  ::  64 Word.word)) w__0  ::  64 Word.word)) LoadData DR
     :: ( 64 Word.word) M) \<bind> (\<lambda> vAddr . 
   (TLBTranslate vAddr LoadData  :: ( 64 Word.word) M) \<bind> (\<lambda> pAddr . 
   (MEMr_wrapper (( 64 :: int)::ii)
      ((concat_vec ((subrange_vec_dec pAddr (( 63 :: int)::ii) (( 3 :: int)::ii)  ::  61 Word.word))
          (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
         ::  64 Word.word)) (( 8 :: int)::ii)
     :: ( 64 Word.word) M) \<bind> (\<lambda> mem_val . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> reg_val . 
   (let b__24 = ((subrange_vec_dec vAddr (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) in
   wGPR rt
     (if (((b__24 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) then
        (concat_vec ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 8 :: int)::ii)  ::  56 Word.word))
           ((subrange_vec_dec mem_val (( 63 :: int)::ii) (( 56 :: int)::ii)  ::  8 Word.word))
          ::  64 Word.word)
      else if (((b__24 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) then
        (concat_vec ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 16 :: int)::ii)  ::  48 Word.word))
           ((subrange_vec_dec mem_val (( 63 :: int)::ii) (( 48 :: int)::ii)  ::  16 Word.word))
          ::  64 Word.word)
      else if (((b__24 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) then
        (concat_vec ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 24 :: int)::ii)  ::  40 Word.word))
           ((subrange_vec_dec mem_val (( 63 :: int)::ii) (( 40 :: int)::ii)  ::  24 Word.word))
          ::  64 Word.word)
      else if (((b__24 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) then
        (concat_vec ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
           ((subrange_vec_dec mem_val (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
          ::  64 Word.word)
      else if (((b__24 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) then
        (concat_vec ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 40 :: int)::ii)  ::  24 Word.word))
           ((subrange_vec_dec mem_val (( 63 :: int)::ii) (( 24 :: int)::ii)  ::  40 Word.word))
          ::  64 Word.word)
      else if (((b__24 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) then
        (concat_vec ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 48 :: int)::ii)  ::  16 Word.word))
           ((subrange_vec_dec mem_val (( 63 :: int)::ii) (( 16 :: int)::ii)  ::  48 Word.word))
          ::  64 Word.word)
      else if (((b__24 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) then
        (concat_vec ((subrange_vec_dec reg_val (( 63 :: int)::ii) (( 56 :: int)::ii)  ::  8 Word.word))
           ((subrange_vec_dec mem_val (( 63 :: int)::ii) (( 8 :: int)::ii)  ::  56 Word.word))
          ::  64 Word.word)
      else mem_val))))))))"


(*val execute_LDL : mword ty5 -> mword ty5 -> mword ty16 -> M unit*)

definition execute_LDL  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_LDL base rt offset = (
   (rGPR base  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (addrWrapperUnaligned
      ((add_vec ((mips_sign_extend (( 64 :: int)::ii) offset  ::  64 Word.word)) w__0  ::  64 Word.word)) LoadData DL
     :: ( 64 Word.word) M) \<bind> (\<lambda> vAddr . 
   (TLBTranslate vAddr LoadData  :: ( 64 Word.word) M) \<bind> (\<lambda> pAddr . 
   (MEMr_wrapper (( 64 :: int)::ii)
      ((concat_vec ((subrange_vec_dec pAddr (( 63 :: int)::ii) (( 3 :: int)::ii)  ::  61 Word.word))
          (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
         ::  64 Word.word)) (( 8 :: int)::ii)
     :: ( 64 Word.word) M) \<bind> (\<lambda> mem_val . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> reg_val . 
   (let b__16 = ((subrange_vec_dec vAddr (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) in
   wGPR rt
     (if (((b__16 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) then mem_val
      else if (((b__16 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) then
        (concat_vec ((subrange_vec_dec mem_val (( 55 :: int)::ii) (( 0 :: int)::ii)  ::  56 Word.word))
           ((subrange_vec_dec reg_val (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
          ::  64 Word.word)
      else if (((b__16 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) then
        (concat_vec ((subrange_vec_dec mem_val (( 47 :: int)::ii) (( 0 :: int)::ii)  ::  48 Word.word))
           ((subrange_vec_dec reg_val (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
          ::  64 Word.word)
      else if (((b__16 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) then
        (concat_vec ((subrange_vec_dec mem_val (( 39 :: int)::ii) (( 0 :: int)::ii)  ::  40 Word.word))
           ((subrange_vec_dec reg_val (( 23 :: int)::ii) (( 0 :: int)::ii)  ::  24 Word.word))
          ::  64 Word.word)
      else if (((b__16 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) then
        (concat_vec ((subrange_vec_dec mem_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
           ((subrange_vec_dec reg_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
          ::  64 Word.word)
      else if (((b__16 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) then
        (concat_vec ((subrange_vec_dec mem_val (( 23 :: int)::ii) (( 0 :: int)::ii)  ::  24 Word.word))
           ((subrange_vec_dec reg_val (( 39 :: int)::ii) (( 0 :: int)::ii)  ::  40 Word.word))
          ::  64 Word.word)
      else if (((b__16 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) then
        (concat_vec ((subrange_vec_dec mem_val (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
           ((subrange_vec_dec reg_val (( 47 :: int)::ii) (( 0 :: int)::ii)  ::  48 Word.word))
          ::  64 Word.word)
      else
        (concat_vec ((subrange_vec_dec mem_val (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
           ((subrange_vec_dec reg_val (( 55 :: int)::ii) (( 0 :: int)::ii)  ::  56 Word.word))
          ::  64 Word.word)))))))))"


(*val execute_JR : mword ty5 -> M unit*)

definition execute_JR  :: "(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_JR rs = ( (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) .  execute_branch w__0))"


(*val execute_JALR : mword ty5 -> mword ty5 -> M unit*)

definition execute_JALR  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_JALR rs rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (execute_branch w__0 \<then>
   (read_reg PC_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__1 :: 64 bits) . 
   wGPR rd ((add_vec_int w__1 (( 8 :: int)::ii)  ::  64 Word.word)))))"


(*val execute_JAL : mword ty26 -> M unit*)

definition execute_JAL  :: "(26)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_JAL offset = (
   (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 :: 64 bits) . 
   (execute_branch
     ((concat_vec
         ((subrange_vec_dec ((add_vec_int w__0 (( 4 :: int)::ii)  ::  64 Word.word)) (( 63 :: int)::ii) (( 28 :: int)::ii)  ::  36 Word.word))
         ((concat_vec offset (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  28 Word.word))
        ::  64 Word.word)) \<then>
   (read_reg PC_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__1 :: 64 bits) . 
   wGPR (vec_of_bits [B1,B1,B1,B1,B1]  ::  5 Word.word) ((add_vec_int w__1 (( 8 :: int)::ii)  ::  64 Word.word)))))"


(*val execute_J : mword ty26 -> M unit*)

definition execute_J  :: "(26)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_J offset = (
   (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 :: 64 bits) . 
   execute_branch
     ((concat_vec
         ((subrange_vec_dec ((add_vec_int w__0 (( 4 :: int)::ii)  ::  64 Word.word)) (( 63 :: int)::ii) (( 28 :: int)::ii)  ::  36 Word.word))
         ((concat_vec offset (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  28 Word.word))
        ::  64 Word.word))))"


(*val execute_HCF : unit -> unit*)

definition execute_HCF  :: " unit \<Rightarrow> unit "  where 
     " execute_HCF _ = ( ()  )"


(*val execute_ERET : unit -> M unit*)

definition execute_ERET  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_ERET _ = (
   (((checkCP0Access ()  \<then>
   ERETHook () ) \<then>
   write_reg CP0LLBit_ref (vec_of_bits [B0]  ::  1 Word.word)) \<then>
   read_reg CP0Status_ref) \<bind> (\<lambda> (w__0 :: StatusReg) . 
   if (((((bits_to_bool ((get_StatusReg_ERL w__0  ::  1 Word.word)))) = ((bit_to_bool B1))))) then
     (read_reg CP0ErrorEPC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 :: 64 bits) . 
     write_reg nextPC_ref w__1 \<then> set_StatusReg_ERL CP0Status_ref (vec_of_bits [B0]  ::  1 Word.word))
   else
     (read_reg CP0EPC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 :: 64 bits) . 
     write_reg nextPC_ref w__2 \<then> set_StatusReg_EXL CP0Status_ref (vec_of_bits [B0]  ::  1 Word.word))))"


(*val execute_DSUBU : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_DSUBU  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_DSUBU rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   wGPR rd ((sub_vec w__0 w__1  ::  64 Word.word)))))"


(*val execute_DSUB : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_DSUB  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_DSUB rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   (let (temp65 :: 65 bits) =
     ((sub_vec ((mips_sign_extend (( 65 :: int)::ii) w__0  ::  65 Word.word))
        ((mips_sign_extend (( 65 :: int)::ii) w__1  ::  65 Word.word))
       ::  65 Word.word)) in
   if ((neq_bool ((bit_to_bool ((access_vec_dec temp65 (( 64 :: int)::ii)))))
          ((bit_to_bool ((access_vec_dec temp65 (( 63 :: int)::ii))))))) then
     SignalException Ov
   else wGPR rd ((subrange_vec_dec temp65 (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))))))"


(*val execute_DSRLV : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_DSRLV  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_DSRLV rs rt rd = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> temp . 
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (let sa = ((subrange_vec_dec w__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) in
   (shift_bits_right instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict temp sa  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) .  wGPR rd w__1)))))"


(*val execute_DSRL32 : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_DSRL32  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_DSRL32 rt rd sa = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> temp . 
   (let sa32 = ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) sa  ::  6 Word.word)) in
   (shift_bits_right instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict temp sa32  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) .  wGPR rd w__0))))"


(*val execute_DSRL : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_DSRL  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_DSRL rt rd sa = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> temp . 
   (shift_bits_right instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict temp sa  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) .  wGPR rd w__0)))"


(*val execute_DSRAV : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_DSRAV  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_DSRAV rs rt rd = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> temp . 
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (let sa = ((subrange_vec_dec w__0 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word)) in
   (shift_bits_right_arith 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict temp sa  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) .  wGPR rd w__1)))))"


(*val execute_DSRA32 : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_DSRA32  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_DSRA32 rt rd sa = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> temp . 
   (let sa32 = ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) sa  ::  6 Word.word)) in
   (shift_bits_right_arith 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict temp sa32  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) .  wGPR rd w__0))))"


(*val execute_DSRA : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_DSRA  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_DSRA rt rd sa = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> temp . 
   (shift_bits_right_arith 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict temp sa  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) .  wGPR rd w__0)))"


(*val execute_DSLLV : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_DSLLV  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_DSLLV rs rt rd = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   (shift_bits_left instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict w__0 ((subrange_vec_dec w__1 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::
      64 Word.word) . 
   wGPR rd w__2))))"


(*val execute_DSLL32 : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_DSLL32  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_DSLL32 rt rd sa = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (shift_bits_left instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict w__0 ((concat_vec (vec_of_bits [B1]  ::  1 Word.word) sa  ::  6 Word.word))
     :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   wGPR rd w__1)))"


(*val execute_DSLL : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_DSLL  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_DSLL rt rd sa = (
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (shift_bits_left instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict w__0 sa  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) .  wGPR rd w__1)))"


(*val execute_DMULTU : mword ty5 -> mword ty5 -> M unit*)

definition execute_DMULTU  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_DMULTU rs rt = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   (let result = ((mult_vec w__0 w__1  ::  128 Word.word)) in
   write_reg HI_ref ((subrange_vec_dec result (( 127 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word)) \<then>
   write_reg LO_ref ((subrange_vec_dec result (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))))))"


(*val execute_DMULT : mword ty5 -> mword ty5 -> M unit*)

definition execute_DMULT  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_DMULT rs rt = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   (let result = ((mults_vec w__0 w__1  ::  128 Word.word)) in
   write_reg HI_ref ((subrange_vec_dec result (( 127 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word)) \<then>
   write_reg LO_ref ((subrange_vec_dec result (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))))))"


(*val execute_DIVU : mword ty5 -> mword ty5 -> M unit*)

definition execute_DIVU  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_DIVU rs rt = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> rsVal . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> rtVal . 
   (if (((((NotWordVal rsVal)) \<or> (((((NotWordVal rtVal)) \<or> (((rtVal = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                 B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                 B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
                     ::  64 Word.word)))))))))) then
      (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 ::  32 Word.word) . 
      (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 ::  32 Word.word) . 
      return (w__0, w__1)))
    else
      (let si = (Word.uint ((subrange_vec_dec rsVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))) in
      (let ti = (Word.uint ((subrange_vec_dec rtVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))) in
      (let qi = (hardware_quot si ti) in
      (let ri = (hardware_mod si ti) in
      return ((to_bits ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) qi  ::  32 Word.word),
              (to_bits ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) ri  ::  32 Word.word))))))) \<bind> (\<lambda> varstup .  (let (q, r) = varstup in
   write_reg HI_ref ((mips_sign_extend (( 64 :: int)::ii) r  ::  64 Word.word)) \<then>
   write_reg LO_ref ((mips_sign_extend (( 64 :: int)::ii) q  ::  64 Word.word)))))))"


(*val execute_DIV : mword ty5 -> mword ty5 -> M unit*)

definition execute_DIV  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_DIV rs rt = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> rsVal . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> rtVal . 
   (if (((((NotWordVal rsVal)) \<or> (((((NotWordVal rtVal)) \<or> (((rtVal = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                 B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                 B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
                     ::  64 Word.word)))))))))) then
      (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 ::  32 Word.word) . 
      (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 ::  32 Word.word) . 
      return (w__0, w__1)))
    else
      (let si = (Word.sint ((subrange_vec_dec rsVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))) in
      (let ti = (Word.sint ((subrange_vec_dec rtVal (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))) in
      (let qi = (hardware_quot si ti) in
      (let ri = (si - ((ti * qi))) in
      return ((to_bits ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) qi  ::  32 Word.word),
              (to_bits ((make_the_value (( 32 :: int)::ii)  ::  32 itself)) ri  ::  32 Word.word))))))) \<bind> (\<lambda> varstup .  (let (q, r) = varstup in
   write_reg HI_ref ((mips_sign_extend (( 64 :: int)::ii) r  ::  64 Word.word)) \<then>
   write_reg LO_ref ((mips_sign_extend (( 64 :: int)::ii) q  ::  64 Word.word)))))))"


(*val execute_DDIVU : mword ty5 -> mword ty5 -> M unit*)

definition execute_DDIVU  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_DDIVU rs rt = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (let rsVal = (Word.uint w__0) in
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   (let rtVal = (Word.uint w__1) in
   (if (((rtVal = (( 0 :: int)::ii)))) then
      (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::  64 Word.word) . 
      (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::  64 Word.word) . 
      return (w__2, w__3)))
    else
      (let qi = (hardware_quot rsVal rtVal) in
      (let ri = (hardware_mod rsVal rtVal) in
      return ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) qi  ::  64 Word.word),
              (to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) ri  ::  64 Word.word))))) \<bind> (\<lambda> varstup .  (let (q, r) = varstup in
   write_reg LO_ref q \<then> write_reg HI_ref r)))))))"


(*val execute_DDIV : mword ty5 -> mword ty5 -> M unit*)

definition execute_DDIV  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_DDIV rs rt = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (let rsVal = (Word.sint w__0) in
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   (let rtVal = (Word.sint w__1) in
   (if (((rtVal = (( 0 :: int)::ii)))) then
      (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::  64 Word.word) . 
      (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::  64 Word.word) . 
      return (w__2, w__3)))
    else
      (let qi = (hardware_quot rsVal rtVal) in
      (let ri = (rsVal - ((qi * rtVal))) in
      return ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) qi  ::  64 Word.word),
              (to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) ri  ::  64 Word.word))))) \<bind> (\<lambda> varstup .  (let (q, r) = varstup in
   write_reg LO_ref q \<then> write_reg HI_ref r)))))))"


(*val execute_DADDU : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_DADDU  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_DADDU rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   wGPR rd ((add_vec w__0 w__1  ::  64 Word.word)))))"


(*val execute_DADDIU : mword ty5 -> mword ty5 -> mword ty16 -> M unit*)

definition execute_DADDIU  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_DADDIU rs rt imm = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   wGPR rt ((add_vec w__0 ((mips_sign_extend (( 64 :: int)::ii) imm  ::  64 Word.word))  ::  64 Word.word))))"


(*val execute_DADDI : mword ty5 -> mword ty5 -> mword ty16 -> M unit*)

definition execute_DADDI  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_DADDI rs rt imm = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (let (sum65 :: 65 bits) =
     ((add_vec ((mips_sign_extend (( 65 :: int)::ii) w__0  ::  65 Word.word))
        ((mips_sign_extend (( 65 :: int)::ii) imm  ::  65 Word.word))
       ::  65 Word.word)) in
   if ((neq_bool ((bit_to_bool ((access_vec_dec sum65 (( 64 :: int)::ii)))))
          ((bit_to_bool ((access_vec_dec sum65 (( 63 :: int)::ii))))))) then
     SignalException Ov
   else wGPR rt ((subrange_vec_dec sum65 (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word)))))"


(*val execute_DADD : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_DADD  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_DADD rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   (let (sum65 :: 65 bits) =
     ((add_vec ((mips_sign_extend (( 65 :: int)::ii) w__0  ::  65 Word.word))
        ((mips_sign_extend (( 65 :: int)::ii) w__1  ::  65 Word.word))
       ::  65 Word.word)) in
   if ((neq_bool ((bit_to_bool ((access_vec_dec sum65 (( 64 :: int)::ii)))))
          ((bit_to_bool ((access_vec_dec sum65 (( 63 :: int)::ii))))))) then
     SignalException Ov
   else wGPR rd ((subrange_vec_dec sum65 (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))))))"


(*val execute_ClearRegs : ClearRegSet -> mword ty16 -> M unit*)

definition execute_ClearRegs  :: " ClearRegSet \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_ClearRegs regset m = (
   ((if ((((((regset = CLo))) \<or> (((regset = CHi)))))) then checkCP2usable () 
    else return () ) \<then>
   (if (((regset = CHi))) then
      (foreachM (index_list (( 0 :: int)::ii) (( 15 :: int)::ii) (( 1 :: int)::ii)) () 
        (\<lambda> i unit_var . 
          (let r =
            ((to_bits ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) ((i + (( 16 :: int)::ii)))  ::  5 Word.word)) in
          and_boolM (return ((bit_to_bool ((access_vec_dec m i))))) ((register_inaccessible r)) \<bind> (\<lambda> (w__1 ::
            bool) . 
          if w__1 then raise_c2_exception CapEx_AccessSystemRegsViolation r
          else return () ))))
    else return () )) \<then>
   (foreachM (index_list (( 0 :: int)::ii) (( 15 :: int)::ii) (( 1 :: int)::ii)) () 
     (\<lambda> i unit_var . 
       if ((bit_to_bool ((access_vec_dec m i)))) then
         (case  regset of
           GPLo =>
            wGPR ((to_bits ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) i  ::  5 Word.word))
              ((zeros0 (( 64 :: int)::ii) ()   ::  64 Word.word))
         | GPHi =>
            wGPR
              ((to_bits ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) ((i + (( 16 :: int)::ii)))
                 ::  5 Word.word)) ((zeros0 (( 64 :: int)::ii) ()   ::  64 Word.word))
         | CLo =>
            if (((i = (( 0 :: int)::ii)))) then write_reg DDC_ref ((capStructToCapReg null_cap  ::  257 Word.word))
            else
              writeCapReg ((to_bits ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) i  ::  5 Word.word))
                null_cap
         | CHi =>
            writeCapReg
              ((to_bits ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) ((i + (( 16 :: int)::ii)))
                 ::  5 Word.word)) null_cap
         )
       else return () )))"


(*val execute_CWriteHwr : mword ty5 -> mword ty5 -> M unit*)

definition execute_CWriteHwr  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CWriteHwr cb sel = (
   checkCP2usable ()  \<then>
   ((let p00 = (Word.uint sel) in
   (if (((p00 = (( 0 :: int)::ii)))) then return (False, False)
    else if (((p00 = (( 1 :: int)::ii)))) then return (False, False)
    else if (((p00 = (( 8 :: int)::ii)))) then return (False, True)
    else if (((p00 = (( 22 :: int)::ii)))) then return (True, False)
    else if (((p00 = (( 23 :: int)::ii)))) then return (True, False)
    else if (((p00 = (( 29 :: int)::ii)))) then return (True, True)
    else if (((p00 = (( 30 :: int)::ii)))) then return (True, True)
    else if (((p00 = (( 31 :: int)::ii)))) then return (True, True)
    else SignalException ResI) \<bind> (\<lambda> varstup .  (let ((needSup :: bool), (needAccessSys :: bool)) = varstup in
   register_inaccessible cb \<bind> (\<lambda> (w__8 :: bool) . 
   if w__8 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
   else
     and_boolM (return needAccessSys)
       (pcc_access_system_regs ()  \<bind> (\<lambda> (w__9 :: bool) .  return ((\<not> w__9)))) \<bind> (\<lambda> (w__10 ::
       bool) . 
     if w__10 then raise_c2_exception CapEx_AccessSystemRegsViolation sel
     else
       and_boolM (return needSup)
         (getAccessLevel ()  \<bind> (\<lambda> (w__11 :: AccessLevel) . 
          return ((\<not> ((grantsAccess w__11 Supervisor)))))) \<bind> (\<lambda> (w__12 :: bool) . 
       if w__12 then raise_c2_exception CapEx_AccessSystemRegsViolation sel
       else
         readCapReg cb \<bind> (\<lambda> capVal . 
         (let p00 = (Word.uint sel) in
         if (((p00 = (( 0 :: int)::ii)))) then write_reg DDC_ref ((capStructToCapReg capVal  ::  257 Word.word))
         else if (((p00 = (( 1 :: int)::ii)))) then
           write_reg CTLSU_ref ((capStructToCapReg capVal  ::  257 Word.word))
         else if (((p00 = (( 8 :: int)::ii)))) then
           write_reg CTLSP_ref ((capStructToCapReg capVal  ::  257 Word.word))
         else if (((p00 = (( 22 :: int)::ii)))) then
           write_reg KR1C_ref ((capStructToCapReg capVal  ::  257 Word.word))
         else if (((p00 = (( 23 :: int)::ii)))) then
           write_reg KR2C_ref ((capStructToCapReg capVal  ::  257 Word.word))
         else if (((p00 = (( 29 :: int)::ii)))) then
           write_reg KCC_ref ((capStructToCapReg capVal  ::  257 Word.word))
         else if (((p00 = (( 30 :: int)::ii)))) then
           write_reg KDC_ref ((capStructToCapReg capVal  ::  257 Word.word))
         else if (((p00 = (( 31 :: int)::ii)))) then
           write_reg EPCC_ref ((capStructToCapReg capVal  ::  257 Word.word))
         else assert_exp False (''should be unreachable code'')))))))))))"


(*val execute_CUnseal : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_CUnseal  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CUnseal cd1 cs ct = (
   (checkCP2usable ()  \<then>
   readCapReg cs) \<bind> (\<lambda> cs_val . 
   readCapReg ct \<bind> (\<lambda> ct_val . 
   (let ct_cursor = (getCapCursor ct_val) in
   register_inaccessible cd1 \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cd1
   else
     register_inaccessible cs \<bind> (\<lambda> (w__1 :: bool) . 
     if w__1 then raise_c2_exception CapEx_AccessSystemRegsViolation cs
     else
       register_inaccessible ct \<bind> (\<lambda> (w__2 :: bool) . 
       if w__2 then raise_c2_exception CapEx_AccessSystemRegsViolation ct
       else if ((\<not>(CapStruct_tag   cs_val))) then raise_c2_exception CapEx_TagViolation cs
       else if ((\<not>(CapStruct_tag   ct_val))) then raise_c2_exception CapEx_TagViolation ct
       else if ((\<not>(CapStruct_sealed   cs_val))) then raise_c2_exception CapEx_SealViolation cs
       else if(CapStruct_sealed   ct_val) then raise_c2_exception CapEx_SealViolation ct
       else if (((ct_cursor \<noteq> ((Word.uint(CapStruct_otype   cs_val)))))) then
         raise_c2_exception CapEx_TypeViolation ct
       else if ((\<not>(CapStruct_permit_unseal   ct_val))) then
         raise_c2_exception CapEx_PermitUnsealViolation ct
       else if ((ct_cursor < ((getCapBase ct_val)))) then
         raise_c2_exception CapEx_LengthViolation ct
       else if ((ct_cursor \<ge> ((getCapTop ct_val)))) then
         raise_c2_exception CapEx_LengthViolation ct
       else
         writeCapReg cd1
           (cs_val (|
             CapStruct_sealed := False, CapStruct_otype := ((zeros0 (( 24 :: int)::ii) ()   ::  24 Word.word)), CapStruct_global :=
               ((((CapStruct_global   cs_val) \<and>(CapStruct_global   ct_val))))|)))))))))"


(*val execute_CToPtr : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_CToPtr  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CToPtr rd cb ct = (
   (checkCP2usable ()  \<then>
   readCapRegDDC ct) \<bind> (\<lambda> ct_val . 
   readCapReg cb \<bind> (\<lambda> cb_val . 
   register_inaccessible cb \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
   else
     register_inaccessible ct \<bind> (\<lambda> (w__1 :: bool) . 
     if w__1 then raise_c2_exception CapEx_AccessSystemRegsViolation ct
     else if ((\<not>(CapStruct_tag   ct_val))) then raise_c2_exception CapEx_TagViolation ct
     else if ((((CapStruct_tag   cb_val) \<and>(CapStruct_sealed   cb_val)))) then
       raise_c2_exception CapEx_SealViolation cb
     else
       (let cbBase = (getCapBase cb_val) in
       (let cbTop = (getCapTop cb_val) in
       (let ctBase = (getCapBase ct_val) in
       (let ctTop = (getCapTop ct_val) in
       wGPR rd
         (if (((((\<not>(CapStruct_tag   cb_val))) \<or> (((((cbBase < ctBase)) \<or> ((cbTop > ctTop)))))))) then
            (zeros0 (( 64 :: int)::ii) ()   ::  64 Word.word)
          else
            (to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
               ((((getCapCursor cb_val)) - ctBase))
              ::  64 Word.word)))))))))))"


(*val execute_CTestSubset : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_CTestSubset  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CTestSubset rd cb ct = (
   (checkCP2usable ()  \<then>
   readCapRegDDC cb) \<bind> (\<lambda> cb_val . 
   readCapReg ct \<bind> (\<lambda> ct_val . 
   (let ct_top = (getCapTop ct_val) in
   (let ct_base = (getCapBase ct_val) in
   (let ct_perms = ((getCapPerms ct_val  ::  31 Word.word)) in
   (let cb_top = (getCapTop cb_val) in
   (let cb_base = (getCapBase cb_val) in
   (let cb_perms = ((getCapPerms cb_val  ::  31 Word.word)) in
   register_inaccessible cb \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
   else
     register_inaccessible ct \<bind> (\<lambda> (w__1 :: bool) . 
     if w__1 then raise_c2_exception CapEx_AccessSystemRegsViolation ct
     else
       (let (result :: 1 bits) =
         (if ((neq_bool(CapStruct_tag   cb_val)(CapStruct_tag   ct_val))) then
           (vec_of_bits [B0]  ::  1 Word.word)
         else if ((ct_base < cb_base)) then (vec_of_bits [B0]  ::  1 Word.word)
         else if ((ct_top > cb_top)) then (vec_of_bits [B0]  ::  1 Word.word)
         else if (((((and_vec ct_perms cb_perms  ::  31 Word.word)) \<noteq> ct_perms))) then
           (vec_of_bits [B0]  ::  1 Word.word)
         else (vec_of_bits [B1]  ::  1 Word.word)) in
       wGPR rd ((mips_zero_extend (( 64 :: int)::ii) result  ::  64 Word.word))))))))))))))"


(*val execute_CSub : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_CSub  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CSub rd cb ct = (
   (checkCP2usable ()  \<then>
   readCapReg ct) \<bind> (\<lambda> ct_val . 
   readCapReg cb \<bind> (\<lambda> cb_val . 
   register_inaccessible cb \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
   else
     register_inaccessible ct \<bind> (\<lambda> (w__1 :: bool) . 
     if w__1 then raise_c2_exception CapEx_AccessSystemRegsViolation ct
     else
       wGPR rd
         ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
             ((((getCapCursor cb_val)) - ((getCapCursor ct_val))))
            ::  64 Word.word)))))))"


(*val execute_CStore : mword ty5 -> mword ty5 -> mword ty5 -> mword ty5 -> mword ty8 -> WordType -> bool -> M unit*)

definition execute_CStore  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(8)Word.word \<Rightarrow> WordType \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CStore rs cb rt rd offset width conditional = (
   (checkCP2usable ()  \<then>
   readCapRegDDC cb) \<bind> (\<lambda> cb_val . 
   register_inaccessible cb \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
   else if ((\<not>(CapStruct_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
   else if(CapStruct_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
   else if ((\<not>(CapStruct_permit_store   cb_val))) then
     raise_c2_exception CapEx_PermitStoreViolation cb
   else
     (let size1 = (wordWidthBytes width) in
     (let cursor = (getCapCursor cb_val) in
     (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
     (let vAddr =
       (((((cursor + ((Word.uint w__1)))) + ((size1 * ((Word.sint offset))))))
         mod
         ((pow2 (( 64 :: int)::ii)))) in
     (let vAddr64 = ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) vAddr  ::  64 Word.word)) in
     if ((((vAddr + size1)) > ((getCapTop cb_val)))) then
       raise_c2_exception CapEx_LengthViolation cb
     else if ((vAddr < ((getCapBase cb_val)))) then raise_c2_exception CapEx_LengthViolation cb
     else if ((\<not> ((isAddressAligned vAddr64 width)))) then SignalExceptionBadAddr AdES vAddr64
     else
       (TLBTranslate vAddr64 StoreData  :: ( 64 Word.word) M) \<bind> (\<lambda> pAddr . 
       (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> rs_val . 
       if conditional then
         (read_reg CP0LLBit_ref  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__2 :: 1 bits) . 
         (if ((bit_to_bool ((access_vec_dec w__2 (( 0 :: int)::ii))))) then
            (case  width of
              B =>
               MEMw_conditional_wrapper pAddr (( 1 :: int)::ii)
                 ((subrange_vec_dec rs_val (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
            | H =>
               MEMw_conditional_wrapper pAddr (( 2 :: int)::ii)
                 ((subrange_vec_dec rs_val (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
            | W =>
               MEMw_conditional_wrapper pAddr (( 4 :: int)::ii)
                 ((subrange_vec_dec rs_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            | D => MEMw_conditional_wrapper pAddr (( 8 :: int)::ii) rs_val
            )
          else return False) \<bind> (\<lambda> (success :: bool) . 
         wGPR rd ((mips_zero_extend (( 64 :: int)::ii) ((bool_to_bits success  ::  1 Word.word))  ::  64 Word.word))))
       else
         (case  width of
           B => MEMw_wrapper pAddr (( 1 :: int)::ii) ((subrange_vec_dec rs_val (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
         | H => MEMw_wrapper pAddr (( 2 :: int)::ii) ((subrange_vec_dec rs_val (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
         | W => MEMw_wrapper pAddr (( 4 :: int)::ii) ((subrange_vec_dec rs_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
         | D => MEMw_wrapper pAddr (( 8 :: int)::ii) rs_val
         )))))))))))"


(*val execute_CSetOffset : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_CSetOffset  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CSetOffset cd1 cb rt = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> (\<lambda> cb_val . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> rt_val . 
   register_inaccessible cd1 \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cd1
   else
     register_inaccessible cb \<bind> (\<lambda> (w__1 :: bool) . 
     if w__1 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
     else if ((((CapStruct_tag   cb_val) \<and>(CapStruct_sealed   cb_val)))) then
       raise_c2_exception CapEx_SealViolation cb
     else
       (let (success, newCap) = (setCapOffset cb_val rt_val) in
       if success then writeCapReg cd1 newCap
       else
         writeCapReg cd1
           ((int_to_cap
               ((add_vec
                   ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) ((getCapBase cb_val))
                      ::  64 Word.word)) rt_val
                  ::  64 Word.word))))))))))"


(*val execute_CSetCause : mword ty5 -> M unit*)

definition execute_CSetCause  :: "(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CSetCause rt = (
   (checkCP2usable ()  \<then>
   pcc_access_system_regs () ) \<bind> (\<lambda> (w__0 :: bool) . 
   if ((\<not> w__0)) then raise_c2_exception_noreg CapEx_AccessSystemRegsViolation
   else
     (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> rt_val . 
     set_CapCauseReg_ExcCode CapCause_ref ((subrange_vec_dec rt_val (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word)) \<then>
     set_CapCauseReg_RegNum CapCause_ref ((subrange_vec_dec rt_val (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)))))"


(*val execute_CSetBoundsImmediate : mword ty5 -> mword ty5 -> mword ty11 -> M unit*)

definition execute_CSetBoundsImmediate  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(11)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CSetBoundsImmediate cd1 cb imm = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> (\<lambda> cb_val . 
   (let immU = (Word.uint imm) in
   (let cursor = (getCapCursor cb_val) in
   (let base = (getCapBase cb_val) in
   (let top1 = (getCapTop cb_val) in
   (let newTop = (cursor + immU) in
   register_inaccessible cd1 \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cd1
   else
     register_inaccessible cb \<bind> (\<lambda> (w__1 :: bool) . 
     if w__1 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
     else if ((\<not>(CapStruct_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
     else if(CapStruct_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
     else if ((cursor < base)) then raise_c2_exception CapEx_LengthViolation cb
     else if ((newTop > top1)) then raise_c2_exception CapEx_LengthViolation cb
     else
       (let (_, newCap) =
         (setCapBounds cb_val
           ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) cursor  ::  64 Word.word))
           ((to_bits ((make_the_value (( 65 :: int)::ii)  ::  65 itself)) newTop  ::  65 Word.word))) in
       writeCapReg cd1 newCap))))))))))"


(*val execute_CSetBoundsExact : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_CSetBoundsExact  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CSetBoundsExact cd1 cb rt = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> (\<lambda> cb_val . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (let rt_val = (Word.uint w__0) in
   (let cursor = (getCapCursor cb_val) in
   (let base = (getCapBase cb_val) in
   (let top1 = (getCapTop cb_val) in
   (let newTop = (cursor + rt_val) in
   register_inaccessible cd1 \<bind> (\<lambda> (w__1 :: bool) . 
   if w__1 then raise_c2_exception CapEx_AccessSystemRegsViolation cd1
   else
     register_inaccessible cb \<bind> (\<lambda> (w__2 :: bool) . 
     if w__2 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
     else if ((\<not>(CapStruct_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
     else if(CapStruct_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
     else if ((cursor < base)) then raise_c2_exception CapEx_LengthViolation cb
     else if ((newTop > top1)) then raise_c2_exception CapEx_LengthViolation cb
     else
       (let (exact, newCap) =
         (setCapBounds cb_val
           ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) cursor  ::  64 Word.word))
           ((to_bits ((make_the_value (( 65 :: int)::ii)  ::  65 itself)) newTop  ::  65 Word.word))) in
       if ((\<not> exact)) then raise_c2_exception CapEx_InexactBounds cb
       else writeCapReg cd1 newCap)))))))))))"


(*val execute_CSetBounds : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_CSetBounds  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CSetBounds cd1 cb rt = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> (\<lambda> cb_val . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (let rt_val = (Word.uint w__0) in
   (let cursor = (getCapCursor cb_val) in
   (let base = (getCapBase cb_val) in
   (let top1 = (getCapTop cb_val) in
   (let newTop = (cursor + rt_val) in
   register_inaccessible cd1 \<bind> (\<lambda> (w__1 :: bool) . 
   if w__1 then raise_c2_exception CapEx_AccessSystemRegsViolation cd1
   else
     register_inaccessible cb \<bind> (\<lambda> (w__2 :: bool) . 
     if w__2 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
     else if ((\<not>(CapStruct_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
     else if(CapStruct_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
     else if ((cursor < base)) then raise_c2_exception CapEx_LengthViolation cb
     else if ((newTop > top1)) then raise_c2_exception CapEx_LengthViolation cb
     else
       (let (_, newCap) =
         (setCapBounds cb_val
           ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) cursor  ::  64 Word.word))
           ((to_bits ((make_the_value (( 65 :: int)::ii)  ::  65 itself)) newTop  ::  65 Word.word))) in
       writeCapReg cd1 newCap)))))))))))"


(*val execute_CSeal : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_CSeal  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CSeal cd1 cs ct = (
   (checkCP2usable ()  \<then>
   readCapReg cs) \<bind> (\<lambda> cs_val . 
   readCapReg ct \<bind> (\<lambda> ct_val . 
   (let ct_cursor = (getCapCursor ct_val) in
   (let ct_top = (getCapTop ct_val) in
   (let ct_base = (getCapBase ct_val) in
   register_inaccessible cd1 \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cd1
   else
     register_inaccessible cs \<bind> (\<lambda> (w__1 :: bool) . 
     if w__1 then raise_c2_exception CapEx_AccessSystemRegsViolation cs
     else
       register_inaccessible ct \<bind> (\<lambda> (w__2 :: bool) . 
       if w__2 then raise_c2_exception CapEx_AccessSystemRegsViolation ct
       else if ((\<not>(CapStruct_tag   cs_val))) then raise_c2_exception CapEx_TagViolation cs
       else if ((\<not>(CapStruct_tag   ct_val))) then raise_c2_exception CapEx_TagViolation ct
       else if(CapStruct_sealed   cs_val) then raise_c2_exception CapEx_SealViolation cs
       else if(CapStruct_sealed   ct_val) then raise_c2_exception CapEx_SealViolation ct
       else if ((\<not>(CapStruct_permit_seal   ct_val))) then
         raise_c2_exception CapEx_PermitSealViolation ct
       else if ((ct_cursor < ct_base)) then raise_c2_exception CapEx_LengthViolation ct
       else if ((ct_cursor \<ge> ct_top)) then raise_c2_exception CapEx_LengthViolation ct
       else if ((ct_cursor > max_otype)) then raise_c2_exception CapEx_LengthViolation ct
       else
         (let (success, newCap) =
           (sealCap cs_val
             ((to_bits ((make_the_value (( 24 :: int)::ii)  ::  24 itself)) ct_cursor  ::  24 Word.word))) in
         if ((\<not> success)) then raise_c2_exception CapEx_InexactBounds cs
         else writeCapReg cd1 newCap))))))))))"


(*val execute_CSC : mword ty5 -> mword ty5 -> mword ty5 -> mword ty5 -> mword ty11 -> bool -> M unit*)

definition execute_CSC  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(11)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CSC cs cb rt rd offset conditional = (
   (checkCP2usable ()  \<then>
   readCapReg cs) \<bind> (\<lambda> cs_val . 
   readCapRegDDC cb \<bind> (\<lambda> cb_val . 
   register_inaccessible cs \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cs
   else
     register_inaccessible cb \<bind> (\<lambda> (w__1 :: bool) . 
     if w__1 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
     else if ((\<not>(CapStruct_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
     else if(CapStruct_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
     else if ((\<not>(CapStruct_permit_store   cb_val))) then
       raise_c2_exception CapEx_PermitStoreViolation cb
     else if ((\<not>(CapStruct_permit_store_cap   cb_val))) then
       raise_c2_exception CapEx_PermitStoreCapViolation cb
     else if (((((\<not>(CapStruct_permit_store_local_cap   cb_val))) \<and> ((((CapStruct_tag   cs_val) \<and> ((\<not>(CapStruct_global   cs_val))))))))) then
       raise_c2_exception CapEx_PermitStoreLocalCapViolation cb
     else
       (let cursor = (getCapCursor cb_val) in
       (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::  64 Word.word) . 
       (let vAddr =
         (((((cursor + ((Word.uint w__2)))) + (((( 16 :: int)::ii) * ((Word.sint offset))))))
           mod
           ((pow2 (( 64 :: int)::ii)))) in
       (let vAddr64 = ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) vAddr  ::  64 Word.word)) in
       if ((((vAddr + cap_size)) > ((getCapTop cb_val)))) then
         raise_c2_exception CapEx_LengthViolation cb
       else if ((vAddr < ((getCapBase cb_val)))) then raise_c2_exception CapEx_LengthViolation cb
       else if (((((vAddr mod cap_size)) \<noteq> (( 0 :: int)::ii)))) then SignalExceptionBadAddr AdES vAddr64
       else
         (TLBTranslateC vAddr64 StoreData  :: (( 64 Word.word * bool)) M) \<bind> (\<lambda> varstup .  (let (pAddr, noStoreCap) = varstup in
         if ((((CapStruct_tag   cs_val) \<and> noStoreCap))) then
           raise_c2_exception CapEx_TLBNoStoreCap cs
         else if conditional then
           (read_reg CP0LLBit_ref  :: ( 1 Word.word) M) \<bind> (\<lambda> (w__3 :: 1 bits) . 
           (if ((bit_to_bool ((access_vec_dec w__3 (( 0 :: int)::ii))))) then
              MEMw_tagged_conditional pAddr(CapStruct_tag   cs_val)
                ((capStructToMemBits cs_val  ::  256 Word.word))
            else return False) \<bind> (\<lambda> success . 
           wGPR rd ((mips_zero_extend (( 64 :: int)::ii) ((bool_to_bits success  ::  1 Word.word))  ::  64 Word.word))))
         else MEMw_tagged pAddr(CapStruct_tag   cs_val) ((capStructToMemBits cs_val  ::  256 Word.word)))))))))))))"


(*val execute_CReturn : unit -> M unit*)

definition execute_CReturn  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CReturn _ = ( checkCP2usable ()  \<then> raise_c2_exception_noreg CapEx_ReturnTrap )"


(*val execute_CReadHwr : mword ty5 -> mword ty5 -> M unit*)

definition execute_CReadHwr  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CReadHwr cd1 sel = (
   checkCP2usable ()  \<then>
   ((let p00 = (Word.uint sel) in
   (if (((p00 = (( 0 :: int)::ii)))) then return (False, False)
    else if (((p00 = (( 1 :: int)::ii)))) then return (False, False)
    else if (((p00 = (( 8 :: int)::ii)))) then return (False, True)
    else if (((p00 = (( 22 :: int)::ii)))) then return (True, False)
    else if (((p00 = (( 23 :: int)::ii)))) then return (True, False)
    else if (((p00 = (( 29 :: int)::ii)))) then return (True, True)
    else if (((p00 = (( 30 :: int)::ii)))) then return (True, True)
    else if (((p00 = (( 31 :: int)::ii)))) then return (True, True)
    else SignalException ResI) \<bind> (\<lambda> varstup .  (let ((needSup :: bool), (needAccessSys :: bool)) = varstup in
   register_inaccessible cd1 \<bind> (\<lambda> (w__8 :: bool) . 
   if w__8 then raise_c2_exception CapEx_AccessSystemRegsViolation cd1
   else
     and_boolM (return needAccessSys)
       (pcc_access_system_regs ()  \<bind> (\<lambda> (w__9 :: bool) .  return ((\<not> w__9)))) \<bind> (\<lambda> (w__10 ::
       bool) . 
     if w__10 then raise_c2_exception CapEx_AccessSystemRegsViolation sel
     else
       and_boolM (return needSup)
         (getAccessLevel ()  \<bind> (\<lambda> (w__11 :: AccessLevel) . 
          return ((\<not> ((grantsAccess w__11 Supervisor)))))) \<bind> (\<lambda> (w__12 :: bool) . 
       if w__12 then raise_c2_exception CapEx_AccessSystemRegsViolation sel
       else
         (let p00 = (Word.uint sel) in
         (if (((p00 = (( 0 :: int)::ii)))) then
            (read_reg DDC_ref  :: ( 257 Word.word) M) \<bind> (\<lambda> (w__13 :: CapReg) . 
            return ((capRegToCapStruct w__13)))
          else if (((p00 = (( 1 :: int)::ii)))) then
            (read_reg CTLSU_ref  :: ( 257 Word.word) M) \<bind> (\<lambda> (w__14 :: CapReg) . 
            return ((capRegToCapStruct w__14)))
          else if (((p00 = (( 8 :: int)::ii)))) then
            (read_reg CTLSP_ref  :: ( 257 Word.word) M) \<bind> (\<lambda> (w__15 :: CapReg) . 
            return ((capRegToCapStruct w__15)))
          else if (((p00 = (( 22 :: int)::ii)))) then
            (read_reg KR1C_ref  :: ( 257 Word.word) M) \<bind> (\<lambda> (w__16 :: CapReg) . 
            return ((capRegToCapStruct w__16)))
          else if (((p00 = (( 23 :: int)::ii)))) then
            (read_reg KR2C_ref  :: ( 257 Word.word) M) \<bind> (\<lambda> (w__17 :: CapReg) . 
            return ((capRegToCapStruct w__17)))
          else if (((p00 = (( 29 :: int)::ii)))) then
            (read_reg KCC_ref  :: ( 257 Word.word) M) \<bind> (\<lambda> (w__18 :: CapReg) . 
            return ((capRegToCapStruct w__18)))
          else if (((p00 = (( 30 :: int)::ii)))) then
            (read_reg KDC_ref  :: ( 257 Word.word) M) \<bind> (\<lambda> (w__19 :: CapReg) . 
            return ((capRegToCapStruct w__19)))
          else if (((p00 = (( 31 :: int)::ii)))) then
            (read_reg EPCC_ref  :: ( 257 Word.word) M) \<bind> (\<lambda> (w__20 :: CapReg) . 
            return ((capRegToCapStruct w__20)))
          else assert_exp False (''should be unreachable code'') \<then> undefined_CapStruct () ) \<bind> (\<lambda> (capVal ::
           CapStruct) . 
         writeCapReg cd1 capVal))))))))))"


(*val execute_CPtrCmp : mword ty5 -> mword ty5 -> mword ty5 -> CPtrCmpOp -> M unit*)

definition execute_CPtrCmp  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> CPtrCmpOp \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CPtrCmp rd cb ct op1 = (
   (checkCP2usable ()  \<then>
   register_inaccessible cb) \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
   else
     register_inaccessible ct \<bind> (\<lambda> (w__1 :: bool) . 
     if w__1 then raise_c2_exception CapEx_AccessSystemRegsViolation ct
     else
       readCapReg cb \<bind> (\<lambda> cb_val . 
       readCapReg ct \<bind> (\<lambda> ct_val . 
       (let equal = False in
       (let ltu = False in
       (let lts = False in
       (let ((equal :: bool), (lts :: bool), (ltu :: bool)) =
         (if ((neq_bool(CapStruct_tag   cb_val)(CapStruct_tag   ct_val))) then
           (let ((lts :: bool), (ltu :: bool)) =
             (if ((\<not>(CapStruct_tag   cb_val))) then
               (let (ltu :: bool) = True in
               (let (lts :: bool) = True in
               (lts, ltu)))
             else (lts, ltu)) in
           (equal, lts, ltu))
         else
           (let cursor1 = (getCapCursor cb_val) in
           (let cursor2 = (getCapCursor ct_val) in
           (let (equal :: bool) = (cursor1 = cursor2) in
           (let (ltu :: bool) = (cursor1 < cursor2) in
           (let (lts :: bool) =
             (zopz0zI_s ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) cursor1  ::  64 Word.word))
               ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) cursor2  ::  64 Word.word))) in
           (equal, lts, ltu))))))) in
       (let (cmp :: bool) =
         ((case  op1 of
           CEQ => equal
         | CNE => \<not> equal
         | CLT => lts
         | CLE => (lts \<or> equal)
         | CLTU => ltu
         | CLEU => (ltu \<or> equal)
         | CEXEQ => (cb_val = ct_val)
         | CNEXEQ => (cb_val \<noteq> ct_val)
         )) in
       wGPR rd ((mips_zero_extend (( 64 :: int)::ii) ((bool_to_bits cmp  ::  1 Word.word))  ::  64 Word.word))))))))))))"


(*val execute_CMOVX : mword ty5 -> mword ty5 -> mword ty5 -> bool -> M unit*)

definition execute_CMOVX  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CMOVX cd1 cb rt ismovn = (
   (checkCP2usable ()  \<then>
   register_inaccessible cd1) \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cd1
   else
     register_inaccessible cb \<bind> (\<lambda> (w__1 :: bool) . 
     if w__1 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
     else
       (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::  64 Word.word) . 
       if ((bits_to_bool
              ((xor_vec
                  ((bool_to_bits (((w__2 = ((zeros0 (( 64 :: int)::ii) ()   ::  64 Word.word)))))  ::  1 Word.word))
                  ((bool_to_bits ismovn  ::  1 Word.word))
                 ::  1 Word.word)))) then
         readCapReg cb \<bind> (\<lambda> (w__3 :: CapStruct) .  writeCapReg cd1 w__3)
       else return () ))))"


(*val execute_CLoad : mword ty5 -> mword ty5 -> mword ty5 -> mword ty8 -> bool -> WordType -> bool -> M unit*)

definition execute_CLoad  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(8)Word.word \<Rightarrow> bool \<Rightarrow> WordType \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CLoad arg0 arg1 arg2 arg3 arg4 arg5 arg6 = (
   (let merge_var = (arg0, arg1, arg2, arg3, arg4, arg5, arg6) in
   (case  merge_var of
     (rd, cb, rt, offset, signext, B, linked) =>
      (checkCP2usable ()  \<then>
      readCapRegDDC cb) \<bind> (\<lambda> cb_val . 
      register_inaccessible cb \<bind> (\<lambda> (w__0 :: bool) . 
      if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
      else if ((\<not>(CapStruct_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
      else if(CapStruct_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
      else if ((\<not>(CapStruct_permit_load   cb_val))) then
        raise_c2_exception CapEx_PermitLoadViolation cb
      else
        (let cursor = (getCapCursor cb_val) in
        (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
        (let vAddr =
          (((((cursor + ((Word.uint w__1)))) + (((( 1 :: int)::ii) * ((Word.sint offset))))))
            mod
            ((pow2 (( 64 :: int)::ii)))) in
        (let vAddr64 = ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) vAddr  ::  64 Word.word)) in
        if ((((vAddr + (( 1 :: int)::ii))) > ((getCapTop cb_val)))) then
          raise_c2_exception CapEx_LengthViolation cb
        else if ((vAddr < ((getCapBase cb_val)))) then raise_c2_exception CapEx_LengthViolation cb
        else if ((\<not> ((isAddressAligned vAddr64 B)))) then SignalExceptionBadAddr AdEL vAddr64
        else
          (TLBTranslate vAddr64 LoadData  :: ( 64 Word.word) M) \<bind> (\<lambda> pAddr . 
          (if linked then
             ((write_reg CP0LLBit_ref (vec_of_bits [B1]  ::  1 Word.word) \<then>
             write_reg CP0LLAddr_ref pAddr) \<then>
             (MEMr_reserve_wrapper pAddr (( 1 :: int)::ii)  :: ( 8 Word.word) M)) \<bind> (\<lambda> (w__2 ::  8 Word.word) . 
             return ((extendLoad w__2 signext  ::  64 Word.word)))
           else
             (MEMr_wrapper (( 8 :: int)::ii) pAddr (( 1 :: int)::ii)  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__3 ::  8 Word.word) . 
             return ((extendLoad w__3 signext  ::  64 Word.word)))) \<bind> (\<lambda> (memResult :: 64 bits) . 
          wGPR rd memResult))))))))
   | (rd, cb, rt, offset, signext, D, linked) =>
      (checkCP2usable ()  \<then>
      readCapRegDDC cb) \<bind> (\<lambda> cb_val . 
      register_inaccessible cb \<bind> (\<lambda> (w__0 :: bool) . 
      if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
      else if ((\<not>(CapStruct_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
      else if(CapStruct_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
      else if ((\<not>(CapStruct_permit_load   cb_val))) then
        raise_c2_exception CapEx_PermitLoadViolation cb
      else
        (let cursor = (getCapCursor cb_val) in
        (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
        (let vAddr =
          (((((cursor + ((Word.uint w__1)))) + (((( 8 :: int)::ii) * ((Word.sint offset))))))
            mod
            ((pow2 (( 64 :: int)::ii)))) in
        (let vAddr64 = ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) vAddr  ::  64 Word.word)) in
        if ((((vAddr + (( 8 :: int)::ii))) > ((getCapTop cb_val)))) then
          raise_c2_exception CapEx_LengthViolation cb
        else if ((vAddr < ((getCapBase cb_val)))) then raise_c2_exception CapEx_LengthViolation cb
        else if ((\<not> ((isAddressAligned vAddr64 D)))) then SignalExceptionBadAddr AdEL vAddr64
        else
          (TLBTranslate vAddr64 LoadData  :: ( 64 Word.word) M) \<bind> (\<lambda> pAddr . 
          (if linked then
             ((write_reg CP0LLBit_ref (vec_of_bits [B1]  ::  1 Word.word) \<then>
             write_reg CP0LLAddr_ref pAddr) \<then>
             (MEMr_reserve_wrapper pAddr (( 8 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__2 ::  64 Word.word) . 
             return ((extendLoad w__2 signext  ::  64 Word.word)))
           else
             (MEMr_wrapper (( 64 :: int)::ii) pAddr (( 8 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::  64 Word.word) . 
             return ((extendLoad w__3 signext  ::  64 Word.word)))) \<bind> (\<lambda> (memResult :: 64 bits) . 
          wGPR rd memResult))))))))
   | (rd, cb, rt, offset, signext, H, linked) =>
      (checkCP2usable ()  \<then>
      readCapRegDDC cb) \<bind> (\<lambda> cb_val . 
      register_inaccessible cb \<bind> (\<lambda> (w__0 :: bool) . 
      if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
      else if ((\<not>(CapStruct_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
      else if(CapStruct_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
      else if ((\<not>(CapStruct_permit_load   cb_val))) then
        raise_c2_exception CapEx_PermitLoadViolation cb
      else
        (let cursor = (getCapCursor cb_val) in
        (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
        (let vAddr =
          (((((cursor + ((Word.uint w__1)))) + (((( 2 :: int)::ii) * ((Word.sint offset))))))
            mod
            ((pow2 (( 64 :: int)::ii)))) in
        (let vAddr64 = ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) vAddr  ::  64 Word.word)) in
        if ((((vAddr + (( 2 :: int)::ii))) > ((getCapTop cb_val)))) then
          raise_c2_exception CapEx_LengthViolation cb
        else if ((vAddr < ((getCapBase cb_val)))) then raise_c2_exception CapEx_LengthViolation cb
        else if ((\<not> ((isAddressAligned vAddr64 H)))) then SignalExceptionBadAddr AdEL vAddr64
        else
          (TLBTranslate vAddr64 LoadData  :: ( 64 Word.word) M) \<bind> (\<lambda> pAddr . 
          (if linked then
             ((write_reg CP0LLBit_ref (vec_of_bits [B1]  ::  1 Word.word) \<then>
             write_reg CP0LLAddr_ref pAddr) \<then>
             (MEMr_reserve_wrapper pAddr (( 2 :: int)::ii)  :: ( 16 Word.word) M)) \<bind> (\<lambda> (w__2 ::  16 Word.word) . 
             return ((extendLoad w__2 signext  ::  64 Word.word)))
           else
             (MEMr_wrapper (( 16 :: int)::ii) pAddr (( 2 :: int)::ii)  :: ( 16 Word.word) M) \<bind> (\<lambda> (w__3 ::  16 Word.word) . 
             return ((extendLoad w__3 signext  ::  64 Word.word)))) \<bind> (\<lambda> (memResult :: 64 bits) . 
          wGPR rd memResult))))))))
   | (rd, cb, rt, offset, signext, W, linked) =>
      (checkCP2usable ()  \<then>
      readCapRegDDC cb) \<bind> (\<lambda> cb_val . 
      register_inaccessible cb \<bind> (\<lambda> (w__0 :: bool) . 
      if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
      else if ((\<not>(CapStruct_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
      else if(CapStruct_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
      else if ((\<not>(CapStruct_permit_load   cb_val))) then
        raise_c2_exception CapEx_PermitLoadViolation cb
      else
        (let cursor = (getCapCursor cb_val) in
        (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
        (let vAddr =
          (((((cursor + ((Word.uint w__1)))) + (((( 4 :: int)::ii) * ((Word.sint offset))))))
            mod
            ((pow2 (( 64 :: int)::ii)))) in
        (let vAddr64 = ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) vAddr  ::  64 Word.word)) in
        if ((((vAddr + (( 4 :: int)::ii))) > ((getCapTop cb_val)))) then
          raise_c2_exception CapEx_LengthViolation cb
        else if ((vAddr < ((getCapBase cb_val)))) then raise_c2_exception CapEx_LengthViolation cb
        else if ((\<not> ((isAddressAligned vAddr64 W)))) then SignalExceptionBadAddr AdEL vAddr64
        else
          (TLBTranslate vAddr64 LoadData  :: ( 64 Word.word) M) \<bind> (\<lambda> pAddr . 
          (if linked then
             ((write_reg CP0LLBit_ref (vec_of_bits [B1]  ::  1 Word.word) \<then>
             write_reg CP0LLAddr_ref pAddr) \<then>
             (MEMr_reserve_wrapper pAddr (( 4 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__2 ::  32 Word.word) . 
             return ((extendLoad w__2 signext  ::  64 Word.word)))
           else
             (MEMr_wrapper (( 32 :: int)::ii) pAddr (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__3 ::  32 Word.word) . 
             return ((extendLoad w__3 signext  ::  64 Word.word)))) \<bind> (\<lambda> (memResult :: 64 bits) . 
          wGPR rd memResult))))))))
   )))"


(*val execute_CLC : mword ty5 -> mword ty5 -> mword ty5 -> mword ty16 -> bool -> M unit*)

definition execute_CLC  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CLC cd1 cb rt offset linked = (
   (checkCP2usable ()  \<then>
   readCapRegDDC cb) \<bind> (\<lambda> cb_val . 
   register_inaccessible cd1 \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cd1
   else
     register_inaccessible cb \<bind> (\<lambda> (w__1 :: bool) . 
     if w__1 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
     else if ((\<not>(CapStruct_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
     else if(CapStruct_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
     else if ((\<not>(CapStruct_permit_load   cb_val))) then
       raise_c2_exception CapEx_PermitLoadViolation cb
     else
       (let cursor = (getCapCursor cb_val) in
       (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::  64 Word.word) . 
       (let vAddr =
         (((((cursor + ((Word.uint w__2)))) + (((( 16 :: int)::ii) * ((Word.sint offset))))))
           mod
           ((pow2 (( 64 :: int)::ii)))) in
       (let vAddr64 = ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) vAddr  ::  64 Word.word)) in
       if ((((vAddr + cap_size)) > ((getCapTop cb_val)))) then
         raise_c2_exception CapEx_LengthViolation cb
       else if ((vAddr < ((getCapBase cb_val)))) then raise_c2_exception CapEx_LengthViolation cb
       else if (((((vAddr mod cap_size)) \<noteq> (( 0 :: int)::ii)))) then SignalExceptionBadAddr AdEL vAddr64
       else
         (TLBTranslateC vAddr64 LoadData  :: (( 64 Word.word * bool)) M) \<bind> (\<lambda> varstup .  (let (pAddr, suppressTag) = varstup in
         (let cd1 = (Word.uint cd1) in
         if linked then
           ((write_reg CP0LLBit_ref (vec_of_bits [B1]  ::  1 Word.word) \<then>
           write_reg CP0LLAddr_ref pAddr) \<then>
           (MEMr_tagged_reserve pAddr  :: ((bool *  256 Word.word)) M)) \<bind> (\<lambda> varstup .  (let (tag, mem) = varstup in
           write_reg
             ((access_list_dec CapRegs cd1  :: (regstate, register_value, ( 257 Word.word)) register_ref))
             ((memBitsToCapBits
                 (((tag \<and> ((((CapStruct_permit_load_cap   cb_val) \<and> ((\<not> suppressTag))))))))
                 mem
                ::  257 Word.word))))
         else
           (MEMr_tagged pAddr  :: ((bool *  256 Word.word)) M) \<bind> (\<lambda> varstup .  (let (tag, mem) = varstup in
           write_reg
             ((access_list_dec CapRegs cd1  :: (regstate, register_value, ( 257 Word.word)) register_ref))
             ((memBitsToCapBits
                 (((tag \<and> ((((CapStruct_permit_load_cap   cb_val) \<and> ((\<not> suppressTag))))))))
                 mem
                ::  257 Word.word)))))))))))))))"


(*val execute_CJALR : mword ty5 -> mword ty5 -> bool -> M unit*)

definition execute_CJALR  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CJALR cd1 cb link = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> (\<lambda> cb_val . 
   (let cb_ptr = (getCapCursor cb_val) in
   (let cb_top = (getCapTop cb_val) in
   (let cb_base = (getCapBase cb_val) in
   and_boolM (return link) ((register_inaccessible cd1)) \<bind> (\<lambda> (w__1 :: bool) . 
   if w__1 then raise_c2_exception CapEx_AccessSystemRegsViolation cd1
   else
     register_inaccessible cb \<bind> (\<lambda> (w__2 :: bool) . 
     if w__2 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
     else if ((\<not>(CapStruct_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
     else if(CapStruct_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
     else if ((\<not>(CapStruct_permit_execute   cb_val))) then
       raise_c2_exception CapEx_PermitExecuteViolation cb
     else if ((cb_ptr < cb_base)) then raise_c2_exception CapEx_LengthViolation cb
     else if ((((cb_ptr + (( 4 :: int)::ii))) > cb_top)) then
       raise_c2_exception CapEx_LengthViolation cb
     else if (((((cb_ptr mod (( 4 :: int)::ii))) \<noteq> (( 0 :: int)::ii)))) then SignalException AdEL
     else
       (if link then
          (read_reg PCC_ref  :: ( 257 Word.word) M) \<bind> (\<lambda> (w__3 :: CapReg) . 
          (let pcc = (capRegToCapStruct w__3) in
          (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 :: 64 bits) . 
          (let (success, linkCap) = (setCapOffset pcc ((add_vec_int w__4 (( 8 :: int)::ii)  ::  64 Word.word))) in
          if success then writeCapReg cd1 linkCap
          else assert_exp False ('''')))))
        else return () ) \<then>
       execute_branch_pcc cb_val)))))))"


(*val execute_CIncOffsetImmediate : mword ty5 -> mword ty5 -> mword ty11 -> M unit*)

definition execute_CIncOffsetImmediate  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(11)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CIncOffsetImmediate cd1 cb imm = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> (\<lambda> cb_val . 
   (let (imm64 :: 64 bits) = ((mips_sign_extend (( 64 :: int)::ii) imm  ::  64 Word.word)) in
   register_inaccessible cd1 \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cd1
   else
     register_inaccessible cb \<bind> (\<lambda> (w__1 :: bool) . 
     if w__1 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
     else if ((((CapStruct_tag   cb_val) \<and>(CapStruct_sealed   cb_val)))) then
       raise_c2_exception CapEx_SealViolation cb
     else
       (let (success, newCap) = (incCapOffset cb_val imm64) in
       if success then writeCapReg cd1 newCap
       else
         writeCapReg cd1
           ((int_to_cap
               ((add_vec
                   ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) ((getCapBase cb_val))
                      ::  64 Word.word)) imm64
                  ::  64 Word.word))))))))))"


(*val execute_CIncOffset : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_CIncOffset  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CIncOffset cd1 cb rt = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> (\<lambda> cb_val . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> rt_val . 
   register_inaccessible cd1 \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cd1
   else
     register_inaccessible cb \<bind> (\<lambda> (w__1 :: bool) . 
     if w__1 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
     else if ((((CapStruct_tag   cb_val) \<and> ((((CapStruct_sealed   cb_val) \<and> (((rt_val \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                       B0,B0,B0,B0]
                           ::  64 Word.word)))))))))) then
       raise_c2_exception CapEx_SealViolation cb
     else
       (let (success, newCap) = (incCapOffset cb_val rt_val) in
       if success then writeCapReg cd1 newCap
       else
         writeCapReg cd1
           ((int_to_cap
               ((add_vec
                   ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) ((getCapBase cb_val))
                      ::  64 Word.word)) rt_val
                  ::  64 Word.word))))))))))"


(*val execute_CGetType : mword ty5 -> mword ty5 -> M unit*)

definition execute_CGetType  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CGetType rd cb = (
   (checkCP2usable ()  \<then>
   register_inaccessible cb) \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
   else
     readCapReg cb \<bind> (\<lambda> capVal . 
     wGPR rd
       (if(CapStruct_sealed   capVal) then
          (mips_zero_extend (( 64 :: int)::ii)(CapStruct_otype   capVal)  ::  64 Word.word)
        else (replicate_bits ((cast_unit_vec0 B1  ::  1 Word.word)) (( 64 :: int)::ii)  ::  64 Word.word)))))"


(*val execute_CGetTag : mword ty5 -> mword ty5 -> M unit*)

definition execute_CGetTag  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CGetTag rd cb = (
   (checkCP2usable ()  \<then>
   register_inaccessible cb) \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
   else
     readCapReg cb \<bind> (\<lambda> capVal . 
     wGPR rd
       ((mips_zero_extend (( 64 :: int)::ii) ((bool_to_bits(CapStruct_tag   capVal)  ::  1 Word.word))  ::  64 Word.word)))))"


(*val execute_CGetSealed : mword ty5 -> mword ty5 -> M unit*)

definition execute_CGetSealed  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CGetSealed rd cb = (
   (checkCP2usable ()  \<then>
   register_inaccessible cb) \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
   else
     readCapReg cb \<bind> (\<lambda> capVal . 
     wGPR rd
       ((mips_zero_extend (( 64 :: int)::ii) ((bool_to_bits(CapStruct_sealed   capVal)  ::  1 Word.word))
          ::  64 Word.word)))))"


(*val execute_CGetPerm : mword ty5 -> mword ty5 -> M unit*)

definition execute_CGetPerm  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CGetPerm rd cb = (
   (checkCP2usable ()  \<then>
   register_inaccessible cb) \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
   else
     readCapReg cb \<bind> (\<lambda> capVal . 
     wGPR rd ((mips_zero_extend (( 64 :: int)::ii) ((getCapPerms capVal  ::  31 Word.word))  ::  64 Word.word)))))"


(*val execute_CGetPCCSetOffset : mword ty5 -> mword ty5 -> M unit*)

definition execute_CGetPCCSetOffset  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CGetPCCSetOffset cd1 rs = (
   (checkCP2usable ()  \<then>
   register_inaccessible cd1) \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cd1
   else
     (read_reg PCC_ref  :: ( 257 Word.word) M) \<bind> (\<lambda> (w__1 :: CapReg) . 
     (let pcc = (capRegToCapStruct w__1) in
     (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> rs_val . 
     (let (success, newPCC) = (setCapOffset pcc rs_val) in
     if success then writeCapReg cd1 newPCC
     else writeCapReg cd1 ((int_to_cap rs_val))))))))"


(*val execute_CGetPCC : mword ty5 -> M unit*)

definition execute_CGetPCC  :: "(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CGetPCC cd1 = (
   (checkCP2usable ()  \<then>
   register_inaccessible cd1) \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cd1
   else
     (read_reg PCC_ref  :: ( 257 Word.word) M) \<bind> (\<lambda> (w__1 :: CapReg) . 
     (let pcc = (capRegToCapStruct w__1) in
     (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 :: 64 bits) . 
     (let (success, pcc2) = (setCapOffset pcc w__2) in
     assert_exp success ('''') \<then> writeCapReg cd1 pcc2))))))"


(*val execute_CGetOffset : mword ty5 -> mword ty5 -> M unit*)

definition execute_CGetOffset  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CGetOffset rd cb = (
   (checkCP2usable ()  \<then>
   register_inaccessible cb) \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
   else
     readCapReg cb \<bind> (\<lambda> capVal . 
     wGPR rd
       ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) ((getCapOffset capVal))  ::  64 Word.word)))))"


(*val execute_CGetLen : mword ty5 -> mword ty5 -> M unit*)

definition execute_CGetLen  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CGetLen rd cb = (
   (checkCP2usable ()  \<then>
   register_inaccessible cb) \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
   else
     readCapReg cb \<bind> (\<lambda> capVal . 
     (let len65 = (getCapLength capVal) in
     wGPR rd
       ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself))
           (if ((len65 > MAX_U64)) then MAX_U64
            else len65)
          ::  64 Word.word))))))"


(*val execute_CGetCause : mword ty5 -> M unit*)

definition execute_CGetCause  :: "(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CGetCause rd = (
   (checkCP2usable ()  \<then>
   pcc_access_system_regs () ) \<bind> (\<lambda> (w__0 :: bool) . 
   if ((\<not> w__0)) then raise_c2_exception_noreg CapEx_AccessSystemRegsViolation
   else
     read_reg CapCause_ref \<bind> (\<lambda> (w__1 :: CapCauseReg) . 
     wGPR rd ((mips_zero_extend (( 64 :: int)::ii) ((get_CapCauseReg_bits w__1  ::  16 Word.word))  ::  64 Word.word)))))"


(*val execute_CGetBase : mword ty5 -> mword ty5 -> M unit*)

definition execute_CGetBase  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CGetBase rd cb = (
   (checkCP2usable ()  \<then>
   register_inaccessible cb) \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
   else
     readCapReg cb \<bind> (\<lambda> capVal . 
     wGPR rd
       ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) ((getCapBase capVal))  ::  64 Word.word)))))"


(*val execute_CGetAddr : mword ty5 -> mword ty5 -> M unit*)

definition execute_CGetAddr  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CGetAddr rd cb = (
   (checkCP2usable ()  \<then>
   register_inaccessible cb) \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
   else
     readCapReg cb \<bind> (\<lambda> capVal . 
     wGPR rd
       ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) ((getCapCursor capVal))  ::  64 Word.word)))))"


(*val execute_CFromPtr : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_CFromPtr  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CFromPtr cd1 cb rt = (
   (checkCP2usable ()  \<then>
   readCapRegDDC cb) \<bind> (\<lambda> cb_val . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> rt_val . 
   register_inaccessible cd1 \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cd1
   else
     register_inaccessible cb \<bind> (\<lambda> (w__1 :: bool) . 
     if w__1 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
     else if (((rt_val = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                               B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                               B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
                   ::  64 Word.word)))) then
       writeCapReg cd1 null_cap
     else if ((\<not>(CapStruct_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
     else if(CapStruct_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
     else
       (let (success, newCap) = (setCapOffset cb_val rt_val) in
       if success then writeCapReg cd1 newCap
       else
         writeCapReg cd1
           ((int_to_cap
               ((add_vec
                   ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) ((getCapBase cb_val))
                      ::  64 Word.word)) rt_val
                  ::  64 Word.word))))))))))"


(*val execute_CCopyType : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_CCopyType  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CCopyType cd1 cb ct = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> (\<lambda> cb_val . 
   readCapReg ct \<bind> (\<lambda> ct_val . 
   (let cb_base = (getCapBase cb_val) in
   (let cb_top = (getCapTop cb_val) in
   (let ct_otype = (Word.uint(CapStruct_otype   ct_val)) in
   register_inaccessible cd1 \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cd1
   else
     register_inaccessible cb \<bind> (\<lambda> (w__1 :: bool) . 
     if w__1 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
     else
       register_inaccessible ct \<bind> (\<lambda> (w__2 :: bool) . 
       if w__2 then raise_c2_exception CapEx_AccessSystemRegsViolation ct
       else if ((\<not>(CapStruct_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
       else if(CapStruct_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
       else if(CapStruct_sealed   ct_val) then
         if ((ct_otype < cb_base)) then raise_c2_exception CapEx_LengthViolation cb
         else if ((ct_otype \<ge> cb_top)) then raise_c2_exception CapEx_LengthViolation cb
         else
           (let (success, cap) =
             (setCapOffset cb_val
               ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) ((ct_otype - cb_base))
                  ::  64 Word.word))) in
           assert_exp success ('''') \<then> writeCapReg cd1 cap)
       else
         writeCapReg cd1
           ((int_to_cap ((replicate_bits ((cast_unit_vec0 B1  ::  1 Word.word)) (( 64 :: int)::ii)  ::  64 Word.word)))))))))))))"


(*val execute_CClearTag : mword ty5 -> mword ty5 -> M unit*)

definition execute_CClearTag  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CClearTag cd1 cb = (
   (checkCP2usable ()  \<then>
   register_inaccessible cd1) \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cd1
   else
     register_inaccessible cb \<bind> (\<lambda> (w__1 :: bool) . 
     if w__1 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
     else readCapReg cb \<bind> (\<lambda> cb_val .  writeCapReg cd1 (cb_val (| CapStruct_tag := False |))))))"


(*val execute_CCheckType : mword ty5 -> mword ty5 -> M unit*)

definition execute_CCheckType  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CCheckType cs cb = (
   (checkCP2usable ()  \<then>
   readCapReg cs) \<bind> (\<lambda> cs_val . 
   readCapReg cb \<bind> (\<lambda> cb_val . 
   register_inaccessible cs \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cs
   else
     register_inaccessible cb \<bind> (\<lambda> (w__1 :: bool) . 
     if w__1 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
     else if ((\<not>(CapStruct_tag   cs_val))) then raise_c2_exception CapEx_TagViolation cs
     else if ((\<not>(CapStruct_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
     else if ((\<not>(CapStruct_sealed   cs_val))) then raise_c2_exception CapEx_SealViolation cs
     else if ((\<not>(CapStruct_sealed   cb_val))) then raise_c2_exception CapEx_SealViolation cb
     else if ((((CapStruct_otype   cs_val) \<noteq>(CapStruct_otype   cb_val)))) then
       raise_c2_exception CapEx_TypeViolation cs
     else return () )))))"


(*val execute_CCheckPerm : mword ty5 -> mword ty5 -> M unit*)

definition execute_CCheckPerm  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CCheckPerm cs rt = (
   (checkCP2usable ()  \<then>
   readCapReg cs) \<bind> (\<lambda> cs_val . 
   (let (cs_perms :: 64 bits) =
     ((mips_zero_extend (( 64 :: int)::ii) ((getCapPerms cs_val  ::  31 Word.word))  ::  64 Word.word)) in
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> rt_perms . 
   register_inaccessible cs \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cs
   else if ((\<not>(CapStruct_tag   cs_val))) then raise_c2_exception CapEx_TagViolation cs
   else if (((((and_vec cs_perms rt_perms  ::  64 Word.word)) \<noteq> rt_perms))) then
     raise_c2_exception CapEx_UserDefViolation cs
   else return () )))))"


(*val execute_CCall : mword ty5 -> mword ty5 -> mword ty11 -> M unit*)

definition execute_CCall  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(11)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CCall cs cb b__151 = (
   if (((b__151 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  11 Word.word)))) then
     (checkCP2usable ()  \<then>
     readCapReg cs) \<bind> (\<lambda> cs_val . 
     readCapReg cb \<bind> (\<lambda> cb_val . 
     (let cs_cursor = (getCapCursor cs_val) in
     register_inaccessible cs \<bind> (\<lambda> (w__0 :: bool) . 
     if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cs
     else
       register_inaccessible cb \<bind> (\<lambda> (w__1 :: bool) . 
       if w__1 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
       else if ((\<not>(CapStruct_tag   cs_val))) then raise_c2_exception CapEx_TagViolation cs
       else if ((\<not>(CapStruct_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
       else if ((\<not>(CapStruct_sealed   cs_val))) then raise_c2_exception CapEx_SealViolation cs
       else if ((\<not>(CapStruct_sealed   cb_val))) then raise_c2_exception CapEx_SealViolation cb
       else if ((((CapStruct_otype   cs_val) \<noteq>(CapStruct_otype   cb_val)))) then
         raise_c2_exception CapEx_TypeViolation cs
       else if ((\<not>(CapStruct_permit_execute   cs_val))) then
         raise_c2_exception CapEx_PermitExecuteViolation cs
       else if(CapStruct_permit_execute   cb_val) then
         raise_c2_exception CapEx_PermitExecuteViolation cb
       else if ((cs_cursor < ((getCapBase cs_val)))) then
         raise_c2_exception CapEx_LengthViolation cs
       else if ((cs_cursor \<ge> ((getCapTop cs_val)))) then
         raise_c2_exception CapEx_LengthViolation cs
       else raise_c2_exception CapEx_CallTrap cs)))))
   else
     (checkCP2usable ()  \<then>
     readCapReg cs) \<bind> (\<lambda> cs_val . 
     readCapReg cb \<bind> (\<lambda> cb_val . 
     (let cs_cursor = (getCapCursor cs_val) in
     register_inaccessible cs \<bind> (\<lambda> (w__2 :: bool) . 
     if w__2 then raise_c2_exception CapEx_AccessSystemRegsViolation cs
     else
       register_inaccessible cb \<bind> (\<lambda> (w__3 :: bool) . 
       if w__3 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
       else if ((\<not>(CapStruct_tag   cs_val))) then raise_c2_exception CapEx_TagViolation cs
       else if ((\<not>(CapStruct_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
       else if ((\<not>(CapStruct_sealed   cs_val))) then raise_c2_exception CapEx_SealViolation cs
       else if ((\<not>(CapStruct_sealed   cb_val))) then raise_c2_exception CapEx_SealViolation cb
       else if ((((CapStruct_otype   cs_val) \<noteq>(CapStruct_otype   cb_val)))) then
         raise_c2_exception CapEx_TypeViolation cs
       else if ((\<not>(CapStruct_permit_ccall   cs_val))) then
         raise_c2_exception CapEx_PermitCCallViolation cs
       else if ((\<not>(CapStruct_permit_ccall   cb_val))) then
         raise_c2_exception CapEx_PermitCCallViolation cb
       else if ((\<not>(CapStruct_permit_execute   cs_val))) then
         raise_c2_exception CapEx_PermitExecuteViolation cs
       else if(CapStruct_permit_execute   cb_val) then
         raise_c2_exception CapEx_PermitExecuteViolation cb
       else if ((cs_cursor < ((getCapBase cs_val)))) then
         raise_c2_exception CapEx_LengthViolation cs
       else if ((cs_cursor \<ge> ((getCapTop cs_val)))) then
         raise_c2_exception CapEx_LengthViolation cs
       else
         (execute_branch_pcc
           (cs_val (|
             CapStruct_sealed := False, CapStruct_otype := ((zeros0 (( 24 :: int)::ii) ()   ::  24 Word.word))|)) \<then>
         write_reg inCCallDelay_ref (vec_of_bits [B1]  ::  1 Word.word)) \<then>
         write_reg
           C26_ref
           ((capStructToCapReg
               (cb_val (|
                 CapStruct_sealed := False, CapStruct_otype := ((zeros0 (( 24 :: int)::ii) ()   ::  24 Word.word))|))
              ::  257 Word.word))))))))"


(*val execute_CCSeal : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_CCSeal  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CCSeal cd1 cs ct = (
   (checkCP2usable ()  \<then>
   readCapReg cs) \<bind> (\<lambda> cs_val . 
   readCapReg ct \<bind> (\<lambda> ct_val . 
   (let ct_cursor = (getCapCursor ct_val) in
   (let ct_top = (getCapTop ct_val) in
   (let ct_base = (getCapBase ct_val) in
   register_inaccessible cd1 \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cd1
   else
     register_inaccessible cs \<bind> (\<lambda> (w__1 :: bool) . 
     if w__1 then raise_c2_exception CapEx_AccessSystemRegsViolation cs
     else
       register_inaccessible ct \<bind> (\<lambda> (w__2 :: bool) . 
       if w__2 then raise_c2_exception CapEx_AccessSystemRegsViolation ct
       else if ((\<not>(CapStruct_tag   cs_val))) then raise_c2_exception CapEx_TagViolation cs
       else if (((((\<not>(CapStruct_tag   ct_val))) \<or> (((((getCapCursor ct_val)) = ((Word.uint ((replicate_bits ((cast_unit_vec0 B1  ::  1 Word.word)) (( 64 :: int)::ii)  ::  64 Word.word))))))))))
       then
         writeCapReg cd1 cs_val
       else if(CapStruct_sealed   cs_val) then raise_c2_exception CapEx_SealViolation cs
       else if(CapStruct_sealed   ct_val) then raise_c2_exception CapEx_SealViolation ct
       else if ((\<not>(CapStruct_permit_seal   ct_val))) then
         raise_c2_exception CapEx_PermitSealViolation ct
       else if ((ct_cursor < ct_base)) then raise_c2_exception CapEx_LengthViolation ct
       else if ((ct_cursor \<ge> ct_top)) then raise_c2_exception CapEx_LengthViolation ct
       else if ((ct_cursor > max_otype)) then raise_c2_exception CapEx_LengthViolation ct
       else
         (let (success, newCap) =
           (sealCap cs_val
             ((to_bits ((make_the_value (( 24 :: int)::ii)  ::  24 itself)) ct_cursor  ::  24 Word.word))) in
         if ((\<not> success)) then raise_c2_exception CapEx_InexactBounds cs
         else writeCapReg cd1 newCap))))))))))"


(*val execute_CBuildCap : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_CBuildCap  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CBuildCap cd1 cb ct = (
   (checkCP2usable ()  \<then>
   readCapRegDDC cb) \<bind> (\<lambda> cb_val . 
   readCapReg ct \<bind> (\<lambda> ct_val . 
   (let cb_base = (getCapBase cb_val) in
   (let ct_base = (getCapBase ct_val) in
   (let cb_top = (getCapTop cb_val) in
   (let ct_top = (getCapTop ct_val) in
   (let cb_perms = ((getCapPerms cb_val  ::  31 Word.word)) in
   (let ct_perms = ((getCapPerms ct_val  ::  31 Word.word)) in
   (let ct_offset = (getCapOffset ct_val) in
   register_inaccessible cd1 \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cd1
   else
     register_inaccessible cb \<bind> (\<lambda> (w__1 :: bool) . 
     if w__1 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
     else
       register_inaccessible ct \<bind> (\<lambda> (w__2 :: bool) . 
       if w__2 then raise_c2_exception CapEx_AccessSystemRegsViolation ct
       else if ((\<not>(CapStruct_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
       else if(CapStruct_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
       else if ((ct_base < cb_base)) then raise_c2_exception CapEx_LengthViolation cb
       else if ((ct_top > cb_top)) then raise_c2_exception CapEx_LengthViolation cb
       else if ((ct_base > ct_top)) then raise_c2_exception CapEx_LengthViolation ct
       else if (((((and_vec ct_perms cb_perms  ::  31 Word.word)) \<noteq> ct_perms))) then
         raise_c2_exception CapEx_UserDefViolation cb
       else
         (let (exact, cd11) =
           (setCapBounds cb_val
             ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) ct_base  ::  64 Word.word))
             ((to_bits ((make_the_value (( 65 :: int)::ii)  ::  65 itself)) ct_top  ::  65 Word.word))) in
         (let (representable, cd2) =
           (setCapOffset cd11
             ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) ct_offset  ::  64 Word.word))) in
         (let cd3 = (setCapPerms cd2 ct_perms) in
         (assert_exp exact ('''') \<then> assert_exp representable ('''')) \<then> writeCapReg cd1 cd3))))))))))))))))"


(*val execute_CBZ : mword ty5 -> mword ty16 -> bool -> M unit*)

definition execute_CBZ  :: "(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CBZ cb imm notzero = (
   (checkCP2usable ()  \<then>
   register_inaccessible cb) \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
   else
     readCapReg cb \<bind> (\<lambda> (w__1 :: CapStruct) . 
     if ((bits_to_bool
            ((xor_vec ((bool_to_bits (((w__1 = null_cap)))  ::  1 Word.word))
                ((bool_to_bits notzero  ::  1 Word.word))
               ::  1 Word.word)))) then
       (let (offset :: 64 bits) =
         ((add_vec_int
            ((mips_sign_extend (( 64 :: int)::ii)
                ((concat_vec imm (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  18 Word.word))
               ::  64 Word.word)) (( 4 :: int)::ii)
           ::  64 Word.word)) in
       (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 :: 64 bits) . 
       execute_branch ((add_vec w__2 offset  ::  64 Word.word))))
     else return () )))"


(*val execute_CBX : mword ty5 -> mword ty16 -> bool -> M unit*)

definition execute_CBX  :: "(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CBX cb imm notset = (
   (checkCP2usable ()  \<then>
   register_inaccessible cb) \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
   else
     readCapReg cb \<bind> (\<lambda> (w__1 :: CapStruct) . 
     if ((bits_to_bool
            ((xor_vec ((bool_to_bits(CapStruct_tag   w__1)  ::  1 Word.word))
                ((bool_to_bits notset  ::  1 Word.word))
               ::  1 Word.word)))) then
       (let (offset :: 64 bits) =
         ((add_vec_int
            ((mips_sign_extend (( 64 :: int)::ii)
                ((concat_vec imm (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  18 Word.word))
               ::  64 Word.word)) (( 4 :: int)::ii)
           ::  64 Word.word)) in
       (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 :: 64 bits) . 
       execute_branch ((add_vec w__2 offset  ::  64 Word.word))))
     else return () )))"


(*val execute_CAndPerm : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_CAndPerm  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CAndPerm cd1 cb rt = (
   (checkCP2usable ()  \<then>
   readCapReg cb) \<bind> (\<lambda> cb_val . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> rt_val . 
   register_inaccessible cd1 \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then raise_c2_exception CapEx_AccessSystemRegsViolation cd1
   else
     register_inaccessible cb \<bind> (\<lambda> (w__1 :: bool) . 
     if w__1 then raise_c2_exception CapEx_AccessSystemRegsViolation cb
     else if ((\<not>(CapStruct_tag   cb_val))) then raise_c2_exception CapEx_TagViolation cb
     else if(CapStruct_sealed   cb_val) then raise_c2_exception CapEx_SealViolation cb
     else
       (let perms = ((getCapPerms cb_val  ::  31 Word.word)) in
       (let newCap =
         (setCapPerms cb_val
           ((and_vec perms ((subrange_vec_dec rt_val (( 30 :: int)::ii) (( 0 :: int)::ii)  ::  31 Word.word))  ::  31 Word.word))) in
       writeCapReg cd1 newCap)))))))"


(*val execute_CACHE : mword ty5 -> mword ty5 -> mword ty16 -> M unit*)

definition execute_CACHE  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CACHE base op1 imm = ( checkCP0Access ()  )"


(*val execute_C2Dump : mword ty5 -> unit*)

definition execute_C2Dump  :: "(5)Word.word \<Rightarrow> unit "  where 
     " execute_C2Dump rt = ( ()  )"


(*val execute_BREAK : unit -> M unit*)

definition execute_BREAK  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_BREAK _ = ( SignalException Bp )"


(*val execute_BEQ : mword ty5 -> mword ty5 -> mword ty16 -> bool -> bool -> M unit*)

definition execute_BEQ  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_BEQ rs rd imm ne likely = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (rGPR rd  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   if ((bits_to_bool
          ((xor_vec ((bool_to_bits (((w__0 = w__1)))  ::  1 Word.word))
              ((bool_to_bits ne  ::  1 Word.word))
             ::  1 Word.word)))) then
     (let (offset :: 64 bits) =
       ((add_vec_int
          ((mips_sign_extend (( 64 :: int)::ii)
              ((concat_vec imm (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  18 Word.word))
             ::  64 Word.word)) (( 4 :: int)::ii)
         ::  64 Word.word)) in
     (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 :: 64 bits) . 
     execute_branch ((add_vec w__2 offset  ::  64 Word.word))))
   else if likely then
     (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 :: 64 bits) . 
     write_reg nextPC_ref ((add_vec_int w__3 (( 8 :: int)::ii)  ::  64 Word.word)))
   else return () )))"


(*val execute_BCMPZ : mword ty5 -> mword ty16 -> Comparison -> bool -> bool -> M unit*)

definition execute_BCMPZ  :: "(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow> Comparison \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_BCMPZ rs imm cmp link likely = (
   (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 :: 64 bits) . 
   (let linkVal = ((add_vec_int w__0 (( 8 :: int)::ii)  ::  64 Word.word)) in
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> regVal . 
   (let condition =
     (compare cmp regVal ((mips_zero_extend (( 64 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  64 Word.word))) in
   (if condition then
      (let (offset :: 64 bits) =
        ((add_vec_int
           ((mips_sign_extend (( 64 :: int)::ii)
               ((concat_vec imm (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  18 Word.word))
              ::  64 Word.word)) (( 4 :: int)::ii)
          ::  64 Word.word)) in
      (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 :: 64 bits) . 
      execute_branch ((add_vec w__1 offset  ::  64 Word.word))))
    else if likely then
      (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 :: 64 bits) . 
      write_reg nextPC_ref ((add_vec_int w__2 (( 8 :: int)::ii)  ::  64 Word.word)))
    else return () ) \<then>
   (if link then wGPR (vec_of_bits [B1,B1,B1,B1,B1]  ::  5 Word.word) linkVal
   else return () ))))))"


(*val execute_ANDI : mword ty5 -> mword ty5 -> mword ty16 -> M unit*)

definition execute_ANDI  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_ANDI rs rt imm = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   wGPR rt ((and_vec w__0 ((mips_zero_extend (( 64 :: int)::ii) imm  ::  64 Word.word))  ::  64 Word.word))))"


(*val execute_AND : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_AND  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_AND rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   wGPR rd ((and_vec w__0 w__1  ::  64 Word.word)))))"


(*val execute_ADDU : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_ADDU  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_ADDU rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> opA . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> opB . 
   if (((((NotWordVal opA)) \<or> ((NotWordVal opB))))) then
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) .  wGPR rd w__0)
   else
     wGPR rd
       ((mips_sign_extend (( 64 :: int)::ii)
           ((add_vec ((subrange_vec_dec opA (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
               ((subrange_vec_dec opB (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
              ::  32 Word.word))
          ::  64 Word.word)))))"


(*val execute_ADDIU : mword ty5 -> mword ty5 -> mword ty16 -> M unit*)

definition execute_ADDIU  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_ADDIU rs rt imm = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> opA . 
   if ((NotWordVal opA)) then
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) .  wGPR rt w__0)
   else
     wGPR rt
       ((mips_sign_extend (( 64 :: int)::ii)
           ((add_vec ((subrange_vec_dec opA (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
               ((mips_sign_extend (( 32 :: int)::ii) imm  ::  32 Word.word))
              ::  32 Word.word))
          ::  64 Word.word))))"


(*val execute_ADDI : mword ty5 -> mword ty5 -> mword ty16 -> M unit*)

definition execute_ADDI  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_ADDI rs rt imm = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> opA . 
   if ((NotWordVal opA)) then
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) .  wGPR rt w__0)
   else
     (let (sum33 :: 33 bits) =
       ((add_vec
          ((mips_sign_extend (( 33 :: int)::ii) ((subrange_vec_dec opA (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
             ::  33 Word.word)) ((mips_sign_extend (( 33 :: int)::ii) imm  ::  33 Word.word))
         ::  33 Word.word)) in
     if ((neq_bool ((bit_to_bool ((access_vec_dec sum33 (( 32 :: int)::ii)))))
            ((bit_to_bool ((access_vec_dec sum33 (( 31 :: int)::ii))))))) then
       SignalException Ov
     else
       wGPR rt
         ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec sum33 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ::  64 Word.word)))))"


(*val execute_ADD : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

definition execute_ADD  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_ADD rs rt rd = (
   (rGPR rs  :: ( 64 Word.word) M) \<bind> (\<lambda> (opA :: 64 bits) . 
   (rGPR rt  :: ( 64 Word.word) M) \<bind> (\<lambda> (opB :: 64 bits) . 
   if (((((NotWordVal opA)) \<or> ((NotWordVal opB))))) then
     (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) .  wGPR rd w__0)
   else
     (let (sum33 :: 33 bits) =
       ((add_vec
          ((mips_sign_extend (( 33 :: int)::ii) ((subrange_vec_dec opA (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
             ::  33 Word.word))
          ((mips_sign_extend (( 33 :: int)::ii) ((subrange_vec_dec opB (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
             ::  33 Word.word))
         ::  33 Word.word)) in
     if ((neq_bool ((bit_to_bool ((access_vec_dec sum33 (( 32 :: int)::ii)))))
            ((bit_to_bool ((access_vec_dec sum33 (( 31 :: int)::ii))))))) then
       SignalException Ov
     else
       wGPR rd
         ((mips_sign_extend (( 64 :: int)::ii) ((subrange_vec_dec sum33 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ::  64 Word.word))))))"


fun execute  :: " ast \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute (DADDIU (rs,rt,imm)) = ( execute_DADDIU rs rt imm )"
|" execute (DADDU (rs,rt,rd)) = ( execute_DADDU rs rt rd )"
|" execute (DADDI (rs,rt,imm)) = ( execute_DADDI rs rt imm )"
|" execute (DADD (rs,rt,rd)) = ( execute_DADD rs rt rd )"
|" execute (ADD (rs,rt,rd)) = ( execute_ADD rs rt rd )"
|" execute (ADDI (rs,rt,imm)) = ( execute_ADDI rs rt imm )"
|" execute (ADDU (rs,rt,rd)) = ( execute_ADDU rs rt rd )"
|" execute (ADDIU (rs,rt,imm)) = ( execute_ADDIU rs rt imm )"
|" execute (DSUBU (rs,rt,rd)) = ( execute_DSUBU rs rt rd )"
|" execute (DSUB (rs,rt,rd)) = ( execute_DSUB rs rt rd )"
|" execute (SUB (rs,rt,rd)) = ( execute_SUB rs rt rd )"
|" execute (SUBU (rs,rt,rd)) = ( execute_SUBU rs rt rd )"
|" execute (AND0 (rs,rt,rd)) = ( execute_AND rs rt rd )"
|" execute (ANDI (rs,rt,imm)) = ( execute_ANDI rs rt imm )"
|" execute (OR0 (rs,rt,rd)) = ( execute_OR rs rt rd )"
|" execute (ORI (rs,rt,imm)) = ( execute_ORI rs rt imm )"
|" execute (NOR (rs,rt,rd)) = ( execute_NOR rs rt rd )"
|" execute (XOR0 (rs,rt,rd)) = ( execute_XOR rs rt rd )"
|" execute (XORI (rs,rt,imm)) = ( execute_XORI rs rt imm )"
|" execute (LUI (rt,imm)) = ( execute_LUI rt imm )"
|" execute (DSLL (rt,rd,sa)) = ( execute_DSLL rt rd sa )"
|" execute (DSLL32 (rt,rd,sa)) = ( execute_DSLL32 rt rd sa )"
|" execute (DSLLV (rs,rt,rd)) = ( execute_DSLLV rs rt rd )"
|" execute (DSRA (rt,rd,sa)) = ( execute_DSRA rt rd sa )"
|" execute (DSRA32 (rt,rd,sa)) = ( execute_DSRA32 rt rd sa )"
|" execute (DSRAV (rs,rt,rd)) = ( execute_DSRAV rs rt rd )"
|" execute (DSRL (rt,rd,sa)) = ( execute_DSRL rt rd sa )"
|" execute (DSRL32 (rt,rd,sa)) = ( execute_DSRL32 rt rd sa )"
|" execute (DSRLV (rs,rt,rd)) = ( execute_DSRLV rs rt rd )"
|" execute (SLL (rt,rd,sa)) = ( execute_SLL rt rd sa )"
|" execute (SLLV (rs,rt,rd)) = ( execute_SLLV rs rt rd )"
|" execute (SRA (rt,rd,sa)) = ( execute_SRA rt rd sa )"
|" execute (SRAV (rs,rt,rd)) = ( execute_SRAV rs rt rd )"
|" execute (SRL (rt,rd,sa)) = ( execute_SRL rt rd sa )"
|" execute (SRLV (rs,rt,rd)) = ( execute_SRLV rs rt rd )"
|" execute (SLT (rs,rt,rd)) = ( execute_SLT rs rt rd )"
|" execute (SLTI (rs,rt,imm)) = ( execute_SLTI rs rt imm )"
|" execute (SLTU (rs,rt,rd)) = ( execute_SLTU rs rt rd )"
|" execute (SLTIU (rs,rt,imm)) = ( execute_SLTIU rs rt imm )"
|" execute (MOVN (rs,rt,rd)) = ( execute_MOVN rs rt rd )"
|" execute (MOVZ (rs,rt,rd)) = ( execute_MOVZ rs rt rd )"
|" execute (MFHI (rd)) = ( execute_MFHI rd )"
|" execute (MFLO (rd)) = ( execute_MFLO rd )"
|" execute (MTHI (rs)) = ( execute_MTHI rs )"
|" execute (MTLO (rs)) = ( execute_MTLO rs )"
|" execute (MUL (rs,rt,rd)) = ( execute_MUL rs rt rd )"
|" execute (MULT (rs,rt)) = ( execute_MULT rs rt )"
|" execute (MULTU (rs,rt)) = ( execute_MULTU rs rt )"
|" execute (DMULT (rs,rt)) = ( execute_DMULT rs rt )"
|" execute (DMULTU (rs,rt)) = ( execute_DMULTU rs rt )"
|" execute (MADD (rs,rt)) = ( execute_MADD rs rt )"
|" execute (MADDU (rs,rt)) = ( execute_MADDU rs rt )"
|" execute (MSUB (rs,rt)) = ( execute_MSUB rs rt )"
|" execute (MSUBU (rs,rt)) = ( execute_MSUBU rs rt )"
|" execute (DIV (rs,rt)) = ( execute_DIV rs rt )"
|" execute (DIVU (rs,rt)) = ( execute_DIVU rs rt )"
|" execute (DDIV (rs,rt)) = ( execute_DDIV rs rt )"
|" execute (DDIVU (rs,rt)) = ( execute_DDIVU rs rt )"
|" execute (J (offset)) = ( execute_J offset )"
|" execute (JAL (offset)) = ( execute_JAL offset )"
|" execute (JR (rs)) = ( execute_JR rs )"
|" execute (JALR (rs,rd)) = ( execute_JALR rs rd )"
|" execute (BEQ (rs,rd,imm,ne,likely)) = ( execute_BEQ rs rd imm ne likely )"
|" execute (BCMPZ (rs,imm,cmp,link,likely)) = ( execute_BCMPZ rs imm cmp link likely )"
|" execute (SYSCALL (arg0)) = ( execute_SYSCALL arg0 )"
|" execute (BREAK (arg0)) = ( execute_BREAK arg0 )"
|" execute (WAIT (arg0)) = ( execute_WAIT arg0 )"
|" execute (TRAPREG (rs,rt,cmp)) = ( execute_TRAPREG rs rt cmp )"
|" execute (TRAPIMM (rs,imm,cmp)) = ( execute_TRAPIMM rs imm cmp )"
|" execute (Load (width,sign,linked,base,rt,offset)) = ( execute_Load width sign linked base rt offset )"
|" execute (Store (width,conditional,base,rt,offset)) = ( execute_Store width conditional base rt offset )"
|" execute (LWL (base,rt,offset)) = ( execute_LWL base rt offset )"
|" execute (LWR (base,rt,offset)) = ( execute_LWR base rt offset )"
|" execute (SWL (base,rt,offset)) = ( execute_SWL base rt offset )"
|" execute (SWR (base,rt,offset)) = ( execute_SWR base rt offset )"
|" execute (LDL (base,rt,offset)) = ( execute_LDL base rt offset )"
|" execute (LDR (base,rt,offset)) = ( execute_LDR base rt offset )"
|" execute (SDL (base,rt,offset)) = ( execute_SDL base rt offset )"
|" execute (SDR (base,rt,offset)) = ( execute_SDR base rt offset )"
|" execute (CACHE (base,op1,imm)) = ( execute_CACHE base op1 imm )"
|" execute (SYNC (arg0)) = ( execute_SYNC arg0 )"
|" execute (MFC0 (rt,rd,sel,double)) = ( execute_MFC0 rt rd sel double )"
|" execute (HCF (arg0)) = ( return ((execute_HCF arg0)))"
|" execute (MTC0 (rt,rd,sel,double)) = ( execute_MTC0 rt rd sel double )"
|" execute (TLBWI (arg0)) = ( execute_TLBWI arg0 )"
|" execute (TLBWR (arg0)) = ( execute_TLBWR arg0 )"
|" execute (TLBR (arg0)) = ( execute_TLBR arg0 )"
|" execute (TLBP (arg0)) = ( execute_TLBP arg0 )"
|" execute (RDHWR (rt,rd)) = ( execute_RDHWR rt rd )"
|" execute (ERET (arg0)) = ( execute_ERET arg0 )"
|" execute (CGetPerm (rd,cb)) = ( execute_CGetPerm rd cb )"
|" execute (CGetType (rd,cb)) = ( execute_CGetType rd cb )"
|" execute (CGetBase (rd,cb)) = ( execute_CGetBase rd cb )"
|" execute (CGetOffset (rd,cb)) = ( execute_CGetOffset rd cb )"
|" execute (CGetLen (rd,cb)) = ( execute_CGetLen rd cb )"
|" execute (CGetTag (rd,cb)) = ( execute_CGetTag rd cb )"
|" execute (CGetSealed (rd,cb)) = ( execute_CGetSealed rd cb )"
|" execute (CGetAddr (rd,cb)) = ( execute_CGetAddr rd cb )"
|" execute (CGetPCC (cd1)) = ( execute_CGetPCC cd1 )"
|" execute (CGetPCCSetOffset (cd1,rs)) = ( execute_CGetPCCSetOffset cd1 rs )"
|" execute (CGetCause (rd)) = ( execute_CGetCause rd )"
|" execute (CSetCause (rt)) = ( execute_CSetCause rt )"
|" execute (CReadHwr (cd1,sel)) = ( execute_CReadHwr cd1 sel )"
|" execute (CWriteHwr (cb,sel)) = ( execute_CWriteHwr cb sel )"
|" execute (CAndPerm (cd1,cb,rt)) = ( execute_CAndPerm cd1 cb rt )"
|" execute (CToPtr (rd,cb,ct)) = ( execute_CToPtr rd cb ct )"
|" execute (CSub (rd,cb,ct)) = ( execute_CSub rd cb ct )"
|" execute (CPtrCmp (rd,cb,ct,op1)) = ( execute_CPtrCmp rd cb ct op1 )"
|" execute (CIncOffset (cd1,cb,rt)) = ( execute_CIncOffset cd1 cb rt )"
|" execute (CIncOffsetImmediate (cd1,cb,imm)) = ( execute_CIncOffsetImmediate cd1 cb imm )"
|" execute (CSetOffset (cd1,cb,rt)) = ( execute_CSetOffset cd1 cb rt )"
|" execute (CSetBounds (cd1,cb,rt)) = ( execute_CSetBounds cd1 cb rt )"
|" execute (CSetBoundsImmediate (cd1,cb,imm)) = ( execute_CSetBoundsImmediate cd1 cb imm )"
|" execute (CSetBoundsExact (cd1,cb,rt)) = ( execute_CSetBoundsExact cd1 cb rt )"
|" execute (CClearTag (cd1,cb)) = ( execute_CClearTag cd1 cb )"
|" execute (CMOVX (cd1,cb,rt,ismovn)) = ( execute_CMOVX cd1 cb rt ismovn )"
|" execute (ClearRegs (regset,m)) = ( execute_ClearRegs regset m )"
|" execute (CFromPtr (cd1,cb,rt)) = ( execute_CFromPtr cd1 cb rt )"
|" execute (CBuildCap (cd1,cb,ct)) = ( execute_CBuildCap cd1 cb ct )"
|" execute (CCopyType (cd1,cb,ct)) = ( execute_CCopyType cd1 cb ct )"
|" execute (CCheckPerm (cs,rt)) = ( execute_CCheckPerm cs rt )"
|" execute (CCheckType (cs,cb)) = ( execute_CCheckType cs cb )"
|" execute (CTestSubset (rd,cb,ct)) = ( execute_CTestSubset rd cb ct )"
|" execute (CSeal (cd1,cs,ct)) = ( execute_CSeal cd1 cs ct )"
|" execute (CCSeal (cd1,cs,ct)) = ( execute_CCSeal cd1 cs ct )"
|" execute (CUnseal (cd1,cs,ct)) = ( execute_CUnseal cd1 cs ct )"
|" execute (CCall (cs,cb,b__151)) = ( execute_CCall cs cb b__151 )"
|" execute (CReturn (arg0)) = ( execute_CReturn arg0 )"
|" execute (CBX (cb,imm,notset)) = ( execute_CBX cb imm notset )"
|" execute (CBZ (cb,imm,notzero)) = ( execute_CBZ cb imm notzero )"
|" execute (CJALR (cd1,cb,link)) = ( execute_CJALR cd1 cb link )"
|" execute (CLoad (rd,cb,rt,offset,signext,arg5,linked)) = (
      execute_CLoad rd cb rt offset signext arg5 linked )"
|" execute (CStore (rs,cb,rt,rd,offset,width,conditional)) = (
      execute_CStore rs cb rt rd offset width conditional )"
|" execute (CSC (cs,cb,rt,rd,offset,conditional)) = ( execute_CSC cs cb rt rd offset conditional )"
|" execute (CLC (cd1,cb,rt,offset,linked)) = ( execute_CLC cd1 cb rt offset linked )"
|" execute (C2Dump (rt)) = ( return ((execute_C2Dump rt)))"
|" execute (RI (arg0)) = ( execute_RI arg0 )"


(*val supported_instructions : ast -> maybe ast*)

definition supported_instructions  :: " ast \<Rightarrow>(ast)option "  where 
     " supported_instructions instr = ( Some instr )"


(*val cycle_limit_reached : unit -> bool*)

definition cycle_limit_reached  :: " unit \<Rightarrow> bool "  where 
     " cycle_limit_reached _ = ( False )"


(*val fetch_and_execute : unit -> M bool*)

definition fetch_and_execute  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " fetch_and_execute _ = (
   (read_reg nextPC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 :: 64 bits) . 
   (write_reg PC_ref w__0 \<then>
   (read_reg branchPending_ref  :: ( 1 Word.word) M)) \<bind> (\<lambda> (w__1 :: 1 bits) . 
   ((write_reg inBranchDelay_ref w__1 \<then>
   write_reg branchPending_ref (vec_of_bits [B0]  ::  1 Word.word)) \<then>
   (read_reg inBranchDelay_ref  :: ( 1 Word.word) M)) \<bind> (\<lambda> (w__2 :: 1 bits) . 
   (if ((bits_to_bool w__2)) then (read_reg delayedPC_ref  :: ( 64 Word.word) M)
    else
      (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 :: 64 bits) . 
      return ((add_vec_int w__4 (( 4 :: int)::ii)  ::  64 Word.word)))) \<bind> (\<lambda> (w__5 ::  64 Word.word) . 
   ((write_reg nextPC_ref w__5 \<then>
   cp2_next_pc () ) \<then>
   read_reg instCount_ref) \<bind> (\<lambda> (w__6 :: ii) . 
   (write_reg instCount_ref ((w__6 + (( 1 :: int)::ii))) \<then>
   (read_reg UART_WRITTEN_ref  :: ( 1 Word.word) M)) \<bind> (\<lambda> (w__7 :: 1 bits) . 
   (((if ((bits_to_bool w__7)) then
      (read_reg UART_WDATA_ref  :: ( 8 Word.word) M) \<bind> (\<lambda> (w__8 :: 8 bits) . 
      (let (_ :: unit) = (putchar ((Word.uint w__8))) in
      write_reg UART_WRITTEN_ref (vec_of_bits [B0]  ::  1 Word.word)))
    else return () ) \<then>
   skip () ) \<then>
   skip () ) \<then>
   ((let loop_again = True in
   try_catch ((read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__9 :: 64 bits) . 
              (TranslatePC w__9  :: ( 64 Word.word) M) \<bind> (\<lambda> pc_pa . 
              (MEMr_wrapper (( 32 :: int)::ii) pc_pa (( 4 :: int)::ii)  :: ( 32 Word.word) M) \<bind> (\<lambda> instr . 
              (let instr_ast = (decode instr) in
              (case  instr_ast of
                Some ((HCF (_))) =>
                 (let (_ :: unit) = (print_endline (''simulation stopped due to halt instruction.'')) in
                 return False)
              | Some (ast) => execute ast \<then> return loop_again
              | None =>
                 (let (_ :: unit) = (print_endline (''Decode failed'')) in
                 return False)
              )))))) (\<lambda>x .  
  (case  x of   ISAException (_) => return loop_again )) \<bind> (\<lambda> (loop_again :: bool) . 
   return (((loop_again \<and> ((\<not> ((cycle_limit_reached () )))))))))))))))))"


(*val init_registers : mword ty64 -> M unit*)

definition init_registers  :: "(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " init_registers initialPC = (
   (init_cp0_state ()  \<then> init_cp2_state () ) \<then> write_reg nextPC_ref initialPC )"


(*val dump_mips_state : unit -> M unit*)

definition dump_mips_state  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " dump_mips_state _ = (
   (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 :: 64 bits) . 
   (let (_ :: unit) = (print_bits 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (''DEBUG MIPS PC '') w__0) in
   (foreachM (index_list (( 0 :: int)::ii) (( 31 :: int)::ii) (( 1 :: int)::ii)) () 
     (\<lambda> idx unit_var . 
       (rGPR ((to_bits ((make_the_value (( 5 :: int)::ii)  ::  5 itself)) idx  ::  5 Word.word))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::
          64 Word.word) . 
       return ((let _ =
         (print_endline
           (((@) (''DEBUG MIPS REG '')
               (((@) ((string_of_int 
  instance_Show_Show_Num_integer_dict idx)) (((@) ('' '') ((string_of_bits w__1))))))))) in
       () ))))))))"


(*val main : unit -> M unit*)

definition main  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " main _ = (
   init_registers
     ((to_bits ((make_the_value (( 64 :: int)::ii)  ::  64 itself)) ((elf_entry () ))  ::  64 Word.word)) \<then>
   ((let startTime = (get_time_ns () ) in
   (whileM ()  (\<lambda> unit_var .  fetch_and_execute () ) (\<lambda> unit_var .  return () )) \<then>
   ((let endTime = (get_time_ns () ) in
   (let elapsed = (endTime - startTime) in
   read_reg instCount_ref \<bind> (\<lambda> (w__1 :: ii) . 
   (let inst_1e9 = (w__1 * (( 1000000000 :: int)::ii)) in
   (let ips = (inst_1e9 div elapsed) in
   ((dump_mips_state ()  \<then>
   dump_cp2_state () ) \<then>
   read_reg instCount_ref) \<bind> (\<lambda> (w__2 :: ii) . 
   (let (_ :: unit) = (print_int (''Executed instructions: '') w__2) in
   (let (_ :: unit) = (print_int (''Nanoseconds elapsed: '') elapsed) in
   return ((print_int (''Instructions per second: '') ips))))))))))))))"


(*val initialize_registers : unit -> M unit*)

definition initialize_registers  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " initialize_registers _ = (
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (write_reg PC_ref w__0 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   (write_reg nextPC_ref w__1 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> (\<lambda> (w__2 ::  1 Word.word) . 
   (write_reg TLBProbe_ref w__2 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 6 :: int)::ii)  :: ( 6 Word.word) M)) \<bind> (\<lambda> (w__3 ::  6 Word.word) . 
   (write_reg TLBIndex_ref w__3 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 6 :: int)::ii)  :: ( 6 Word.word) M)) \<bind> (\<lambda> (w__4 ::  6 Word.word) . 
   (write_reg TLBRandom_ref w__4 \<then>
   undefined_TLBEntryLoReg () ) \<bind> (\<lambda> (w__5 :: TLBEntryLoReg) . 
   (write_reg TLBEntryLo0_ref w__5 \<then>
   undefined_TLBEntryLoReg () ) \<bind> (\<lambda> (w__6 :: TLBEntryLoReg) . 
   (write_reg TLBEntryLo1_ref w__6 \<then>
   undefined_ContextReg () ) \<bind> (\<lambda> (w__7 :: ContextReg) . 
   (write_reg TLBContext_ref w__7 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 16 :: int)::ii)  :: ( 16 Word.word) M)) \<bind> (\<lambda> (w__8 ::  16 Word.word) . 
   (write_reg TLBPageMask_ref w__8 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 6 :: int)::ii)  :: ( 6 Word.word) M)) \<bind> (\<lambda> (w__9 ::  6 Word.word) . 
   (write_reg TLBWired_ref w__9 \<then>
   undefined_TLBEntryHiReg () ) \<bind> (\<lambda> (w__10 :: TLBEntryHiReg) . 
   (write_reg TLBEntryHi_ref w__10 \<then>
   undefined_XContextReg () ) \<bind> (\<lambda> (w__11 :: XContextReg) . 
   (write_reg TLBXContext_ref w__11 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__12 :: TLBEntry) . 
   (write_reg TLBEntry00_ref w__12 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__13 :: TLBEntry) . 
   (write_reg TLBEntry01_ref w__13 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__14 :: TLBEntry) . 
   (write_reg TLBEntry02_ref w__14 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__15 :: TLBEntry) . 
   (write_reg TLBEntry03_ref w__15 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__16 :: TLBEntry) . 
   (write_reg TLBEntry04_ref w__16 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__17 :: TLBEntry) . 
   (write_reg TLBEntry05_ref w__17 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__18 :: TLBEntry) . 
   (write_reg TLBEntry06_ref w__18 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__19 :: TLBEntry) . 
   (write_reg TLBEntry07_ref w__19 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__20 :: TLBEntry) . 
   (write_reg TLBEntry08_ref w__20 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__21 :: TLBEntry) . 
   (write_reg TLBEntry09_ref w__21 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__22 :: TLBEntry) . 
   (write_reg TLBEntry10_ref w__22 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__23 :: TLBEntry) . 
   (write_reg TLBEntry11_ref w__23 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__24 :: TLBEntry) . 
   (write_reg TLBEntry12_ref w__24 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__25 :: TLBEntry) . 
   (write_reg TLBEntry13_ref w__25 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__26 :: TLBEntry) . 
   (write_reg TLBEntry14_ref w__26 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__27 :: TLBEntry) . 
   (write_reg TLBEntry15_ref w__27 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__28 :: TLBEntry) . 
   (write_reg TLBEntry16_ref w__28 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__29 :: TLBEntry) . 
   (write_reg TLBEntry17_ref w__29 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__30 :: TLBEntry) . 
   (write_reg TLBEntry18_ref w__30 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__31 :: TLBEntry) . 
   (write_reg TLBEntry19_ref w__31 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__32 :: TLBEntry) . 
   (write_reg TLBEntry20_ref w__32 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__33 :: TLBEntry) . 
   (write_reg TLBEntry21_ref w__33 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__34 :: TLBEntry) . 
   (write_reg TLBEntry22_ref w__34 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__35 :: TLBEntry) . 
   (write_reg TLBEntry23_ref w__35 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__36 :: TLBEntry) . 
   (write_reg TLBEntry24_ref w__36 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__37 :: TLBEntry) . 
   (write_reg TLBEntry25_ref w__37 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__38 :: TLBEntry) . 
   (write_reg TLBEntry26_ref w__38 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__39 :: TLBEntry) . 
   (write_reg TLBEntry27_ref w__39 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__40 :: TLBEntry) . 
   (write_reg TLBEntry28_ref w__40 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__41 :: TLBEntry) . 
   (write_reg TLBEntry29_ref w__41 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__42 :: TLBEntry) . 
   (write_reg TLBEntry30_ref w__42 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__43 :: TLBEntry) . 
   (write_reg TLBEntry31_ref w__43 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__44 :: TLBEntry) . 
   (write_reg TLBEntry32_ref w__44 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__45 :: TLBEntry) . 
   (write_reg TLBEntry33_ref w__45 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__46 :: TLBEntry) . 
   (write_reg TLBEntry34_ref w__46 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__47 :: TLBEntry) . 
   (write_reg TLBEntry35_ref w__47 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__48 :: TLBEntry) . 
   (write_reg TLBEntry36_ref w__48 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__49 :: TLBEntry) . 
   (write_reg TLBEntry37_ref w__49 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__50 :: TLBEntry) . 
   (write_reg TLBEntry38_ref w__50 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__51 :: TLBEntry) . 
   (write_reg TLBEntry39_ref w__51 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__52 :: TLBEntry) . 
   (write_reg TLBEntry40_ref w__52 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__53 :: TLBEntry) . 
   (write_reg TLBEntry41_ref w__53 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__54 :: TLBEntry) . 
   (write_reg TLBEntry42_ref w__54 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__55 :: TLBEntry) . 
   (write_reg TLBEntry43_ref w__55 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__56 :: TLBEntry) . 
   (write_reg TLBEntry44_ref w__56 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__57 :: TLBEntry) . 
   (write_reg TLBEntry45_ref w__57 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__58 :: TLBEntry) . 
   (write_reg TLBEntry46_ref w__58 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__59 :: TLBEntry) . 
   (write_reg TLBEntry47_ref w__59 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__60 :: TLBEntry) . 
   (write_reg TLBEntry48_ref w__60 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__61 :: TLBEntry) . 
   (write_reg TLBEntry49_ref w__61 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__62 :: TLBEntry) . 
   (write_reg TLBEntry50_ref w__62 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__63 :: TLBEntry) . 
   (write_reg TLBEntry51_ref w__63 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__64 :: TLBEntry) . 
   (write_reg TLBEntry52_ref w__64 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__65 :: TLBEntry) . 
   (write_reg TLBEntry53_ref w__65 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__66 :: TLBEntry) . 
   (write_reg TLBEntry54_ref w__66 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__67 :: TLBEntry) . 
   (write_reg TLBEntry55_ref w__67 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__68 :: TLBEntry) . 
   (write_reg TLBEntry56_ref w__68 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__69 :: TLBEntry) . 
   (write_reg TLBEntry57_ref w__69 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__70 :: TLBEntry) . 
   (write_reg TLBEntry58_ref w__70 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__71 :: TLBEntry) . 
   (write_reg TLBEntry59_ref w__71 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__72 :: TLBEntry) . 
   (write_reg TLBEntry60_ref w__72 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__73 :: TLBEntry) . 
   (write_reg TLBEntry61_ref w__73 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__74 :: TLBEntry) . 
   (write_reg TLBEntry62_ref w__74 \<then>
   undefined_TLBEntry () ) \<bind> (\<lambda> (w__75 :: TLBEntry) . 
   (write_reg TLBEntry63_ref w__75 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__76 ::  32 Word.word) . 
   (write_reg CP0Compare_ref w__76 \<then>
   undefined_CauseReg () ) \<bind> (\<lambda> (w__77 :: CauseReg) . 
   (write_reg CP0Cause_ref w__77 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__78 ::  64 Word.word) . 
   (write_reg CP0EPC_ref w__78 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__79 ::  64 Word.word) . 
   (write_reg CP0ErrorEPC_ref w__79 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> (\<lambda> (w__80 ::  1 Word.word) . 
   (write_reg CP0LLBit_ref w__80 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__81 ::  64 Word.word) . 
   (write_reg CP0LLAddr_ref w__81 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__82 ::  64 Word.word) . 
   (write_reg CP0BadVAddr_ref w__82 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__83 ::  32 Word.word) . 
   (write_reg CP0Count_ref w__83 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 32 :: int)::ii)  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__84 ::  32 Word.word) . 
   (write_reg CP0HWREna_ref w__84 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__85 ::  64 Word.word) . 
   (write_reg CP0UserLocal_ref w__85 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 3 :: int)::ii)  :: ( 3 Word.word) M)) \<bind> (\<lambda> (w__86 ::  3 Word.word) . 
   (write_reg CP0ConfigK0_ref w__86 \<then>
   undefined_StatusReg () ) \<bind> (\<lambda> (w__87 :: StatusReg) . 
   (write_reg CP0Status_ref w__87 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> (\<lambda> (w__88 ::  1 Word.word) . 
   (write_reg branchPending_ref w__88 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> (\<lambda> (w__89 ::  1 Word.word) . 
   (write_reg inBranchDelay_ref w__89 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__90 ::  64 Word.word) . 
   (write_reg delayedPC_ref w__90 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__91 ::  64 Word.word) . 
   (write_reg HI_ref w__91 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__92 ::  64 Word.word) . 
   (write_reg LO_ref w__92 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 64 :: int)::ii)  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__93 ::  64 Word.word) . 
   (undefined_vector (( 32 :: int)::ii) w__93  :: ( ( 64 Word.word)list) M) \<bind> (\<lambda> (w__94 :: ( 64 Word.word) list) . 
   (write_reg GPR_ref w__94 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 8 :: int)::ii)  :: ( 8 Word.word) M)) \<bind> (\<lambda> (w__95 ::  8 Word.word) . 
   (write_reg UART_WDATA_ref w__95 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> (\<lambda> (w__96 ::  1 Word.word) . 
   (write_reg UART_WRITTEN_ref w__96 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 8 :: int)::ii)  :: ( 8 Word.word) M)) \<bind> (\<lambda> (w__97 ::  8 Word.word) . 
   (write_reg UART_RDATA_ref w__97 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> (\<lambda> (w__98 ::  1 Word.word) . 
   (write_reg UART_RVALID_ref w__98 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__99 ::  257 Word.word) . 
   (write_reg PCC_ref w__99 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__100 ::  257 Word.word) . 
   (write_reg nextPCC_ref w__100 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__101 ::  257 Word.word) . 
   (write_reg delayedPCC_ref w__101 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 1 :: int)::ii)  :: ( 1 Word.word) M)) \<bind> (\<lambda> (w__102 ::  1 Word.word) . 
   (write_reg inCCallDelay_ref w__102 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__103 ::  257 Word.word) . 
   (write_reg DDC_ref w__103 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__104 ::  257 Word.word) . 
   (write_reg C01_ref w__104 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__105 ::  257 Word.word) . 
   (write_reg C02_ref w__105 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__106 ::  257 Word.word) . 
   (write_reg C03_ref w__106 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__107 ::  257 Word.word) . 
   (write_reg C04_ref w__107 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__108 ::  257 Word.word) . 
   (write_reg C05_ref w__108 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__109 ::  257 Word.word) . 
   (write_reg C06_ref w__109 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__110 ::  257 Word.word) . 
   (write_reg C07_ref w__110 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__111 ::  257 Word.word) . 
   (write_reg C08_ref w__111 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__112 ::  257 Word.word) . 
   (write_reg C09_ref w__112 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__113 ::  257 Word.word) . 
   (write_reg C10_ref w__113 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__114 ::  257 Word.word) . 
   (write_reg C11_ref w__114 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__115 ::  257 Word.word) . 
   (write_reg C12_ref w__115 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__116 ::  257 Word.word) . 
   (write_reg C13_ref w__116 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__117 ::  257 Word.word) . 
   (write_reg C14_ref w__117 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__118 ::  257 Word.word) . 
   (write_reg C15_ref w__118 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__119 ::  257 Word.word) . 
   (write_reg C16_ref w__119 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__120 ::  257 Word.word) . 
   (write_reg C17_ref w__120 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__121 ::  257 Word.word) . 
   (write_reg C18_ref w__121 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__122 ::  257 Word.word) . 
   (write_reg C19_ref w__122 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__123 ::  257 Word.word) . 
   (write_reg C20_ref w__123 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__124 ::  257 Word.word) . 
   (write_reg C21_ref w__124 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__125 ::  257 Word.word) . 
   (write_reg C22_ref w__125 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__126 ::  257 Word.word) . 
   (write_reg C23_ref w__126 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__127 ::  257 Word.word) . 
   (write_reg C24_ref w__127 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__128 ::  257 Word.word) . 
   (write_reg C25_ref w__128 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__129 ::  257 Word.word) . 
   (write_reg C26_ref w__129 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__130 ::  257 Word.word) . 
   (write_reg C27_ref w__130 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__131 ::  257 Word.word) . 
   (write_reg C28_ref w__131 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__132 ::  257 Word.word) . 
   (write_reg C29_ref w__132 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__133 ::  257 Word.word) . 
   (write_reg C30_ref w__133 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__134 ::  257 Word.word) . 
   (write_reg C31_ref w__134 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__135 ::  257 Word.word) . 
   (write_reg CTLSU_ref w__135 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__136 ::  257 Word.word) . 
   (write_reg CTLSP_ref w__136 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__137 ::  257 Word.word) . 
   (write_reg KR1C_ref w__137 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__138 ::  257 Word.word) . 
   (write_reg KR2C_ref w__138 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__139 ::  257 Word.word) . 
   (write_reg KCC_ref w__139 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__140 ::  257 Word.word) . 
   (write_reg KDC_ref w__140 \<then>
   (undefined_bitvector 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict (( 257 :: int)::ii)  :: ( 257 Word.word) M)) \<bind> (\<lambda> (w__141 ::  257 Word.word) . 
   (write_reg EPCC_ref w__141 \<then>
   undefined_CapCauseReg () ) \<bind> (\<lambda> (w__142 :: CapCauseReg) . 
   (write_reg CapCause_ref w__142 \<then>
   undefined_int () ) \<bind> (\<lambda> (w__143 :: ii) .  write_reg instCount_ref w__143)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))"


definition initial_regstate  :: " regstate "  where 
     " initial_regstate = (
  (| instCount = ((( 0 :: int)::ii)), 
     CapCause =
       ((| CapCauseReg_CapCauseReg_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  16 Word.word)) |)), 
     EPCC =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     KDC =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     KCC =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     KR2C =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     KR1C =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     CTLSP =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     CTLSU =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     C31 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     C30 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     C29 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     C28 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     C27 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     C26 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     C25 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     C24 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     C23 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     C22 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     C21 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     C20 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     C19 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     C18 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     C17 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     C16 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     C15 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     C14 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     C13 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     C12 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     C11 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     C10 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     C09 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     C08 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     C07 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     C06 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     C05 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     C04 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     C03 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     C02 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     C01 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     DDC =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     inCCallDelay = ((vec_of_bits [B0]  ::  1 Word.word)), 
     delayedPCC =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     nextPCC =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     PCC =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  257 Word.word)), 
     UART_RVALID = ((vec_of_bits [B0]  ::  1 Word.word)), 
     UART_RDATA = ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word)), 
     UART_WRITTEN = ((vec_of_bits [B0]  ::  1 Word.word)), 
     UART_WDATA = ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word)), 
     GPR =
       ([(vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word)]), 
     LO =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     HI =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     delayedPC =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     inBranchDelay = ((vec_of_bits [B0]  ::  1 Word.word)), 
     branchPending = ((vec_of_bits [B0]  ::  1 Word.word)), 
     CP0Status =
       ((| StatusReg_StatusReg_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0]
               ::  32 Word.word)) |)), 
     CP0ConfigK0 = ((vec_of_bits [B0,B0,B0]  ::  3 Word.word)), 
     CP0UserLocal =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     CP0HWREna =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     CP0Count =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     CP0BadVAddr =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     CP0LLAddr =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     CP0LLBit = ((vec_of_bits [B0]  ::  1 Word.word)), 
     CP0ErrorEPC =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     CP0EPC =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     CP0Cause =
       ((| CauseReg_CauseReg_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0]
               ::  32 Word.word)) |)), 
     CP0Compare =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0]
         ::  32 Word.word)), 
     TLBEntry63 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry62 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry61 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry60 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry59 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry58 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry57 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry56 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry55 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry54 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry53 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry52 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry51 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry50 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry49 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry48 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry47 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry46 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry45 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry44 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry43 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry42 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry41 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry40 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry39 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry38 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry37 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry36 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry35 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry34 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry33 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry32 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry31 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry30 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry29 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry28 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry27 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry26 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry25 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry24 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry23 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry22 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry21 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry20 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry19 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry18 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry17 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry16 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry15 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry14 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry13 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry12 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry11 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry10 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry09 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry08 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry07 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry06 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry05 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry04 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry03 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry02 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry01 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntry00 =
       ((| TLBEntry_TLBEntry_chunk_1 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0]
               ::  53 Word.word)), 
           TLBEntry_TLBEntry_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBXContext =
       ((| XContextReg_XContextReg_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntryHi =
       ((| TLBEntryHiReg_TLBEntryHiReg_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBWired = ((vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)), 
     TLBPageMask = ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  16 Word.word)), 
     TLBContext =
       ((| ContextReg_ContextReg_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntryLo1 =
       ((| TLBEntryLoReg_TLBEntryLoReg_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBEntryLo0 =
       ((| TLBEntryLoReg_TLBEntryLoReg_chunk_0 =
             ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                           B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
               ::  64 Word.word)) |)), 
     TLBRandom = ((vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)), 
     TLBIndex = ((vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)), 
     TLBProbe = ((vec_of_bits [B0]  ::  1 Word.word)), 
     nextPC =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     PC =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)) |) )"



end
